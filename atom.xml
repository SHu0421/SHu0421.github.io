<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hello World</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-01-26T08:51:38.856Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>huhu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>多线程</title>
    <link href="http://example.com/2022/01/26/leetcode/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"/>
    <id>http://example.com/2022/01/26/leetcode/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/</id>
    <published>2022-01-26T04:19:28.000Z</published>
    <updated>2022-01-26T08:51:38.856Z</updated>
    
    <content type="html"><![CDATA[<h3 id="semaphore-信号量"><a href="#semaphore-信号量" class="headerlink" title="semaphore 信号量"></a>semaphore 信号量</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">#<span class="hljs-keyword">include</span> &lt;semaphore.h&gt;<br>sem_t sem1;<span class="hljs-comment">//进行变量申明</span><br><br>sem<span class="hljs-constructor">_init(&amp;<span class="hljs-params">sem1</span>, 1, 0)</span>; <br>第一个参数：指向的信号对象<br>第二个参数：控制信号量的类型，如果其值为<span class="hljs-number">0</span>，就表示信号量是当前进程的局部信号量，否则信号量就可以在多个进程间共享<br>第三个参数：信号量sem的初始值<br><br>sem<span class="hljs-constructor">_post(&amp;<span class="hljs-params">sem1</span>)</span> 信号量值加<span class="hljs-number">1</span><br><br>sem<span class="hljs-constructor">_wait(&amp;<span class="hljs-params">sem1</span>)</span> 信号量值减<span class="hljs-number">1</span><br><br>sem<span class="hljs-constructor">_destroy(&amp;<span class="hljs-params">sem1</span>)</span> 信号量销毁<br></code></pre></td></tr></table></figure><h3 id="互斥锁和条件变量（可以实现一个进程打印5次，另外一个进程打印1次的场景）"><a href="#互斥锁和条件变量（可以实现一个进程打印5次，另外一个进程打印1次的场景）" class="headerlink" title="互斥锁和条件变量（可以实现一个进程打印5次，另外一个进程打印1次的场景）"></a>互斥锁和条件变量（可以实现一个进程打印5次，另外一个进程打印1次的场景）</h3><p>C++： condition_variable C: pthread_cond_t<br>条件变量的一个例子，讲得很详细：<a href="https://blog.csdn.net/jinking01/article/details/110362483">https://blog.csdn.net/jinking01/article/details/110362483</a></p><p>讲述conditon_variable的一个例子：<a href="https://segmentfault.com/a/1190000006679917">https://segmentfault.com/a/1190000006679917</a> </p><p>1.<br>引入条件变量一个就是为了避免为了查看条件是否成立而不断轮询的情况<br>总结：互斥锁实现的是线程之间的互斥，条件变量实现的是线程之间的同步。<br>初始化条件变量<br>pthread_cond_t cond = PTHREAD_COND_INITIALIZER;</p><p>该函数用来在一个ConditionVariable上阻塞等待，做以下三步操作：①释放Mutex；②阻塞等待；③当被唤醒时，重新获得Mutex并返回。<br>int pthread_cond_wait(pthread_cond_t &amp;cond_name, pthread_mutex_t &amp;mutex_name);</p><p>唤醒等待线程<br>pthread_cond_signal()：用于唤醒在该条件变量下等待的一个线程，至于哪个被唤醒，取决于线程的优先级和调度策略。<br>pthread_cond_broadcast()：用于唤醒在某个ConditionVariable 上等待的所有线程。使用这种方法时，瞬间唤醒的线程数过多，资源请求过大，容易导致系统不稳定。<br>int pthread_cond_signal(pthread_cond_t &amp;cond_name);<br>int pthread_cond_broadcast(pthread_cond_t &amp;cond_name);</p><ol start="2"><li>和信号量的区别：<br>条件变量的提出是为了解决互斥锁中的循环等待问题，其希望引入一种挂起、唤醒的机制来实现cpu的高效利用<br>（1）使用条件变量可以一次唤醒所有等待者，而这个信号量没有的功能，感觉是最大区别。<br>（2）信号量是有一个值（状态的），而条件变量是没有的，没有地方记录唤醒（发送信号）过多少次，也没有地方记录唤醒线程（wait返回）过多少次。</li></ol><ol start="3"><li>注意！！！！<br>条件变量被通知后，挂起的线程就被唤醒，但是唤醒也有可能是假唤醒，或者是因为超时等异常情况，所以被唤醒的线程仍要检查条件是否满足，所以 wait 是放在条件循环里面。cv.wait(lock, [] { return ready; }); 相当于：while (!ready) { cv.wait(lock); }。</li></ol><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>为了实现两个函数的交替打印，可以使用信号量，也可以使用交替锁<br>1115. 交替打印 FooBar</p><p>solution 1:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++">func1:<br><span class="hljs-built_in">sem_wait</span>(&amp;sem_foo);<br><span class="hljs-built_in">printFoo</span>();<br><span class="hljs-built_in">sem_post</span>(&amp;sem_bar);<br><br><span class="hljs-function">func2</span><br><span class="hljs-function"><span class="hljs-title">sem_wait</span><span class="hljs-params">(&amp;sem_bar)</span></span>;<br><span class="hljs-built_in">printBar</span>();<br><span class="hljs-built_in">sem_post</span>(&amp;sem_foo);<br></code></pre></td></tr></table></figure><p>solution 2 互斥锁（不建议用这种解法，在不同线程加锁解锁确实会出问题）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++">func1:<br>mutex lock1, lock2; <span class="hljs-comment">//这里锁类似条件变量</span><br><br>lock1.<span class="hljs-built_in">lock</span>();<br><span class="hljs-built_in">printFoo</span>();<br>lock2.<span class="hljs-built_in">unlock</span>();<br><br>func2<br>lock2.<span class="hljs-built_in">lock</span>();<br><span class="hljs-built_in">printBar</span>();<br>lock1.<span class="hljs-built_in">unlock</span>();<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;semaphore-信号量&quot;&gt;&lt;a href=&quot;#semaphore-信号量&quot; class=&quot;headerlink&quot; title=&quot;semaphore 信号量&quot;&gt;&lt;/a&gt;semaphore 信号量&lt;/h3&gt;&lt;figure class=&quot;highlight reas</summary>
      
    
    
    
    
    <category term="多线程并发， 信号量， 互斥锁" scheme="http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%EF%BC%8C-%E4%BF%A1%E5%8F%B7%E9%87%8F%EF%BC%8C-%E4%BA%92%E6%96%A5%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>分布式训练</title>
    <link href="http://example.com/2022/01/26/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%AD%E7%BB%83/"/>
    <id>http://example.com/2022/01/26/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%AD%E7%BB%83/</id>
    <published>2022-01-26T02:50:50.000Z</published>
    <updated>2022-01-26T03:25:14.661Z</updated>
    
    <content type="html"><![CDATA[<h3 id="资料："><a href="#资料：" class="headerlink" title="资料："></a>资料：</h3><p>一个pytorch 分布式 单机多卡/多机多卡的例子<br><a href="https://github.com/lesliejackson/PyTorch-Distributed-Training">https://github.com/lesliejackson/PyTorch-Distributed-Training</a></p><p>常见分布式训练讲解，但是主要命令是启动单机多卡，而不是多机多卡 包括slum, apex, horovod<br><a href="https://github.com/tczhangzhi/pytorch-distributed">https://github.com/tczhangzhi/pytorch-distributed</a> </p><p>pytorch DDP介绍<br><a href="https://zhuanlan.zhihu.com/p/76638962">https://zhuanlan.zhihu.com/p/76638962</a></p><p><a href="https://github.com/richardkxu/distributed-pytorch">https://github.com/richardkxu/distributed-pytorch</a> （也有多机多卡的命令）</p><p>可能会用到：<br>两个机器之间相互免密登录：<a href="https://blog.csdn.net/u010391029/article/details/51126210">https://blog.csdn.net/u010391029/article/details/51126210</a></p><p>DDP time breakdown<br><a href="https://discuss.pytorch.org/t/how-to-measure-ddp-time-breakdown/78925">https://discuss.pytorch.org/t/how-to-measure-ddp-time-breakdown/78925</a><br><a href="https://discuss.pytorch.org/t/how-to-measure-ddp-time-breakdown/78925">https://discuss.pytorch.org/t/how-to-measure-ddp-time-breakdown/78925</a><br><a href="https://discuss.pytorch.org/t/calculating-flops-of-a-given-pytorch-model/3711/4">https://discuss.pytorch.org/t/calculating-flops-of-a-given-pytorch-model/3711/4</a> FLOPS计算</p><p>多进程logging和mkdir设置，分布式inferenc/ 分布式训练的一些小技巧</p><p><a href="https://zhuanlan.zhihu.com/p/250471767">https://zhuanlan.zhihu.com/p/250471767</a> </p><blockquote><p>包括的内容1. 在DDP中引入SyncBN<br>2. DDP下的Gradient Accumulation的进一步加速<br>3. 多机多卡环境下的inference加速<br>4. 保证DDP性能：确保数据的一致性<br>5. 和DDP有关的小技巧<br>6. 1. 控制不同进程的执行顺序<br>   2. 避免DDP带来的冗余输出</p></blockquote><p>Ray分布式执行框架  PyTorch + Ray Tune 调参<br><a href="https://blog.csdn.net/tszupup/article/details/112059788">https://blog.csdn.net/tszupup/article/details/112059788</a></p><p>分布式相关论文源码<br><a href="https://github.com/msr-fiddle/pipedream">https://github.com/msr-fiddle/pipedream</a>  pipedream源码 mini-bath parallism<br><a href="https://github.com/kakaobrain/torchgpipe">https://github.com/kakaobrain/torchgpipe</a></p><p>pytorch分布式训练的时候保存一定要用model.module<br><a href="https://blog.csdn.net/comway_Li/article/details/107531165">https://blog.csdn.net/comway_Li/article/details/107531165</a> 一些需要注意的地方</p><p>horovod多机多卡<br><a href="http://chaopeng.name/2020/01/03/horovod%E5%A4%9A%E6%9C%BA%E5%A4%9A%E5%8D%A1%E5%90%AF%E5%8A%A8%E6%8C%87%E5%8D%97/">http://chaopeng.name/2020/01/03/horovod%E5%A4%9A%E6%9C%BA%E5%A4%9A%E5%8D%A1%E5%90%AF%E5%8A%A8%E6%8C%87%E5%8D%97/</a></p><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ol><li>DP和DDP区别<br>DP是单进程多线程数据并行，将模型copy到每个设备，scatter数据到每个设备进行计算后，将多个GPU输出传到master device(一般为设备0)进行损失计算，（可以优化一下：将loss作为forward 一部分，这样的话每个GPU上自行计算loss，而不用进行模型输出的传输）将损失结果（分发的是各个GPU分别对应的loss）传给每个设备进行反向传播，每个设备将反向传播后的梯度到主设备进行汇聚求平均，然后replicate一份模型的参数到每个设备中，重复上诉的训练过程。</li></ol><ol start="2"><li><p>DDP中all reduce与PS<br> DDP （all reduce）同步的是梯度，不是参数<br> PS，传给master的是梯度，返回的是参数</p><p> 思考：对不重要的梯度进行累积后同步/直接不同步（会不会造成模型的不一致）</p></li><li><p>同步代码<br>分布式训练源代码解读：<a href="https://zhuanlan.zhihu.com/p/343951042">https://zhuanlan.zhihu.com/p/343951042</a></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">手动同步梯度<br><span class="hljs-keyword">for</span> param <span class="hljs-keyword">in</span> ddp_model.parameters<span class="hljs-literal">()</span>: <br>dist.all<span class="hljs-constructor">_reduce(<span class="hljs-params">param</span>.<span class="hljs-params">grad</span>.<span class="hljs-params">data</span>, <span class="hljs-params">op</span>=<span class="hljs-params">dist</span>.<span class="hljs-params">reduce_op</span>.SUM)</span><br>    param.grad.data /= world_size <br><br>手动同步参数：<br>在不重要的样本反向传播后但是不同步参数后，同步梯度<br><span class="hljs-keyword">for</span> param <span class="hljs-keyword">in</span> ddp_model.parameters<span class="hljs-literal">()</span>: <br>dist.all<span class="hljs-constructor">_reduce(<span class="hljs-params">param</span>.<span class="hljs-params">data</span>, <span class="hljs-params">op</span>=<span class="hljs-params">dist</span>.<span class="hljs-params">reduce_op</span>.SUM)</span><br>    param.data /= world_size <br></code></pre></td></tr></table></figure></li></ol><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><h4 id="solution-1-atom版本"><a href="#solution-1-atom版本" class="headerlink" title="solution 1 - atom版本"></a>solution 1 - atom版本</h4><p>裸机 多节点 atom平台</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /workspace/mnt/storage/anchao/ac_file/traffic_iteration/SupreVision &amp;&amp; \<br>./install.sh &amp;&amp; \<br>python -m torch.distributed.launch \<br>        --nnode=4 \<br>        --node_rank=0 \<br>        --nproc_per_node=8 \<br>        --master_addr=<span class="hljs-string">&quot;10.244.55.30&quot;</span> \<br>        --master_port=23467 \<br>        tools/train.py \<br>        --config_file configs/YOLOv3/opencv_pelee_reorg.yml \<br>        SOLVER.IMS_PER_BATCH <span class="hljs-string">&quot;16&quot;</span> \<br>        MODEL.DEVICE_ID <span class="hljs-string">&quot;(&#x27;0,1,2,3,4,5,6,7&#x27;)&quot;</span> \<br>        &gt; detection0.log 2&gt;&amp;1<br></code></pre></td></tr></table></figure><p>单机多卡</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /workspace/mnt/storage/anchao/ac_file/traffic_iteration/SupreVision &amp;&amp; \<br>./install.sh &amp;&amp; \<br>CUDA_VISIBLE_DEVICES=3,4,5,6 python -m torch.distributed.launch \<br>                --nproc_per_node=2 \<br>                --master_port=$((RANDOM + <span class="hljs-number">20000</span>)) \<br>                ./imagenet_final_train_master.py \<br>                --config_file configs/YOLOv3/opencv_pelee_reorg.yml \<br>                &gt; detection0.log 2&gt;&amp;1<br></code></pre></td></tr></table></figure><h4 id="solution-2-简洁版"><a href="#solution-2-简洁版" class="headerlink" title="solution 2 - 简洁版"></a>solution 2 - 简洁版</h4><p>多机多卡<br>suppose we have two machines and one machine have 4 gpus<br>In multi machine multi gpu situation, you have to choose a machine to be master node.<br>we named the machines A and B, and set A to be master node</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">script run at A<br><br>python -m torch.distributed.launch --nproc_per_node=4 --nnode=2 --node_rank=0 --master_addr=A_ip_address master_port=29500 main.py ... <br><br>script run at B<br><br>python -m torch.distributed.launch --nproc_per_node=4 --nnode=2 --node_rank=1 --master_addr=A_ip_address master_port=29500 main.py ... <br></code></pre></td></tr></table></figure><p>单机多卡</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python -m torch.distributed.launch --nproc_per_node=ngpus --master_port=29500 main.py ... <br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;资料：&quot;&gt;&lt;a href=&quot;#资料：&quot; class=&quot;headerlink&quot; title=&quot;资料：&quot;&gt;&lt;/a&gt;资料：&lt;/h3&gt;&lt;p&gt;一个pytorch 分布式 单机多卡/多机多卡的例子&lt;br&gt;&lt;a href=&quot;https://github.com/leslieja</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>md语法相关</title>
    <link href="http://example.com/2022/01/20/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/md%E8%AF%AD%E6%B3%95%E7%9B%B8%E5%85%B3/"/>
    <id>http://example.com/2022/01/20/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/md%E8%AF%AD%E6%B3%95%E7%9B%B8%E5%85%B3/</id>
    <published>2022-01-20T04:11:13.000Z</published>
    <updated>2022-01-20T05:01:50.841Z</updated>
    
    <content type="html"><![CDATA[<p>对代码块进行折叠</p><details>  <summary>点击时的区域标题</summary><pre><p>内容</p></code></details>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;对代码块进行折叠&lt;/p&gt;
&lt;details&gt;
  &lt;summary&gt;点击时的区域标题&lt;/summary&gt;
&lt;pre&gt;

&lt;p&gt;内容&lt;/p&gt;
&lt;/code&gt;
&lt;/details&gt;


</summary>
      
    
    
    
    
    <category term="typora, md" scheme="http://example.com/tags/typora-md/"/>
    
  </entry>
  
  <entry>
    <title>系统设计相关题目</title>
    <link href="http://example.com/2022/01/19/leetcode/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    <id>http://example.com/2022/01/19/leetcode/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</id>
    <published>2022-01-19T06:09:24.000Z</published>
    <updated>2022-01-20T05:10:04.031Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题型"><a href="#题型" class="headerlink" title="题型"></a>题型</h4><h5 id="1-标准布隆过滤器hash函数的设置"><a href="#1-标准布隆过滤器hash函数的设置" class="headerlink" title="1.标准布隆过滤器hash函数的设置"></a>1.标准布隆过滤器hash函数的设置</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashFunction</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> cap, seed;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">HashFunction</span>(<span class="hljs-keyword">int</span> cap, <span class="hljs-keyword">int</span> seed) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;cap = cap;<br>        <span class="hljs-keyword">this</span>-&gt;seed = seed;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(string&amp; value)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> n = value.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            ret += seed * ret + value[i];<br>            ret %= cap;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StandardBloomFilter</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> k;<br>    vector&lt;HashFunction*&gt; hashFunc;<br>    bitset&lt;200000&gt; bits;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">StandardBloomFilter</span>(<span class="hljs-keyword">int</span> k) &#123;<br>        <span class="hljs-comment">// initialize your data structure here</span><br>        <span class="hljs-keyword">this</span>-&gt;k = k;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i)<br>            hashFunc.<span class="hljs-built_in">push_back</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">HashFunction</span>(<span class="hljs-number">100000</span> + i, <span class="hljs-number">2</span> * i + <span class="hljs-number">3</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>每个字符串通过这个hash函数可以得到一个值（position），然后将bit[200000]中该位置为1，多个函数，那么就会有多个位置为1;判断某一个字符串是否存在，就是判断多个函数计算出来值是否都在bit中位1，如果有一个不为1，说明该字符串不在</p><h5 id="2-序列化Trie树-Lintcode"><a href="#2-序列化Trie树-Lintcode" class="headerlink" title="2. 序列化Trie树(Lintcode)"></a>2. 序列化Trie树(Lintcode)</h5><p>注意这道题</p><ul><li>在进行序列化：使用dfs, 在遍历完所有的chidren后，加上‘/‘表示退出当前循环</li><li>在进行反序列化时： 使用全局index, index在进入下一层循环和退出循环(注意这里和二叉树不同，有两处)之前都需要+1， 其余情况index保持不变</li><li>注意:<br>(1)在退出训练时候不是返回null, 而是返回一个Trie对象的指针！！！<br>(2)因为一个节点有多个节点，而不是只有二叉树的left和right节点，因此需要使用while判断，如果data[index]==’/‘的时候退出while循环<br>(3)<figure class="highlight c++"><figcaption><span>right</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">TrieNode* tmp=<span class="hljs-keyword">new</span> <span class="hljs-built_in">TrieNode</span>(); <span class="hljs-comment">//注意区分类和结构体</span><br>map&lt;<span class="hljs-keyword">char</span>, TrieNode*&gt; &amp;childs=tmp-&gt;children;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><figcaption><span>wrong</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">TrieNode* tmp; <span class="hljs-comment">//注意区分类和类指针，这里直接申明一个空指针是不对的, 即使是结构体也应该是student s;</span><br>map&lt;<span class="hljs-keyword">char</span>, TrieNode*&gt; childs;<br>tmp-&gt;children=childs;<br></code></pre></td></tr></table></figure></li></ul><p>官方题解使用的<data> 进行序列化+栈的方式进行反序列化：&lt;将当前current入栈 &gt;将栈顶出栈 其余：新建一个Trie对象(current)，将当前data[index]指向这个对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition of TrieNode:</span><br><span class="hljs-comment"> * class TrieNode &#123;</span><br><span class="hljs-comment"> * public:</span><br><span class="hljs-comment"> *     TrieNode() &#123;&#125;</span><br><span class="hljs-comment"> *     map&lt;char, TrieNode*&gt; children;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * This method will be invoked first, you should design your own algorithm </span><br><span class="hljs-comment">     * to serialize a trie which denote by a root node to a string which</span><br><span class="hljs-comment">     * can be easily deserialized by your own &quot;deserialize&quot; method later.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">string <span class="hljs-title">serialize</span><span class="hljs-params">(TrieNode* root)</span> </span>&#123;<br>        <span class="hljs-comment">// Write your code here</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        string data;<br>        <span class="hljs-keyword">for</span> (map&lt;<span class="hljs-keyword">char</span>, TrieNode*&gt;::iterator it = root-&gt;children.<span class="hljs-built_in">begin</span>();<br>             it != root-&gt;children.<span class="hljs-built_in">end</span>(); ++it) &#123;<br>            data += it-&gt;first;<br>            data += <span class="hljs-built_in">serialize</span>(it-&gt;second);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;&quot;</span> + data + <span class="hljs-string">&quot;&gt;&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * This method will be invoked second, the argument data is what exactly</span><br><span class="hljs-comment">     * you serialized at method &quot;serialize&quot;, that means the data is not given by</span><br><span class="hljs-comment">     * system, it&#x27;s given by your own serialize method. So the format of data is</span><br><span class="hljs-comment">     * designed by yourself, and deserialize it here as you serialize it in </span><br><span class="hljs-comment">     * &quot;serialize&quot; method.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">TrieNode* <span class="hljs-title">deserialize</span><span class="hljs-params">(string data)</span> </span>&#123;<br>        <span class="hljs-comment">// Write your code here</span><br>        <span class="hljs-keyword">if</span> (data.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>        TrieNode* head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TrieNode</span>();<br>        TrieNode* current = head;<br>        stack&lt;TrieNode*&gt; path;<br>        <span class="hljs-keyword">int</span> len = data.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;<br>            <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (data[i]) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>:<br>                    path.<span class="hljs-built_in">push</span>(current);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>:<br>                    path.<span class="hljs-built_in">pop</span>();<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">default</span>:<br>                    current = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TrieNode</span>();<br>                    path.<span class="hljs-built_in">top</span>()-&gt;children[data[i]] = current;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>一般是有关于系统， 多个函数的整体设计题目<br>比如：GeoHash, GFS, 布隆过滤器， 心跳设计， 缓存系统， LRU cache设计，二叉树的序列化和反序列化等<br>还有新定义一种数据结构，嵌套返回list leetcode-扁平化嵌套列表迭代器 使用递归方式分解</p><p>为了在vector里面删除元素更快，可以再配合使用一个dict (map)映射特定值对应的index;注意在进行删除元素的时候，除了交换vector中最后一个元素和当前元素，还需要修改hash最后一个元素映射的下标为当前index+从hash中删除key</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;题型&quot;&gt;&lt;a href=&quot;#题型&quot; class=&quot;headerlink&quot; title=&quot;题型&quot;&gt;&lt;/a&gt;题型&lt;/h4&gt;&lt;h5 id=&quot;1-标准布隆过滤器hash函数的设置&quot;&gt;&lt;a href=&quot;#1-标准布隆过滤器hash函数的设置&quot; class=&quot;headerli</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Zplot画图相关知识点</title>
    <link href="http://example.com/2022/01/04/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/zplot/"/>
    <id>http://example.com/2022/01/04/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/zplot/</id>
    <published>2022-01-04T08:04:52.000Z</published>
    <updated>2022-01-04T13:42:28.423Z</updated>
    
    <content type="html"><![CDATA[<p>Zplot-folder<br>|–breakdown<br>    |–Makefile<br>    |–breakdown1.py<br>    |–breakdown1.data<br>    |–breakdown2.py<br>    |–breakdown2.data<br>|–eval_lineplot<br>    |–Makefile<br>|–…<br>|–makefig.sh</p><ol><li>每次运行的时候只需要运行makefig文件就可以了，如果要修改所有生成的pdf在的目录，直接修改makefig.sh</li></ol><p>2。 Makefile里面的文件主要是运行当前py文件生成eps文件，然后使用ps2pdf转为pdf并使用pdf2crop对生成的pdf文件进行裁剪<br>PS：一定要注意python文件的名字一定要和data文件名字相同，否则会报错</p><p>prequisuite</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install zplot <br><span class="hljs-comment">#注意可能会出现list错误，可能是由于python2 和python3的不兼容原因，只需要将zplot.py里面的ListType改为list就可以了</span><br><br>sudo apt-get install texlive-extra-utils  <br></code></pre></td></tr></table></figure><p>Makefile文件分析</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash">PY=python<br>EPS2PDF=ps2pdf<br>CROP=pdfcrop<br><br>SRC := $(wildcard *.py) <span class="hljs-comment">#列出所有文件对应的py文件</span><br>SRC := $(filter-out zplot.py, $(SRC))<br>EPS = $(patsubst %.py,%.eps,$(SRC))<br>PDF = $(patsubst %.py,%.pdf,$(SRC)) <span class="hljs-comment">#列出所有文件对应的eps和pdf文件</span><br><br>all: $(EPS) $(PDF)<br><br>%.eps: %.py  <span class="hljs-comment"># 目标文件： 源文件</span><br>$(PY) $&lt; eps  <span class="hljs-comment">#$&lt; 表示源文件  $@表示目标文件//官方解释： $&lt; 表示第一个依赖文件， $@ 表示目标集</span><br><br>%.pdf: %.eps<br>$(EPS2PDF) $&lt;<br>$(CROP) <span class="hljs-variable">$@</span> <span class="hljs-variable">$@</span><br>rm -rf $&lt;<br><br>fig:<br><span class="hljs-comment"># mv -f *.pdf ../../../fig/ #将所有的文件都转移到zplot对应的root目录下面</span><br>mv -f *.pdf ../../<br>rm -rf *.eps *.pdf<br></code></pre></td></tr></table></figure><p>makefile语法的参考链接： <a href="https://seisman.github.io/how-to-write-makefile/rules.html">https://seisman.github.io/how-to-write-makefile/rules.html</a> </p><p>makefig.sh文件分析</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>rm -rf *.pdf <span class="hljs-comment">#这是我自己家的，在执行生成之前，现将之前生成的pdf文件删除，应该是也不用</span><br><br><span class="hljs-keyword">for</span>  dir  <span class="hljs-keyword">in</span>  `find .  -name Makefile`  <span class="hljs-comment">#找到包含Makefile文件的dir</span><br><span class="hljs-keyword">do</span><br>path=`dirname <span class="hljs-variable">$dir</span>` <span class="hljs-comment">#找到dir对应的路径path</span><br>    <span class="hljs-comment"># echo $path</span><br>    <span class="hljs-comment"># echo $dir</span><br><span class="hljs-keyword">if</span>  [ <span class="hljs-variable">$path</span>  !=  . ]<br><span class="hljs-keyword">then</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$path</span> <span class="hljs-comment">#打印出path的路径</span><br><span class="hljs-built_in">cd</span> <span class="hljs-variable">$path</span>  <br>make    <span class="hljs-comment">#执行make和makefig命令</span><br>make fig<br><span class="hljs-built_in">cd</span>  -<br><span class="hljs-keyword">fi</span><br><span class="hljs-keyword">done</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Zplot-folder&lt;br&gt;|–breakdown&lt;br&gt;    |–Makefile&lt;br&gt;    |–breakdown1.py&lt;br&gt;    |–breakdown1.data&lt;br&gt;    |–breakdown2.py&lt;br&gt;    |–breakdown2.</summary>
      
    
    
    
    
    <category term="zplot" scheme="http://example.com/tags/zplot/"/>
    
  </entry>
  
  <entry>
    <title>Anaconda环境搭建</title>
    <link href="http://example.com/2021/12/15/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/anaconda%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%BB%8E%E9%9B%B6%E5%88%B0%E4%B8%80/"/>
    <id>http://example.com/2021/12/15/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/anaconda%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%BB%8E%E9%9B%B6%E5%88%B0%E4%B8%80/</id>
    <published>2021-12-15T06:48:24.000Z</published>
    <updated>2022-01-07T01:11:49.353Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>一个服务器上已经搭建好的环境，但是需要换另一台机器，或者另外的用户需要访问这个环境， 如果另一台服务器上没有anaconda环境就需要从0开始进行搭建，然后再进行环境的迁移</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol><li>安装anaconda3<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">wget</span> https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda<span class="hljs-number">3</span>-<span class="hljs-number">5</span>.<span class="hljs-number">3</span>.<span class="hljs-number">1</span>-Linux-x<span class="hljs-number">86</span>_<span class="hljs-number">64</span>.sh<br><span class="hljs-attribute">bash</span> Anaconda<span class="hljs-number">3</span>-<span class="hljs-number">5</span>.<span class="hljs-number">3</span>.<span class="hljs-number">1</span>-Linux-x<span class="hljs-number">86</span>_<span class="hljs-number">64</span>.sh<br></code></pre></td></tr></table></figure></li></ol><p>一般情况下安装是默认设置，在安装vscode的时候可以根据需要选择no或者yes<br>注意在安装installer的时候需要选择yes, 如果选择了no<br>那么可以自行添加环境:<br><a href="https://zhuanlan.zhihu.com/p/64930395%EF%BC%88%E4%B9%9F%E5%B0%B1%E6%98%AF%E6%BF%80%E6%B4%BB%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%89">https://zhuanlan.zhihu.com/p/64930395（也就是激活环境中的方法二）</a></p><ol start="2"><li>激活环境<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 方法一失效</span><br>输入命令打开配置文件：vim ~/.bashrc<br>在最后添加语句：export PATH=<span class="hljs-regexp">/root/</span>xxx<span class="hljs-regexp">/anaconda3/</span>bin:<span class="hljs-variable">$PATH</span> （<span class="hljs-regexp">/root/</span>xxx 为安装路径）<br>最后输入如下命令，更新配置文件即可：source ~/.bashrc<br><br><span class="hljs-comment">#方法二有效：</span><br>如果conda的初始化时选择了no，则需要自行配置环境变量。<br><br>打开profile文件：<br><br>vi <span class="hljs-regexp">/etc/</span>profile<br>在文件最后加入如下语句（路径需要根据自己的安装位置更改）：<br><br>PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-regexp">/opt/</span>anaconda3/bin<br>export PATH<br>保存文件并退出。最后使用如下命令刷新环境变量即可：<br><br>source <span class="hljs-regexp">/etc/</span>profile<br>echo <span class="hljs-variable">$PATH</span><br></code></pre></td></tr></table></figure></li></ol><p>PS: 如果conda名称弹出问题，使用<code>sudo vi ~/.bashrc</code>查看conda路径是否正确</p><ol start="3"><li>conda相关命令<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs applescript">conda <span class="hljs-built_in">list</span> 查看安装包<br>conda info <span class="hljs-comment">--envs 查看环境</span><br>conda <span class="hljs-built_in">activate</span> XXX 激活环境 （XXX 为环境名称）<br>python -V 检查Python版本<br><br>如果需要卸载anaconda的话，只需要删除anaconda目录即可:<br>rm -rf /root/xxx/anaconda3<br></code></pre></td></tr></table></figure></li><li>使用conda-pack迁移环境</li></ol><p>在源机器：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">conda pack -n env-<span class="hljs-built_in">name</span> <span class="hljs-comment">--ignore-editable-packages（如果没有后面这个会报错）</span><br>得到一个env_name.tar.gz压缩文件<br></code></pre></td></tr></table></figure><p>在目标机器：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">cd ~<span class="hljs-regexp">/anaconda3/</span>envs;<br>mkdir env_name<br>tar -xzvf env_name.tar.gz -C <span class="hljs-regexp">/home/</span>root_name<span class="hljs-regexp">/anaconda3/</span>envs/env_name<br></code></pre></td></tr></table></figure><ol start="5"><li>使用环境<br><code>source activate attnGAN</code></li></ol><p>注意使用conda activate会报错<br>目前找到一个解决方案：<br><a href="https://blog.csdn.net/qq_43828332/article/details/114235922">https://blog.csdn.net/qq_43828332/article/details/114235922</a></p><p>总共耗时 1个半小时左右~</p><h4 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h4><ol><li><a href="https://blog.csdn.net/lwgkzl/article/details/89329383">https://blog.csdn.net/lwgkzl/article/details/89329383</a></li><li><a href="https://www.jianshu.com/p/1fddd11bcd25">https://www.jianshu.com/p/1fddd11bcd25</a></li><li><a href="https://blog.csdn.net/ds1302__/article/details/120027173">https://blog.csdn.net/ds1302__/article/details/120027173</a></li></ol><p>注意之江实验室hec anaconda3的安装路径是：/nfs/home </p><h4 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h4><p>在终端输入conda info –envs检验anaconda是否安装成功，发现报错：conda: command not found</p><p>原因是因为~/.bashrc文件没有配置好</p><p>解决方案：<br>sudo vim ~/.bashrc<br>在最后一行加上<br>export PATH=$PATH:/home/vincent/anaconda3/bin</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h3&gt;&lt;p&gt;一个服务器上已经搭建好的环境，但是需要换另一台机器，或者另外的用户需要访问这个环境， 如果另一台服务器上没有anaconda</summary>
      
    
    
    
    
    <category term="conda environment" scheme="http://example.com/tags/conda-environment/"/>
    
  </entry>
  
  <entry>
    <title>RPC related</title>
    <link href="http://example.com/2021/12/03/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/rpc/"/>
    <id>http://example.com/2021/12/03/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/rpc/</id>
    <published>2021-12-03T02:01:07.000Z</published>
    <updated>2022-01-28T10:41:05.465Z</updated>
    
    <content type="html"><![CDATA[<p>gRPC 可以保证不同语言之间的通讯<br>编写.proto文件，生成指定语言源代码。<br>编写服务端代码<br>编写客户端代码<br><a href="https://www.liwenzhou.com/posts/Go/gRPC/">https://www.liwenzhou.com/posts/Go/gRPC/</a>  一个python客户端和go服务端的例子</p><p>pytorch的官网框架<br>rpc常见方法<br>rpc_sync同步远程调用、rpc_async异步远程调用、remote异步远程调用。</p><p>rpc.init_rpc 初始化rpc，需要在master和worker都进行初始化，方便之后的通讯<br>rpc.rpc_sync  worker端调用在master上进行执行的方法<br>rpc.rpc_async<br>rpc.remote</p><p>dist_autograd.get_gradient(cid) 目前猜测在rpc场景进行前向传播，的梯度反向传播需要使用dist_grad</p><p>TrainNet是worker调用的假的网络，实际的网络是在Net里面调用，每次worker里面数据的前向传播，实际上都是在master里面的调用net进行前向传播</p><h3 id="分析rpc-parameter-server代码"><a href="#分析rpc-parameter-server代码" class="headerlink" title="分析rpc_parameter_server代码"></a>分析rpc_parameter_server代码</h3><p>master和worker都需要init_rpc</p><p>worker里面主要执行TrainNet：初始化的时候得到远程parameterServer的引用，然后包含二个函数 get_global_param_rref 以及forward函数(均要调用remote_method)<br>master里面执行parameterServer类，：初始的时候，得到真实训练的model, 同时实现三个函数, 对模型参数加上的引用rpc.RRef，使用dist_autograd得到模型参数，以及对输入数据进行前向传播</p><p>在master中加上</p><p>uni_sample_score_rref</p><h3 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h3><p>route_guide_client文件主要是通过stub 和传入的参数调用server的函数</p><p>route_guide_server里面主要是编写得到输入服务器处理函数逻辑</p><p>route_guide_pb2_grpc，类似于头文件，定义Stub类和Servicer类，每个类只是定义函数，但不进行具体的实现； 以及一个add_RouteGuideServicer_to_server的函数</p><h4 id="使用go语言"><a href="#使用go语言" class="headerlink" title="使用go语言"></a>使用go语言</h4><ul><li>前置安装要求<br>安装go，和protocol buffer编译器<br><a href="https://grpc.io/docs/languages/go/quickstart/#prerequisites">https://grpc.io/docs/languages/go/quickstart/#prerequisites</a></li></ul><p>go command not found<br>使用export， 重启一个控制台窗口就找不到这个命令了<br>需要使用vim <del>/.bashrc写入文件 将这个命令写进去，然后使用source ~/.bashrc<br>(</del>/.bashrc:是用户相关的终端（shell）的环境设置，通常打开一个新终端时，默认会load里面的设置，在这里的设置不影响其它人。<br>/etc/profile会影响所有的用户)</p><p>go download超时解决：<br>export GOPROXY=<a href="https://goproxy.cn/">https://goproxy.cn</a></p><h4 id="使用python"><a href="#使用python" class="headerlink" title="使用python"></a>使用python</h4><p>一个python小例子：<a href="https://grpc.io/docs/languages/python/quickstart/">https://grpc.io/docs/languages/python/quickstart/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;gRPC 可以保证不同语言之间的通讯&lt;br&gt;编写.proto文件，生成指定语言源代码。&lt;br&gt;编写服务端代码&lt;br&gt;编写客户端代码&lt;br&gt;&lt;a href=&quot;https://www.liwenzhou.com/posts/Go/gRPC/&quot;&gt;https://www.liwen</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>orangefs</title>
    <link href="http://example.com/2021/12/01/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/orangefs/"/>
    <id>http://example.com/2021/12/01/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/orangefs/</id>
    <published>2021-12-01T07:54:01.000Z</published>
    <updated>2021-12-13T07:31:23.945Z</updated>
    
    <content type="html"><![CDATA[<h3 id="orangefs"><a href="#orangefs" class="headerlink" title="orangefs"></a>orangefs</h3><ol><li><p>genconfig是一个go语言文件，它有一个可选参数oranges-server.conf</p></li><li><p>init_start_all.sh相比start_all.sh 多了一个/local500G/orange_store/ 以及多了一条有-f命令的语句 应该是在服务器节点启动pvfs-server<br>orangefs默认的服务器的文件系统挂载的目录是在oranges-server.conf里面进行配置（/nfs/home/yfwang/orangefs/install/etc/oranges-server.conf）</p></li></ol><p>加上f的原因： 第一次启动PVFS2服务要首先分配空间，添加参数-f：<br>root@ubuntu:~# pvfs2-server /etc/pvfs2-fs.conf -f<br>其后启动服务则不需加参数，或使用-d使得服务运行于前台（占用当前终端窗口，终端窗口关闭后服务终止）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> host <span class="hljs-keyword">in</span> `cat /nfs/home/yfwang/orangefs/install/nodelist`<br><span class="hljs-keyword">do</span><br><span class="hljs-comment">#       ssh -t -t -o StrictHostKeyChecking=no -o PasswordAuthentication=no $USER@$host sudo rm -rf /local500G/orange_store/*</span><br>        ssh -t -t -o StrictHostKeyChecking=no -o PasswordAuthentication=no <span class="hljs-variable">$USER</span>@<span class="hljs-variable">$host</span> sudo /nfs/home/yfwang/orangefs/install/sbin/pvfs2-server -f /nfs/home/yfwang/orangefs/install/etc/oranges-server.conf<br>        ssh -t -t -o StrictHostKeyChecking=no -o PasswordAuthentication=no <span class="hljs-variable">$USER</span>@<span class="hljs-variable">$host</span> sudo /nfs/home/yfwang/orangefs/install/sbin/pvfs2-server /nfs/home/yfwang/orangefs/install/etc/oranges-server.conf<br><span class="hljs-keyword">done</span> <br></code></pre></td></tr></table></figure><ol start="4"><li><p>stop_all.sh 停止所有的pvfs-server</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> host <span class="hljs-keyword">in</span> `cat /nfs/home/yfwang/orangefs/install/nodelist`<br><span class="hljs-keyword">do</span><br>        ssh -t -t -o StrictHostKeyChecking=no -o PasswordAuthentication=no <span class="hljs-variable">$USER</span>@<span class="hljs-variable">$host</span> sudo killall pvfs2-server<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure></li><li><p>start_client.sh 启动客户端orangefs-client， 同时将服务器任意一个节点的位置暴露为客户端，例子是hec09</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo /nfs/home/yfwang/orangefs/install/sbin/pvfs2-client -f -p /nfs/home/yfwang/orangefs/install/sbin/pvfs2-client-core<br>sudo mount -t pvfs2 tcp://hec09:3334/orangefs /mnt/orangefs<br></code></pre></td></tr></table></figure><p>nodelist<br>里面直接写hec10 hec11</p><p><a href="https://github.com/waltligon/orangefs/wiki/Distributions-and-Layouts">https://github.com/waltligon/orangefs/wiki/Distributions-and-Layouts</a> 设置数据不同的放置策略,一个文件放在一个节点使用basic方式 distribution</p><p><a href="https://github.com/waltligon/orangefs/wiki/Programming-Guide">https://github.com/waltligon/orangefs/wiki/Programming-Guide</a></p><p>setfattr -n “user.pvfs2.dist_name” -v “basic_dist” /mnt/pvfs2/directory<br>./bin/pvfs2-xattr -s -k “user.pvfs2.dist_name” -v “basic-dist” /mnt/shu-orangefs/dataset</p><p>orangefs里面有一个PINT_dist函数<br><a href="https://www.mcs.anl.gov/~robl/pvfs2/pvfs2-dox/html/pint-distribution_8c.html#a2">https://www.mcs.anl.gov/~robl/pvfs2/pvfs2-dox/html/pint-distribution_8c.html#a2</a></p><h5 id="现在找到将文件保存在一个服务器的方案："><a href="#现在找到将文件保存在一个服务器的方案：" class="headerlink" title="现在找到将文件保存在一个服务器的方案："></a>现在找到将文件保存在一个服务器的方案：</h5><p><a href="https://stackoverflow.com/questions/64923445/how-to-configure-orangefs-save-the-file-into-the-same-server-not-split-it">https://stackoverflow.com/questions/64923445/how-to-configure-orangefs-save-the-file-into-the-same-server-not-split-it</a><br>使用命令：setfattr -n “user.pvfs2.num_dfiles” -v “1” /mnt/orangefs<br>如果按照这种方式设置会报错：setfattr -n “user.pvfs2.dist_name” -v “basic_dist” /mnt/pvfs2/directory 传输数据会报错</p><h3 id="配置教程"><a href="#配置教程" class="headerlink" title="配置教程"></a>配置教程</h3><p>安装server<br>拷贝已经编译好的程序<br>cp -r /nfs/home/yfwang/orangefs/install /nfs/home/weijian/orangefs_install/<br>配置server<br>./bin/pvfs2-genconfig /nfs/home/weijian/orangefs_install/install/orangefs-server.conf<br>具体的配置项，自己可以先记录下来<br>tcp<br>3336<br>/local500G/wj-fast/storage/data<br>/local500G/wj-fast/storage/meta<br>/var/log/orangefs-server.log<br>hec08,hec09<br>配置完成时可以cat /nfs/home/weijian/orangefs_install/install/orangefs-server.conf查看配置项是否符合需求<br>到各个server上，各自初始化存储目录<br>sudo ./sbin/pvfs2-server -f orangefs-server.conf -a <server alias><br>到各个server上，启动服务<br>sudo ./sbin/pvfs2-server  orangefs-server.conf</p><p>安装client<br>拷贝已经编译好的程序（如果已经可以访问就不需要拷贝了）<br>scp -r weijian@hec08:/nfs/home/yfwang/orangefs/install/ /nfs/home/weijian/orangefs_install/<br>向内核加载orangefs模块<br>sudo modprobe orangefs<br>创建挂载点<br>sudo mkdir /mnt/wj-fast-orangefs<br>写配置文件<br>sudo sh -c “echo ‘tcp://hec08:3336/orangefs /mnt/wj-fast-orangefs pvfs2’ &gt;&gt; /etc/pvfs2tab”<br>测试与server是否连通<br>./bin/pvfs2-ping -m /mnt/wj-fast-orangefs<br>启动client客户端<br>sudo ./sbin/pvfs2-client -p ./sbin/pvfs2-client-core<br>挂载<br>sudo mount -t pvfs2 tcp://hec08:3336/orangefs /mnt/wj-fast-orangefs</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;orangefs&quot;&gt;&lt;a href=&quot;#orangefs&quot; class=&quot;headerlink&quot; title=&quot;orangefs&quot;&gt;&lt;/a&gt;orangefs&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;genconfig是一个go语言文件，它有一个可选参数oranges-se</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>System Design</title>
    <link href="http://example.com/2021/11/24/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/system%20design/"/>
    <id>http://example.com/2021/11/24/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/system%20design/</id>
    <published>2021-11-24T12:40:15.000Z</published>
    <updated>2021-11-24T12:43:50.793Z</updated>
    
    <content type="html"><![CDATA[<p>lintcode</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;lintcode&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>二叉树</title>
    <link href="http://example.com/2021/11/23/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://example.com/2021/11/23/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2021-11-23T02:27:56.000Z</published>
    <updated>2022-02-12T04:12:46.473Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>二叉树的前序序列化<br> 观察规律题或者建树题<br> 我的思路是直接建立一颗二叉树，但是建立树代码可以不写；<br> 官方题解是：通过槽位计数，如果遍历到最后槽位为0说明正确，如果中间槽位为0，说明出错<br> 注意这道题的易错点是: 字符串中包含’,’而且可能数字包含两个字符 98,7,#</p></li><li><p>二叉树的宽度： 宽度应该包含一层的节点之间夹杂的空字符，所以为了得到一层的宽度，应该在栈中压入每个节点的下标(左边：2 * pos, 右边：2 * pos+1)，而不是具体的二叉树ListNode</p></li><li><p>两个子节点的最近公共父节点</p></li></ol><p>如果一个节点为target_one或者target_two那么直接返回当前节点，否则进行dfs, dfs返回的左右节点都是非NULL那么就返回当前节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">ListNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(ListNode* root, ListNode* node1, ListNode* node2)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>||root==p||root==q) <span class="hljs-keyword">return</span> root;<br>    <span class="hljs-keyword">if</span>(root==node1||root==node2)&#123;<br>        <span class="hljs-keyword">return</span> cur;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        ListNode *left=<span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left, node1, node2);<br>        ListNode *right=<span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right, node1, node2);<br>        <span class="hljs-keyword">if</span>(left&amp;&amp;right)&#123;<br>            <span class="hljs-keyword">return</span> cur;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left)&#123;<br>            <span class="hljs-keyword">return</span> left;<br>        &#125;<br>        <span class="hljs-keyword">return</span> right;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><ol start="4"><li>从二叉树一个节点到另一个节点每一步的方向</li></ol><p>方法，通过dfs找到到达startValue和dstValue的具体路径，然后删除路径前面相同的部分，然后到达startValue剩余的size都加上U， 到达dstValue剩余的都加上dst剩余的路径</p><ol start="5"><li>寻找重复的树，<br>注意这道题需要记录空节点，同时，只能使用前序或者后序遍历 唯一判定两棵子树是否相同，而不能使用中序遍历。而且数据与数据应该用，隔开，因为222可以理解为2+2+2也可以理解为2+22 </li></ol><p>==加上#的这种情况，只有后序遍历和前序遍历能够唯一确定一课子树。中序遍历不行==</p><p>同样这道题使用二叉树的序列化和反序列化, 因为前序和后序都可以知道根节点，但是中序不行</p><ol start="6"><li><p>最长同值路径<br>为了区分left+right+1 left+1 right+1三种情况，可以使用一个left_mark 如果左边和root相等那么==left_val+1否则为0。那么最后的结果都是left_mark+right_mark+1， 解决了三种情况 返回max(left_mark, right_mark)+1</p></li><li><p>二叉树中所有距离为 K 的结点<br>先通过dfs找到每个节点的父节点，然后再对target节点进行dfs 左右和父节点 (或者bfs+vis)</p></li><li><p>二叉树寻路，使用数学方法<br> 1.先求每个数正常的父亲，然后再对不同的层进行修改<br> 2.在进行修改的时候抓住对称的点的和是相同的<br> 3.如果层数是偶数，那么只需要修改奇数层的值；如果层数是奇数，那么需要修改奇数层的数据</p></li><li><p>二叉树中两个节点间的距离<br>先求两个节点的最近公共祖先，然后从最近公共祖先出发，求祖先节点分别到两个节点的距离(使用dfs两次，target==p||q)，距离之和就是两个节点的最短路径<br>代码：<a href="https://www.jianshu.com/p/cec33f514f69">https://www.jianshu.com/p/cec33f514f69</a></p></li></ol><ol start="10"><li>树的直径问题<br>任意选择一个节点为根，然后找到离他最远的节点a，然后找到离a最远的节点b，那么a-&gt;b就是最远的路径（数的直径）<br>如果是二叉树有指针的情况可以使用递归<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> result=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxDistance</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> leftLength=<span class="hljs-built_in">maxDistance</span>(root-&gt;left);<br>    <span class="hljs-keyword">int</span> rightLenght=<span class="hljs-built_in">maxDistance</span>(root-&gt;right);<br>    result=<span class="hljs-built_in">max</span>(leftLength+rightLenght+<span class="hljs-number">1</span>, result);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(leftLength, rightLenght)+<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">diameterOfBinaryTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-built_in">maxDistance</span>(root);<br>    <span class="hljs-keyword">return</span> result<span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>如果是无向图：<br>算法思想<br>①从任意一点P出发，通过DFS寻找离它最远的点Q。<br>②再次从点Q出发，通过DFS寻找离它最远的W。<br>③直径即为WQ。<br>证明：<a href="https://zhuanlan.zhihu.com/p/115966044">https://zhuanlan.zhihu.com/p/115966044</a></li></ol><p>两次dfs</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> st)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;edge[st].<span class="hljs-built_in">size</span>();i++)<br>    &#123;<br>        <span class="hljs-keyword">int</span> to=edge[st][i];<br>        <span class="hljs-keyword">if</span>(!vis[to])<br>        &#123;<br>            vis[to]=<span class="hljs-number">1</span>;<br>            dis[to]=dis[st]+<span class="hljs-number">1</span>;<span class="hljs-comment">//注意，本代码计算的是无权树的直径，所以边权为1</span><br>            <span class="hljs-comment">//如果是有权树，则这里的1要改为边权</span><br>            <span class="hljs-built_in">dfs</span>(to);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>求最长就是求最大的dis，两次dfs中间需要重新初始化dis=0</p><ol start="11"><li>具有所有最深节点的最小子树</li></ol><p>在深度优先搜索的时候同时返回结果和计算深度，返回的是一个结构体 node{root, dist}.<br>1)获取当前节点的左右子树的最大深度<br>2)如果两边最大深度相同，则这个节点就是结果<br>3)不相等，那返回深度大的子树的root信息</p><ol start="12"><li><ol start="205"><li>同构字符串/890. 查找和替换模式<br>查找和对应模式一致的字符串，abb模式。<br>使用双hash,也就是两边都没有映射，才建立映射，或者两边都有映射且未对方，那么continue,否则说明出处<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span>(s2t.<span class="hljs-built_in">find</span>(s[i])==s2t.<span class="hljs-built_in">end</span>()&amp;&amp;t2s.<span class="hljs-built_in">find</span>(t[i])==t2s.<span class="hljs-built_in">end</span>())&#123;<br>    s2t[s[i]]=t[i];<br>    t2s[t[i]]=s[i];<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s2t[s[i]]=t[i]&amp;&amp;t2s[t[i]]==s[i])&#123;<br>    <span class="hljs-keyword">continue</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;p&gt;二叉树的前序序列化&lt;br&gt; 观察规律题或者建树题&lt;br&gt; 我的思路是直接建立一颗二叉树，但是建立树代码可以不写；&lt;br&gt; 官方题解是：通过槽位计数，如果遍历到最后槽位为0说明正确，如果中间槽位为0，说明出错&lt;br&gt; 注意这道题的易错点是: 字符串中包含’,</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>链表</title>
    <link href="http://example.com/2021/11/16/leetcode/%E9%93%BE%E8%A1%A8/"/>
    <id>http://example.com/2021/11/16/leetcode/%E9%93%BE%E8%A1%A8/</id>
    <published>2021-11-16T10:29:23.000Z</published>
    <updated>2022-02-14T09:47:19.612Z</updated>
    
    <content type="html"><![CDATA[<p>有序链表的合并，一定要注意判断两个链表是否相交，或者链表是否有环的情况，如果遇到这两种情况要特殊处理</p><h5 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h5><ol><li>扁平化多级双向链表</li></ol><h5 id="易错点"><a href="#易错点" class="headerlink" title="易错点"></a>易错点</h5><ol><li>判断head是否为null</li><li>在使用tmp-&gt;next 或者tmp-&gt;prev 一定要注意判断当前节点不能为null<br>也就是if(tmp){</li></ol><p>}</p><p>3.双向链表在进行删除某个节点的时候，先固定前面和后面的关系都可以；但是在插入一个节点的时候一定要先固定后面的</p><p>4.LRU cache易错点：再删除需要指针+hash都需要消除，cache.erase(lastNode-&gt;key); delete lastNode;<br>可以用hash.size()定位cache元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"> LRU cache（一个双向链表，一个hash）<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LinkNode</span>&#123;</span><br>    <span class="hljs-keyword">int</span> key,val;<br>    LinkNode* next;<br>    LinkNode* pre;<br>    <span class="hljs-built_in">LinkNode</span>()&#123;<br>        next=<span class="hljs-literal">nullptr</span>;<br>        pre=<span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;有序链表的合并，一定要注意判断两个链表是否相交，或者链表是否有环的情况，如果遇到这两种情况要特殊处理&lt;/p&gt;
&lt;h5 id=&quot;例题&quot;&gt;&lt;a href=&quot;#例题&quot; class=&quot;headerlink&quot; title=&quot;例题&quot;&gt;&lt;/a&gt;例题&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;扁平化多级双</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>资源汇总</title>
    <link href="http://example.com/2021/11/16/%E5%85%B6%E4%BB%96/%E5%90%84%E7%B1%BB%E8%B5%84%E6%BA%90/"/>
    <id>http://example.com/2021/11/16/%E5%85%B6%E4%BB%96/%E5%90%84%E7%B1%BB%E8%B5%84%E6%BA%90/</id>
    <published>2021-11-16T07:32:21.000Z</published>
    <updated>2022-01-05T10:43:02.233Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.payititi.com/">人工智能相关各种任务数据集下载网站</a></p><p>阿里巴巴各部门:<a href="https://blog.csdn.net/alitech2017/article/details/105096822">https://blog.csdn.net/alitech2017/article/details/105096822</a></p><p>基础设施部门面经</p><p>8a100tianshu账号登录方式：<br>登录地址(需之江内网orVPN)：<a href="https://access.zhejianglab.com/">https://access.zhejianglab.com</a>  maokuang 密码请咨询毛旷，登录后：运维–主机运维—“登陆”栏目下的地球图<br>密码zjlab!@#</p><p><a href="https://github.com/SharingSource/LogicStack-LeetCode/wiki">https://github.com/SharingSource/LogicStack-LeetCode/wiki</a> 宫水三叶的刷题笔记</p><p>画图工具：<br><a href="https://draveness.me/sketch-and-sketch/">https://draveness.me/sketch-and-sketch/</a></p><p>hugo为后端的博客</p><p>做笔记的工具：notion 截图的工具：snipaste</p><p>可以将进程放在后台执行的软件 screen或者tmux</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.payititi.com/&quot;&gt;人工智能相关各种任务数据集下载网站&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;阿里巴巴各部门:&lt;a href=&quot;https://blog.csdn.net/alitech2017/article/details/10509</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>每天任务记录</title>
    <link href="http://example.com/2021/11/15/%E6%97%A5%E5%B8%B8%E8%AE%B0%E4%BA%8B/%E6%AF%8F%E5%A4%A9%E4%BB%BB%E5%8A%A1%E8%AE%B0%E5%BD%95/"/>
    <id>http://example.com/2021/11/15/%E6%97%A5%E5%B8%B8%E8%AE%B0%E4%BA%8B/%E6%AF%8F%E5%A4%A9%E4%BB%BB%E5%8A%A1%E8%AE%B0%E5%BD%95/</id>
    <published>2021-11-15T03:19:12.000Z</published>
    <updated>2022-01-28T13:01:25.600Z</updated>
    
    <content type="html"><![CDATA[<p>11-15<br>记得之后验证一下multiple是否支持只有loss这种情况，如果支持的话，sampler全部修改为一个，同时目前只修改和看BS这种情况</p><p>tune参数包括warm_up_epoch and sampling rate</p><p>完成情况：整理完之前的IOAS代码，将multi和single进行融合，同时使用字典形式来替换if-else多个flag的情况<br>记录：leetcode 刷题指南完成：贪心算法， 哈希表，双指针部分, 栈与队列部分</p><p>11-16<br>初步完成论文框架思维导图</p><p>修改代码，找到IO瓶颈场景</p><p>在代码中添加上视频分析这个场景</p><p>今天突然想到suprevision是用的什么anchor box，需要将数据下载完成后验证，猜测使用featmap_size??而不是预设的anchor</p><p>总结：<br>看完interviewtop上操作系统的八股文<br>下载coco数据<br>完成一版xmind思路调整<br>查看阿里基础架构面经</p><p>11-17<br>找到io为瓶颈的场景，并进行重要性采样实验<br>目前发现MS比BS精度高</p><p>BS：面临的问题  如何选择阈值 目前：搜索出初始thres_ratio, 之后使用历史+当前thres_ratio调整，//没有被计算的使用远程存储的模型进行计算,以及根据模型能力调整thres_ratio</p><p>MS: recall interval,不同等级之间的recall 时间差距是1 epoch 吗，新划分出来训练的类又如何根据阈值划分呢（等分感觉不科学）//建一个模型自动划分和确定等待的时间  （多个阈值和多个等待时间的确定）</p><p>现在只修改BS (1)实现在存储端计算样本重要性， （2）感觉样本的位置</p><p><a href="https://www.sigarch.org/the-new-bottlenecks-of-ml-training-a-storage-perspective/">https://www.sigarch.org/the-new-bottlenecks-of-ml-training-a-storage-perspective/</a> 这个讲得挺好<br>处理的浏览了一下FreqCheck 的源码 但是每太明白细节上是如何在torch.save()后面封装 fsync(),   以及如何根据runtime overhead的profile结果进行自适应的checkpointing frequency超参数的调节</p><p>目标：弄懂多进程异步/模型的异步训练， 参考autoassist 以及checkFreq，subprocess<br>以及另外开一个进程来进行io带宽的测量(profile)以及未读取数据的重要性更新，另外一个空闲节点</p><p>11-18</p><p>看了autoassist的多进程，但是他们在训练另外一个模型进行样本的现在是训练了另外一个二分模型，这个二分模型的目标是 loss大于均值为target或者target model判断错误的label=1</p><p>我要训练的另外一个模型是在存储节点训练的模型，无需训练只需要将模型每次最新权重穿过来，在checkpoint的时候将模型传给远端; screen 需要同时训练另外一个模型会加重CPU和GPU训练负担，同时也不是很好同步轻量级模型和远程target模型判断样本重要性的差距</p><p>完成另外一个进程异步训练模型的初步代码</p><p>11-22</p><p>完成情况：<br>完成主进程和子进程相互传输重要性分数，invalid list以及模型初步代码</p><p>明天需要解决的问题：<br>1）如果解决模型参数保存的时候使用model.cpu().state_dict() 但是计算的时候需要使用dp 或者cuda, 保存模型这个动作如何转为复制模型参数，而不是真正将模型保存到cpu</p><ol start="2"><li>如何减少推理时间太长的问题，如果使用原模型进行不重要样本重要性计算</li></ol><p>3）如果将一个节点转移到两个节点间的数据传输（远端存储系统情况）</p><p>4）把这个解决了，再解决如何修改io module 自定义一个缓冲区，然后在缓冲区/cache中实现TLB表，以及数据从缓冲区中读取</p><p>要解决的问题：1 分布式训练如何将另外一个进程计算得到的uni_score广播给其他进程<br>而且注意是多个分布式训练主进程对应一个子进程，不应该建立多个进行不重要样本重要性计算的子进程</p><p>目前遇到的问题：RuntimeError: module must have its parameters and buffers on device cuda:0 (device_ids[0]) but found one of them on device: cpu–&gt;解决，因为model.cpu().state_dict导致</p><p>11-23</p><p>完成情况：</p><p>1）使用一个copy.deepcopy完成在gpu上模型的拷贝到cpu<br>2) 解决子进程无法正常退出的问题<br>3）初步熟悉dataloader和dataset的代码</p><p>下一步：<br>如何解决判断数据是在缓存， 本地磁盘， 还是远端存储系统呢</p><p>11-24  </p><p>1）调整了lru_cache的逻辑<br>2）但是目前不知道如何将tlb得到的信息转为io_predict_time<br>3）初步使用多进程访问同一个cache,同时记录总访问次数和命中率，因为多进程需要共享一个数据结构，因此使用multiprocessing.Manager 因为LRUcache是自定义的一个数据结构，因此需要使用自定义的manager</p><p>目前发现worker越多，access 缓存次数越多</p><p>worker = 8<br>self.size:256<br>total_access_time:2432, hit_time:128</p><p>worker = 4<br>self.size:256<br>total_access_time:1048, hit_time:128</p><p>worker = 0<br>self.size:128<br>total_access_time:384, hit_time:256</p><p>如何只是对cache的每个变量使用multiprocessing进行加锁的话会导致出现None 结构remove错误，所以对于cache的get set函数都应该是一个原子操作（一个事务），所以需要对cache使用原子操作（加锁），而不仅仅是里面的一个变量加锁就可以了</p><p>11-25</p><p>验证多进程为什么总的访问次数会增加，以及为什么使用缓存的大小增加，但是命中率会减小<br>考虑如何将tlb功能转为IO score的计算<br>如何感知数据的位置，在其他节点的存储中，本地存储中，还是缓存中</p><p>发现：epoch=0和epoch=1的时候多进程取数据hit time=0， cache size=256 但是如果worker=0的话， epoch=1时候的命中率应该为128 cache size=128<br>解释：因为我在执行流程中间break了，但是数据还在提前取后面一轮的，所以导致cache size会满，同时命中率下降；第二轮本来要取的序列就减少了，所以多进程也没有讲缓存的数据冲走；也可以解释第0轮epoch就有2000多次的访问量</p><p>加上缓存：<br>Training done in 0.069387 hours<br>Training  done in 0.068791 hours</p><p>不加缓存：<br>Training  done in 0.017339 hours<br>Training  done in 0.035785 hours<br>Training  done in 0.037956 hours 命中率384</p><p>使用字典进行缓存，随机置换：<br>Training  done in 0.022509 hours<br>Training  done in 0.039637 hours  命中率 224</p><p>pyshmht 为python设计的基于hash表的共享内存</p><p>asyncio</p><p>目前结论：使用一个随机置换策略的缓存相比LRU置换效果更好  或者直接使用coodl的缓存后就固定不变</p><p>感觉应该是LRU每次加锁读写链表</p><p>明日安排：完成整个训练过程加缓存以及如何将缓存的位置转化为IO score</p><p>11-29</p><p>RPC小例子<br><a href="https://zhuanlan.zhihu.com/p/136372142">https://zhuanlan.zhihu.com/p/136372142</a></p><p>了解一下rpc pytorch， 打算使用nfs再使用orangefs来实现两个节点上worker的通信<br>看了两篇论文：1.是分析深度学习不同存储方式的性能 2.运用机器学习判断应用的IO模式，然后自适应的选择相应的优化策略（主要是针对有读写，以及I/O模式在整个应用生命过程中会改变，但深度学习是只读的，I/O模式似乎都是一样的）<br><a href="https://github.com/apachecn/apachecn-dl-zh/blob/master/docs/pt-tut-17/65.md">https://github.com/apachecn/apachecn-dl-zh/blob/master/docs/pt-tut-17/65.md</a></p><p>11-30<br>使用sudo aptitude install nfs-common 选择n y的时候安装失败，导致sudo无法使用，同时机器无法连接，修机器<br>参加rebuttal的会议</p><p>12-1</p><p>问题如何在orangefs上挂imagenet, 挂了之后仍然像ext4文件一样访问 /mnt/orangefs吗， 记得修改默认orangefs 服务器的文件目录，目前默认是/local500/storage-orangefs/吗<br>最后为什么是mount hec09的orangefs 为什么不是local500/storage-orangefs</p><p>12-2 </p><ol><li>完成 rebuttal的提交</li><li>初步在节点hec01 和hec03上实现 rpc测试  学长使用的是不同语言之间相互通信的grpc 先写一个.proto 文件，然后使用一个工具 将他编译为目标py文件或者go文件，然后分别在py和go文件里面使用这个编译好的文件</li></ol><p>在提交英文版本的时候一定要注意英语的拼写问题</p><p>pytorch官网上的rpc网络： <a href="https://github.com/pytorch/pytorch/blob/master/docs/source/rpc.rst">https://github.com/pytorch/pytorch/blob/master/docs/source/rpc.rst</a></p><p>12-3 现在的问题是：worker如何确定当前可以shutdown</p><p>目前遇到的问题是如果是将远程过程调用放在sampler，如果是多进程取sampler的话会导致 出错，因此应该把远程过程调用的逻辑放在主函数里面</p><p>多进程会有多个sampler副本吗  难道是多进程访问sampler会加锁？？</p><p>明天 1.实现在每个epoch前进行重要性计算 train_one_epoch前  2. score通过字典传递，而不是list</p><p>rpc在远程过程调用的时候，如果调用的函数和初始化不在main函数下面py文件(主要的train_main 文件里)内会导致调用函数不一样 本来打算调用worker, 调用到master端</p><p>12-7<br>实现使用nfs， 以及torch.distributed.rpc实现两个任务之间的通信， 阅读grpc 的route_guide example源码， 如果要使用grpc需要使用异步+call back函数，或者使用一个子进程+同步grpc，然后实现主进程和子进程之间通过共享内存实现数据的共享</p><p>12-13</p><p>在hec01使用setattr修改了文件dataset的属性<br>现在的问题是存储单元如何得知自己存储节点的数据，或者假设存储节点非常的近，那么存储节点只需要派一个节点进行训练就好了</p><p>现在可以实现在一个存储单元上挂载orangefs-client查看数据， 之后换到新机器上实验orangefs形式的存储单元和计算单元 通讯和传递消息，目前server端只需要一个节点来进行推理，不需要每个server对每个server端的数据进行推理</p><p>12-14<br>找到一个bug， loss.mean().backward应该在loss.cpu.detach()前面，否则就会训练的时候精度一直为0，怀疑是torch版本的问题<br>打算再新环境中使用orangefs，然后进行通讯任务训练<br>以及考虑加上cache + IO score 预先训练cache中的数据</p><p>今天leetcode练习到532题</p><p>明日安排：</p><ol><li><p>先profile一下cache time 是否真的的比ssd time小很多 </p></li><li><p>同时查看一下是不是每轮epoch 第一个iteration时间最长， 找到网上解答原因</p></li><li><p>multi-criterion到底应该怎么用。</p></li><li><p>写一个简单的用cache的信息加入到multi-criterion计算（不同的优先级给定一个分数），以及在cache中采样第一个batch, 以及随机置换的cache策略，先写一个版本</p></li><li><p>cache size以及cache的转换策略将对io score产生怎样的影响</p></li></ol><p>相同数据每次的load time是不是都是变化很大。我感觉应该用时间近似，而不应该用level,因为不同cache的ssd的远近可能导致这两个时间相差很大，有的ssd读取和cache时间差不多那么io score应该就差不多，否则就应该加大io score的差距</p><p>感觉多进程预取会抵消cache好处？？如果IO是瓶颈的话，那么预取的效果就比从cache中取数据的效果差</p><p>12-15 完成一个简易版本的cache-aware sampling</p><p>主要包含下面三个功能的实现：</p><ol><li>IO score的计算问题 使用profile的cache的时间和ssd时间近似替代训练序列的all_result_list[‘iotime’]</li><li>sampler的序列问题， 先使用cache 里面缓存的序列</li><li>cache的置换问题，初步使用self.vis字典实现先替换cache中vis的序列，但是问题是每个epoch都需要clear一下cache的vis序列</li></ol><p>但是现在还是在注释中</p><p>12-16<br>尝试在8a100上实验，可能会考虑到分布式训练的sampler的修改<br>使之适应于分布式+orangefs这种场景</p><p>完成情况：目前在多GPU上调试了之前hec上面的代码，可以跑通单机多卡加上cache, 和修改了cache time计算方式的代码<br>初步完成昨天1， 2， 3个功能，目前的问题就是DataParallel+ another model in storage side可能会有问题</p><p>发现4 worker的时候 每4个iteration 第一个时间最长， 之后的时间都递减</p><p>明日计划：</p><p>四叉树合集有时间看看</p><p>12-17 数据传输慢是因为传输的带宽被占满了吗？ 是否可以开不同的数据取线程？来为用于级别cache增加命中率<br>为什么4worker时每个iteration 4个中必有一个时间长 （已解决）<br>这个iteration time和worker的设置有关</p><p>12-20<br>TODO: 分布式情况，多个节点得有多个cache, 这样的话在进行取数据的时候首先取cache中缓存的数据就不对，需要通过RDMA 需要直接取其他节点的cache数据才行<br>目前分析原因是消耗比读取快，消耗了一轮回过来，还是没有讲一个batch读完，所以又会在worker1处阻塞住，同时在worker1阻塞的时候，其他worker也在读取，所以表现为每隔一段时间就会出现一个IO时间非常长</p><p>但是如果计算是瓶颈，应该不会出现这个<br>resnet152的时候io_time就能够被计算时间覆盖了，所以所有的iotime大概都是0.0003左右</p><p>那么可以找到一个比较便捷的io瓶颈测量是将，看是否iotime是否随着worker进行周期变化； 但是总体上来说都是第一个iteration的iotime时间最长为1.6左右，因为没有任何计算来对iotime进行覆盖<br>alexnet其他worker每隔一段时间大概为0.5；resnet大概为0.2；其余为0.0003</p><p><a href="https://kangsheng.xyz/2020/07/14/pytorch%E4%B8%ADdataloader%E7%9A%84num_workers%E8%AE%BE%E7%BD%AE/">https://kangsheng.xyz/2020/07/14/pytorch%E4%B8%ADdataloader%E7%9A%84num_workers%E8%AE%BE%E7%BD%AE/</a><br>这里的iotime包括进程开销，以及batch读取+batch处理开销 但是多进程加载数据包括读+处理两个部分， 而不是只读<br>8A100 2个物理CPU, 每个cpu 物理64核， 每个核有两个逻辑处理器；所以两个cpu一起就有256个逻辑处理器（2<em>2</em>64）<br>hec02是8个cpu, 每个cpu上面只有一个核</p><p><a href="https://zhuanlan.zhihu.com/p/91521705">https://zhuanlan.zhihu.com/p/91521705</a> 查看dataset多worker加载数据，每个worker负责一个batch,只有在当前batch消耗掉之后才会取下一个分配的任务，而不是一直取数据。同时这个worker取数据包括读+数据增强两个部分</p><blockquote><p>其实各个worker之间读取数据时间差不多，并且由于是多进程任务，所以每次第一个worker读完数据就绪以后其他也准备就绪了，主进程随即开始连续前向传递了，并轮询的向各worker发送读新一批数据的信号，只不过跑完上一轮次所有worker产生的数据（num_workers个batch）后，各worker中新一轮次数据还没就绪，所以阻塞住了。</p></blockquote><p>4worker的情况下；<br>io_time: 0.6680457592010498<br>io_time: 0.00039649009704589844<br>io_time: 0.0004131793975830078<br>io_time: 0.00040602684020996094<br>io_time: 0.7091846466064453</p><p>8worker的情况下：<br>io_time: 0.583601713180542<br>io_time: 0.00048732757568359375<br>io_time: 0.011454343795776367<br>io_time: 0.0005695819854736328<br>io_time: 0.00035643577575683594<br>io_time: 0.0003287792205810547<br>io_time: 0.0004932880401611328<br>io_time: 0.0003211498260498047<br>io_time: 0.5443663597106934</p><p>16worker的时候：<br>io_time: 0.6202142238616943<br>io_time: 0.0005917549133300781<br>io_time: 0.0004055500030517578<br>io_time: 0.00042128562927246094<br>io_time: 0.0004863739013671875<br>io_time: 0.00027370452880859375<br>io_time: 0.0002474784851074219<br>io_time: 0.0002865791320800781<br>io_time: 0.00033855438232421875<br>io_time: 0.00021886825561523438<br>io_time: 0.0002658367156982422<br>io_time: 0.00020456314086914062<br>io_time: 0.0001895427703857422<br>io_time: 0.0005667209625244141<br>io_time: 0.0004878044128417969<br>io_time: 0.013859033584594727</p><p>worker数量越小，出现io_time突然增加的可能性越高<br>现在的问题是：在worker数量不足的时候是否这种用另外的worker去取数据，是否会影响数据加载的性能；相当于增加了线程数量；这好像更多加一个worker，然后多加一个缓存空间，实现超前预取没有实质区别<br>另外一种合理的解释就是说利用data worker取数据的空闲时间来进行cache的换新，但是IO 瓶颈data worker空闲的时间也不多呀；只有计算密集的data worker才会空闲</p><p>而且cache如果这样设计的话和buffer没有什么区别，因为都是取一次用一次，结论在buffer里面实现预取进程无用! 而且可能增加磁盘带宽压力</p><p>coordl又讲使用cache的理由吗？感觉可以直接沿用coordl理由</p><p>Gist：在两次数据利用之间有长时间的gap，因此可以对数据进行压缩，之后要用的时候再解压缩， ==在cache里面对数据进行压缩解压== 问题是data没有稀疏性，如果较好的无损压缩</p><p>12-21<br>目前分别在hec 和 8a100上测试远程过程调用和cache的代码</p><p>看代码的时候注意一下几个方面：<br>1）远程过程调用现在不能使用dataparallel  create_file<br>2) cache代码里面可以使用DP, 需要确定cache大小<br>3）loss.backward一定要在loss.cpu/记录loss 之前，否则会报错<br>4）合起来的时候一定要注意将init_rpc 以及 有关worker和master的代码打开（train_evaluate）<br>5) 感觉增加worker数量就能消除IO瓶颈的问题如何解决</p><p>找到一个bug: 使用dp的时候，batch_size应该*gpu数量，因为是一个batch size拆分，但是ddp不是</p><p>明天任务：<br>如何实现多GPU情况下，多进程共享一个数据结构cache， 因为现在好像是多个进程，每个可能都会创建一个cache这个是不合理的</p><p>12.22 </p><p>看了以及整理了一下括号相关的leetcode题目</p><p>rpc在回调结果的时候遇到一个问题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">master使用远程过程调用的结果来更新criterion_history_list_dict<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;./imagenet_final_train_master.py&quot;</span>, line <span class="hljs-number">206</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>    train_main(args.gpu, ngpus_per_node, args, kwargs)<br>  File <span class="hljs-string">&quot;./imagenet_final_train_master.py&quot;</span>, line <span class="hljs-number">94</span>, <span class="hljs-keyword">in</span> train_main<br>    run_training(model, trainloader, testloader, trainset, testset,  optimizer, criterion, dirs, args.epochs, args, kwargs)<br>  File <span class="hljs-string">&quot;/nfs/home/shu/hushuang_all_files/ImageClassification/8a100-code/IOAS/imagenet/train_evaluate.py&quot;</span>, line <span class="hljs-number">177</span>, <span class="hljs-keyword">in</span> run_training<br>    refresh_uni_list( uni_score_rref, allscore_numpy_dict, args)<br>  File <span class="hljs-string">&quot;/nfs/home/shu/hushuang_all_files/ImageClassification/8a100-code/IOAS/imagenet/rpc_func.py&quot;</span>, line <span class="hljs-number">44</span>, <span class="hljs-keyword">in</span> refresh_uni_list<br>    uni_score_list = uni_score_rref.to_here().numpy().tolist()<br>RuntimeError: RPCErr:<span class="hljs-number">1</span>:RPC ran <span class="hljs-keyword">for</span> more than <span class="hljs-built_in">set</span> timeout (<span class="hljs-number">60000</span> ms) <span class="hljs-keyword">and</span> will now be marked <span class="hljs-keyword">with</span> an error<br><br><span class="hljs-comment"># worker 端</span><br><br>[W tensorpipe_agent.cpp:<span class="hljs-number">498</span>] RPC agent <span class="hljs-keyword">for</span> worker1 encountered error when sending response to request <span class="hljs-comment">#16 to worker0: EOF: end of file</span><br></code></pre></td></tr></table></figure><p>12.23<br>现在8a100端注释了master的和worker代码就可以实现 存储端计算重要性+主进程端使用cache缓存部分数据</p><p>主要逻辑：（cache 3+ 存储单元 1）</p><ol><li>0epoch冷启动， 在1epoch缓存端已经开始缓存数据， 每轮训练的时候将vis的数据打一个标记，置换策略将vis的数据随机置换出去</li><li>下一轮 sampler返回训练的时候将cache中的数据放在前面</li><li>在重要性采样开始前一轮epoch，开始搜集重要性metric设计的分数，如果有io 分数的话，通过profile 的iotime 来对cache time的ssd load time进行估计（求平均值），同时对下一轮样本的iotime进行预测</li><li>将计算出来的重要的样本下一轮训练，不重要的样本序列通过rpc传给存储端的计算单元，让master和worker分别更新重要的样本和不重要样本的分数。</li><li>然后之后在进行采样的使用用全部更新好的重要性分数，重复排序和训练更新步骤</li></ol><p>解决两个bug:</p><ol><li>之所以8a100上面使用分布式调用不起来，是因为我之前在使用torch.distributed.rpc的时候写了os[‘environment’] =hec01  导致分布式错误</li><li>训练精度很低， 修改criterion<br>criterion = nn.CrossEntropyLoss(reduce=False).cuda(args.gpu) hec02实验<br>目前是用这个解决了，但是assert语句显示一致, 不知道原因</li></ol><p>12-27<br>解决cache在mp.spawn 使用多进程训练的时候导致段错误或者信号接收错误<br>选择启动方式：mp.set_start_method(‘spawn’)</p><p>在进行调试的时候，break不应该放在args,rank==0下面，否则就会卡死</p><p>12-28<br>现在的任务就是看rpc是否能和分布式训练的mp.spawn同时存在, 应该主进程主要负责rpc</p><p>ssh需要输入密码的节点为何无法使用rpc进行通信</p><p>12-29<br>今天主要看了legoos这篇论文， 对调度相关的其他论文也进行了总结和分类，以及看了ppt下面的链接有关内容<br>明日安排，做一下最短路径（单源或者多源情况）， 练习今天学到的有关Dijstra, Bellman-Ford算法以及Floyd算法</p><h4 id="2022"><a href="#2022" class="headerlink" title="2022"></a>2022</h4><p>1-3<br>完成&gt;400目标<br>代码主要就是看分布式+rpc是否能够兼容(+cache目前通过mp.spawn解决)并调试通过，实在ddp+rpc无法完成，就只能使用dp+rpc</p><p>1-6 现在遇到的问题：1.有ssh密码登录的机器，使用rpc无法正常运行， 同时rpc在同一台机器好像也无法正常运行</p><p>解决！<br>注意在rpc中发出rpc_async请求的是worker, 接收请求的是master</p><p>hec上使用pytorch 1.8.1只能在没有gpu的节点上，如果在hec01 hec02上就会报错</p><p>现在问题 8a100和hec06节点连接会报错：<br>aster: ECONNREFUSED: connection refused<br>Failed to respond to ‘Shutdown Proceed’ in time, got error ECONNREFUSED: connection refused<br>Traceback (most recent call last):<br>  File “worker.py”, line 88, in <module><br>    rpc.shutdown()<br>  File “/nfs/home/anaconda3/envs/pytorch-shu/lib/python3.6/site-packages/torch/distributed/rpc/api.py”, line 78, in wrapper<br>    return func(*args, **kwargs)<br>  File “/nfs/home/anaconda3/envs/pytorch-shu/lib/python3.6/site-packages/torch/distributed/rpc/api.py”, line 284, in shutdown<br>    _get_current_rpc_agent().join()<br>RuntimeError: [/opt/conda/conda-bld/pytorch_1607370193460/work/third_party/gloo/gloo/transport/tcp/pair.cc:575] Connection closed by peer [10.5.30.42]:27806</p><p>Solution: Edit /etc/hosts and change 127.0.1.1 to your actual ip-address 目前看到的一个答案<br>分析：现在在hec上互相使用rpc（即使有密码）是可以的，但是在8a100就不行，所以现在怀疑的是需要在host里面添加目录，以及需要在两台机器上换成同一个用户才行<br>第二种解决方案，应该使用tpc的init_method，以及使用gloo后端，但是目前试验过，仍然会报错</p><p>感觉在分布式多台机器上训练也会出现相同的问题</p><p>找到的真正的解决方案：backend=rpc.BackendType.PROCESS_GROUP， 不需要加其他的<br>os.environ[‘TF_SOCKET_IFNAME’] = ‘ens3’ (x)<br>os.environ[‘GLOO_SOCKET_IFNAME’] = ‘ens3’ (x)</p><p>寒假安排：</p><ol><li>leetcode争取上500 可以先将宫水三叶的题刷完，应该都是经典题目</li><li>对之前写的leetcode进行总结，整理，转为每个知识点，先放总结的思路，或者针对的题型，然后放相应的例题，没道例题简答写一下解决方案，和总结的思路进行对应</li><li>回归操作系统，计网的基础知识, 转为笔试的xmind (408题目看看)<br>github和牛客网应该有许多资源，多看看多比较; 包括深度学习和目标检测相关的面试题目<br>牛客网上， 网友的总结：(CyC2018)<br>[<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E7%9B%AE%E5%BD%95.md]">https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E7%9B%AE%E5%BD%95.md]</a></li><li>补充面试的xmind</li><li>有时间学一下grpc</li><li>记得备份一下8a100上面的数据 (目前正在8a100使用rsync进行传输 到hec06 /nfs目录下)<br>7。一些公司名单和深度学习的资料<br><a href="https://github.com/amusi/CV-Company-List">https://github.com/amusi/CV-Company-List</a><br>注意关注一下春招信息，微软已经开始投递了，然后我因为错过了问卷，错过了提前批，之后注意准备面试和之后的问卷</li><li>修改简历，变为项目两个， research两个，将重要性采样自己的工作写上去zzw</li><li>项目一定要非常非常熟悉，整理面试可能问到的每一个问题，和自己优化的思考！！！</li></ol><p>刷完八股之后，进行自测：<a href="https://github.com/youngyangyang04/TechCPP">https://github.com/youngyangyang04/TechCPP</a><br><a href="https://github.com/youngyangyang04/leetcode-master">https://github.com/youngyangyang04/leetcode-master</a></p><p>leetcode暂时未看的条目：<br>买通行票的最低价格</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;11-15&lt;br&gt;记得之后验证一下multiple是否支持只有loss这种情况，如果支持的话，sampler全部修改为一个，同时目前只修改和看BS这种情况&lt;/p&gt;
&lt;p&gt;tune参数包括warm_up_epoch and sampling rate&lt;/p&gt;
&lt;p&gt;完成情况：</summary>
      
    
    
    
    
    <category term="daily task" scheme="http://example.com/tags/daily-task/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2021/11/13/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/hello-world/"/>
    <id>http://example.com/2021/11/13/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/hello-world/</id>
    <published>2021-11-13T12:26:46.510Z</published>
    <updated>2021-11-13T12:27:48.242Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    <category term="工具相关" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/"/>
    
    
  </entry>
  
  <entry>
    <title>基本神经网络相关问题</title>
    <link href="http://example.com/2021/11/13/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E5%9F%BA%E6%9C%AC%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2021/11/13/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E5%9F%BA%E6%9C%AC%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/</id>
    <published>2021-11-13T12:11:27.000Z</published>
    <updated>2021-12-01T09:29:08.103Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>滤波和传统的图像算法 e.g. SIFT</p></li><li><p>CNN感受野定义以及计算方式<br>感受野指的是一个特定的 CNN 特征（特征图上的某个点）在输入空间所受影响的区域。<br>感受野的计算是输出图像的反向过程<br>out_put=(iput_size-kernel_size)/stride+1<br>input_size=(out_put-1)*stride+kernel_size</p></li></ol><ol start="3"><li><p>CNN矩阵乘法原理<br>参考链接：<a href="https://shuokay.com/2016/06/08/convolution/">卷积计算</a><br>img2col将卷积运算转为矩阵乘法<br>其中输入的矩阵：行方向对应特征图不同channel同一视野（位置）的向量展开；列方向代表不同的位置；<br>kernel的矩阵：行方向代表代表不同的卷积核，列方向代表一个滤波器每个channel的矩阵-&gt;向量，<br>输出矩阵</p></li><li><p>BatchNormalization与正则化的区别：<br> BatchNormalization主要是用于将神经网络中间输入特征图的均值和方差进行规范化，使输入分布拉到容易激活后面激活层中，解决梯度消失和梯度爆炸问题问题<br> 正则化，通常用于机器学习，在损失函数中加上参数的一阶或者二阶和，防止过拟合</p></li></ol><ol start="5"><li>产生梯度消失或爆炸的原因：<br>网络层数太深而引发的梯度反向传播中的连乘效应<br>解决梯度消失或者梯度爆炸问题的解决方案：<ul><li>batch BatchNormalization</li><li>梯度裁剪</li><li>修改激活函数，比如leaky relu</li><li>残差结构</li><li>每层预训练后微调</li></ul></li></ol><ol start="6"><li>机器学习：多分类如何转为多个二分类问题：需要训练N个分类器<br><a href="https://yuanxiaosc.github.io/2018/07/01/%E4%BA%8C%E5%88%86%E7%B1%BB%E3%80%81%E5%A4%9A%E5%88%86%E7%B1%BB%E4%B8%8E%E5%A4%9A%E6%A0%87%E7%AD%BE%E9%97%AE%E9%A2%98%E7%9A%84%E5%8C%BA%E5%88%AB%E2%80%94%E2%80%94%E5%AF%B9%E5%BA%94%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E7%9A%84%E9%80%89%E6%8B%A9/">参考链接</a><br>将每一次的一个类作为正例，其余作为反例，总共训练N个分类器。测试的时候若仅有一个分类器预测为正的类别则对应的类别标记作为最终分类结果，若有多个分类器预测为正类，则选择置信度最大的类别作为最终分类结果。<br>PS:目标检测的多标签二分类损失函数是使用每个标签的概率的求二分损失函数（逻辑损失）然后求平均值得到整体的损失<br>其他方案：<br>一对一，建立N(N-1)/2个分类器，然后进行投票<br>直接用softmax进行多分类任务训练</li></ol><ol start="7"><li><p>网络退化以及resnet为什么可以解决梯度消失和网络退化问题：<br>首先介绍什么是网络退化问题<br>举个例子，假设已经有了一个最优化的网络结构，是18层。当我们设计网络结构的时候，我们并不知道具体多少层次的网络时最优化的网络结构，假设设计了34层网络结构。那么多出来的16层其实是冗余的，我们希望训练网络的过程中，模型能够自己将这16层冗余层训练为恒等映射，也就是经过这层时的输入与输出完全一样。<br>但是往往模型很难将这16层恒等映射的参数学习正确，那么就不如最优化的18层网络结构的性能，这就是随着网络深度增加，模型会产生退化现象。它不是由过拟合产生的，而是由冗余的网络层学习了不是恒等映射的参数造成的。<br>也就是说神经网络学习恒等映射 F(x)=x 的效果不好，但是加上了skip connection 神经网络就用于学习F(x)=0</p></li><li><p>链式法则：<br>原本y对x求偏导，但是由于过程较为复杂，我们引入了一个中间层z，先利用y对z求偏导，在乘上z对x求偏导，这样会使整个计算更为简单。<br>当前error对当前层参数的导数，是error对当前输出（输出特征图）的倒数*当前节点的输入（输入特征图）</p></li></ol><ol start="9"><li>矩阵的反向传播算法/CNN的反向梯度传播算法</li></ol><ol start="10"><li>激活函数sigmoid，tanh，relu. 各自的优点和适用场景<br>[参考链接]（<a href="https://zhuanlan.zhihu.com/p/71882757%EF%BC%89">https://zhuanlan.zhihu.com/p/71882757）</a><br>激活函数的作用：主要是向神经网络中引入非线性的特征</li></ol><ul><li>sigmoid函数：主要运用在逻辑二分类中，缺点：计算复杂，不是0均值，同时容易出现梯度饱和，当输入是非常大的正值或者负值的时候，反向传播梯度为0；</li><li>tanh函数：是0均值，但是计算复杂，同时也容易出现梯度饱和问题</li><li>relu函数：计算简单，在输入大于0的时候不会出现梯度饱和，但是在输入小于0的时候会出现梯度为0，造成死的神经元，因此参数一直得不到更新</li></ul><ol start="11"><li><p>常见神经网络的结构特点和结构优势</p></li><li><p>牛顿法和SGD的各自原理，优势，区别</p></li><li><p>LR的梯度反向传播推导<br><a href="https://blog.csdn.net/ft_sunshine/article/details/105370528">https://blog.csdn.net/ft_sunshine/article/details/105370528</a></p></li></ol><p>方程：y=theta<em>x<br>激活函数 h(x)-1/(1+e^(-theta x))<br>损失函数 loss=1/m</em>求和(y^ilog(h(x)) - (1-y^i)log(1-h(x))))</p>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;p&gt;滤波和传统的图像算法 e.g. SIFT&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;CNN感受野定义以及计算方式&lt;br&gt;感受野指的是一个特定的 CNN 特征（特征图上的某个点）在输入空间所受影响的区域。&lt;br&gt;感受野的计算是输出图像的反向过程&lt;br&gt;out_put</summary>
      
    
    
    
    <category term="项目相关" scheme="http://example.com/categories/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/"/>
    
    
  </entry>
  
  <entry>
    <title>机器学习</title>
    <link href="http://example.com/2021/11/13/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2021/11/13/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-11-13T12:11:16.000Z</published>
    <updated>2021-11-13T12:27:48.243Z</updated>
    
    <content type="html"><![CDATA[<ol><li>xgboost与GDBT的区别</li></ol><p>xgboost属于GDBT的工程实现，但是相比于GDBT有更多的优化</p><ul><li>1.两者都是属于boosting方法，就是迭代串行求多个模型，每个模型不同权重，训练过程中样本也具有不同的权重</li><li>2.GDBT是使用多个决策树组成的，xgboost可以使用线性模型</li><li>3.xgboost使用了代价函数的一阶和二阶信息，同时可以用户自定义代价函数，同时xgboost在代价函数中加入了正则项，用于控制模型的复杂度</li><li>4.xgboost能够自动对缺失值进行处理</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;xgboost与GDBT的区别&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;xgboost属于GDBT的工程实现，但是相比于GDBT有更多的优化&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.两者都是属于boosting方法，就是迭代串行求多个模型，每个模型不同权重，训练过程中样本也具有不同的</summary>
      
    
    
    
    <category term="项目相关" scheme="http://example.com/categories/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="machine learning" scheme="http://example.com/tags/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title>编程语言</title>
    <link href="http://example.com/2021/11/13/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    <id>http://example.com/2021/11/13/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/</id>
    <published>2021-11-13T12:11:07.000Z</published>
    <updated>2022-02-14T09:34:26.692Z</updated>
    
    <content type="html"><![CDATA[<h4 id="python"><a href="#python" class="headerlink" title="python"></a>python</h4><ol><li><p>python GIL介绍</p></li><li><p>list tuple set的区别</p></li></ol><ol start="3"><li><p>python迭代器和生成器的区别是什么<br>生成器本质上还是一个迭代器，也是用在迭代操作中，因此它有和迭代器一样的特性，唯一的区别在于实现方式上不一样，后者更加简洁；<br>生成器只是在需要这个值再生成</p></li><li><p>迭代器<br>迭代器对象要求支持迭代器协议的对象。在Python中，支持迭代器协议就是实现对象的__iter__()和next()方法。<br>其中__iter__()方法返回迭代器对象本身；next()方法返回容器的下一个元素，在结尾时引发StopIteration异常。<br>iter是可迭代对象，可迭代对象才能调用next函数</p></li></ol><ol start="5"><li>生成器<br>生成器(generator)就是一个函数，它提供了一种实现迭代器协议的便捷方式。<br>生成器与普通函数的区别在于它包含 yield 表达式，并且不需要定义 <strong>iter</strong>()和__next__()。</li></ol><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><h5 id="1-vector"><a href="#1-vector" class="headerlink" title="1.vector"></a>1.vector</h5><p>find(vector.begin(), vector.end(), target_val)!=vector.end() find函数返回的是一个迭代器</p><p>vector.push_back(i)<br>vector.pop_back()</p><p>vec1.swap(vec2)//进行vector1和vector2的交换<br>vec2(vec1.begin(), vec1.begin()+4)表示截取vector的一部分，并赋值给vec2,注意后面的值表示vec不需要 也就是左闭右开模式</p><p>vector最后一个元素，vector.back()</p><p>vector.insert(vec.begin()+pos, target); // 将target元素插入到pos位置</p><p>auto pos=lower_bound(nums.begin(), nums.end(), target)<br>index = pos-nums.begin() //<br>lower_bound返回的是大于等于目标函数的数， upper_bound返回的是大于目标函数的数</p><p>注意和set的lower_bound不一样的<br>set.lower_bound(targets) 返回一个迭代器</p><p>mp的lower_bound也是不一样的<br>auto iter = mp.lower_bound(val)</p><p>set和map中的元素都是排好序的</p><h5 id="2-unordered-set-my-set"><a href="#2-unordered-set-my-set" class="headerlink" title="2.unordered_set my_set"></a>2.unordered_set my_set</h5><p>my_set.find(target_value)!=my_set.end() or my_set.count(target_value)!=0<br>my_set.insert(value)<br>my_set.erase(value)A</p><p>unordered_set查找元素的两种方式：（1）umap.find(target)!=-1  (2) umap[target]<br>unordered_set在进行查找的时候可以直接使用unordered_set[target]即使是target不存在也不会报错，<br>但是在vector中查找某一个元素就需要vec.find(target)!=vec.end() </p><h5 id="3-priority-queue-queue"><a href="#3-priority-queue-queue" class="headerlink" title="3. priority_queue / queue"></a>3. priority_queue / queue</h5><p>q.push()<br>q.pop()</p><h5 id="4-set-insert-value-erase-value-push-pop"><a href="#4-set-insert-value-erase-value-push-pop" class="headerlink" title="4. set insert(value) erase(value) push pop"></a>4. set insert(value) erase(value) push pop</h5><p>遍历 for(auto iter=set.begin(); iter!=set.end(); iter++)</p><p>用vector里面的元素初始化set unordered_set<int> nums_set(nums1.begin(), nums1.end());//其中nums1是vector</p><h5 id="5-map"><a href="#5-map" class="headerlink" title="5.map"></a>5.map</h5><p>插入元素：map[key]=value; 或者map.insert(make_pair(key, value))<br>删除元素：map.erase(key)//注意不是remove</p><p>查找元素：map.find(key)</p><p>复制：hash.insert(hash1.begin(), hash1.end())<br>PS： vector的复制是 vec.assign(vec1.begin(), vec1.end())</p><h5 id="6-其他语法"><a href="#6-其他语法" class="headerlink" title="6.其他语法"></a>6.其他语法</h5><p>判断字符是字母：isalpha()</p><p>判断字符是数字：isdigit()</p><p>判断字符是字母或数字：isalnum()</p><p>同时注意c++中，字符用单引号表示，字符串用双引号表示</p><p>注意c++中只有数组能够使用memset，在vector中不能使用</p><h5 id="7-string"><a href="#7-string" class="headerlink" title="7.string"></a>7.string</h5><p>find函数 pos=s.find(target)  pos=s.find(target,0)<br>如果没有找到返回s.npos 或者string::npos</p><p>原地移除数组上的元素，我们说到了数组上的元素，不能真正的删除，只能覆盖。array.erase(i)的时间复杂度是O(n)</p><h5 id="8-set-数组-map的选择"><a href="#8-set-数组-map的选择" class="headerlink" title="8.set 数组 map的选择"></a>8.set 数组 map的选择</h5><p>主要是看数据的范围，如果数据返回不确定那么尽量选择map or set，如果确定是小写字母的话，也就是26个字母，可以使用数组<br>set包含 unordered_set（无序， 哈希表，不能重复， 查询和增删效率O(1)）, multiset（有序，红黑树，可以重复 O(nlogn)）, set(有序， 红黑树，不能重复， O(nlong))； map类似<br>三种都是只能erase和insert不能修改数值， map不能修改key但是可以修改value</p><h5 id="9-stack"><a href="#9-stack" class="headerlink" title="9. stack"></a>9. stack</h5><p>栈的底层实现可以是vector, dequeue, list<br>栈只能获取最后一个元素，无法直接获取第一个元素<br>top()    返回栈顶元素的引用，类型为 T&amp;，如果栈为空，返回值未定义<br>pop()    栈顶元素出栈<br>size()    返回栈中元素的个数<br>empty()    栈中没有元素时返回 true<br>emplace()    使用传入的参数调用构造函数，在栈顶生成对象<br>push(const T&amp; obj)    将对象副本压入栈顶，通过调用底层容器的 push_back() 函数实现<br>push(T&amp;&amp; obj)    以移动对象的方式将对象压入栈，通过调用底层容器的有右值引用参数的 push_back() 函数实现<br>swap(stack<T> &amp; other_stack)    将当前栈中的元素和参数中的元素交换，参数所包含元素的类型必须和当前栈的相同，对于 stack 对象有一个特例化的全局函数 swap() 可以使用</p><p>可以出一道面试题：栈里面的元素在内存中是连续分布的么？</p><p>这个问题有两个陷阱：<br>陷阱1：栈是容器适配器，底层容器使用不同的容器，导致栈内数据在内存中是不是连续分布。<br>陷阱2：缺省情况下，默认底层容器是deque，那么deque的在内存中的数据分布是什么样的呢？答案是：不连续的，下文也会提到deque。</p><h5 id="10-queue-队列"><a href="#10-queue-队列" class="headerlink" title="10.queue 队列"></a>10.queue 队列</h5><p>可以访问队列最后一个元素，但是无法pop最后一个元素<br>queue入队，如例：q.push(x); 将x 接到队列的末端。</p><p>queue出队，如例：q.pop(); 弹出队列的第一个元素，注意，并不会返回被弹出元素的值。</p><p>访问queue队首元素，如例：q.front()，即最早被压入队列的元素。</p><p>访问queue队尾元素，如例：q.back()，即最后被压入队列的元素。</p><p>判断queue队列空，如例：q.empty()，当队列空时，返回true。</p><h5 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h5><p>pair&lt;int, int&gt; 访问元素不是用下标而是用first second; 创建一个pair用pair&lt;int, int&gt; res = make_pair&lt;a, b&gt;<br>或者用括号 pair&lt;int, int&gt; b(1, 2);</p><h5 id="新建一个未知长度的数组"><a href="#新建一个未知长度的数组" class="headerlink" title="新建一个未知长度的数组"></a>新建一个未知长度的数组</h5><p>int *queue;<br>queue=new int[k+1] 主要是用于类构建动态数组的这种情况</p><h4 id="向上取整"><a href="#向上取整" class="headerlink" title="向上取整"></a>向上取整</h4><p>(x+(b-1))/b*b</p><h4 id="malloc和new的区别"><a href="#malloc和new的区别" class="headerlink" title="malloc和new的区别"></a>malloc和new的区别</h4><p><img src="%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/image-20220122202312622.png" alt="image-20220122202312622"></p><h4 id="hashMap原理"><a href="#hashMap原理" class="headerlink" title="hashMap原理"></a>hashMap原理</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;python&quot;&gt;&lt;a href=&quot;#python&quot; class=&quot;headerlink&quot; title=&quot;python&quot;&gt;&lt;/a&gt;python&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;python GIL介绍&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;list tuple set的</summary>
      
    
    
    
    <category term="项目相关" scheme="http://example.com/categories/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="python, C++" scheme="http://example.com/tags/python-C/"/>
    
  </entry>
  
  <entry>
    <title>面试</title>
    <link href="http://example.com/2021/11/13/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E9%9D%A2%E8%AF%95/"/>
    <id>http://example.com/2021/11/13/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E9%9D%A2%E8%AF%95/</id>
    <published>2021-11-13T12:10:52.000Z</published>
    <updated>2021-12-09T11:19:16.315Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>回答问题模板：<br>a) 我为什么要做这个项目？要达到什么目标？<br>b) 学术上，或者工业上 有哪些方法？能达到什么目标？这些方法分别有什么优缺点？<br>c) 我为什么要选择这个方法？项目上做了哪些取舍？<br>d) 这里面，我做了哪些创新点/亮点？为什么我要做这个创新点？<br>e) 最后项目达到了什么样的结果</p></blockquote><p>发现、动机、实践和验证</p><h4 id="计算机视觉"><a href="#计算机视觉" class="headerlink" title="计算机视觉"></a>计算机视觉</h4><p>对于自己的工作，尤其是准备重点介绍的工作，每一个细节都要很熟悉，要能解释清楚做了什么，为什么这么做，效果怎么样。<br>对实习能力有哪些要求：自学能力+基础知识扎实<br>每个项目都按照STAR法则（背景-任务-行动-结果）的结构都写下来</p><p>如何解决小目标问题：<br>使用多尺度或者增大输入的scale(在可以选择的scale范围中选择更大的)，以及focal loss</p><p>每次面试都需要串一篇检测模型</p><p>RCNN/Fast RCNN/Faster RCNN/Mask RCNN</p><p>Yolov123</p><h5 id="首先介绍自己的工作"><a href="#首先介绍自己的工作" class="headerlink" title="首先介绍自己的工作"></a>首先介绍自己的工作</h5><ol><li>熟悉平台和公司内部算法框架</li><li>熟悉数据，了解训练模型的数据处理流程，包括相关标注文档撰写， 数据发标， review, 完善标注质量评估的相关代码</li><li>多任务分类代码阅读理解</li><li>主要是训练一个目标检测模型</li></ol><h5 id="实习-项目遇到的问题，是如何解决的？"><a href="#实习-项目遇到的问题，是如何解决的？" class="headerlink" title="实习/项目遇到的问题，是如何解决的？"></a>实习/项目遇到的问题，是如何解决的？</h5><blockquote><p>你其实可以运用STAR的总结回答你的问题，项目背景——遇到啥问题——你怎么做——有什么结果？<br>  eg:<br>  背景：现在要做一个考勤的功能，统计公司人员的打卡情况。<br>  问题：在评审会议中涉及考勤的功能时对于统计与开发有不同意见。<br>  怎么做：对两种统计结果、开发难度等维度进行分析，形成分析报告，再下次评审中与开发进行沟通处理。<br>  结果：达成一致意见，在会后对自己这件事进行复盘总结方法论，避免下次出现该问题</p></blockquote><p>  实习中遇到的困难，如何解决？<br>  最开始遇到的困难：</p><ol><li>训练模型精度不高。排查查看训练输入数据的格式是否正确。数据格式确认后，分析精度主要是因为一类的精度非常小导致的， 之后分析数据发现主要是1）该类数据量非常少 2) 该类的目标框非常小，之后修改损失为focal loss以及多维度输入的时候，尽量选择比较大的scale范围（rescale的时候增大scale）</li><li>训练模型主要关注的如何调节参数提升模型的精度，参数搜索空间非常大，如何找到一个合适的调节参数的方向；解决：先询问身边的同事，因为他们比我更有经验，一定知道调节什么参数对模型的精度影响更大；第二个在明确大致的参数调节方向后，自己实践，需要用一个表格记录自己所做的实验，方便之后进行结果对比和进一步修正,最终在crop size mAP大概为92%-93% 在原图mAP 95%.</li></ol><p>  研究过程中遇到的困难？</p><p>  毕业设计/模型量化和剪枝中遇到的困难？<br>  1.使用distiller的库的时候，发现剪枝训练精度最后为0，效果突然变差，解决方案。1）是在github issue/ stack overflow 中查找相关问题的解决方案，没有则进行提问<br>  2.实验结果不理想和预期差距大。最开始实验的结构化剪枝精度下降会非常快，查看其它文献，分析差距主要在哪里，然后调整自己的实验，最后解决方案：在论文中加入敏感性分析+同时明白结构化剪枝局限性：主要适用于参数量比较多的网络</p><p>  新加坡项目遇到的困难？<br>  1.实验结果不理想。分析原因，查找数据/代码是否有问题，调整算法实现</p><p>椒盐噪声，怎么处理？<br>椒盐噪声就是根据输入的信噪比参数，随机在图像中加入0和225（黑点和白点）</p><p>中值滤波是如何做的？</p><p>一、目标检测<br>suprevision  解决图像太少的问题，混合公开数据集一起训练<br>1.faster-RCNN<br>faster-rcnn的整个从输入到输出的框架流程，然后是rpn的原理，列举一下针对小目标的解决措施，如何解决类内的检测，还有项目中有无其他困难<br>如何提高小目标检出率（RPN哪里也可以提升小目标检出率）</p><p>2.RNN的损失如何求</p><p>3.写IOU函数</p><ol start="4"><li>在suprevision中的anchor 的anchor.ratio是如何产生的，是根据feature size 还是随机产生的</li></ol><p>做了什么优化使 mAP 提高了2个百分点</p><h5 id="现有的一些目标检测的算法优缺点对比"><a href="#现有的一些目标检测的算法优缺点对比" class="headerlink" title="现有的一些目标检测的算法优缺点对比"></a>现有的一些目标检测的算法优缺点对比</h5><p><a href="https://zhuanlan.zhihu.com/p/354060133?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=1113097318299123712&amp;utm_campaign=shareopn">https://zhuanlan.zhihu.com/p/354060133?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=1113097318299123712&amp;utm_campaign=shareopn</a></p><p>二、图像分类<br>vehicle attributes<br>多任务共同学习：<br>因为训练数据集相对较小，容易产生过拟合，为了避免这种情况的发生，合并多个数据集。</p><p>三、视频分类</p><h4 id="模型压缩"><a href="#模型压缩" class="headerlink" title="模型压缩"></a>模型压缩</h4><p>1.常用的模型压缩和量化方法</p><p>2.知识蒸馏采用的具体方法如下：<br>1、训练复杂的教师模型（teacher model）：先用硬目标（hard target），也就是正常的标签（label）训练大模型。<br>2、计算软目标（soft target）：利用训练好的大模型来计算软目标（soft target），也就是大模型“软化后”再经过softmax层的输出。<br>3、训练小模型，在小模型的基础上再加一个额外的软目标（soft target）的损失函数，通过比例参数来调节两个损失函数的比重。<br>4、预测时，将训练好的小模型来进行实验。</p><h4 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h4><p>在项目中得到了什么提升/相比于本科，研究生阶段有什么新的收获？<br>1.代码规范与记录，注意细节，代码的可理解性<br>2.实践工程能力与计算机思维，手动思维想自动思维的转换，图形界面转为命令行，计算机专业的人主要就是让更多的手动工作变为一键操作<br>3.实际场景的数据可能不是像标准训练数据那样 每个类别都非常均衡，因此在实际场景中要注意类别标签不均衡问题<br>4.懂得记录 博客/github上代码整理<br>5.更加关注底层和原理，以及现有方法为什么这么做，有什么问题，以及如何改进这些问题</p><h4 id="开放的针对深度学习的理解的题目"><a href="#开放的针对深度学习的理解的题目" class="headerlink" title="开放的针对深度学习的理解的题目"></a>开放的针对深度学习的理解的题目</h4><p>给了一个情景，如何训练模型、调优。（题目很空，主要考察你对深度学习的理解）<br>根据需求（前向传播时间、模型大小），确定模型和基础网络，跑第一版模型。（举了个栗子）<br>判断模型是否出现过拟合的情况，来决定下一步的优化方向。<br>结果分析(confusionMatrix等)，分析问题，将论文中的方法套上去，如果没有自己创造。（又举了个栗子）</p><h4 id="凸优化了解吗？-牛顿法、SGD、最小二乘法，各自的优势。"><a href="#凸优化了解吗？-牛顿法、SGD、最小二乘法，各自的优势。" class="headerlink" title="凸优化了解吗？ 牛顿法、SGD、最小二乘法，各自的优势。"></a>凸优化了解吗？ 牛顿法、SGD、最小二乘法，各自的优势。</h4><p>牛客实习生论坛</p><p>四、 应用开发</p><p>遇到的困难：从bomb请求数据的时候，数据还没有请求得到，已经开始执行后面的语句，无法正确获取到最新的数据并显示，后来发现是异步执行流程的原因导致</p><h4 id="推荐系统算法总结"><a href="#推荐系统算法总结" class="headerlink" title="推荐系统算法总结"></a>推荐系统算法总结</h4><p><a href="https://cloud.tencent.com/developer/article/1614209">https://cloud.tencent.com/developer/article/1614209</a> </p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;回答问题模板：&lt;br&gt;a) 我为什么要做这个项目？要达到什么目标？&lt;br&gt;b) 学术上，或者工业上 有哪些方法？能达到什么目标？这些方法分别有什么优缺点？&lt;br&gt;c) 我为什么要选择这个方法？项目上做了哪些取舍？&lt;br&gt;d) 这里面，我做了哪些创新</summary>
      
    
    
    
    <category term="项目相关" scheme="http://example.com/categories/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/"/>
    
    
  </entry>
  
  <entry>
    <title>笔试</title>
    <link href="http://example.com/2021/11/13/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E7%AC%94%E8%AF%95/"/>
    <id>http://example.com/2021/11/13/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E7%AC%94%E8%AF%95/</id>
    <published>2021-11-13T12:10:47.000Z</published>
    <updated>2021-11-17T12:40:44.849Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/lcylmhlcy/Awesome-algorithm-interview/blob/master/README.md#1-interview-1">Awesome algorithm interview</a></p><h4 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h4><p>TCP连接为什么要三次握手，TCP关闭为什么要4次挥手？<br>三次握手是为了防止服务器资源的浪费，因为如何是两次的话，如果客户端发送请求连接，但是不发送请求数据，就可能造成服务器端口占用，资源被浪费；四次回收是因为客户端和服务器可以各自关闭，比如客户端告诉服务器FIN，表示自己不发送数据，但是仍然可以接收数据，因此服务器可以继续发送，服务器将数据发送完了之后，再发出关闭信号，因此四次挥手允许客户端和服务器各自分别关闭</p><h4 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h4><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><p>搜索github 上面的面试八股文</p><p><a href="https://github.com/cosen1024/Java-Interview">https://github.com/cosen1024/Java-Interview</a> java面试小抄书</p><p>JVM内存结构，什么是hash 冲突，如何解决</p><p>语言/数据结构/操作系统/网络/分布式/系统设计</p><p>考研408</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/lcylmhlcy/Awesome-algorithm-interview/blob/master/README.md#1-interview-1&quot;&gt;Awesome algorithm interview&lt;/a&gt;&lt;/p</summary>
      
    
    
    
    <category term="项目相关" scheme="http://example.com/categories/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="八股文" scheme="http://example.com/tags/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>哈希相关</title>
    <link href="http://example.com/2021/11/13/leetcode/%E5%93%88%E5%B8%8C%E7%9B%B8%E5%85%B3/"/>
    <id>http://example.com/2021/11/13/leetcode/%E5%93%88%E5%B8%8C%E7%9B%B8%E5%85%B3/</id>
    <published>2021-11-13T11:58:31.000Z</published>
    <updated>2022-02-08T06:05:04.550Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前缀和-hash题目汇总"><a href="#前缀和-hash题目汇总" class="headerlink" title="前缀和 + hash题目汇总"></a>前缀和 + hash题目汇总</h4><p>一定要注意先判断hash[presum-target]是否存在并更新结果，再更新hash[presum]++， 因为可能nums[i]=0</p><p>例题：<br>面试题 17.05.  字母与数字，要求字母和数字个数相同，那么就是将字母转为1， 数字转为-1的时候，前缀和为0的最长序列；<br>另外使用这种思想是的”和等于 k 的最长子数组长度“ ”和等于k子数组“<br> ”1371. 每个元音包含偶数次的最长子字符串“:<br>题解：为了表明每个元音出现了偶数次，可以使用二进制数，如果一个位经过一轮之后仍然为当前的值，那么说明这个位出现了偶数次或者没出现过，<br>通过这种方法可以类推到特定字符出现k数次，那么就使用k进制；同时注意是每个元音出现偶数次，而不是元音总个数为偶数次，如果是第二种情况<br>可以使用元音为奇数表示，sum%2==0表示元音个数为偶数）</p><ol><li><p>连续的子数组和 注意这道题不是说连续的子数组为目标数，而是为目标数的倍数，但是仍然可以用这种方法来做，因为为目标数的倍数，意味着前缀和%该数得到的余数相同，因为可以用hash记录第一次出现该余数的下标，然后再次出现时，判断数组长度是否大于等于2， 一定要注意在开始的时候hash[0]=-1!!!</p></li><li><p>连续数组 相同的0和1的个数，其实也是前缀和，只不过遇到0变为-1</p></li><li><p>和相同的二元子数组<br>注意一定要先查找hash[presum-target]，更新hash[presum]++<br>主要是针对0的情况，如果先更新hash就会报错<br>注意最开始要设置hash[0]要为1</p></li><li><p>统计「优美子数组」<br>将奇数转为1， 偶数转为0， 然后求和为k的子数组个数</p></li></ol><h4 id="hash-双指针"><a href="#hash-双指针" class="headerlink" title="hash + 双指针"></a>hash + 双指针</h4><p>一定要注意返回的是元素还是元素的下标，一个可以排序使用指针，一个不能使用指针<br>两数之和：用双指针只能针对已经排好序的数组，没有排好序的数组，但是要求要返回下标，那么就用hash (unordered_set)<br>三数之和<br>四数之和：三重循环，因此有是三个去重的部分，不要只去重最后一层循环，忘了i j 层循环的去重</p><p>注意！！！</p><ol><li>hash方法是不能去重的，要去重只能使用循环+双指针；同时返回坐标不能用双指针，返回值才能使用双指针</li><li>去重放在==target的if语句之内（==循环去重==），同时可以用一些剪枝策略，但是要记得四个数相加可能出现溢出，所以如果要剪枝，记得强转为long型<figure class="highlight c++"><figcaption><span>去重模板</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">while</span>(i &lt; j &amp;&amp; nums[i] == nums[++i]);<span class="hljs-keyword">while</span>(i &lt; j &amp;&amp; nums[j] == nums[--j]);<br><br></code></pre></td></tr></table></figure></li><li>数组不一定是排好序的，因此需要先对数组进行排序</li></ol><p>变形：数组中的k-diff数对，这里只是换成了绝对值差，而不是目标值; 而且因为数组中存在重复的数字，因此需要先用set记录结果，然后再返回set.size<br>这道题也可以用排序+二分查找（找到目标的k+nums[i]），同时需要过滤掉已经找的数据</p><p>拓展：<br>注意前面三个题是可能包含重复的元素，但是需要返回不重复的元组对，下面这个题是找出所有的元组对，因此是包含重复的元组对的<br>题目：三数之和的多种可能<br>解决方案：仍然是三数之和的方法的，但是在进行计算的时候如果arr[left]!=arr[right]那么res+=hash[left]<em>hash[right] (用while循环找到hash[left]，或者提前计算)<br>如果arr[left]==arr[right] res+=(right-left+1)</em>(right-left)/2</p><h4 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> size=nums.<span class="hljs-built_in">size</span>();<br><span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-3</span>;i++)&#123;<br>    <span class="hljs-keyword">while</span>(i<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>&amp;&amp;nums[i]==nums[i<span class="hljs-number">-1</span>])&#123;<br>        <span class="hljs-keyword">continue</span>; <span class="hljs-comment">//去重</span><br>    &#125;<br>    <span class="hljs-keyword">if</span>((<span class="hljs-keyword">long</span>) nums[i]+nums[i+<span class="hljs-number">1</span>]+nums[i+<span class="hljs-number">2</span>]+nums[i+<span class="hljs-number">3</span>]&gt;target)&#123;<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>((<span class="hljs-keyword">long</span>) nums[i]+nums[size<span class="hljs-number">-3</span>]+nums[size<span class="hljs-number">-2</span>]+nums[size<span class="hljs-number">-1</span>]&gt;target)&#123;<br>            <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i+<span class="hljs-number">1</span>;j&lt;nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-2</span>;j++)&#123;<br>        <span class="hljs-keyword">if</span> (j &gt; i + <span class="hljs-number">1</span> &amp;&amp; nums[j] == nums[j - <span class="hljs-number">1</span>]) &#123;<br>                    <span class="hljs-keyword">continue</span>; <span class="hljs-comment">//去重</span><br>        &#125;<br>        <span class="hljs-keyword">if</span>((<span class="hljs-keyword">long</span>) nums[i]+nums[j]+nums[j+<span class="hljs-number">1</span>]+nums[j+<span class="hljs-number">2</span>]&gt;target)&#123;<br>                <span class="hljs-keyword">break</span>; <span class="hljs-comment">//注意是break不是continue</span><br>        &#125;<br>        <span class="hljs-keyword">if</span>((<span class="hljs-keyword">long</span>) nums[i]+nums[j]+nums[size<span class="hljs-number">-2</span>]+nums[size<span class="hljs-number">-1</span>]&gt;target)&#123;<br>                <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> k=j+<span class="hljs-number">1</span>, q=size<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">int</span> find_num=target-nums[i]-nums[j];<br>        <span class="hljs-keyword">while</span>(k&lt;q)&#123;<br>            <span class="hljs-keyword">if</span>(nums[k]+nums[q]&gt;find_num)&#123;<br>                q--;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[k]+nums[q]&lt;find_num)&#123;<br>                k++;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[k]+nums[q]==find_num)&#123;<br>                res.<span class="hljs-built_in">push_back</span>(&#123;nums[i], nums[j], nums[q], nums[k]&#125;);<br>                k++;<br>                q--;<br>                <span class="hljs-keyword">while</span>(k&lt;q&amp;&amp;nums[k]==nums[k<span class="hljs-number">-1</span>])&#123;<br>                    k++;<br>                &#125;<br>                <span class="hljs-keyword">while</span>(k&lt;q&amp;&amp;nums[q]==nums[q+<span class="hljs-number">1</span>])&#123;<br>                q--;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>参考链接：<a href="https://leetcode-cn.com/problems/4sum/solution/si-shu-zhi-he-by-leetcode-solution/">四数之和答案</a></p></blockquote><h4 id="hash-动态规划"><a href="#hash-动态规划" class="headerlink" title="hash+动态规划"></a>hash+动态规划</h4><ol><li>最长定差子序列<br>转移方程： dp[arr[i]]=dp[arr[i]-diff]+1<br>因为不知道arr[i]的最大值，以及可能出现负数的下标， 所以直接使用hash，而不是数组<br>dp[x] 表示以 x 结尾的最长等差子序列的长度；</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;前缀和-hash题目汇总&quot;&gt;&lt;a href=&quot;#前缀和-hash题目汇总&quot; class=&quot;headerlink&quot; title=&quot;前缀和 + hash题目汇总&quot;&gt;&lt;/a&gt;前缀和 + hash题目汇总&lt;/h4&gt;&lt;p&gt;一定要注意先判断hash[presum-target</summary>
      
    
    
    
    <category term="leetcode" scheme="http://example.com/categories/leetcode/"/>
    
    
  </entry>
  
</feed>
