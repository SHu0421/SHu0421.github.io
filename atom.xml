<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hello World</title>
  
  
  <link href="http://shu0421.github.io/atom.xml" rel="self"/>
  
  <link href="http://shu0421.github.io/"/>
  <updated>2023-12-01T08:50:32.004Z</updated>
  <id>http://shu0421.github.io/</id>
  
  <author>
    <name>Shu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>hexo + github 博客搭建</title>
    <link href="http://shu0421.github.io/2023/11/29/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <id>http://shu0421.github.io/2023/11/29/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</id>
    <published>2023-11-29T09:06:41.000Z</published>
    <updated>2023-12-01T08:50:32.004Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>记录： 相同的错误解决更快；知识点便于之后的复习</li><li>分享： 开源与共享精神</li></ul><h2 id="现有方案"><a href="#现有方案" class="headerlink" title="现有方案"></a>现有方案</h2><ul><li>直接利用：简书，博客园，</li><li>自己搭建：hexo, WordPress, Typecho</li><li>其他笔记工具：Notion, 印象笔记，语雀</li></ul><p>选择hexo原因：</p><blockquote><p>有前端基础，会Markdown、会HTML和CSS，选择 Hexo<br>有Vue基础可以选择 vuePress 或者 vitePress<br>会Go可以选择 Hugo<br>会Rust可以选择 Zola<br>会Ruby可以选择 Jekyll<br>会PHP可以考虑使用 WordPress</p></blockquote><ul><li>简单便捷，上手快</li><li>使用用户多，参考素材多，踩坑解决方案多</li><li>专注博客内容本身，其他比较困难的框架可以之后有需要再看</li></ul><h2 id="hexo-github搭建流程"><a href="#hexo-github搭建流程" class="headerlink" title="hexo+github搭建流程"></a>hexo+github搭建流程</h2><ol><li>git, node, hexo 的安装</li><li>将博客内容部署到github （config配置+安装部署插件+hexo d）</li><li>使用xxx.github.io来访问博客</li><li>页面修改与重新部署</li></ol><p><a href="https://hexo.io/zh-cn/docs/commands.html">hexo常用命令</a>:</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># 创建新页面 </span><br>hexo <span class="hljs-keyword">new</span> <span class="hljs-string">&quot;My New Post&quot;</span><br><span class="hljs-meta"># 清空缓存</span><br>hexo c<br><span class="hljs-meta"># 生成静态页面 </span><br>hexo g <br><span class="hljs-meta"># 本地预览 </span><br>hexo s <br><span class="hljs-meta"># 部署到网站 </span><br>hexo d<br></code></pre></td></tr></table></figure><p><a href="https://markdown.com.cn/basic-syntax/headings.html">Markdown语法</a></p><p><a href="https://zz2summer.github.io/github-hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/">Windows环境下使用hexo搭建个人博客</a><br><a href="https://blog.l3zc.com/2022/05/mac%E7%8E%AF%E5%A2%83%E4%B8%8B%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/">Mac OS环境下使用Hexo搭建个人博客</a></p><h2 id="hexo个性化功能"><a href="#hexo个性化功能" class="headerlink" title="hexo个性化功能"></a>hexo个性化功能</h2><ul><li>更改域名</li><li>修改主题</li><li>自定义界面</li><li>配置到个人服务器<br>….</li></ul><p><a href="https://wty-yy.space/posts/60487/">添加评论功能</a><br><a href="https://zhuanlan.zhihu.com/p/111614119">更改域名和修改主题</a><br><a href="https://hexo.fluid-dev.com/docs/guide/#%E5%85%B3%E4%BA%8E%E6%8C%87%E5%8D%97">hexo fluid 用户手册</a><br><a href="https://hexo.io/themes/index.html">hexo主题</a><br><a href="https://callmelp.online/2022/03/26/hexoToMyServer/">将hexo配置到个人服务器 nginx配置https</a></p><h2 id="案例展示"><a href="#案例展示" class="headerlink" title="案例展示"></a>案例展示</h2><p><a href="https://shu0421.github.io/">我的博客</a></p><p><a href="https://arcsin2.cloud/">简洁例子</a></p><p><a href="https://wty-yy.space/">关于页面</a></p><p><a href="https://202271.xyz/friends">新建友联</a></p><p><a href="https://blog.akimio.top/link/">其他格式</a></p><p><a href="https://www.zywvvd.com/messagebd/">站点分析</a></p><h2 id="常见问题及解决"><a href="#常见问题及解决" class="headerlink" title="常见问题及解决"></a>常见问题及解决</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;记录： 相同的错误解决更快；知识点便于之后的复习&lt;/li&gt;
&lt;li&gt;分享： 开源与共享精神&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=</summary>
      
    
    
    
    <category term="工具相关" scheme="http://shu0421.github.io/categories/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="hexo" scheme="http://shu0421.github.io/tags/hexo/"/>
    
    <category term="github" scheme="http://shu0421.github.io/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>K8S学习</title>
    <link href="http://shu0421.github.io/2023/11/28/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/k8s/"/>
    <id>http://shu0421.github.io/2023/11/28/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/k8s/</id>
    <published>2023-11-28T04:51:37.000Z</published>
    <updated>2023-11-29T02:21:21.320Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学习打算"><a href="#学习打算" class="headerlink" title="学习打算"></a>学习打算</h2><p>先学习k8s, 在hec06 hec07, hec08上面实验，然后再学习microk8s minik8s, minikube的方式进行kubenetes的学习</p><h2 id="microk8s"><a href="#microk8s" class="headerlink" title="microk8s"></a>microk8s</h2><p>官方安装教程<br><a href="https://kubernetes.io/zh/blog/2019/11/26/%E4%BD%BF%E7%94%A8-microk8s-%E5%9C%A8-linux-%E4%B8%8A%E6%9C%AC%E5%9C%B0%E8%BF%90%E8%A1%8C-kubernetes/">404 Page not found | Kubernetes</a></p><p>给kubectl改别名:<br><code>sudo snap alias microk8s.kubectl kubectl</code> </p><h2 id="原生k8s平台的搭建"><a href="#原生k8s平台的搭建" class="headerlink" title="原生k8s平台的搭建"></a>原生k8s平台的搭建</h2><h2 id="在hec集群上搭建过程"><a href="#在hec集群上搭建过程" class="headerlink" title="在hec集群上搭建过程"></a>在hec集群上搭建过程</h2><h3 id="1-安装kubelet-kubeadm-kubectl"><a href="#1-安装kubelet-kubeadm-kubectl" class="headerlink" title="1. 安装kubelet kubeadm kubectl"></a>1. 安装kubelet kubeadm kubectl</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br>sudo apt-get update &amp;&amp; sudo apt-get install -y apt-transport-https curl<br><span class="hljs-comment"># curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add - </span><br><span class="hljs-comment"># 上面那个命令要翻墙，因此先将apt-get.gpg下载下来，然后使用如下命令替换</span><br>sudo apt-key add apt-key.gpg<br>sudo sh -c <span class="hljs-string">&#x27;echo &quot;deb https://mirrors.aliyun.com/kubernetes/apt kubernetes-xenial main&quot;&gt;/etc/apt/sources.list&#x27;</span><br><br>sudo add-apt-repository --remove  ppa:pascallj/docker.io-clone3 删除ppa<br>或者<span class="hljs-built_in">cd</span> /etc/apt/sources.list.d, 然后进行删除<br><br><span class="hljs-comment"># E: Package &#x27;socat&#x27;/&#x27;conntrack&#x27; has no installation candidate</span><br><span class="hljs-comment"># 在 https://launchpad.net/+search?field.text=conntrack+ppa&amp;field.actions.search=Search </span><br><span class="hljs-comment"># 网站上搜索 conntrack/ socat的 ppa源，然后使用命令, 添加ppa源： </span><br>sudo add-apt-repository ppa:ionel-mc/socat<br>sudo add-apt-repository ppa:brightbox/experimental <br><br>sudo apt-get update<br><br>sudo apt-get install conntrack<br>sudo apt-get install socat<br>sudo apt-get update &amp;&amp; sudo apt-get install docker.io<br><br><span class="hljs-comment"># 最后再运行下面的命令就不会报错了:</span><br>sudo apt-get install -y kubelet=1.15.1-00 kubeadm=1.15.1-00 kubectl=1.15.1-00<br><br></code></pre></td></tr></table></figure><h3 id="2-运行docker"><a href="#2-运行docker" class="headerlink" title="2. 运行docker"></a>2. 运行docker</h3><p>docker需要在每个节点都运行起来：<br>sudo systemctl start docker</p><!-- 没有权限的解决方案 --><p>sudo chmod a+rw /var/run/docker.sock</p><h3 id="3-用-kubeadm-创建-Cluster"><a href="#3-用-kubeadm-创建-Cluster" class="headerlink" title="3. 用 kubeadm 创建 Cluster"></a>3. 用 kubeadm 创建 Cluster</h3><p>在master节点上运行：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo kubeadm reset<br>sudo kubeadm init <span class="hljs-attribute">--apiserver-advertise-address</span>=10.5.26.67 <span class="hljs-attribute">--pod-network-cidr</span>=10.244.0.0/16 <span class="hljs-attribute">--image-repository</span>=registry.aliyuncs.com/google_containers <span class="hljs-attribute">--ignore-preflight-errors</span>=all<br></code></pre></td></tr></table></figure><!-- 其他人的一个例子 --> <!-- sudo kubeadm reset --><!-- sudo kubeadm init \--apiserver-advertise-address=10.5.26.67 \--image-repository registry.aliyuncs.com/google_containers \--kubernetes-version v1.13.3 \--service-cidr=10.1.0.0/16 \--pod-network-cidr=10.244.0.0/16 \--ignore-preflight-errors=all--><p>如果卡住，出现下列报警：[kubelet-check] Initial timeout of 40s passed.</p><p>查看原因：<code>sudo journalctl -u kubelet tail -100f /var/log/messages|grep kub</code></p><p>解决方法：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs awk">修改docker cgroup:<br>sudo vi <span class="hljs-regexp">/etc/</span>docker/daemon.json<br>&#123;<br>  <span class="hljs-string">&quot;exec-opts&quot;</span>: [<br>        <span class="hljs-string">&quot;native.cgroupdriver=systemd&quot;</span><br>  ],<br>  <span class="hljs-string">&quot;log-driver&quot;</span>: <span class="hljs-string">&quot;json-file&quot;</span>,<br>  <span class="hljs-string">&quot;log-opts&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;max-size&quot;</span>: <span class="hljs-string">&quot;100m&quot;</span><br>  &#125;,<br>  <span class="hljs-string">&quot;storage-driver&quot;</span>: <span class="hljs-string">&quot;overlay2&quot;</span>,<br>  <span class="hljs-string">&quot;storage-opts&quot;</span>: [<br>        <span class="hljs-string">&quot;overlay2.override_kernel_check=true&quot;</span><br>  ],<br>  <span class="hljs-string">&quot;registry-mirrors&quot;</span> : [<br>        <span class="hljs-string">&quot;https://ot2k4d59.mirror.aliyuncs.com/&quot;</span><br>  ],<br>  <span class="hljs-string">&quot;graph&quot;</span>: <span class="hljs-string">&quot;/data/docker&quot;</span><br>&#125;<br>sudo systemctl daemon-reload<br>sudo systemctl restart docker <span class="hljs-regexp">//</span>重启docker<br>sudo iptables -F &amp;&amp; sudo iptables -t nat -F &amp;&amp; sudo iptables -t mangle -F &amp;&amp; sudo iptables -X<br>sudo swapoff -a<br>sudo systemctl restart kubelet<br></code></pre></td></tr></table></figure><p>上述问题解决方案的参考链接：<a href="https://stackoverflow.com/questions/67606941/kubeadm-init-failing-while-initializing-a-kubernetes-cluster">kubeadm init failing while initializing a Kubernetes cluster - Stack Overflow</a></p><h3 id="4-为master配置-kubectl"><a href="#4-为master配置-kubectl" class="headerlink" title="4. 为master配置 kubectl"></a>4. 为master配置 kubectl</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo mkdir -p <span class="hljs-variable">$HOME</span>/.kube<br>sudo cp -i <span class="hljs-regexp">/etc/</span>kubernetes<span class="hljs-regexp">/admin.conf $HOME/</span>.kube/config<br>sudo chown $(id -u):$(id -g) <span class="hljs-variable">$HOME</span><span class="hljs-regexp">/.kube/</span>config<br></code></pre></td></tr></table></figure><p>  运行完这三句之后，<code>sudo kubectl version</code>显示正常结果</p><h3 id="5-其他节点加入master节点"><a href="#5-其他节点加入master节点" class="headerlink" title="5. 其他节点加入master节点"></a>5. 其他节点加入master节点</h3><!-- 注意一定要保证服务器和客户端之间的kubectl版本一致sudo apt-get install -y kubelet=1.23.6-00 kubeadm=1.23.6-00 kubectl=1.23.6-00 --><p>先初始化网络：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">kubectl apply -f https:<span class="hljs-regexp">//</span>raw.githubusercontent.com<span class="hljs-regexp">/coreos/</span>flannel<span class="hljs-regexp">/master/</span>Documentation/kube-flannel.yml<br></code></pre></td></tr></table></figure><p>最后得到的token:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim">sudo kubeadm <span class="hljs-keyword">join</span> <span class="hljs-number">10.5</span>.<span class="hljs-number">26.67</span>:<span class="hljs-number">6443</span> --token <span class="hljs-number">9</span>am4ce.fnycv1gi9gx7mbch \<br>    --discovery-token-<span class="hljs-keyword">ca</span>-cert-hash <span class="hljs-built_in">sha256</span>:<span class="hljs-number">3368</span>a9667447c72ab00404ce0ff9b4975e9402b1f86c9afce511d992ecfcd29e --ignore-preflight-errors=<span class="hljs-keyword">all</span><br></code></pre></td></tr></table></figure><h2 id="平台搭建问题及解决方案："><a href="#平台搭建问题及解决方案：" class="headerlink" title="平台搭建问题及解决方案："></a>平台搭建问题及解决方案：</h2><h3 id="1-kubeadm-join超时"><a href="#1-kubeadm-join超时" class="headerlink" title="1. kubeadm join超时"></a>1. kubeadm join超时</h3><p>一直join不了的解决方法和k8s master kubeadm init不了的解决方案相同，见”修改docker cgroup“</p><p>一些误区：<br>节点之间不需要免密登录，也能进行kubectl的通信（kubeadm join）</p><h3 id="2-建立镜像的时候出现docker-build-pip超时，使用国内源仍然无法解决"><a href="#2-建立镜像的时候出现docker-build-pip超时，使用国内源仍然无法解决" class="headerlink" title="2. 建立镜像的时候出现docker build pip超时，使用国内源仍然无法解决"></a>2. 建立镜像的时候出现docker build pip超时，使用国内源仍然无法解决</h3><p>解决方案：在docker build命令后面加上 –network=”host”</p><h3 id="3-安装kubeflow"><a href="#3-安装kubeflow" class="headerlink" title="3.安装kubeflow"></a>3.安装kubeflow</h3><p><a href="https://zhuanlan.zhihu.com/p/368720477">轻量级Kubeflow模型训练 - 知乎</a><br>安装kubeflow遇到的问题：<br><a href="https://stackoverflow.com/questions/69054622/unable-to-install-crds-in-kubernetes-kind">Unable to install CRDs in kubernetes kind - Stack Overflow</a></p><p>降级kubeadm的版本：sudo apt-get install kubeadm=1.20.4-00 kubectl=1.20.4-00 kubelet=1.20.4-00 -y –allow-downgrades 允许降低版本<br>在降低版本之后，需要重新进行kubeadm的init和join， 否则会导致kubectl 客户端和服务器版本不一致的问题</p><h3 id="4-coredns-一直处在containerWaiting的状态"><a href="#4-coredns-一直处在containerWaiting的状态" class="headerlink" title="4. coredns 一直处在containerWaiting的状态"></a>4. coredns 一直处在containerWaiting的状态</h3><p><a href="https://58jb.com/html/k8s_v1.20_coredns_error.html">https://58jb.com/html/k8s_v1.20_coredns_error.html</a><br>注意worker节点上面的10-canal.conflist和calico-kubeconfig删 也要删除！！！1</p><p>// 这个链接没有尝试：<a href="https://bbs.huaweicloud.com/forum/thread-60243-1-1.html">华为云论坛_云计算论坛_开发者论坛_技术论坛-华为云</a></p><p>service/pytorch-operator created<br>deployment.apps/pytorch-operator created</p><p>查看一个运行pod的镜像: kubectl edit pod pytorch-operator-7756f57455-6xj9g -n kubeflow</p><h3 id="5-在安装pytorch-operator的时候出现镜像找不到"><a href="#5-在安装pytorch-operator的时候出现镜像找不到" class="headerlink" title="5.在安装pytorch operator的时候出现镜像找不到"></a>5.在安装pytorch operator的时候出现镜像找不到</h3><p>参考的安装目录： <a href="https://zhuanlan.zhihu.com/p/368720477">轻量级Kubeflow模型训练 - 知乎</a><br>“${MANIFESTS_DIR}/pytorch-job/pytorch-operator/base/“ 里面deployment.yaml的镜像为<br>“registry.cn-shenzhen.aliyuncs.com/shikanon/kubeflow-images-public.pytorch-operator:v1.0.0-rc.0”</p><p>主要参考的替换方法：<a href="https://developer.aliyun.com/article/741640">kubeflow系列(一)：基于国内阿里云镜像解决kubeflow一键安装-阿里云开发者社区</a></p><h3 id="6-现在创建了pytorch-job但是运行不起来，create-之后找不到"><a href="#6-现在创建了pytorch-job但是运行不起来，create-之后找不到" class="headerlink" title="6. 现在创建了pytorch job但是运行不起来，create 之后找不到"></a>6. 现在创建了pytorch job但是运行不起来，create 之后找不到</h3><p><a href="https://github.com/kubeflow/pytorch-operator">GitHub - kubeflow/pytorch-operator: PyTorch on Kubernetes</a>（明天照着这个看看）</p><ul><li>执行以下命令，通过 kubectl 提交该 PyTorch Job：<br>kubectl create -f ./pytorch_job_mnist_nccl.yaml</li><li>执行以下命令，查看该 PyTorch Job：<br>kubectl get -o yaml pytorchjobs pytorch-dist-mnist-nccl</li><li>执行以下命令，查看 PyTorch 任务创建的相关 Pod：<br>kubectl get pods -l pytorch_job_name=pytorch-dist-mnist-nccl  </li></ul><h3 id="7-现在创建local-path-storage的时候遇到错误"><a href="#7-现在创建local-path-storage的时候遇到错误" class="headerlink" title="7. 现在创建local-path-storage的时候遇到错误"></a>7. 现在创建local-path-storage的时候遇到错误</h3><p>换了一个节点hec05,然后在每个节点按照 <a href="https://bbs.huaweicloud.com/forum/thread-60243-1-1.html">华为云论坛_云计算论坛_开发者论坛_技术论坛-华为云</a> 运行命令就可以了<br>然后使用设置为default的local-path</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">kubectl patch storageclass <span class="hljs-keyword">local</span>-path -p &#x27;&#123;<span class="hljs-string">&quot;metadata&quot;</span>: &#123;<span class="hljs-string">&quot;annotations&quot;</span>:&#123;<span class="hljs-string">&quot;storageclass.kubernetes.io/is-default-class&quot;</span>:<span class="hljs-string">&quot;true&quot;</span>&#125;&#125;&#125;&#x27;<br></code></pre></td></tr></table></figure><p>正确的解决的方法应该是每个节点都删除cth0, 主要命令见服务器上的run_update.sh脚本</p><h3 id="8-下载kubeflow的时候cert-manager出现错误"><a href="#8-下载kubeflow的时候cert-manager出现错误" class="headerlink" title="8. 下载kubeflow的时候cert-manager出现错误"></a>8. 下载kubeflow的时候cert-manager出现错误</h3><!-- //下面这个解决方法是错误的，因为for flannel  you must pass 10.244.0.0/16!!!!1kubectl edit cm -n kube-system kube-flannel-cfg将10.244.0.0/16 改为 最开始kubeadm init的值--pod-network-cidr=192.168.0.0/16也可以通过下面命令查看 kubectl get nodes -o jsonpath='{.items[*].spec.podCIDR}' to get pod CIDR --><p>正确的解决的方法应该是每个节点都删除cth0, 主要命令见服务器上的run_update.sh脚本， 同时设置–pod-network-cidr=10.244.0.0/16</p><h3 id="9-ImageBackOff问题"><a href="#9-ImageBackOff问题" class="headerlink" title="9. ImageBackOff问题"></a>9. ImageBackOff问题</h3><p>在执行命令kfctl apply -f kfctl_k8s_istio.v1.2.0.yaml 因为需要下载许多的镜像，所以可能会导致ImageBackOff<br>因此至少需要100G的存储空间，同时需要借助阿里云的镜像来进行所有镜像的下载，然后再执行这个命令，主要参考下面两个链接<br><a href="https://blog.csdn.net/koukouwuwu/article/details/117016360">k8s中的kubeflow1.02安装过程记录_ZhuoJieTech的博客-CSDN博客</a><br><a href="https://blog.csdn.net/qq_46595591/article/details/107765833">【最新】k8s中kubeflow(v1.0)部署全过程+踩坑全集（图文）_kubeflow踩坑-CSDN博客</a></p><p><a href="https://github.com/shikanon/kubeflow-manifests#%E5%AE%89%E8%A3%85kubeflow">GitHub - shikanon/kubeflow-manifests: kubeflow国内一键安装文件</a> 国内环境一键安装kubeflow1.3试试</p><p>查看是否安装好: <code>kubectl -n kubeflow get all</code> </p><h3 id="10-k8s可视化"><a href="#10-k8s可视化" class="headerlink" title="10.  k8s可视化"></a>10.  k8s可视化</h3><ul><li><p>安装过程：<a href="https://www.jianshu.com/p/f4e35abe0462">helm3安装prometheus到K8s集群</a> 通过这个安装grafana和 prometheus<br>(主要安装命令见服务器 install_tools.sh)</p></li><li><p>遇到的问题：无法将localhost:9090添加到grafana的仪表盘</p></li><li><p>主要原因： prometheus开启的时候自环网络，<code>curl localhost:9090</code>成功；但是<code>curl 10.5.26.66:9090</code> 失败；所以用 <code>ssh -L 9090:127.0.0.1:9090 shu@10.5.26.66 -o ProxyCommand=&quot;ssh shu@10.5.26.19 -W %h:%p&quot; </code> 建立隧道也失败</p></li><li><p>解决方案：</p><ol><li>需要在你的prometheus.yml 文件 中监控的localhost 改为你的IP</li><li>grafana改用brower模式，填入htpp://localhost:30090 （也就是prometheus的浏览器地址）</li></ol></li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://github.com/wenbin8/doc/blob/master/%E5%88%86%E5%B8%83%E5%BC%8F/CloudNative/Kubernetes/01-Kubernetes%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA.md">其他人搭建的过程，可借鉴</a></p><h2 id="k8s-其他辅助功能"><a href="#k8s-其他辅助功能" class="headerlink" title="k8s 其他辅助功能"></a>k8s 其他辅助功能</h2><h2 id="1-查看日志"><a href="#1-查看日志" class="headerlink" title="1. 查看日志"></a>1. 查看日志</h2><p>看系统日志</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">cat</span> /<span class="hljs-keyword">var</span>/<span class="hljs-keyword">log</span>/messages<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs xml">用kubectl 查看日志<br><span class="hljs-comment">&lt;!-- 注意：使用Kubelet describe 查看日志，一定要带上 命名空间，否则会报如下错误[root@node2 ~]# kubectl describe pod coredns-6c65fc5cbb-8ntpvError from server (NotFound): pods &quot;coredns-6c65fc5cbb-8ntpv&quot; not found --&gt;</span><br><br>kubectl describe pod kubernetes-dashboard-849cd79b75-s2snt --namespace kube-system<br><br>kubectl logs -f pods/monitoring-influxdb-fc8f8d5cd-dbs7d -n kube-system<br><br>kubectl logs --tail 200 -f kube-apiserver -n kube-system |more<br><br>kubectl logs --tail 200 -f podname -n jenkins<br><br><br><br>用journalctl查看日志非常管用<br><br>journalctl -u kube-scheduler<br><br>journalctl -xefu kubelet  -n 10（主要是这个）<br><br>journalctl -u kube-apiserver<br><br><br>journalctl -u kubelet |tail<br><br>journalctl -xe<br><br><br>用docker查看日志<br><br>docker logs c36c56e4cfa3  (容器id)<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;学习打算&quot;&gt;&lt;a href=&quot;#学习打算&quot; class=&quot;headerlink&quot; title=&quot;学习打算&quot;&gt;&lt;/a&gt;学习打算&lt;/h2&gt;&lt;p&gt;先学习k8s, 在hec06 hec07, hec08上面实验，然后再学习microk8s minik8s, minikub</summary>
      
    
    
    
    <category term="工具相关" scheme="http://shu0421.github.io/categories/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="k8s" scheme="http://shu0421.github.io/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>DP问题专栏</title>
    <link href="http://shu0421.github.io/2023/11/25/dp%E9%97%AE%E9%A2%98%E4%B8%93%E6%A0%8F/DAG+%E6%A0%91%E7%8A%B6+%E5%85%B6%E4%BB%96dp/"/>
    <id>http://shu0421.github.io/2023/11/25/dp%E9%97%AE%E9%A2%98%E4%B8%93%E6%A0%8F/DAG+%E6%A0%91%E7%8A%B6+%E5%85%B6%E4%BB%96dp/</id>
    <published>2023-11-25T08:42:14.263Z</published>
    <updated>2023-11-29T02:21:21.648Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-DAG上的dp"><a href="#1-DAG上的dp" class="headerlink" title="1. DAG上的dp"></a>1. DAG上的dp</h3><p>UVa 437 巴比伦塔 The Tower of Babylon</p><p>这道题求最高的塔，其实就是一个记忆化dfs的过程<br>一些需要注意的点：</p><ol><li>因为不可能出现一个立方体同时叠两次，因此不需要vis</li><li>因为有三种叠法，所以需要3个方向</li><li>因为最开始让谁做底部是不清楚的，所以使用循环遍历方法</li><li>因为一个底确定之后的最高是确定的，因此使用记忆化搜索，避免重复计算</li><li>对于这种题情况多，再加上dfs的题，先分析一两个小的情况（if-else, 三个方向分情况讨论）， 再暴力（dfs）， 再优化（记忆化数组）</li><li>类似最长路问题</li></ol><h3 id="2-树状dp-dfs-dp"><a href="#2-树状dp-dfs-dp" class="headerlink" title="2. 树状dp: dfs+dp"></a>2. 树状dp: dfs+dp</h3><p>主要是针对图有层级结构（没有上司的舞会），或者选择课程这样的dp, 主要是背包和树状dp结合<br>使用dfs+dp</p><ul><li>一般解题步骤：</li><li>先使用dfs记录子节点的状态：dp[i][0]/ dp[i][1]/ dp[i][k]</li><li>然后计算当前节点的状态转移 (u是父节点， i是子节点)<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">dp[u][a+b] = <span class="hljs-built_in">max</span>(dp[u][a+b], dp[u][a]+dp[i][b]) <span class="hljs-comment">//课程的转移方程</span><br>或者<br>dp[u][<span class="hljs-number">0</span>] += <span class="hljs-built_in">max</span>(dp[i][<span class="hljs-number">0</span>], dp[i][<span class="hljs-number">1</span>]); <span class="hljs-comment">//上司的转移方程</span><br>dp[u][<span class="hljs-number">1</span>] += dp[i][<span class="hljs-number">0</span>];<br></code></pre></td></tr></table></figure></li></ul><p>例题：洛谷 P2014 CTSC1997 选课 （挺难的）</p><ul><li>加入一门课程，森林转为树，求解dp[0][m+1]</li><li>我们枚举 u点的每个子结点 ，同时枚举以 i 为根的子树选了几门课程，将子树的结果合并到 u 上。注意这个使用a的取值范围随着访问的子树的数量逐渐增加</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> p = <span class="hljs-number">1</span>;<br>  f[u][<span class="hljs-number">1</span>] = s[u];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : e[u]) &#123;<br>    <span class="hljs-keyword">int</span> siz = <span class="hljs-built_in">dfs</span>(v);<br>    <span class="hljs-comment">// 注意下面两重循环的上界和下界</span><br>    <span class="hljs-comment">// 只考虑已经合并过的子树，以及选的课程数超过 m+1 的状态没有意义</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-built_in">min</span>(p, m + <span class="hljs-number">1</span>); i; i--)<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= siz &amp;&amp; i + j &lt;= m + <span class="hljs-number">1</span>; j++)<br>        f[u][i + j] = <span class="hljs-built_in">max</span>(f[u][i + j], f[u][i] + f[v][j]);  <span class="hljs-comment">// 转移方程</span><br>    p += siz; <span class="hljs-comment">//p逐渐增加</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="换根dp"><a href="#换根dp" class="headerlink" title="换根dp"></a>换根dp</h3><ul><li>两次dfs， 找到换根前后dp的转移公式</li><li>树和图dfs不一样，不需要使用vis,只需要记录一下当前index，和当前index的father就能避免访问同一节点</li></ul><h3 id="数位dp"><a href="#数位dp" class="headerlink" title="数位dp"></a>数位dp</h3><p><a href="https://blog.csdn.net/Enjoying_Science/article/details/44082929">不要62（数位DP）-CSDN博客</a> 动态规划<br><a href="https://www.cnblogs.com/wenruo/p/4725005.html">HDU 2089 不要62 (数位DP) - 我不吃饼干呀 - 博客园</a> 动态规划，解释有点问题<br><a href="http://www.calvinneo.com/2017/09/23/HDU2089%E4%B8%8D%E8%A6%8162/">HDU 2089 不要62 数位DP | Calvin’s Marbles</a> dfs<br><a href="https://www.programminghunter.com/article/8939658418/">hdu 2089 不要62【数位dp】 - 编程猎人</a> dfs<br><a href="https://leetcode.cn/problems/non-negative-integers-without-consecutive-ones/">600. 不含连续1的非负整数</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-DAG上的dp&quot;&gt;&lt;a href=&quot;#1-DAG上的dp&quot; class=&quot;headerlink&quot; title=&quot;1. DAG上的dp&quot;&gt;&lt;/a&gt;1. DAG上的dp&lt;/h3&gt;&lt;p&gt;UVa 437 巴比伦塔 The Tower of Babylon&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="dp问题专栏" scheme="http://shu0421.github.io/categories/dp%E9%97%AE%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
    
    <category term="动态规划" scheme="http://shu0421.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>Git 命令相关</title>
    <link href="http://shu0421.github.io/2022/10/17/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/git/"/>
    <id>http://shu0421.github.io/2022/10/17/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/git/</id>
    <published>2022-10-17T12:13:18.000Z</published>
    <updated>2023-11-30T11:20:40.976Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-git-pull超时，访问缓慢的解决方案"><a href="#1-git-pull超时，访问缓慢的解决方案" class="headerlink" title="1. git pull超时，访问缓慢的解决方案"></a>1. git pull超时，访问缓慢的解决方案</h3><p><a href="https://jasonkayzk.github.io/2019/10/10/%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8Git%E6%97%B6push-pull%E8%B6%85%E6%97%B6-%E4%BB%A5%E5%8F%8AGithub%E8%AE%BF%E9%97%AE%E6%85%A2%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/">参考链接</a></p><p>git超时比较有用的命令：git config –global –add remote.origin.proxy “” </p><p>git 现在不支持密码登陆，只支持token登陆：<br>git remote set-url origin https://<your_token>@github.com/<USERNAME>/<REPO>.git<br>比如：<br>git remote set-url origin <a href="https://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@github.com/SHu0421/DNN_Cplusplus.git">GitHub - SHu0421/DNN_Cplusplus</a></REPO></USERNAME></your_token></p><p><a href="https://hexo.io/zh-cn/docs/github-pages.html#%E7%A7%81%E6%9C%89-Repository">在 GitHub Pages 上部署 Hexo | Hexo</a> hexo+github私有仓库</p><h3 id="2-github-authentication-failed"><a href="#2-github-authentication-failed" class="headerlink" title="2. github authentication failed"></a>2. github authentication failed</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">Missing or invalid credentials.<br>Error: ENOSPC: no space left on device, write<br>    at Object.writeSync (node:fs:884:3)<br>    at Object.writeFileSync (node:fs:2163:26)<br>    at /nfs/home/shu/.vscode-server/bin/64bbfbf67ada9953918d72e1df2f4d8e537d340e/extensions/git/dist/askpass-main.js:1:9371<br><br>fatal: Authentication failed <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;https://github.com/SHu0421/Graduate_Thesis.git/&#x27;</span><br></code></pre></td></tr></table></figure><ul><li>原因一：根目录满了</li><li>原因二：<a href="https://blog.csdn.net/weixin_41010198/article/details/119698015">remote: Support for password authentication was removed on August 13, 2021.-CSDN博客</a><br>当输入github的邮箱和密码的时候，使用git token作为密码，而不是github仓库的密码</li></ul><h3 id="3-使用本地网络在服务器上下载东西"><a href="#3-使用本地网络在服务器上下载东西" class="headerlink" title="3. 使用本地网络在服务器上下载东西"></a>3. 使用本地网络在服务器上下载东西</h3><p>具体见：command-related的第一条-使用网络隧道</p><h3 id="4-github-clone一直卡住"><a href="#4-github-clone一直卡住" class="headerlink" title="4. github clone一直卡住"></a>4. github clone一直卡住</h3><p><a href="https://blog.csdn.net/x763795151/article/details/114903758">git拉取上游代码：LibreSSL SSL_connect: SSL_ERROR_SYSCALL in connection to github.com:443_git libressl ssl_connect:_不识君的荒漠的博客-CSDN博客</a><br>一定要先设置代理后取消，直接取消没有效果</p><h3 id="5-git使用ssh-key的方式连接远程仓库"><a href="#5-git使用ssh-key的方式连接远程仓库" class="headerlink" title="5. git使用ssh key的方式连接远程仓库"></a>5. git使用ssh key的方式连接远程仓库</h3><p>查看remote-url:<br><code>git remote -v </code><br>删除remote-url:<br><code>git remote rm origin</code><br>添加<br><code>git remote add origin git@xxxx </code></p><p>添加和删除可以合并为一个操作<br><code>git remote set-url origin</code></p><h3 id="6-git版本回滚"><a href="#6-git版本回滚" class="headerlink" title="6. git版本回滚"></a>6. git版本回滚</h3><p>如果回滚到上一次提交，删除<code>git add . 和git commit</code>的内容但是本地修改记录不变的话，使用<code>git reset --mixed version_num</code></p><div class="note note-info">            <p>–mixed：为默认值，等同于git reset。作用为：将文件回退到工作区，此时会保留工作区中的文件，但会丢弃暂存区中的文件；<br>–soft：作用为：将文件回退到暂存区，此时会保留工作区和暂存区中的文件（保留git add和git commit内容）；<br>–hard：作用为：将文件回退到修改前，此时会丢弃工作区和暂存区中的文件；</p>          </div><h3 id="7-git新建分支与合并"><a href="#7-git新建分支与合并" class="headerlink" title="7. git新建分支与合并"></a>7. git新建分支与合并</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">新建分支：<br>  git checkout -a dev<br>上传repo: <br>  git add .<br>  git commit -m <span class="hljs-string">&quot;first commit&quot;</span><br>  git push origin dev<br>将<span class="hljs-built_in">source</span>代码合并过来:<br>  git checkout <span class="hljs-built_in">source</span><br>  git pull 和远程分支同步<br>  git checkout dev<br>  git merge <span class="hljs-built_in">source</span> <span class="hljs-comment"># 合并完成后，可能需要解决冲突，然后再提交</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-git-pull超时，访问缓慢的解决方案&quot;&gt;&lt;a href=&quot;#1-git-pull超时，访问缓慢的解决方案&quot; class=&quot;headerlink&quot; title=&quot;1. git pull超时，访问缓慢的解决方案&quot;&gt;&lt;/a&gt;1. git pull超时，访问缓慢的</summary>
      
    
    
    
    <category term="工具相关" scheme="http://shu0421.github.io/categories/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="git" scheme="http://shu0421.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>八股文总结</title>
    <link href="http://shu0421.github.io/2022/06/12/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    <id>http://shu0421.github.io/2022/06/12/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E5%85%AB%E8%82%A1%E6%96%87/</id>
    <published>2022-06-12T09:47:35.000Z</published>
    <updated>2023-11-29T02:21:21.322Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><h3 id="C-多态特性"><a href="#C-多态特性" class="headerlink" title="C++ 多态特性"></a>C++ 多态特性</h3><p>虚函数 是在基类中使用关键字 virtual 声明的函数。虚函数允许子类重新定义成员函数，而子类重新定义父类的做法称为覆盖(override)，或者称为重写。C++多态(polymorphism)就是通过虚函数来实现的。<br>纯虚函数 函数虚函数后面有==0。包含纯虚函数的类就是抽象类，这种类不能有对象，比如动物下面有青蛙，狗，但是动物不能有对象</p><p>静态多态性包括 函数重载 运算符重载， 重载就是同一个函数名字，但是不同的参数类型或者参数个数<br>动态多态主要由虚函数实现，也就是子类重写父类的方法</p><h3 id="C-运算符重载"><a href="#C-运算符重载" class="headerlink" title="C++运算符重载"></a>C++运算符重载</h3><ol><li>在类内实现（类成员函数）的运算符重载<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 重载 + 运算符，用于把两个 Box 对象相加</span><br>    Box <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> Box&amp; b) <span class="hljs-comment">//第一个Box代表返回值类型</span><br>    &#123;<br>        Box box;<br>        box.length = <span class="hljs-keyword">this</span>-&gt;length + b.length;<br>        box.breadth = <span class="hljs-keyword">this</span>-&gt;breadth + b.breadth;<br>        box.height = <span class="hljs-keyword">this</span>-&gt;height + b.height;<br>        <span class="hljs-keyword">return</span> box;<br>    &#125;<br></code></pre></td></tr></table></figure></li><li>友元函数实现的运算符重载 (无this指针)<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 友元函数实现运算符重载 类中申明</span><br>    <span class="hljs-keyword">friend</span> Demo &amp; <span class="hljs-keyword">operator</span>+ (Demo &amp; demo, <span class="hljs-keyword">int</span> n);<br><span class="hljs-comment">//类外实现</span><br><br><span class="hljs-comment">// 重载 &quot;+&quot; 运算符</span><br>Demo &amp; <span class="hljs-keyword">operator</span>+ (Demo &amp; demo, <span class="hljs-keyword">int</span> n)<br>&#123;<br>    demo.a += n;<br>    <span class="hljs-keyword">return</span> demo;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ol><p>// C#好像没有this指针，即使是在成员函数实现重载方法，还是会传入两个对象</p><h3 id="C-内存管理和python内存管理"><a href="#C-内存管理和python内存管理" class="headerlink" title="C++内存管理和python内存管理"></a>C++内存管理和python内存管理</h3><ul><li>C++内存结构是 栈 堆 未初始化存储器， 静态/全局变量存储区， 数据段， 代码段<br>  内存分配使用new delete 或者malloc free<br>  new不仅分配内存，还会调用类的构造函数，malloc只分配内存，不会进行类的初始化工作<br>  但是在分配的时候，可能会出现内存泄漏问题，为了防止这样的情况发生，使用智能指针（shared_ptr, strong_ptr, weak_ptr）</li><li>python 内存管理机制<br>  引入了内存池的概念：预先在内存中申请一定数量的，大小相等的内存块留作备用，当有新的内存需求时，就先从内存池中分配内存给这个需求，不够之后再申请新的内存。这样做最显著的优势就是能够减少内存碎片，提升效率。<br>垃圾回收是：采用引用计数机制为主，标记-清除和分代回收机制为辅的策略。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;C&quot;&gt;&lt;a href=&quot;#C&quot; class=&quot;headerlink&quot; title=&quot;C++&quot;&gt;&lt;/a&gt;C++&lt;/h2&gt;&lt;h3 id=&quot;C-多态特性&quot;&gt;&lt;a href=&quot;#C-多态特性&quot; class=&quot;headerlink&quot; title=&quot;C++ 多态特性&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="项目相关" scheme="http://shu0421.github.io/categories/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/"/>
    
    
  </entry>
  
  <entry>
    <title>图专题</title>
    <link href="http://shu0421.github.io/2022/05/05/leetcode/%E5%9B%BE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
    <id>http://shu0421.github.io/2022/05/05/leetcode/%E5%9B%BE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</id>
    <published>2022-05-05T06:43:54.000Z</published>
    <updated>2023-11-29T02:21:21.322Z</updated>
    
    <content type="html"><![CDATA[<h2 id="图相关例题"><a href="#图相关例题" class="headerlink" title="图相关例题"></a>图相关例题</h2><h3 id="竞赛第四题-hard-lc2097-合法重新排列数对"><a href="#竞赛第四题-hard-lc2097-合法重新排列数对" class="headerlink" title="竞赛第四题 hard lc2097. 合法重新排列数对"></a>竞赛第四题 hard lc2097. 合法重新排列数对</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    map&lt;<span class="hljs-keyword">int</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; mp;<br>    map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; deg;<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; ans;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sn)</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;e = mp[sn]; <span class="hljs-comment">// 注意这个是引用</span><br>        <span class="hljs-keyword">while</span> (!e.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">int</span> fn = e.<span class="hljs-built_in">back</span>();<br>            e.<span class="hljs-built_in">pop_back</span>();<br>            <span class="hljs-built_in">dfs</span>(fn);<br>            ans.<span class="hljs-built_in">push_back</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;&#123;sn, fn&#125;);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//为什么要先dfs再push_back没看明白</span><br><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">validArrangement</span>(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; pairs) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;pair : pairs) &#123;<br>            mp[pair[<span class="hljs-number">0</span>]].<span class="hljs-built_in">push_back</span>(pair[<span class="hljs-number">1</span>]);<br>            deg[pair[<span class="hljs-number">0</span>]]--; deg[pair[<span class="hljs-number">1</span>]]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = deg.<span class="hljs-built_in">begin</span>(); it != deg.<span class="hljs-built_in">end</span>(); it++) <span class="hljs-keyword">if</span> (it-&gt;second == <span class="hljs-number">-1</span>) <span class="hljs-built_in">dfs</span>(it-&gt;first);<br>        <span class="hljs-keyword">if</span> (ans.<span class="hljs-built_in">empty</span>()) <span class="hljs-built_in">dfs</span>(deg.<span class="hljs-built_in">begin</span>()-&gt;first);<br>        <span class="hljs-built_in">reverse</span>(ans.<span class="hljs-built_in">begin</span>(), ans.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h3 id="有关于有向图和无向图的最短路径，以及有负边和无负边的最短路径"><a href="#有关于有向图和无向图的最短路径，以及有负边和无负边的最短路径" class="headerlink" title="有关于有向图和无向图的最短路径，以及有负边和无负边的最短路径"></a>有关于有向图和无向图的最短路径，以及有负边和无负边的最短路径</h3><ol><li><p>Dijstra算法，适用于单源，有向或者无向的最短路径，不能适用于有负边（注意不是负环，负环情况下，无最短路径）的情况：例子：-1， -5， 2<br>时间复杂度O(n^2))</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><br><br><span class="hljs-keyword">int</span> e[Max][Max];<span class="hljs-comment">//e[i][j]代表从i-&gt;j的距离，不通设为无穷大</span><br><span class="hljs-keyword">int</span> dis[Max];<span class="hljs-comment">//dis[i]代表从起点到i的最短距离</span><br><span class="hljs-keyword">bool</span> book[Max];<span class="hljs-comment">//book[i]代表点i是否在S中</span><br><span class="hljs-keyword">int</span> n;<span class="hljs-comment">//n个顶点</span><br><span class="hljs-keyword">int</span> s;<span class="hljs-comment">//起点</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-comment">//初始化dis数组</span><br>        dis[i]=e[s][i];<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-comment">//初始化book数组</span><br>        book[i]=<span class="hljs-number">0</span>;<br>    dis[s]=<span class="hljs-number">0</span>;<br>    book[s]=<span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n<span class="hljs-number">-1</span>;i++)<span class="hljs-comment">//Dijkstra算法核心语句  注意也是n-1次</span><br>    &#123;<br>        <span class="hljs-keyword">int</span> minDis=INF;<br>        <span class="hljs-keyword">int</span> k;<span class="hljs-comment">//找到与s最近的顶点k</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(book[j]==<span class="hljs-number">0</span> &amp;&amp; dis[j]&lt;minDis)<br>            &#123;<br>                minDis=dis[j];<br>                k=j;<br>            &#125;<br>        &#125;<br>        book[k]=<span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<span class="hljs-comment">//“松弛”过程</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(e[k][j]&lt;INF)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(dis[j]&gt;dis[k]+e[k][j])<br>                    dis[j]=dis[k]+e[k][j];<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>Bellman-ford算法：适用于单源，可有负权，有向或者无向的最短路径 记住只松弛n-1次<br>能够检测出有负环情况<br>dp[i][dst]=min(dp[i][dst], dp[i-1][src]+dist[src][dst]) i==1的时候表示经过的中转站为0</p></li></ol><p>时间复杂度O(n*m)/O(VE)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span>&#123;</span><br>    <span class="hljs-keyword">int</span> u;<span class="hljs-comment">//起</span><br>    <span class="hljs-keyword">int</span> v;<span class="hljs-comment">//终</span><br>    <span class="hljs-keyword">int</span> weight;<span class="hljs-comment">//长度</span><br>&#125;;<br><br>Edge edge[maxm];<span class="hljs-comment">//用来存储所有的边</span><br><span class="hljs-keyword">int</span> dis[maxn];<span class="hljs-comment">//dis[i]表示源点到i的最短距离</span><br><span class="hljs-keyword">int</span> n,m;<span class="hljs-comment">//n个点，m条边</span><br><span class="hljs-keyword">int</span> s;<span class="hljs-comment">//源点</span><br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Bellmen_ford</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-comment">//初始化</span><br>        dis[i]=INF;<br><br>    dis[s]=<span class="hljs-number">0</span>;<span class="hljs-comment">//源节点到自己的距离为0</span><br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)<span class="hljs-comment">//松弛过程，计算最短路径 </span><br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++) <span class="hljs-comment">//m条边</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(dis[edge[j].v]&gt;dis[edge[j].u]+edge[j].weight)<span class="hljs-comment">//比较s-&gt;v与s-&gt;u-&gt;v大小</span><br>                dis[edge[j].v]=dis[edge[j].u]+edge[j].weight;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)<span class="hljs-comment">//判断是否有负边权的边</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(dis[edge[j].v]&gt;dis[edge[j].u]+edge[j].weight)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>SPFA算法：是Bellman-ford算法的队列优化，适用于单源，可有负权，有向或者无向的最短路径 （自身其实无法处理负权）<br>设立一个队列用来保存待优化的点，优化时每次取出队首结点u，并且用u点当前的最短路径估计值对u点所指向的结点v进行松弛操作，如果v点的最短路径估计值有所调整，且v点不在当前的队列中，就将v点放入队尾。这样不断从队列中取出结点来进行松弛操作，直至队列空为止。</li></ol><p>注意，一旦从队列中弹出来，vis就设置为false，感觉负权的情况就会一直循环下去，不会跳出；遍历点，与边无关</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><br><br><span class="hljs-keyword">int</span> dis[MAX];<span class="hljs-comment">//dis[i]表示起点到i的最短距离</span><br><span class="hljs-keyword">bool</span> vis[MAX];<span class="hljs-comment">//是否访问过点i</span><br><span class="hljs-keyword">int</span> e[MAX][MAX];<span class="hljs-comment">//矩阵</span><br><br><span class="hljs-keyword">int</span> n,m;<span class="hljs-comment">//点和边的数量</span><br><span class="hljs-keyword">int</span> s;<span class="hljs-comment">//源点</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SPFA</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-comment">//初始化</span><br>    &#123;<br>        dis[i]=INF;<br>        vis[i]=<span class="hljs-literal">false</span>;<br>    &#125;<br>    queue&lt;<span class="hljs-keyword">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(s);<br>    dis[s]=<span class="hljs-number">0</span>;<br>    vis[s]=<span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        <span class="hljs-keyword">int</span> cur=q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        vis[cur]=<span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-comment">//遍历每一个节点</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(e[cur][i]!=INF&amp;&amp;dis[i]&gt;=dis[cur]+e[cur][i])<br>            &#123;<br>                dis[i]=dis[cur]+e[cur][i];<br>                <span class="hljs-keyword">if</span>(!vis[i])<br>                &#123;<br>                    vis[i]=<span class="hljs-literal">true</span>;<br>                    q.<span class="hljs-built_in">push</span>(i);  <span class="hljs-comment">///之后将start缩小的边才拿出来</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>Floyd算法： Floyd算法是一种利用动态规划思想的计算加权图中多源点之间最短路径的算法。可以正确处理有向图或负权的最短路径问题。</li></ol><p>时间复杂度：O(N^3）</p><p>空间复杂度：O(N^2）</p><p>处理问题：多源、可有负权、有向图、无向图最短路径 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> e[Max][Max];<span class="hljs-comment">//e[i][j]代表从i-&gt;j的距离，不通设为无穷大</span><br><span class="hljs-keyword">int</span> n;<span class="hljs-comment">//n个顶点</span><br><span class="hljs-comment">//Floyd算法</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Floyd</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;k++)<span class="hljs-comment">//遍历所有的中间点</span><br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-comment">//遍历所有的起点</span><br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<span class="hljs-comment">//遍历所有的终点</span><br>            &#123;<br>                <span class="hljs-keyword">if</span> (e[i][j]&gt;e[i][k]+e[k][j])<span class="hljs-comment">//如果当前i-&gt;j的距离大于i-&gt;k-&gt;j的距离之和</span><br>                    e[i][j]=e[i][k]+e[k][j];<span class="hljs-comment">//更新从i-&gt;j的最短路径</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最短路衍生拓展的一类题目"><a href="#最短路衍生拓展的一类题目" class="headerlink" title="最短路衍生拓展的一类题目"></a>最短路衍生拓展的一类题目</h3><h3 id="1-最长路径问题"><a href="#1-最长路径问题" class="headerlink" title="1. 最长路径问题"></a>1. 最长路径问题</h3><p>图不为非负权图：当存在正环时无解。<br>如果不存在正环，边权取负后使用Bellman-Ford算法求最短路。</p><h3 id="2-变形的最长路径"><a href="#2-变形的最长路径" class="headerlink" title="2. 变形的最长路径"></a>2. 变形的最长路径</h3><p>路径长度的计算是权重之间的乘积，而且权重都是0-1之间的值，使用Dijstra算法 （e.g概率最大的路径）<br>Solution:<br>    单独使用Dijstra会导致超时，因此需要结合Dijstra+优先队列<br>    1.现将src点push 到堆进行<br>    2.然后遍历堆中的每个节点，如果当前节点能够松弛它的邻接节点，那么就放入堆中，否则不放入类似于SPFA,但是不同的是，<br>    - 这个使用的优先队列，而SPFA是用的是一般的堆<br>    - 这个不仅仅push了节点，也push了当前节点的最大概率，因此没有vis数组来标记当前节点是否在堆中，因为即使在堆中， 概率也可能是不一样的。<br>    总的来说这道题使用bellman-ford算法更简单，只要当前没有任何松弛的边，那么直接退出循环</p><p>颜色交替的最短路径：使用bellman-ford算法（本质是动态规划）， 只是在距离的转换是需要讨论两种情况<br>dstEndWithRed[end]=min(dstEndWithRed[end], dstEndWithBlue[start]+1);<br>dstEndWithBlue[end]=min(dstEndWithBlue[end], dstEndWithRed[start]+1);</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> edge: redEdges)&#123;<br>        <span class="hljs-keyword">int</span> start=edge[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">int</span> end=edge[<span class="hljs-number">1</span>];<br>        dstEndWithRed[end]=<span class="hljs-built_in">min</span>(dstEndWithRed[end], dstEndWithBlue[start]+<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> edge: blueEdges)&#123;<br>        <span class="hljs-keyword">int</span> start=edge[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">int</span> end=edge[<span class="hljs-number">1</span>];<br>        dstEndWithBlue[end]=<span class="hljs-built_in">min</span>(dstEndWithBlue[end], dstEndWithRed[start]+<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-成语接龙的最长，使用bfs，同时对连接好的成语，再来一次bfs-微软三面"><a href="#3-成语接龙的最长，使用bfs，同时对连接好的成语，再来一次bfs-微软三面" class="headerlink" title="3. 成语接龙的最长，使用bfs，同时对连接好的成语，再来一次bfs (微软三面)"></a>3. 成语接龙的最长，使用bfs，同时对连接好的成语，再来一次bfs (微软三面)</h3><p><font color="red">4. lc787. K 站中转内最便宜的航班</font></p><ul><li>只能最多经过k个中转站的最短路径</li><li>使用bellman-ford算法，k个中转站就是松弛每条边 k+1次(1~k+1)，然后使用dp[i][dst]记录 中转i次的最短路径<br>最后的结果就是在dp[1][dst] 到dp[k+1][dst]中取最小的一个</li></ul><h3 id="4-lc6134-找到离给定两个节点最近的节点"><a href="#4-lc6134-找到离给定两个节点最近的节点" class="headerlink" title="4. lc6134. 找到离给定两个节点最近的节点"></a>4. lc6134. 找到离给定两个节点最近的节点</h3><ul><li>内向基环树</li><li>求出node1 到每个点的距离， 和node2 到每个点的距离，然后取最小 (两次求距离，然后取最小，最后注意返回的是最近的下标，而不是最近的距离)</li></ul><p>PS, 最开始理解的时候，感觉应该用两个节点的最近公共祖先来解决，但是因为图中可能有环，所以不能使用最近公共祖先的栈或者dfs方法解决</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;图相关例题&quot;&gt;&lt;a href=&quot;#图相关例题&quot; class=&quot;headerlink&quot; title=&quot;图相关例题&quot;&gt;&lt;/a&gt;图相关例题&lt;/h2&gt;&lt;h3 id=&quot;竞赛第四题-hard-lc2097-合法重新排列数对&quot;&gt;&lt;a href=&quot;#竞赛第四题-hard-lc20</summary>
      
    
    
    
    <category term="leetcode" scheme="http://shu0421.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>数学相关问题</title>
    <link href="http://shu0421.github.io/2022/05/05/leetcode/%E6%95%B0%E5%AD%A6%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
    <id>http://shu0421.github.io/2022/05/05/leetcode/%E6%95%B0%E5%AD%A6%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</id>
    <published>2022-05-05T06:42:44.000Z</published>
    <updated>2023-11-29T02:21:21.344Z</updated>
    
    <content type="html"><![CDATA[<h2 id="random类似题目"><a href="#random类似题目" class="headerlink" title="random类似题目"></a>random类似题目</h2><p>rand5 to rand7<br>rand01p to rand6<br>rand1toM to rand1toN<br>1）二维的方式，使得两个调用rand5在二维矩阵上是大于rand7，然后就可以选取7的倍数的一段距离对rand7取模</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">do</span>&#123;<br>    row=<span class="hljs-built_in">rand5</span>()<span class="hljs-number">-1</span>;<br>    col=<span class="hljs-built_in">rand5</span>()<span class="hljs-number">-1</span>;<br>    num=row*<span class="hljs-number">5</span>+col <span class="hljs-comment">//0-24之间</span><br>&#125;<span class="hljs-keyword">while</span>(num&gt;=<span class="hljs-number">21</span>)<br><br><span class="hljs-keyword">return</span> num%<span class="hljs-number">7</span>+<span class="hljs-number">1</span>;<br><br></code></pre></td></tr></table></figure><p>2）首先等概率产生0-1  01 10是等概率残生的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rand01</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">do</span>&#123;<br>        num=<span class="hljs-built_in">rand01p</span>();<br>    &#125;<span class="hljs-keyword">while</span>(num==<span class="hljs-built_in">rand01p</span>());<br>    <span class="hljs-keyword">return</span> num;<br>&#125;<br><br>那么rand03=<span class="hljs-built_in">rand01</span>()*<span class="hljs-number">2</span>+<span class="hljs-built_in">rand01</span>();<br>rand0<span class="hljs-number">-15</span>=<span class="hljs-built_in">rand03</span>()*<span class="hljs-number">4</span>+<span class="hljs-built_in">rand03</span>(); <span class="hljs-comment">//倍数+插空  用进制的方法可以产生rand07()=rand03()+rand01()*4</span><br>那么rand6可由如下产生:<br><span class="hljs-keyword">do</span>&#123;<br>    num=rand0<span class="hljs-number">-15</span>;<br>&#125;<span class="hljs-keyword">while</span>(num&gt;=<span class="hljs-number">12</span>)<br><span class="hljs-keyword">return</span> num%<span class="hljs-number">6</span>+<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>3）k维的方式<br>rand1toM()转为rand1toN()其实就是调用k次（用N的M进制可以求得）的rand1toM, 使得这a* M^(k-1)+b* M^(k-2)+……  +c 比n要小， 然后返回就可以了<br>其实就是用M进制的数来表示N-1，如果随机生成的数是大于N，那么从头进行生成（注意是从头，而不是从当前数重新生成），否则返回这个数<br>步骤：<br>   1、将n-1转换成m进制数，假设结果转换成数组为 k = [a,b,c,d,e]<br>　　2、使用rand1ToM(m)函数产生结果数组 res = [A,B,C,D,E]，如果res所表示的数值大于k所表示的数值，将res丢掉重新随机，直到产生的结果小于或等于k，这时产生的res的范围就在0～n-1之间，但是此时res所表示的数还是m进制的。 //随机生成M进制的每一位数<br>　　3、将res数组转换成10进制整数。<br>　　4、将步骤3的结果加1就是最终的结果。</p><h2 id="数字运算相关例题"><a href="#数字运算相关例题" class="headerlink" title="数字运算相关例题"></a>数字运算相关例题</h2><h3 id="1-求num阶层中最后的包含0的个数"><a href="#1-求num阶层中最后的包含0的个数" class="headerlink" title="1. 求num阶层中最后的包含0的个数"></a>1. 求num阶层中最后的包含0的个数</h3><p>因为包含因子2的个数一定比5多，因此可以直接求包含因子5的个数<br>每5个数有一个5，每25个数中有一个数包含两个5<br>同样下面的模板可以用于求任何因子的个数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(num)&#123;<br>        res+=num/<span class="hljs-number">5</span>;<br>        num=num/<span class="hljs-number">5</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-判断一个点是否在矩形中：叉乘-点乘"><a href="#2-判断一个点是否在矩形中：叉乘-点乘" class="headerlink" title="2. 判断一个点是否在矩形中：叉乘+点乘"></a><font color="blue">2. 判断一个点是否在矩形中：叉乘+点乘</font></h3><p>对角向量叉积的点积&gt;=0,（对角向量的叉积方向相同），使用叉积的原因是：一个点在线外还是在线内，叉积的正负不同<br>使用叉积可以判断方向，A = &lt;a1, a2&gt;，B = &lt;b1, b2&gt;<br>AXB=a1* b2-a2 *b1, 叉积向量的方向为法线的方向，上下为第一个向量指向第二个向量，大手指的方向<br>叉乘加内积</p><p>(p1 p2 X p1 p ) * (p3 p4 X p3 p1)  &gt;= 0  （四个边分成两组，每两个对边一组， 看两边的叉积是否同方向）</p><h3 id="3-相同的题型：判断点是否在三角形中-叉乘"><a href="#3-相同的题型：判断点是否在三角形中-叉乘" class="headerlink" title="3. 相同的题型：判断点是否在三角形中 叉乘"></a><font color="blue">3. 相同的题型：判断点是否在三角形中 叉乘</font></h3><p>1）先判断三个点的顺序是否是逆时针方向:逆时针方向叉积小于0；顺时针方向叉积大于等于（注意顺序可能导致结果不同！！！）；如果是顺时针正方向，那么调整点位置<br>2）然后判断这个点x是否都是在三角形每条边的左边，判断过程：三角形每个顶点和边的叉积小于0</p><p>（逆时针，点左侧；判断逆时针，仍然使用点左侧）</p><p>求三个三角形不推荐，因为double类型可能出现误差</p><p>PS:lc478. 在圆内随机生成点(Pony.AI)</p><ol><li>拒绝采样，在矩形中采样，如果点距离中心的位置大于半径的话，那么就重新采样</li><li>在（0-p^2）中随机采样然后开方，在（0，2*pi）中随机采样，然后使用极坐标 p * cos(theta),p * sin(theta)</li></ol><h3 id="4-路径数组转为统计数组的题目：原地hash-注意以负数作为标记的话，全部的数都需要转为正数"><a href="#4-路径数组转为统计数组的题目：原地hash-注意以负数作为标记的话，全部的数都需要转为正数" class="headerlink" title="4. 路径数组转为统计数组的题目：原地hash, 注意以负数作为标记的话，全部的数都需要转为正数"></a><font color="red">4. 路径数组转为统计数组的题目：原地hash, 注意以负数作为标记的话，全部的数都需要转为正数</font></h3><p>要求额外的空间复杂度为O(1)<br>如果要实现空间复杂度为O(1),那么需要在原来的数据上进行运算，那么每个位置存储跳过来的位置（最开始节点存储为-1），直到当前的数为一个负数（表示已经求过距离），然后跳回去的时候就知道来的位置，同时更新当前的距离，<br>为了区分已经判断过的值和未判断过的值，使用负数；求到距离矩阵之后再计算每个距离出现的次数，仍然是使用跳的方式，开始节点记得赋值为0，表示已经访问计算过</p><p>这种方式也出现在”第一个未出现的正数“这道题解决方案中（值与下标相互映射）</p><h3 id="5-正数数组的最小不可组成和"><a href="#5-正数数组的最小不可组成和" class="headerlink" title="5. 正数数组的最小不可组成和"></a>5. 正数数组的最小不可组成和</h3><p>dp[0][0]=1<br>使用动态规划<br>for j=0; j=arr.size(); j++:<br>    for i = sum to min: //注意反着,因为一个数只能取一次0-1背包<br>        if(i&gt;=arr[j]):<br>            dp[i]=dp[i-arr[j]]?True:dp[i]//注意是dp[i]而不是false,也不是dp[i]=dp[i-arr[i]]//因为可能一个数一种方式可以组成，但是另一种不行</p><p>PS:没有思路就想暴力算法，然后递归考虑是否能转为动态规划，类似背包问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++">dp[i][j]=dp[i<span class="hljs-number">-1</span>][j-arr[i]]||dp[i<span class="hljs-number">-1</span>][j];<br><br><span class="hljs-keyword">for</span> i in min to sum:<br>    <span class="hljs-keyword">if</span> dp[n][i] == <span class="hljs-literal">false</span>:<br>        <span class="hljs-keyword">return</span> i<br></code></pre></td></tr></table></figure><h3 id="6-累加出整个范围最少还需要的数"><a href="#6-累加出整个范围最少还需要的数" class="headerlink" title="6. 累加出整个范围最少还需要的数"></a>6. 累加出整个范围最少还需要的数</h3><p>使用当前可以累加得到的范围，如果范围超过了当前遍历到的arr的第一个数，那么下一个可以累加得到的范围是当前的范围+arr[i];否则下一个差的数应该是touch+1,可以累加得到的数是touch+1+touch</p><p>可以累加得到的数是touch,下一个差的数是touch+1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++">touch=<span class="hljs-number">0</span>;<br>cnt=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;arr.<span class="hljs-built_in">size</span>();i++)&#123;<br>    <span class="hljs-keyword">if</span>(touch+<span class="hljs-number">1</span>&lt;arr[i])&#123;<br>        <span class="hljs-keyword">while</span>(touch&lt;arr[i]+<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//注意这是循环</span><br>            touch+=touch+<span class="hljs-number">1</span>;<br>            cnt++;<br>            <span class="hljs-keyword">if</span>(touch&gt;=range)&#123;<br>                <span class="hljs-keyword">return</span> cnt;<br>            &#125;<br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        touch+=arr[i];<br>        <span class="hljs-keyword">if</span>(touch&gt;=range)&#123;<br>            <span class="hljs-keyword">return</span> cnt;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">while</span>(touch&lt;range)&#123;<br>        touch+=touch+<span class="hljs-number">1</span>;<br>        cnt++;    <br>&#125;<br><br>    <span class="hljs-keyword">return</span> cnt;<br></code></pre></td></tr></table></figure><h3 id="7-一种字符串和数字对应的关系-（lc168-Excel表列名称）"><a href="#7-一种字符串和数字对应的关系-（lc168-Excel表列名称）" class="headerlink" title="7. 一种字符串和数字对应的关系 （lc168. Excel表列名称）"></a>7. 一种字符串和数字对应的关系 （lc168. Excel表列名称）</h3><p>A -&gt; 1<br>B -&gt; 2<br>C -&gt; 3<br>…<br>Z -&gt; 26<br>AA -&gt; 27<br>AB -&gt; 28<br>从 1开始的的 2626 进制转换题。（每一位至少都有1）</p><ul><li><p>方法1：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++">string res=<span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">while</span>(columnNumber&gt;<span class="hljs-number">0</span>)&#123;<br>    columnNumber--;<br>    res+=(columnNumber%<span class="hljs-number">26</span>+<span class="hljs-string">&#x27;A&#x27;</span>);<br>    columnNumber/=<span class="hljs-number">26</span>;<br>&#125;<br><span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>());<br><span class="hljs-keyword">return</span> res;<br></code></pre></td></tr></table></figure></li><li><p>方法2：注意是K伪进制数，也就是每一个伪至少为1不能为0，因此需要先从右往左计算位数（同时每一位分得1, 因为这个规则每一位至少都有1），然后从左往右分剩下的数字 </p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//先从右往左，减掉一轮，再从左往右看补在哪为 进制如果为3：base=1 3 9</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">int2str</span><span class="hljs-params">()</span></span>&#123;<br>    cur=<span class="hljs-number">1</span>;<span class="hljs-comment">//代表进制的基数</span><br>    k=<span class="hljs-number">0</span><span class="hljs-comment">//代表位数</span><br>    base=<span class="hljs-number">3</span><span class="hljs-comment">//代表进制数，多少个字符就是多少进制</span><br>    <span class="hljs-keyword">while</span>(n&gt;=cur)&#123;<br>        k++;<br>        n-=cur;<br>        cur*=base;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> index=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(k)&#123;<br>        cur/=base;<br>        res[index++]=<span class="hljs-built_in">getchar</span>(n/cur);  <span class="hljs-comment">//当前base的数量应该为n/cur+1,对应的下标就是n/cur</span><br>        n=n%cur; <span class="hljs-comment">//剩下的数可以分多少到下一个进制位中</span><br>        k--;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>str2int类似于K进制</p><p>从N个数中等概率打印M个数,空间复杂度为O(1)：将每次打印的数每次交换到整个数组的末尾，然后下次在生成随机数的时候，减少生成范围（1，n-count）</p><h3 id="8-数字的中文表达和英文表达"><a href="#8-数字的中文表达和英文表达" class="headerlink" title="8. 数字的中文表达和英文表达"></a>8. 数字的中文表达和英文表达</h3><ul><li>1.中文表达：对于零特殊处理</li><li>2.英文表达：每三个一组进行处理；使用递归或者迭代。递归方式就是分别求出billion million和thousand三个部分的数字，然后加起来，<br>在求每个部分的时候，先判断百位，如果百位有数字的话，那么加上”hundred“,否则分为数字&lt;=10 &lt;20; &lt;=20 &lt;100 and &lt;10 三种情况进行处理</li></ul><h3 id="9-实现sqrt函数"><a href="#9-实现sqrt函数" class="headerlink" title="9. 实现sqrt函数"></a>9. 实现sqrt函数</h3><ul><li><p>方法一：使用二分算法（一个数的平方根不会大于 n/2+1），标准二分，返回right</p></li><li><p>方法二：牛顿迭代算法： y=f(x0)+k(x-x0)<br>令y=0, 得到 x_i+1=(x_i+ C/x_i)  其中C为要求的目标</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">double</span> C = x, x0 = x;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">double</span> xi = <span class="hljs-number">0.5</span> * (x0 + C / x0);<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(x0 - xi) &lt; <span class="hljs-number">1e-7</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            x0 = xi;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(x0);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><h3 id="10-进制转换"><a href="#10-进制转换" class="headerlink" title="10. 进制转换"></a>10. 进制转换</h3><p>小数的十进制转为二进制是*2 取整数部分，如果整数&gt;=1, 那么num-=1,否则当前位为0， 直到num=0; 也可以1连除2，num如果num&gt;base,那么减去base<br>十进制整数转换为二进制整数采用”除2取余，逆序排列”法<br>十进制小数转换成二进制小数采用”乘2取整，顺序排列”法</p><h3 id="11-全排列问题"><a href="#11-全排列问题" class="headerlink" title="11. 全排列问题"></a>11. 全排列问题</h3><p>使用交换或者vis+回溯，一定要注意是否有重复的字符，如果有重复的字符，那么下一个交换或者选择的数，一定是当前没有选择的 （可以和当前自己位置进行交换）</p><h3 id="12-树状数组例题"><a href="#12-树状数组例题" class="headerlink" title="12. 树状数组例题"></a><font color="red">12. 树状数组例题</font></h3><ul><li><p>数字流的秩 线段树（平衡树+二叉搜索树，需要初始化4*n区间） 使用频繁更新数组的某一位（后面的位数也需要相应修改），以及求前缀和</p></li><li><p>线段树和树状数组的基本功能都是在某一满足结合律的操作(比如加法，乘法，最大值，最小值)下，O(logn)的时间复杂度内修改单个元素并且维护区间信息。不同的是，树状数组只能维护前缀“操作和”(前缀和，前缀积，前缀最大最小)，而线段树可以维护区间操作和。线段数组是真正的数，而树状数组只是一个数组</p></li><li><p>树状数组主要是用于求前缀和，（改变原始然后求前缀和；差分数组适用于，某一段的元素被整体加上或者减去一个元素）</p><ul><li>区间查询：求index的前缀和其实就是不断将index的二进制数的最后一个一个1逐渐变为0 的数据对应的值相加；（x-(x&amp;-x)）//不断地去掉二进制数最右边的一个1 （从x到=n）</li><li>单点修改：更新一个index需要更新的其他下标的值相当于 不断加上最后一个1所代表的数字下标对应的值（x+(x&amp;-x)）//从右边起一系列连续的1变为0，再把这一系列1的前一位0变为1,相当与最后一个1+1，导致连续进位<br>其中存储值的下标从1开始，0下标主要是判断循环的终点，不被用来存储值 （从x到0）</li></ul></li><li><p>树状数组的下标从1开始，常用于频繁更新和频繁求前缀和</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++">建立树状数组：<br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">int</span> a[<span class="hljs-number">1005</span>],c[<span class="hljs-number">1005</span>]; <span class="hljs-comment">//对应原数组和树状数组</span><br><span class="hljs-comment">//范围是[1,n]</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> x&amp;(-x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">updata</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> k)</span></span>&#123;    <span class="hljs-comment">//在i位置加上k</span><br>    <span class="hljs-keyword">while</span>(i &lt;= n)&#123;<br>        c[i] += k;<br>        i += <span class="hljs-built_in">lowbit</span>(i);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getsum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;        <span class="hljs-comment">//求A[1 - i]的和</span><br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i &gt; <span class="hljs-number">0</span>)&#123;<br>        res += c[i];<br>        i -= <span class="hljs-built_in">lowbit</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>树状数组如果输入有0， 那么所有的输入都应该向右边偏移以为（输入x，实际上对应x+1）</p></li></ul><h3 id="lc5999-统计数组中好三元组数目"><a href="#lc5999-统计数组中好三元组数目" class="headerlink" title="lc5999. 统计数组中好三元组数目"></a>lc5999. 统计数组中好三元组数目</h3><p>这道题是求在一个数的左边，同时小于这个数的数量（数量题）<br>lc307. 区域和检索 - 数组可修改</p><ul><li>这道题是，频繁的修改某个下标的元素值+同时求某个范围元素之间的元素和（值题目）</li><li>数组的大小为arr的范围n， 下标对于树状数组的二进制下标</li><li>需要先将num的值插入树状数组中， 然后更新的时候使用newvalue-ori[index]来更新当前节点后面的值，同时一定要记得更新ori[index]=newvalue !!!!</li><li>一定要记得树状数组的下标是从1开始，但是num的下标从0开始；而且区间范围是两边闭合，所以求区间差的时候，left_index应该减1</li></ul><h3 id="lc315-计算右侧小于当前元素的个数（hard）"><a href="#lc315-计算右侧小于当前元素的个数（hard）" class="headerlink" title="lc315. 计算右侧小于当前元素的个数（hard）"></a><font color="red">lc315. 计算右侧小于当前元素的个数（hard）</font></h3><ul><li>注意这道题数据可能为负数，因此需要对数据+10000+1 使数据shift到[1, +无穷]</li><li>使用归并排序，每个i, j 那么num[i]+=j-i-1 (就是在i后面而且比nums[i]小的数的数量)<br>归并排序易错点：需要使用索引数组,同时在进行归并的时候会修改索引数组，一定要记得复制一个新的数组出来，不能使用原来的数组；其次就是注意数组的范围，左右都闭合；归并排序还长用于计算逆序对</li></ul><h3 id="lc493-翻转对-hard"><a href="#lc493-翻转对-hard" class="headerlink" title="lc493. 翻转对(hard)"></a>lc493. 翻转对(hard)</h3><ul><li>归并排序</li><li>范围映射的树状数组（具体代码可见模板代码）</li></ul><h3 id="13-最佳直线，使用暴力枚举的方式，-三重循环"><a href="#13-最佳直线，使用暴力枚举的方式，-三重循环" class="headerlink" title="13. 最佳直线，使用暴力枚举的方式， 三重循环"></a>13. 最佳直线，使用暴力枚举的方式， 三重循环</h3><p>枚举直线两个起始端点(i, j)，后面遍历k是否在直线(i, j)上，在的话计算过得点个数进行更新， 最后判断这条直线上最多有多少个同点<br>时间复杂度：O(n^3)<br>空间复杂度：O(1)O(1)</p><h3 id="14-枚举题"><a href="#14-枚举题" class="headerlink" title="14. 枚举题"></a>14. 枚举题</h3><p>模式匹配问题，暂时未做，主要是通过a和b的数量来枚举a匹配的字符的长度和b字符的长度，主要是注意边界情况应该先于长度的枚举进行判断<br>    example： pattern = “abba”, value = “dogcatcatdog”<br>    注意：pattern只包含字母”a”和”b”两种字符， 而且a或者b可以为空串， 而且a 与b映射的字符串不应该相等<br>    lena lenb都为0; lena为0; lenb为0;lena lenb都不为0时， 他们映射的字符串不应该相等</p><h3 id="15-大数相乘的题目"><a href="#15-大数相乘的题目" class="headerlink" title="15. 大数相乘的题目"></a>15. 大数相乘的题目</h3><ul><li>使用第二个数的每一位数和第一个数相乘&lt;&lt; i 位，然后将求得的结果相加</li><li>使用第一个数的每一位和第二个数相乘，更新结果的 arr[i+k]位</li></ul><h3 id="16-矩形覆盖面积"><a href="#16-矩形覆盖面积" class="headerlink" title="16. 矩形覆盖面积"></a>16. 矩形覆盖面积</h3><ul><li>公式为:<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">area1<span class="hljs-operator">+</span>area2<span class="hljs-operator">-</span>inter_area<br>inter_area <span class="hljs-operator">=</span> <span class="hljs-built_in">max</span>((最小 右上横坐标 <span class="hljs-operator">-</span> 最大左下横坐标), <span class="hljs-number">0</span>)<span class="hljs-operator">*</span> <span class="hljs-built_in">max</span>(（最小右上纵坐标 <span class="hljs-operator">-</span>  最大左下纵坐标, <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure>注意一定要和0进行比较</li></ul><h3 id="16-找众数II"><a href="#16-找众数II" class="headerlink" title="16. 找众数II"></a>16. 找众数II</h3><ul><li>使用hash算法</li><li>使用摩尔投票算法</li></ul><p>找到超过 (n/3) 向下取整的数：数学证明这样的数最多2个，选两个数，如果当前的数都不等于前两个数，那么两个投票数都–<br>这种投票算法同样适用于找到超过 n/2</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">majorityElement</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; ans;<br>        <span class="hljs-keyword">int</span> element1 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> element2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> vote1 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> vote2 = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp; num : nums) &#123;<br>            <span class="hljs-keyword">if</span> (vote1 &gt; <span class="hljs-number">0</span> &amp;&amp; num == element1) &#123; <span class="hljs-comment">//如果该元素为第一个元素，则计数加1</span><br>                vote1++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (vote2 &gt; <span class="hljs-number">0</span> &amp;&amp; num == element2) &#123; <span class="hljs-comment">//如果该元素为第二个元素，则计数加1</span><br>                vote2++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (vote1 == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 选择第一个元素</span><br>                element1 = num;<br>                vote1++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (vote2 == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 选择第二个元素</span><br>                element2 = num;<br>                vote2++;<br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//如果三个元素均不相同，则相互抵消1次</span><br>                vote1--;<br>                vote2--;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> cnt1 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> cnt2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp; num : nums) &#123;<br>            <span class="hljs-keyword">if</span> (vote1 &gt; <span class="hljs-number">0</span> &amp;&amp; num == element1) &#123;<br>                cnt1++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (vote2 &gt; <span class="hljs-number">0</span> &amp;&amp; num == element2) &#123;<br>                cnt2++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 检测元素出现的次数是否满足要求</span><br>        <span class="hljs-keyword">if</span> (vote1 &gt; <span class="hljs-number">0</span> &amp;&amp; cnt1 &gt; nums.<span class="hljs-built_in">size</span>() / <span class="hljs-number">3</span>) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(element1);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (vote2 &gt; <span class="hljs-number">0</span> &amp;&amp; cnt2 &gt; nums.<span class="hljs-built_in">size</span>() / <span class="hljs-number">3</span>) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(element2);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h3 id="17-为运算表达式计算优先级"><a href="#17-为运算表达式计算优先级" class="headerlink" title="17. 为运算表达式计算优先级"></a>17. 为运算表达式计算优先级</h3><p>使用分治算法, 遍历表达式，找到运算符，将结果分成两个部分， 递归查找。类似二叉树的组成方式查找<br>如果求具体的结果，那么需要使用vector将结果进行push_back,否则可以直接使用动态规划，计算总数</p><h3 id="18-摆动序列"><a href="#18-摆动序列" class="headerlink" title="18. 摆动序列"></a>18. 摆动序列</h3><p>如果是需要相邻两个数不能等于的话，只能两个字符串都进行翻转，如果可以相邻等于的话，可以后面的字符串进行翻转就行了 </p><h3 id="19-中文变为阿拉伯数字和阿拉伯数字变为中文"><a href="#19-中文变为阿拉伯数字和阿拉伯数字变为中文" class="headerlink" title="19. 中文变为阿拉伯数字和阿拉伯数字变为中文"></a>19. 中文变为阿拉伯数字和阿拉伯数字变为中文</h3><p>1.中文变为阿拉伯数字<br>使用栈，将文字划分为数字和量纲，遇到量纲，那么从栈中弹出与当前量纲小的数字与当前量纲相乘，然后不断累加，知道栈为空或者栈顶量纲比当前量纲大，然后将当前累加到的数压入栈中；最后的结果就是栈中的数求和</p><p>2.阿拉伯数字变为中文<br>注意：亿，万节之后如果只有0那么不需要输出0，如果千位为0的话那么需要输出0<br>10500，一万零五百， 15000一万五千</p><p>将数组划分为节，然后每节使用一个函数判断<br>如果不是第一节，而且当前的数是大于0，而且小于1000的话那么需要加零</p><h3 id="20-面试题-16-14-最佳直线-149-直线上最多的点数"><a href="#20-面试题-16-14-最佳直线-149-直线上最多的点数" class="headerlink" title="20. 面试题 16.14. 最佳直线/149. 直线上最多的点数"></a>20. 面试题 16.14. 最佳直线/149. 直线上最多的点数</h3><ul><li>暴力方法：使用三重循环，前两个点固定一条直线，后一个点判断是否在直线上，是cnt++,最后找最大的cnt</li><li>hash方法，使用二重循环，遍历两个点，两个点得到一个斜率，然后hash_map中存储该斜率的cnt, 最后取最大值的时候res=max(res, cnt+1)//一定记得+1<br>  因为gcd(5, 0)=5=cd(0, 5) 所以不存在除0情况<br>  斜率为0和正无穷的方法分别特判<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> a = x1 - x2, b = y1 - y2;<br><span class="hljs-keyword">int</span> k = <span class="hljs-built_in">gcd</span>(a, b);<br>String key = (a / k) + <span class="hljs-string">&quot;_&quot;</span> + (b / k); <span class="hljs-comment">//斜率用string存储</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> b == <span class="hljs-number">0</span> ? a : <span class="hljs-built_in">gcd</span>(b, a % b);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="21-阶层之后的零"><a href="#21-阶层之后的零" class="headerlink" title="21. 阶层之后的零"></a>21. 阶层之后的零</h3><ul><li> 方法1， 直接计算，n是5的倍数的个数+25倍数个数+…<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> pow=<span class="hljs-number">5</span>;<br><span class="hljs-keyword">while</span>(n&gt;=pow)&#123;<br>    cnt+=n/pow;<br>    pow=pow*<span class="hljs-number">5</span>;<br>&#125;<br><span class="hljs-keyword">return</span> cnt;<br></code></pre></td></tr></table></figure></li><li>方法2， 对1-n中的每一个数计算，能够拆分为多少个5的因子<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">int</span> tmp=i;<br><span class="hljs-keyword">while</span>(tmp%<span class="hljs-number">5</span>==<span class="hljs-number">0</span>)&#123;<br>    tmp=tmp/<span class="hljs-number">5</span>;<br>    cnt++;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="22-lc277-find-the-celebrity"><a href="#22-lc277-find-the-celebrity" class="headerlink" title="22. lc277. find-the-celebrity"></a>22. lc277. find-the-celebrity</h3><ul><li>所有的人都认识名人，名人谁都不认识，找出名人</li><li>假设法，O(n), 假设0是名人，如果遇到knows(0, i)==true, 说明0不是名人，同时说明[0~i-1]都不是名人，因为他们都不被0知道</li><li>之后再判断一次，如果出现know(ans, i)==true||know(i, ans)==false, 返回-1</li></ul><h3 id="23-欧拉筛法-埃及筛法求n以内的质数的个数-一个数的包含的因数的个数"><a href="#23-欧拉筛法-埃及筛法求n以内的质数的个数-一个数的包含的因数的个数" class="headerlink" title="23. 欧拉筛法/埃及筛法求n以内的质数的个数/一个数的包含的因数的个数"></a>23. 欧拉筛法/埃及筛法求n以内的质数的个数/一个数的包含的因数的个数</h3><p><a href="http://oi-wiki.com/math/number-theory/sieve/#_10">筛法 - OI Wiki</a></p><h2 id="蓄水池抽样算法"><a href="#蓄水池抽样算法" class="headerlink" title="蓄水池抽样算法"></a>蓄水池抽样算法</h2><p>模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Solution</span>(ListNode* head) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;head=head;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getRandom</span><span class="hljs-params">()</span> </span>&#123;<br>        ListNode*cur=<span class="hljs-keyword">this</span>-&gt;head;<br>        <span class="hljs-keyword">int</span> pool=<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(cur)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">rand</span>()%i==<span class="hljs-number">0</span>)pool=cur-&gt;val; <span class="hljs-comment">//只选取一个数的情况</span><br>            i++;<br>            cur=cur-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pool;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    ListNode*head;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>例题：</p><ol><li>链表随机节点</li><li>随机索引数 ，找到target数的随机一个index</li></ol><h2 id="摩尔投票算法"><a href="#摩尔投票算法" class="headerlink" title="摩尔投票算法"></a>摩尔投票算法</h2><h3 id="1-求众数"><a href="#1-求众数" class="headerlink" title="1.求众数"></a>1.求众数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> target_num=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>    <span class="hljs-keyword">if</span>(k==<span class="hljs-number">0</span>)&#123;<br>        target_num=nums[i];<br>        k=<span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">if</span>(nums[i]==target_num)&#123;<br>            k++;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            k--;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//判断target_num的数是否大于n/2;</span><br><span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>    <span class="hljs-keyword">if</span>(nums[i]==target_num)&#123;<br>        cnt++;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">if</span>(cnt&gt;n/<span class="hljs-number">2</span>)&#123;<br>    <span class="hljs-keyword">return</span> target_num;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-求大于n-3-的数"><a href="#2-求大于n-3-的数" class="headerlink" title="2.求大于n/3 的数"></a>2.求大于n/3 的数</h3><p>这样的数最多只有两个</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> k1=<span class="hljs-number">0</span>;<span class="hljs-comment">//投票的数量</span><br><span class="hljs-keyword">int</span> k2=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> target_num1;<span class="hljs-comment">//具体的数</span><br><span class="hljs-keyword">int</span> target_num2;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>    <span class="hljs-keyword">if</span>(k1&gt;<span class="hljs-number">0</span>&amp;&amp;target_num1==nums[i])&#123;<br>        k1++;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(k2&gt;<span class="hljs-number">0</span>&amp;&amp;target_num2==nums[i])&#123;<br>        k2++;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(k1==<span class="hljs-number">0</span>)&#123;<br>        target_num1=nums[i];<br>        k1=<span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(k2==<span class="hljs-number">0</span>)&#123;<br>        target_num2=nums[i];<br>        k2=<span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        k1--;<br>        k2--;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">int</span> cnt1=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> cnt2=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>    <span class="hljs-keyword">if</span>(k1&gt;<span class="hljs-number">0</span>&amp;&amp;nums[i]==target_num1)&#123;<br>        cnt1++;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(k2&gt;<span class="hljs-number">0</span>&amp;&amp;nums[i]==target_num2)&#123;<br>        cnt2++;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">if</span>(cnt1&gt;n/<span class="hljs-number">3</span>)&#123;<br>    res.<span class="hljs-built_in">push_back</span>(target_num1);<br>&#125;<br><span class="hljs-keyword">if</span>(cnt2&gt;n/<span class="hljs-number">3</span>)&#123;<br>    res.<span class="hljs-built_in">push_back</span>(target_num2);<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="3-剑指-Offer-20-表示数值的字符串"><a href="#3-剑指-Offer-20-表示数值的字符串" class="headerlink" title="3. 剑指 Offer 20. 表示数值的字符串"></a>3. 剑指 Offer 20. 表示数值的字符串</h3><ol><li>这道题可以用，先搜索一个整数，然后如果遇到点，搜索一个无符号整数，或者不变；遇到E搜索一个整数<br>然后就实现搜索一个整数和搜索一个无符号整数两个函数就可以了(剑指offer上面的答案)</li><li>第二种方法就是使用<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">bool <span class="hljs-attribute">isE</span>=<span class="hljs-literal">false</span>;<br>bool <span class="hljs-attribute">isNum</span>=<span class="hljs-literal">false</span>;<br>bool <span class="hljs-attribute">isPoint</span>=<span class="hljs-literal">false</span>;<br>bool <span class="hljs-attribute">isSymbol</span>=<span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure>每当遇到. E 判断前面的flag, 同时设置当前的flag</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>除掉最后一个1的方法是： <code>n&amp;(n-1)</code></li><li>只取最后一个1的方法是： <code>n&amp;(~n+1)</code></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;random类似题目&quot;&gt;&lt;a href=&quot;#random类似题目&quot; class=&quot;headerlink&quot; title=&quot;random类似题目&quot;&gt;&lt;/a&gt;random类似题目&lt;/h2&gt;&lt;p&gt;rand5 to rand7&lt;br&gt;rand01p to rand6&lt;br&gt;</summary>
      
    
    
    
    <category term="leetcode" scheme="http://shu0421.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Zsim编译</title>
    <link href="http://shu0421.github.io/2022/04/26/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/zsim%E7%BC%96%E8%AF%91/"/>
    <id>http://shu0421.github.io/2022/04/26/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/zsim%E7%BC%96%E8%AF%91/</id>
    <published>2022-04-26T13:05:06.000Z</published>
    <updated>2023-11-29T02:21:21.320Z</updated>
    
    <content type="html"><![CDATA[<h2 id="服务器环境"><a href="#服务器环境" class="headerlink" title="服务器环境"></a>服务器环境</h2><p>ubuntu18.04下gcc7.5.0</p><h2 id="主要参考文档"><a href="#主要参考文档" class="headerlink" title="主要参考文档"></a>主要参考文档</h2><p>步骤文档：<br><a href="https://blog.csdn.net/yy1348046572/article/details/118194214">ubuntu18.04下gcc7.5.0安装zsim_zsim安装-CSDN博客</a><br>注意使用sudo make &amp;&amp; sudo make install</p><p>安装zsim版本：<a href="https://github.com/SteveY4ng/zsim">GitHub - SteveY4ng/zsim: A fast and scalable x86-64 multicore simulator</a></p><p>除此之外，自己加了一个env.sh文件来添加环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">BASEDIR=$(<span class="hljs-built_in">pwd</span>)<br>PINPATH=<span class="hljs-variable">$BASEDIR</span>/pin-2.14<br>ZSIMPATH=<span class="hljs-variable">$BASEDIR</span>/zsim<br>LIBCONFIGPATH=/nfs/home/siling/zsim/zsim-ubuntu18_04/libconfig-1.7.3<br>HDF5PATH=/nfs/home/siling/zsim/zsim-ubuntu18_04/hdf5-1.12.0<br><span class="hljs-built_in">export</span> CPATH=<span class="hljs-string">&quot;/usr/include/hdf5/serial/&quot;</span><br><span class="hljs-built_in">export</span> ZSIMPATH PINPATH LIBCONFIGPATH POLARSSLPATH<br><span class="hljs-built_in">export</span> CXX=g++ CC=gcc<br></code></pre></td></tr></table></figure><h2 id="遇到的问题及解决方案"><a href="#遇到的问题及解决方案" class="headerlink" title="遇到的问题及解决方案"></a>遇到的问题及解决方案</h2><h3 id="1-在安装hdf5使用源文件，出错，因此使用的命令安装-sudo-apt-get-install-libhdf5-dev"><a href="#1-在安装hdf5使用源文件，出错，因此使用的命令安装-sudo-apt-get-install-libhdf5-dev" class="headerlink" title="1. 在安装hdf5使用源文件，出错，因此使用的命令安装 sudo apt-get install libhdf5-dev"></a>1. 在安装hdf5使用源文件，出错，因此使用的命令安装 sudo apt-get install libhdf5-dev</h3><p><a href="https://blog.csdn.net/tianminggenie/article/details/110921264">ubuntu 16.04 安装 hdf5-1.12  c++库_ubuntu hdf5 c动态库安装-CSDN博客</a></p><h3 id="2-hdf5文件错误1"><a href="#2-hdf5文件错误1" class="headerlink" title="2. hdf5文件错误1"></a>2. hdf5文件错误1</h3><blockquote><p>Can’t find file #include&lt;hdf5.h&gt;</p></blockquote><p>解决方案：<br>在env.sh中加上</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">CPATH</span>=<span class="hljs-string">&quot;/usr/include/hdf5/serial/&quot;</span><br></code></pre></td></tr></table></figure><h3 id="3-hdf5文件错误2"><a href="#3-hdf5文件错误2" class="headerlink" title="3. hdf5文件错误2"></a>3. hdf5文件错误2</h3><blockquote><p>Cannot find -lhdf5_hl and -lhdf5</p></blockquote><p>解决方案：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">cd</span> /usr/lib/x86_64-linux-gnu<br>然后根据情况执行下面两句：<br>sudo <span class="hljs-keyword">ln</span> -s libhdf5_serial.<span class="hljs-keyword">so</span>.<span class="hljs-number">10.1</span>.<span class="hljs-number">0</span> libhdf5.<span class="hljs-keyword">so</span><br>sudo <span class="hljs-keyword">ln</span> -s libhdf5_serial_hl.<span class="hljs-keyword">so</span>.<span class="hljs-number">10.0</span>.<span class="hljs-number">2</span> libhdf5_hl.<span class="hljs-keyword">so</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;服务器环境&quot;&gt;&lt;a href=&quot;#服务器环境&quot; class=&quot;headerlink&quot; title=&quot;服务器环境&quot;&gt;&lt;/a&gt;服务器环境&lt;/h2&gt;&lt;p&gt;ubuntu18.04下gcc7.5.0&lt;/p&gt;
&lt;h2 id=&quot;主要参考文档&quot;&gt;&lt;a href=&quot;#主要参考文档&quot;</summary>
      
    
    
    
    <category term="工具相关" scheme="http://shu0421.github.io/categories/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/"/>
    
    
  </entry>
  
  <entry>
    <title>MacOS 环境配置</title>
    <link href="http://shu0421.github.io/2022/04/23/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/Macos/"/>
    <id>http://shu0421.github.io/2022/04/23/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/Macos/</id>
    <published>2022-04-23T04:00:05.000Z</published>
    <updated>2023-11-29T02:21:21.319Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-macos上下载brew"><a href="#1-macos上下载brew" class="headerlink" title="1. macos上下载brew:"></a>1. macos上下载brew:</h3><p><code>/bin/zsh -c &quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot;</code></p><h3 id="2-macos-vscode-配置-opencv-C"><a href="#2-macos-vscode-配置-opencv-C" class="headerlink" title="2. macos vscode 配置 opencv(C++)"></a>2. macos vscode 配置 opencv(C++)</h3><p>切换opencv的版本：<br><a href="https://zhuanlan.zhihu.com/p/121721651">macOS Homebrew 安装 OpenCV 及切换版本 - 知乎</a></p><p>vscode配置opencv4:<br><a href="https://codeantenna.com/a/VAayPeG1xI">MacOS-VScode-opencv4.3-yolov3-C++（测试成功） - CodeAntenna</a></p><h3 id="3-在macos-big-sur的vscode上配置c-c-程序运行和调试工具"><a href="#3-在macos-big-sur的vscode上配置c-c-程序运行和调试工具" class="headerlink" title="3. 在macos big sur的vscode上配置c/c++程序运行和调试工具"></a>3. 在macos big sur的vscode上配置c/c++程序运行和调试工具</h3><p><a href="https://blog.csdn.net/weixin_44881648/article/details/111046381">MacOS安装vs code并且配置C/C++环境2020最新版_mac 升级c++-CSDN博客</a><br>详细步骤如下：</p><ol><li>安装codellb</li><li>设置左边菜单栏：（只能通过放大来设置 ctrl+/-）<br>{<br> “editor.fontSize”: 15,<br> “window.zoomLevel”: 0.5,<br>}</li></ol><ol start="3"><li>coderunner的设置<br>settings.json里面设置<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-string">&quot;code-runner.executorMap&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;c&quot;</span>: <span class="hljs-string">&quot;cd <span class="hljs-subst">$dir</span> &amp;&amp; gcc <span class="hljs-subst">$fileName</span> -o <span class="hljs-subst">$fileNameWithoutExt</span> &amp;&amp; <span class="hljs-subst">$dir</span><span class="hljs-subst">$fileNameWithoutExt</span>&quot;</span>,<br>    <span class="hljs-string">&quot;cpp&quot;</span>: <span class="hljs-string">&quot;cd <span class="hljs-subst">$dir</span> &amp;&amp; g++ -std=c++11 -stdlib=libc++ <span class="hljs-subst">$fileName</span> -o <span class="hljs-subst">$fileNameWithoutExt</span> &amp;&amp; <span class="hljs-subst">$dir</span><span class="hljs-subst">$fileNameWithoutExt</span>&quot;</span><br>&#125;,<br></code></pre></td></tr></table></figure>默认设置（不设置这两句话）运行会报错<blockquote><p>./forward.cpp:185:42: error: a space is required between consecutive right angle brackets (use ‘&gt; &gt;’)</p></blockquote></li></ol><p>下面这个问题是由于运行的不是main函数的文件</p><blockquote><p>Undefined symbols for architecture x86_64:<br>  “_main”, referenced from:<br>     implicit entry/start for main executable<br>ld: symbol(s) not found for architecture x86_64<br>clang: error: linker command failed with exit code 1 (use -v to see invocation)</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-macos上下载brew&quot;&gt;&lt;a href=&quot;#1-macos上下载brew&quot; class=&quot;headerlink&quot; title=&quot;1. macos上下载brew:&quot;&gt;&lt;/a&gt;1. macos上下载brew:&lt;/h3&gt;&lt;p&gt;&lt;code&gt;/bin/zsh -c </summary>
      
    
    
    
    <category term="工具相关" scheme="http://shu0421.github.io/categories/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/"/>
    
    
  </entry>
  
  <entry>
    <title>Hard题目集合</title>
    <link href="http://shu0421.github.io/2022/04/10/leetcode/hard%E9%A2%98%E7%9B%AE%E5%90%88%E9%9B%86/"/>
    <id>http://shu0421.github.io/2022/04/10/leetcode/hard%E9%A2%98%E7%9B%AE%E5%90%88%E9%9B%86/</id>
    <published>2022-04-10T08:41:22.000Z</published>
    <updated>2023-11-29T02:21:21.322Z</updated>
    
    <content type="html"><![CDATA[<h3 id="lc6040-花园的最大总美丽值-枚举-二分"><a href="#lc6040-花园的最大总美丽值-枚举-二分" class="headerlink" title="lc6040. 花园的最大总美丽值 (枚举+二分)"></a>lc6040. 花园的最大总美丽值 (枚举+二分)</h3><ul><li>主要是在求partial的最小超时, 还有就是一个long long数据类型注意！！</li><li>法一: 从右到左，先枚举完善花园数目，再计算不完善花园数据可以获得的最大<br>解决方案：使用二分+前缀和来求增加后的最小值，而不是一个一个遍历(空间复杂度O(n))</li></ul><p>-法二: 如果是从左到右计算，可以将空间开销降到O(1)，先计算要让所有的花园变为完善花园还剩下的花的数量（可能为负数），然后遍历的时候一个一个加回去，同时不完善花园数目最小值是逐渐增大，所以可以在之前的结果上累加，不用重头计算</p><ul><li>同样类型的题目，+k使最小的数能够达到的最大值，lc6039. K 次增加后的最大乘积（这道题也可以最小堆+1，一个一个加）</li></ul><h3 id="lc6066-统计区间中的整数数目"><a href="#lc6066-统计区间中的整数数目" class="headerlink" title="lc6066. 统计区间中的整数数目"></a>lc6066. 统计区间中的整数数目</h3><ul><li>区间问题，主要是插入多个区间，如何合并得到最后的不重复的区间</li><li>使用hash start_end，那么每次判断的时候需要和前面一个和后面多个区间进行判断 upper_bound, 前面一个区间就是iter–</li><li>如果使用hash end_start(或者set&lt;pair&lt;end, start&gt;&gt;)那么只需要判断后面的多个可能覆盖的区间   lower_bound， iter++</li><li>每次合并区间，一定记得同时更新l_bound和r_bound</li><li>删除hash中的一个元素，并移动到下一个的正确姿势， hash.erase(iter++);</li><li>加速小技巧：为了不每次count都从头计算一次，可以使用插入的时候维护一个全局ans, 之后count的时候直接返回全局ans就可以了；这种利用先计算打表，后面直接使用的思想在前缀和，hulu面试的（组成平行四边形的个数）也可以体现出来<br>在进行i j两两组合的时候可以将，每组的组合方式求加和提前算出来，之后直接使用前缀和思想减掉0 到 i-1，就是当前i对应的组合方式</li></ul><h3 id="lc6077-巫师的总力量和"><a href="#lc6077-巫师的总力量和" class="headerlink" title="lc6077. 巫师的总力量和"></a>lc6077. 巫师的总力量和</h3><ul><li>子数组+区间问题</li><li>找到每个最小数的管辖区间（使用单调栈，同时为了避免出现数可能相等的情况使用了左边&gt;=, 右边&gt;的情况）</li><li>求管辖区间的每个子区间的sum, 使用前缀和的前缀和方法，也就是将右边放到一起，左边放到一起，将（a1-b1）+(a2-b2)+….+<br>= （a1+a2+…+an）-(b1+b2+….+bn) 其中a和b都是代表的前缀和</li><li>递推公式：</li></ul><img src="/2022/04/10/leetcode/hard%E9%A2%98%E7%9B%AE%E5%90%88%E9%9B%86/image-20220522153532000.png" alt="image-20220522153532000" style="zoom:50%;"><ul><li>补充类似的题目：<br>  lc907. 子数组的最小值之和<br>  lc1856. 子数组最小乘积的最大值<br>  lc2104. 子数组范围和<br>  都是使用单调栈求一个数作为最大值或者最小值的管辖范围（找到该数i左右两边第一个比这个数，或者大的数）然后包含数i的区间就有（r-i）*(i-l)个，其中r,l都是不包含在区间内，所以不需要+1</li></ul><h3 id="lc6094-公司命名"><a href="#lc6094-公司命名" class="headerlink" title="lc6094. 公司命名"></a>lc6094. 公司命名</h3><ul><li><p>题意，从字典中随便找两个单词，如果找到的单词交换首字母后，新单词都没在字典中出现过，那么res++, 问最后的res是多少</p></li><li><p>解决方案：先遍历一次字典每个单词，计算一个数组cnt[i][j], 表示将字典中单词首字母为 i+’a’ 转为j+’a’，且未在字典中出现的个数，那么结果就是再次遍历字典的每个单词, 将首字母换为26个字母中任意一个，如果该单词没在字典中出现过 则res+=cnt[j][i]</p></li><li><p>利用枚举+互补思想，如果一个单词转为另外一个首字母可行，那么就要判断以另外这个字母为首字母的单词，转为当前单词首字母 一共有多少种情况</p></li><li><p>优化点: 在vector O(n)里面查找的时间复杂度远远高于在set O(1)中，所以如果针对频繁在vec中查找的情况，可以将其转到set中查找</p></li></ul><h3 id="lc903-DI-序列的有效排列"><a href="#lc903-DI-序列的有效排列" class="headerlink" title="lc903. DI 序列的有效排列"></a>lc903. DI 序列的有效排列</h3><ul><li>这道题主要的难点在于使用映射，而不是vis数组来表示已经访问的数据</li><li>得到动态转移方程<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span>(s[i<span class="hljs-number">-1</span>]==<span class="hljs-string">&#x27;D&#x27;</span>)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=j;k&lt;i;k++)&#123; <span class="hljs-comment">//注意这是j to i-1 不是j+1到i, 因为i-1的时候是取不到 i的，因为有一个映射</span><br>        dp[i][j]+=dp[i<span class="hljs-number">-1</span>][k];<br>        dp[i][j]%=MOD;<br>    &#125;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;j;k++)&#123;<br>        dp[i][j]+=dp[i<span class="hljs-number">-1</span>][k];<br>        dp[i][j]%=MOD;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="lc730-统计不同回文子序列"><a href="#lc730-统计不同回文子序列" class="headerlink" title="lc730. 统计不同回文子序列"></a>lc730. 统计不同回文子序列</h3><ul><li><p>难点在于使用动态规划找不重复的</p></li><li><p>解决方案：分情况讨论 s[i]， s[j]是否相等 ， 当相等的时候，s[i], s[j]之间有几个和s[i]相同的字符</p><img src="/2022/04/10/leetcode/hard%E9%A2%98%E7%9B%AE%E5%90%88%E9%9B%86/image-20220625120018624.png" class title="image-20220625120018624"></li></ul><h3 id="lc6109-知道秘密的人数-显示为medium，但是我感觉类似hard难度"><a href="#lc6109-知道秘密的人数-显示为medium，但是我感觉类似hard难度" class="headerlink" title="lc6109. 知道秘密的人数(显示为medium，但是我感觉类似hard难度)"></a>lc6109. 知道秘密的人数(显示为medium，但是我感觉类似hard难度)</h3><ul><li>一个人知道密码吼，会在[i+delay, i+foraget-1]区间每个时间都告诉一个人， 问第n天知道密码的人</li><li>解决方法：第i天知道密码的人数=第i天新增人数+第i天还没有忘记秘密的人数(但是不是第i天新增的人数)<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>   <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i+delay;j&lt;=<span class="hljs-built_in">min</span>(i+forget<span class="hljs-number">-1</span>, n);j++)&#123;<br>        dp[j]= (dp[j]+dp[i])%MOD; <span class="hljs-comment">// dp[i]表示第i天新增知道的人数</span><br>    &#125; <br>    <span class="hljs-keyword">if</span>(i+forget<span class="hljs-number">-1</span>&gt;=n )&#123;<br>        cnt_a= (cnt_a+dp[i])%MOD; <span class="hljs-comment">//第n天还没有忘记秘密的人数(包括了第n天新增的人数+前面新增且第n天没有忘记)</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> cnt_a % MOD;<br></code></pre></td></tr></table></figure></li><li>类似前缀和的思想， 时间复杂度O(n^2),空间复杂度O(n)</li></ul><h3 id="lc6115-统计理想数组的数目"><a href="#lc6115-统计理想数组的数目" class="headerlink" title="lc6115. 统计理想数组的数目"></a>lc6115. 统计理想数组的数目</h3><ul><li><p>我的思路：求dp[i][j][len]的总数，也就是首是i， 尾是j，长度为len的方案的总数， 最后的答案就是 len==n的所有方案总和<br>但是因为O(n^3)所以超时,递推公式如下</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">dp[i][j][len%<span class="hljs-number">2</span>] = (dp[i][j][len%<span class="hljs-number">2</span>] + dp[i][j/k][(len<span class="hljs-number">-1</span>)%<span class="hljs-number">2</span>])%MOD; j/k需要j可以被k整除且j/k&gt;=i<br></code></pre></td></tr></table></figure></li><li><p>官方解答：排列组合题目</p><ol><li>先求到以i结尾的长度为j的个数 dp[i][j]+=dp[k][j-1] k能够被i整除</li><li>再求将长度为n包含互不相同的j个数，一共有多少种方案<br>固定第一个数的方案总数：Cn-1 j-1</li><li>总结就是，找序列不同个数， 找序列不同数的排布</li></ol></li><li><p>关键点，在于找不同数</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;lc6040-花园的最大总美丽值-枚举-二分&quot;&gt;&lt;a href=&quot;#lc6040-花园的最大总美丽值-枚举-二分&quot; class=&quot;headerlink&quot; title=&quot;lc6040. 花园的最大总美丽值 (枚举+二分)&quot;&gt;&lt;/a&gt;lc6040. 花园的最大总美丽值</summary>
      
    
    
    
    <category term="leetcode" scheme="http://shu0421.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>多线程</title>
    <link href="http://shu0421.github.io/2022/01/26/leetcode/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"/>
    <id>http://shu0421.github.io/2022/01/26/leetcode/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/</id>
    <published>2022-01-26T04:19:28.000Z</published>
    <updated>2023-11-29T02:21:21.322Z</updated>
    
    <content type="html"><![CDATA[<h2 id="semaphore-信号量"><a href="#semaphore-信号量" class="headerlink" title="semaphore 信号量"></a>semaphore 信号量</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">#<span class="hljs-keyword">include</span> &lt;semaphore.h&gt;<br>sem_t sem1;<span class="hljs-comment">//进行变量申明</span><br><br>sem<span class="hljs-constructor">_init(&amp;<span class="hljs-params">sem1</span>, 1, 0)</span>; <br>第一个参数：指向的信号对象<br>第二个参数：控制信号量的类型，如果其值为<span class="hljs-number">0</span>，就表示信号量是当前进程的局部信号量，否则信号量就可以在多个进程间共享<br>第三个参数：信号量sem的初始值<br><br>sem<span class="hljs-constructor">_post(&amp;<span class="hljs-params">sem1</span>)</span> 信号量值加<span class="hljs-number">1</span><br><br>sem<span class="hljs-constructor">_wait(&amp;<span class="hljs-params">sem1</span>)</span> 信号量值减<span class="hljs-number">1</span><br><br>sem<span class="hljs-constructor">_destroy(&amp;<span class="hljs-params">sem1</span>)</span> 信号量销毁<br></code></pre></td></tr></table></figure><h2 id="互斥锁和条件变量（可以实现一个进程打印5次，另外一个进程打印1次的场景）"><a href="#互斥锁和条件变量（可以实现一个进程打印5次，另外一个进程打印1次的场景）" class="headerlink" title="互斥锁和条件变量（可以实现一个进程打印5次，另外一个进程打印1次的场景）"></a>互斥锁和条件变量（可以实现一个进程打印5次，另外一个进程打印1次的场景）</h2><p>C++： condition_variable C: pthread_cond_t<br>条件变量的一个例子，讲得很详细：<a href="https://blog.csdn.net/jinking01/article/details/110362483">C++中的条件变量_c++条件变量-CSDN博客</a></p><p>讲述conditon_variable的一个例子：<a href="https://segmentfault.com/a/1190000006679917">https://segmentfault.com/a/1190000006679917</a> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++">伪代码<br>condition_variable cond;<br>mutex p_lock;<br><span class="hljs-keyword">int</span> count=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">process1</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *args)</span></span>&#123;<br>  <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>    p_lock.<span class="hljs-built_in">lock</span>();<br>    count++;<br>    <span class="hljs-keyword">if</span>(count%<span class="hljs-number">5</span>==<span class="hljs-number">0</span>)&#123;<br>      cond.<span class="hljs-built_in">cond_signal</span>(&amp;cond);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>      <span class="hljs-built_in">printFunction</span>(<span class="hljs-string">&quot;this is process 1&quot;</span>);<br>    &#125;<br>    p_lock.<span class="hljs-built_in">unlock</span>();<br><br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">process2</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *args)</span></span>&#123;<br>  <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        p_lock.<span class="hljs-built_in">lock</span>();<br>        <span class="hljs-built_in">cond_wait</span>(&amp;cond);<span class="hljs-comment">//锁内部</span><br>        <span class="hljs-built_in">printFunction</span>(<span class="hljs-string">&quot;this is process 2&quot;</span>);<br>        p_lock.<span class="hljs-built_in">unlock</span>();t<br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>生产者-消费者问题<br>读者-写者问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">sem_t</span> full;<br><span class="hljs-keyword">sem_t</span> empty;<br><span class="hljs-keyword">sem_t</span> mutex;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Producer</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>      <span class="hljs-built_in">down</span>(&amp;empty);<br>      <span class="hljs-built_in">down</span>(&amp;mutex);<br>      <span class="hljs-built_in">produce_item</span>();<br>      <span class="hljs-built_in">up</span>(&amp;mutex);<br>      <span class="hljs-built_in">up</span>(&amp;full);<br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Consumer</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>      <span class="hljs-built_in">down</span>(&amp;full);<br>      <span class="hljs-built_in">down</span>(&amp;mutex);<br>      <span class="hljs-built_in">produce_item</span>();<br>      <span class="hljs-built_in">up</span>(&amp;mutex);<br>      <span class="hljs-built_in">up</span>(&amp;empty);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>读者-写者问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">sem_t</span> data_mutex;<br><span class="hljs-keyword">sem_t</span> count_mutex;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Reader</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>      <span class="hljs-built_in">down</span>(&amp;count_mutex);<br>      count++;<br>      <span class="hljs-keyword">if</span>(count==<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-built_in">down</span>(&amp;data_mutex);<br>      &#125;<br>      <span class="hljs-built_in">up</span>(&amp;count_mutex);<br><br>      <span class="hljs-built_in">read</span>();<span class="hljs-comment">//没有单独加数据锁</span><br><br>      <span class="hljs-built_in">down</span>(&amp;count_mutex);<br>      count--;<br>      <span class="hljs-keyword">if</span>(count==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">up</span>(&amp;data_mutex);<br>      &#125;<br>      <span class="hljs-built_in">up</span>(&amp;count_mutex);<br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">riter</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>      <span class="hljs-built_in">down</span>(&amp;data_mutex);<br>      <span class="hljs-built_in">produce_item</span>();<br>      <span class="hljs-built_in">up</span>(&amp;data_mutex);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>1.<br>引入条件变量一个就是为了避免为了查看条件是否成立而不断轮询的情况<br>总结：互斥锁实现的是线程之间的互斥，条件变量实现的是线程之间的同步。<br>初始化条件变量<br>pthread_cond_t cond = PTHREAD_COND_INITIALIZER;</p><p>该函数用来在一个ConditionVariable上阻塞等待，做以下三步操作：①释放Mutex；②阻塞等待；③当被唤醒时，重新获得Mutex并返回。<br>int pthread_cond_wait(pthread_cond_t &amp;cond_name, pthread_mutex_t &amp;mutex_name);</p><p>唤醒等待线程<br>pthread_cond_signal()：用于唤醒在该条件变量下等待的一个线程，至于哪个被唤醒，取决于线程的优先级和调度策略。<br>pthread_cond_broadcast()：用于唤醒在某个ConditionVariable 上等待的所有线程。使用这种方法时，瞬间唤醒的线程数过多，资源请求过大，容易导致系统不稳定。<br>int pthread_cond_signal(pthread_cond_t &amp;cond_name);<br>int pthread_cond_broadcast(pthread_cond_t &amp;cond_name);</p><ol start="2"><li>和信号量的区别：<br>条件变量的提出是为了解决互斥锁中的循环等待问题，其希望引入一种挂起、唤醒的机制来实现cpu的高效利用<br>（1）使用条件变量可以一次唤醒所有等待者，而这个信号量没有的功能，感觉是最大区别。<br>（2）信号量是有一个值（状态的），而条件变量是没有的，没有地方记录唤醒（发送信号）过多少次，也没有地方记录唤醒线程（wait返回）过多少次。</li></ol><ol start="3"><li>注意！！！！<br>条件变量被通知后，挂起的线程就被唤醒，但是唤醒也有可能是假唤醒，或者是因为超时等异常情况，所以被唤醒的线程仍要检查条件是否满足，所以 wait 是放在条件循环里面。cv.wait(lock, [] { return ready; }); 相当于：while (!ready) { cv.wait(lock); }。</li></ol><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><ol><li>为了实现两个函数的交替打印，可以使用信号量，也可以使用交替锁</li><li>交替打印 FooBar</li></ol><p>solution 1:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++">func1:<br><span class="hljs-built_in">sem_wait</span>(&amp;sem_foo);<br><span class="hljs-built_in">printFoo</span>();<br><span class="hljs-built_in">sem_post</span>(&amp;sem_bar);<br><br><span class="hljs-function">func2</span><br><span class="hljs-function"><span class="hljs-title">sem_wait</span><span class="hljs-params">(&amp;sem_bar)</span></span>;<br><span class="hljs-built_in">printBar</span>();<br><span class="hljs-built_in">sem_post</span>(&amp;sem_foo);<br></code></pre></td></tr></table></figure><p>solution 2 互斥锁（不建议用这种解法，在不同线程加锁解锁确实会出问题）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++">func1:<br>mutex lock1, lock2; <span class="hljs-comment">//这里锁类似条件变量</span><br><br>lock1.<span class="hljs-built_in">lock</span>();<br><span class="hljs-built_in">printFoo</span>();<br>lock2.<span class="hljs-built_in">unlock</span>();<br><br>func2<br>lock2.<span class="hljs-built_in">lock</span>();<br><span class="hljs-built_in">printBar</span>();<br>lock1.<span class="hljs-built_in">unlock</span>();<br></code></pre></td></tr></table></figure><ol start="2"><li>实现一个线程安全的队列<br>在多个线程进行push的时候需要加锁，在push的时候通知pop的线程可以pop<br>使用trypop，如果加锁，判断队列为空，那么直接返回，否则调用pop //不用try pop那么可能出现阻塞<br>pop函数使用使用条件锁 m_cond, 在pop的时候也需要加锁 //在多进程需要使用条件变量，虽然判断了是否为empty再进入的pop，因为可能时间片被其他线程占用导致当前没有元素pop<br>empty(), 加锁判断队列里面是否有元素</li></ol><p>使用条件变量判断队列里面是否有元素，才能pop</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>生成者-消费者需要两个信号量用于同步，一个用于给数据加锁<br>条件变量主要是用于达到了某个条件通知另外的进程可以做某件事（5对1，或者队列pop push）<br>读者-写者，写者加数据锁（信号量），读者只需要加count锁，因为多个读者可以同时读<br>队列这种，pop先判断是否为空，为空直接返回；不为空还需要等待条件变量，放置pop的时候被其他pop抢占，或者多个同时判断不为空，但是只有一个元素情况</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;semaphore-信号量&quot;&gt;&lt;a href=&quot;#semaphore-信号量&quot; class=&quot;headerlink&quot; title=&quot;semaphore 信号量&quot;&gt;&lt;/a&gt;semaphore 信号量&lt;/h2&gt;&lt;figure class=&quot;highlight reas</summary>
      
    
    
    
    <category term="leetcode" scheme="http://shu0421.github.io/categories/leetcode/"/>
    
    
    <category term="多线程并发， 信号量， 互斥锁" scheme="http://shu0421.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%EF%BC%8C-%E4%BF%A1%E5%8F%B7%E9%87%8F%EF%BC%8C-%E4%BA%92%E6%96%A5%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>分布式训练</title>
    <link href="http://shu0421.github.io/2022/01/26/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%AD%E7%BB%83/"/>
    <id>http://shu0421.github.io/2022/01/26/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%AD%E7%BB%83/</id>
    <published>2022-01-26T02:50:50.000Z</published>
    <updated>2023-11-29T02:21:21.320Z</updated>
    
    <content type="html"><![CDATA[<h2 id="资料："><a href="#资料：" class="headerlink" title="资料："></a>资料：</h2><p>一个pytorch 分布式 单机多卡/多机多卡的例子<br><a href="https://github.com/lesliejackson/PyTorch-Distributed-Training">GitHub - lesliejackson/PyTorch-Distributed-Training: Example of PyTorch DistributedDataParallel</a></p><p>常见分布式训练讲解，但是主要命令是启动单机多卡，而不是多机多卡 包括slum, apex, horovod<br><a href="https://github.com/tczhangzhi/pytorch-distributed">GitHub - tczhangzhi/pytorch-distributed: A quickstart and benchmark for pytorch distributed training.</a> </p><p>pytorch DDP介绍<br><a href="https://zhuanlan.zhihu.com/p/76638962">Pytorch 分布式训练 - 知乎</a></p><p><a href="https://github.com/richardkxu/distributed-pytorch">GitHub - richardkxu/distributed-pytorch: Distributed, mixed-precision training with PyTorch</a> （也有多机多卡的命令）</p><p>可能会用到：<br>两个机器之间相互免密登录：<a href="https://blog.csdn.net/u010391029/article/details/51126210">多台Linux服务器SSH相互访问无需密码-CSDN博客</a></p><p>DDP time breakdown<br><a href="https://discuss.pytorch.org/t/how-to-measure-ddp-time-breakdown/78925">How to measure DDP time breakdown? - distributed - PyTorch Forums</a><br><a href="https://discuss.pytorch.org/t/how-to-measure-ddp-time-breakdown/78925">How to measure DDP time breakdown? - distributed - PyTorch Forums</a><br><a href="https://discuss.pytorch.org/t/calculating-flops-of-a-given-pytorch-model/3711/4">Calculating flops of a given pytorch model - #4 by warmspringwinds - PyTorch Forums</a> FLOPS计算</p><p>多进程logging和mkdir设置，分布式inferenc/ 分布式训练的一些小技巧</p><p><a href="https://zhuanlan.zhihu.com/p/250471767">[原创][深度][PyTorch] DDP系列第三篇：实战与技巧 - 知乎</a> </p><blockquote><p>包括的内容1. 在DDP中引入SyncBN<br>2. DDP下的Gradient Accumulation的进一步加速<br>3. 多机多卡环境下的inference加速<br>4. 保证DDP性能：确保数据的一致性<br>5. 和DDP有关的小技巧<br>6. 1. 控制不同进程的执行顺序<br>   2. 避免DDP带来的冗余输出</p></blockquote><p>Ray分布式执行框架  PyTorch + Ray Tune 调参<br><a href="https://blog.csdn.net/tszupup/article/details/112059788">PyTorch + Ray Tune 调参_pytorch ray tune_烟雨风渡的博客-CSDN博客</a></p><p>分布式相关论文源码<br><a href="https://github.com/msr-fiddle/pipedream">GitHub - msr-fiddle/pipedream</a>  pipedream源码 mini-bath parallism<br><a href="https://github.com/kakaobrain/torchgpipe">GitHub - kakaobrain/torchgpipe: A GPipe implementation in PyTorch</a></p><p>pytorch分布式训练的时候保存一定要用model.module<br><a href="https://blog.csdn.net/comway_Li/article/details/107531165">pytorch 分布式多卡训练DistributedDataParallel 踩坑记_加载多卡训练的预训练模型default process group has not been ini-CSDN博客</a> 一些需要注意的地方</p><p>horovod多机多卡<br><a href="http://chaopeng.name/2020/01/03/horovod%E5%A4%9A%E6%9C%BA%E5%A4%9A%E5%8D%A1%E5%90%AF%E5%8A%A8%E6%8C%87%E5%8D%97/">horovod多机多卡启动指南 | 技术自留地</a></p><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ol><li>DP和DDP区别<br>DP是单进程多线程数据并行，将模型copy到每个设备，scatter数据到每个设备进行计算后，将多个GPU输出传到master device(一般为设备0)进行损失计算，（可以优化一下：将loss作为forward 一部分，这样的话每个GPU上自行计算loss，而不用进行模型输出的传输）将损失结果（分发的是各个GPU分别对应的loss）传给每个设备进行反向传播，每个设备将反向传播后的梯度到主设备进行汇聚求平均，然后replicate一份模型的参数到每个设备中，重复上诉的训练过程。</li></ol><ol start="2"><li><p>DDP中all reduce与PS<br> DDP （all reduce）同步的是梯度，不是参数<br> PS，传给master的是梯度，返回的是参数</p><p> 思考：对不重要的梯度进行累积后同步/直接不同步（会不会造成模型的不一致）</p></li><li><p>同步代码<br>分布式训练源代码解读：<a href="https://zhuanlan.zhihu.com/p/343951042">PyTorch 源码解读之 DP &amp; DDP：模型并行和分布式训练解析 - 知乎</a></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">手动同步梯度<br><span class="hljs-keyword">for</span> param <span class="hljs-keyword">in</span> ddp_model.parameters<span class="hljs-literal">()</span>: <br>dist.all<span class="hljs-constructor">_reduce(<span class="hljs-params">param</span>.<span class="hljs-params">grad</span>.<span class="hljs-params">data</span>, <span class="hljs-params">op</span>=<span class="hljs-params">dist</span>.<span class="hljs-params">reduce_op</span>.SUM)</span><br>    param.grad.data /= world_size <br><br>手动同步参数：<br>在不重要的样本反向传播后但是不同步参数后，同步梯度<br><span class="hljs-keyword">for</span> param <span class="hljs-keyword">in</span> ddp_model.parameters<span class="hljs-literal">()</span>: <br>dist.all<span class="hljs-constructor">_reduce(<span class="hljs-params">param</span>.<span class="hljs-params">data</span>, <span class="hljs-params">op</span>=<span class="hljs-params">dist</span>.<span class="hljs-params">reduce_op</span>.SUM)</span><br>    param.data /= world_size <br></code></pre></td></tr></table></figure></li></ol><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="solution-1-atom版本"><a href="#solution-1-atom版本" class="headerlink" title="solution 1 - atom版本"></a>solution 1 - atom版本</h3><p>裸机 多节点 atom平台</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /workspace/mnt/storage/anchao/ac_file/traffic_iteration/SupreVision &amp;&amp; \<br>./install.sh &amp;&amp; \<br>python -m torch.distributed.launch \<br>        --nnode=4 \<br>        --node_rank=0 \<br>        --nproc_per_node=8 \<br>        --master_addr=<span class="hljs-string">&quot;10.244.55.30&quot;</span> \<br>        --master_port=23467 \<br>        tools/train.py \<br>        --config_file configs/YOLOv3/opencv_pelee_reorg.yml \<br>        SOLVER.IMS_PER_BATCH <span class="hljs-string">&quot;16&quot;</span> \<br>        MODEL.DEVICE_ID <span class="hljs-string">&quot;(&#x27;0,1,2,3,4,5,6,7&#x27;)&quot;</span> \<br>        &gt; detection0.log 2&gt;&amp;1<br></code></pre></td></tr></table></figure><p>单机多卡</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /workspace/mnt/storage/anchao/ac_file/traffic_iteration/SupreVision &amp;&amp; \<br>./install.sh &amp;&amp; \<br>CUDA_VISIBLE_DEVICES=3,4,5,6 python -m torch.distributed.launch \<br>                --nproc_per_node=2 \<br>                --master_port=$((RANDOM + <span class="hljs-number">20000</span>)) \<br>                ./imagenet_final_train_master.py \<br>                --config_file configs/YOLOv3/opencv_pelee_reorg.yml \<br>                &gt; detection0.log 2&gt;&amp;1<br></code></pre></td></tr></table></figure><h3 id="solution-2-简洁版"><a href="#solution-2-简洁版" class="headerlink" title="solution 2 - 简洁版"></a>solution 2 - 简洁版</h3><p>多机多卡<br>suppose we have two machines and one machine have 4 gpus<br>In multi machine multi gpu situation, you have to choose a machine to be master node.<br>we named the machines A and B, and set A to be master node</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">script run at A<br><br>python -m torch.distributed.launch --nproc_per_node=4 --nnode=2 --node_rank=0 --master_addr=A_ip_address master_port=29500 main.py ... <br><br>script run at B<br><br>python -m torch.distributed.launch --nproc_per_node=4 --nnode=2 --node_rank=1 --master_addr=A_ip_address master_port=29500 main.py ... <br></code></pre></td></tr></table></figure><p>单机多卡</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python -m torch.distributed.launch --nproc_per_node=ngpus --master_port=29500 main.py ... <br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;资料：&quot;&gt;&lt;a href=&quot;#资料：&quot; class=&quot;headerlink&quot; title=&quot;资料：&quot;&gt;&lt;/a&gt;资料：&lt;/h2&gt;&lt;p&gt;一个pytorch 分布式 单机多卡/多机多卡的例子&lt;br&gt;&lt;a href=&quot;https://github.com/leslieja</summary>
      
    
    
    
    <category term="工具相关" scheme="http://shu0421.github.io/categories/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="分布式" scheme="http://shu0421.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>md语法相关</title>
    <link href="http://shu0421.github.io/2022/01/20/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/md%E8%AF%AD%E6%B3%95%E7%9B%B8%E5%85%B3/"/>
    <id>http://shu0421.github.io/2022/01/20/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/md%E8%AF%AD%E6%B3%95%E7%9B%B8%E5%85%B3/</id>
    <published>2022-01-20T04:11:13.000Z</published>
    <updated>2023-11-29T02:21:21.320Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-对代码块进行折叠"><a href="#1-对代码块进行折叠" class="headerlink" title="1. 对代码块进行折叠"></a>1. 对代码块进行折叠</h3><p>代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">details</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">summary</span>&gt;</span>点击时的区域标题<span class="hljs-tag">&lt;/<span class="hljs-name">summary</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span><br><br>内容<br><br><span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">details</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果：</p><details>  <summary>点击时的区域标题</summary><pre><p>内容</p></pre></details>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-对代码块进行折叠&quot;&gt;&lt;a href=&quot;#1-对代码块进行折叠&quot; class=&quot;headerlink&quot; title=&quot;1. 对代码块进行折叠&quot;&gt;&lt;/a&gt;1. 对代码块进行折叠&lt;/h3&gt;&lt;p&gt;代码：&lt;/p&gt;
&lt;figure class=&quot;highlight xml</summary>
      
    
    
    
    <category term="工具相关" scheme="http://shu0421.github.io/categories/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="md语法" scheme="http://shu0421.github.io/tags/md%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>系统设计相关题目</title>
    <link href="http://shu0421.github.io/2022/01/19/leetcode/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    <id>http://shu0421.github.io/2022/01/19/leetcode/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</id>
    <published>2022-01-19T06:09:24.000Z</published>
    <updated>2023-11-29T02:21:21.630Z</updated>
    
    <content type="html"><![CDATA[<h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p><a href="https://github.com/donnemartin/system-design-primer">GitHub - donnemartin/system-design-primer: Learn how to design large-scale systems. Prep for the system design interview.  Includes Anki flashcards.</a></p><h2 id="题型"><a href="#题型" class="headerlink" title="题型"></a>题型</h2><h3 id="1-标准布隆过滤器hash函数的设置"><a href="#1-标准布隆过滤器hash函数的设置" class="headerlink" title="1.标准布隆过滤器hash函数的设置"></a>1.标准布隆过滤器hash函数的设置</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashFunction</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> cap, seed;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">HashFunction</span>(<span class="hljs-keyword">int</span> cap, <span class="hljs-keyword">int</span> seed) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;cap = cap;<br>        <span class="hljs-keyword">this</span>-&gt;seed = seed;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(string&amp; value)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> n = value.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            ret += seed * ret + value[i];<br>            ret %= cap;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StandardBloomFilter</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> k;<br>    vector&lt;HashFunction*&gt; hashFunc;<br>    bitset&lt;200000&gt; bits;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">StandardBloomFilter</span>(<span class="hljs-keyword">int</span> k) &#123;<br>        <span class="hljs-comment">// initialize your data structure here</span><br>        <span class="hljs-keyword">this</span>-&gt;k = k;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i)<br>            hashFunc.<span class="hljs-built_in">push_back</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">HashFunction</span>(<span class="hljs-number">100000</span> + i, <span class="hljs-number">2</span> * i + <span class="hljs-number">3</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>每个字符串通过这个hash函数可以得到一个值（position），然后将bit[200000]中该位置为1，多个函数，那么就会有多个位置为1;判断某一个字符串是否存在，就是判断多个函数计算出来值是否都在bit中位1，如果有一个不为1，说明该字符串不在</p><h3 id="2-序列化Trie树-Lintcode"><a href="#2-序列化Trie树-Lintcode" class="headerlink" title="2. 序列化Trie树(Lintcode)"></a>2. 序列化Trie树(Lintcode)</h3><p> 这个模板一定要记住，不要用自己的方法，用模板<br> 同类型题目：二叉树的序列化和反序列化， n叉数的序列化和反序列化<br>注意这道题</p><ul><li>在进行序列化：使用dfs, 在遍历完所有的chidren后，加上‘/‘表示退出当前循环</li><li>在进行反序列化时： 使用全局index, index在进入下一层循环和退出循环(注意这里和二叉树不同，有两处)之前都需要+1， 其余情况index保持不变</li><li>注意:<br>(1)在退出训练时候不是返回null, 而是返回一个Trie对象的指针！！！<br>(2)因为一个节点有多个节点，而不是只有二叉树的left和right节点，因此需要使用while判断，如果data[index]==’/‘的时候退出while循环<br>(3)<figure class="highlight c++"><figcaption><span>right</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">TrieNode* tmp=<span class="hljs-keyword">new</span> <span class="hljs-built_in">TrieNode</span>(); <span class="hljs-comment">//注意区分类和结构体</span><br>map&lt;<span class="hljs-keyword">char</span>, TrieNode*&gt; &amp;childs=tmp-&gt;children;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><figcaption><span>wrong</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">TrieNode* tmp; <span class="hljs-comment">//注意区分类和类指针，这里直接申明一个空指针是不对的, 即使是结构体也应该是student s;</span><br>map&lt;<span class="hljs-keyword">char</span>, TrieNode*&gt; childs;<br>tmp-&gt;children=childs;<br></code></pre></td></tr></table></figure></li></ul><p>官方题解使用的<data> 进行序列化+栈的方式进行反序列化：&lt;将当前current入栈 &gt;将栈顶出栈 其余：新建一个Trie对象(current)，将当前data[index]指向这个对象</data></p><p>下面模板代码可以用作n叉树的遍历或者trie树遍历，下面的这种方式会将空字符串用&lt;&gt;，如果想要空字符串没有，可以使用dfs2</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition of TrieNode:</span><br><span class="hljs-comment"> * class TrieNode &#123;</span><br><span class="hljs-comment"> * public:</span><br><span class="hljs-comment"> *     TrieNode() &#123;&#125;</span><br><span class="hljs-comment"> *     map&lt;char, TrieNode*&gt; children;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-comment">//适用于n叉数的遍历， 但是这种方式在进行反序列化的时候，每次从栈中弹出一个元素前，需要将栈顶赋值给cur</span><br> <span class="hljs-comment">//&lt;1&lt;3&lt;5&gt;&lt;6&gt;&gt;&lt;2&gt;&lt;4&gt;&gt; null节点无&lt;&gt;</span><br><span class="hljs-comment">//  lc428 每个节点都被&lt;&gt;分开，即使是同一层</span><br><span class="hljs-function">string <span class="hljs-title">dfs</span><span class="hljs-params">(Node* root)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br>    string data;<br>    <span class="hljs-keyword">int</span> size=root-&gt;children.<span class="hljs-built_in">size</span>();<br>    data+=<span class="hljs-built_in">to_string</span>(root-&gt;val);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>        data+=<span class="hljs-built_in">dfs</span>(root-&gt;children[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;&quot;</span>+data+<span class="hljs-string">&quot;&gt;&quot;</span>;<br>&#125;<br><br><span class="hljs-comment">//&lt;a&lt;b&lt;e&lt;&gt;&gt;c&lt;&gt;d&lt;f&lt;&gt;&gt;&gt;&gt; 节点之间可能没有&lt;&gt;分开</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * This method will be invoked first, you should design your own algorithm </span><br><span class="hljs-comment">     * to serialize a trie which denote by a root node to a string which</span><br><span class="hljs-comment">     * can be easily deserialized by your own &quot;deserialize&quot; method later.</span><br><span class="hljs-comment">     */</span><br>     <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(TrieNode* root)</span></span>&#123;<br>        <span class="hljs-function">string <span class="hljs-title">dfs</span><span class="hljs-params">(Node* root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        string data;<br>        <span class="hljs-keyword">int</span> size=root-&gt;children.<span class="hljs-built_in">size</span>();<br>        data+=<span class="hljs-built_in">to_string</span>(root-&gt;val);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>            data+=<span class="hljs-built_in">dfs</span>(root-&gt;children[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;&quot;</span>+data+<span class="hljs-string">&quot;&gt;&quot;</span>;<br>    &#125;<br>    <br>    <span class="hljs-function">string <span class="hljs-title">serialize</span><span class="hljs-params">(TrieNode* root)</span> </span>&#123;<br>        <span class="hljs-comment">// Write your code here</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        string data;<br>        <span class="hljs-keyword">for</span> (map&lt;<span class="hljs-keyword">char</span>, TrieNode*&gt;::iterator it = root-&gt;children.<span class="hljs-built_in">begin</span>();<br>             it != root-&gt;children.<span class="hljs-built_in">end</span>(); ++it) &#123;<br>            data += it-&gt;first;<br>            data += <span class="hljs-built_in">serialize</span>(it-&gt;second);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;&quot;</span> + data + <span class="hljs-string">&quot;&gt;&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * This method will be invoked second, the argument data is what exactly</span><br><span class="hljs-comment">     * you serialized at method &quot;serialize&quot;, that means the data is not given by</span><br><span class="hljs-comment">     * system, it&#x27;s given by your own serialize method. So the format of data is</span><br><span class="hljs-comment">     * designed by yourself, and deserialize it here as you serialize it in </span><br><span class="hljs-comment">     * &quot;serialize&quot; method.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">TrieNode* <span class="hljs-title">deserialize</span><span class="hljs-params">(string data)</span> </span>&#123;<br>        <span class="hljs-comment">// Write your code here</span><br>        <span class="hljs-keyword">if</span> (data.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>        TrieNode* head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TrieNode</span>();<br>        TrieNode* current = head;<br>        stack&lt;TrieNode*&gt; path;<br>        <span class="hljs-keyword">int</span> len = data.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;<br>            <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (data[i]) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>:<br>                    path.<span class="hljs-built_in">push</span>(current);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>:<br>                    <span class="hljs-comment">//如果是null节点无&lt;&gt;情况，那么需要在这里赋值cur=path.top()</span><br>                    path.<span class="hljs-built_in">pop</span>();<br>                    <br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">default</span>:<br>                    current = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TrieNode</span>();<br>                    path.<span class="hljs-built_in">top</span>()-&gt;children[data[i]] = current;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="3-Trie树构建"><a href="#3-Trie树构建" class="headerlink" title="3. Trie树构建"></a>3. Trie树构建</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">class <span class="hljs-title">Trie</span><span class="hljs-params">()</span></span>&#123;<br>    vector&lt;Trie*&gt; children;<br>    <span class="hljs-keyword">bool</span> isEnd;<br>    <span class="hljs-built_in">Trie</span>()&#123;<br>        <span class="hljs-keyword">this</span>-&gt;child = vector&lt;Trie*&gt;(<span class="hljs-number">26</span>,<span class="hljs-literal">nullptr</span>); <span class="hljs-comment">//一定要记得初始化26个节点，而且都为null</span><br>        <span class="hljs-keyword">this</span>-&gt;isEnd = <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-built_in">search</span>(string s)&#123;<br>        Trie* root=<span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(root-&gt;children[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>]==<span class="hljs-literal">NULL</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            root= root-&gt;children[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> root-&gt;isEnd;<br>    &#125;<br>    <span class="hljs-built_in">insert</span>(string s)&#123;<br>        Trie* root=<span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(root-&gt;children[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>]==<span class="hljs-literal">NULL</span>)&#123;<br>                root-&gt;children[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>]=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Trie</span>();<br>            &#125;<br>            root= root-&gt;children[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        root-&gt;isEnd=<span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>二叉树的序列化和反序列可以使用前序遍历实现</p><h3 id="4-lc355-设计推特"><a href="#4-lc355-设计推特" class="headerlink" title="4. lc355. 设计推特"></a>4. lc355. 设计推特</h3><ul><li>需要实现4个功能: 关注， 取消关注， 发表博客， 列出userid和userid最近发表的10条博客</li><li>实现关注和取消关注使用unordered_map&lt;int, unordered_set<int>&gt; hash</int></li><li>发表博客使用unordered_map&lt;int, node*&gt; , 其中node记录<br>node{<br>  tuiteid, //充当时间戳<br>  userid, //发表用户<br>  node* next; //指向下一个node, 类似于LRU，方便使用头插入方法<br>}</li><li> 列出userid和userid最近发表的10条博客， 使用K个链表的合并，找出前M个数</li><li>为什么使用链表，这样的话扩展非常方便，如果不使用，那么在删除博客的时候就比较麻烦</li></ul><h3 id="5-单词自动补全系统"><a href="#5-单词自动补全系统" class="headerlink" title="5. 单词自动补全系统"></a>5. 单词自动补全系统</h3><ul><li>题意：1. 初始化系统，包括一些句子和句子最初始的频率，一个句子之间可能小写字符或者空格 2. 每次input一个字符应该接着上一个字符，同时输出‘#’表示输出的末尾，这时候需要初始化data=””, cur=root（全局变量）, 更新句子的频率</li><li>解决方案：</li><li><ol><li>使用前缀树+hash(存储句子+频率) 前缀树的每个节点，应该存储一个vector<string> 表示走到这个节点的下面所有字符</string></li></ol></li><li><ol start="2"><li>注意字符串在进行查找如果cur==null, 那么直接返回空，否则一直在cur的基础上走一步 cur=cur-&gt;children[c]//unordered_map&lt;char, TrieNode*&gt; children;</li></ol></li><li><ol start="3"><li>如果走到‘#’，表示走到了末尾，这时候需要初始化data=””, cur=root, 同时更新句子的频率 +1（句子频率会更新）</li></ol></li><li>参考答案: <a href="https://aaronice.gitbook.io/lintcode/data_structure/design-search-autocomplete-system">Design Search Autocomplete System - LintCode &amp; LeetCode</a><br><a href="https://zhuanlan.zhihu.com/p/99499171">642. Design Search Autocomplete System - 知乎</a> (有点问题，不应该在每个节点里面记录节点的频率，因为这个随时更新，之后就不准确，应该用一个单独的hashmap来记录)</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>一般是有关于系统， 多个函数的整体设计题目<br>比如：GeoHash, GFS, 布隆过滤器， 心跳设计， 缓存系统， LRU cache设计，二叉树的序列化和反序列化等<br>还有新定义一种数据结构，嵌套返回list leetcode-扁平化嵌套列表迭代器 使用递归方式分解</p></li><li><p>为了在vector里面删除元素更快，可以再配合使用一个dict (map)映射特定值对应的index。注意在进行删除元素的时候，除了交换vector中最后一个元素和当前元素，还需要修改hash最后一个元素映射的下标为当前index+从hash中删除key</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;资源&quot;&gt;&lt;a href=&quot;#资源&quot; class=&quot;headerlink&quot; title=&quot;资源&quot;&gt;&lt;/a&gt;资源&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/donnemartin/system-design-primer&quot;&gt;GitHub -</summary>
      
    
    
    
    <category term="leetcode" scheme="http://shu0421.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Zplot画图</title>
    <link href="http://shu0421.github.io/2022/01/04/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/zplot/"/>
    <id>http://shu0421.github.io/2022/01/04/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/zplot/</id>
    <published>2022-01-04T08:04:52.000Z</published>
    <updated>2023-11-29T02:21:21.319Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">Zplot-<span class="hljs-built_in">folder</span><br>|<span class="hljs-comment">--breakdown</span><br>    |<span class="hljs-comment">--Makefile</span><br>    |<span class="hljs-comment">--breakdown1.py</span><br>    |<span class="hljs-comment">--breakdown1.data</span><br>    |<span class="hljs-comment">--breakdown2.py</span><br>    |<span class="hljs-comment">--breakdown2.data</span><br>|<span class="hljs-comment">--eval_lineplot</span><br>    |<span class="hljs-comment">--Makefile</span><br>|<span class="hljs-comment">--...</span><br>|<span class="hljs-comment">--makefig.sh</span><br></code></pre></td></tr></table></figure><h2 id="使用注意事项"><a href="#使用注意事项" class="headerlink" title="使用注意事项"></a>使用注意事项</h2><ol><li><p>每次运行的时候只需要运行makefig文件就可以了，如果要修改所有生成的pdf在的目录，直接修改makefig.sh</p></li><li><p> Makefile里面的文件主要是运行当前py文件生成eps文件，然后使用ps2pdf转为pdf并使用pdf2crop对生成的pdf文件进行裁剪<br>PS：一定要注意python文件的名字一定要和data文件名字相同，否则会报错</p></li></ol><h3 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install zplot <br><span class="hljs-comment">#注意可能会出现list错误，可能是由于python2 和python3的不兼容原因，只需要将zplot.py里面的ListType改为list就可以了</span><br><br>sudo apt-get install texlive-extra-utils  <br></code></pre></td></tr></table></figure><h3 id="Makefile文件分析"><a href="#Makefile文件分析" class="headerlink" title="Makefile文件分析"></a>Makefile文件分析</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash">PY=python<br>EPS2PDF=ps2pdf<br>CROP=pdfcrop<br><br>SRC := $(wildcard *.py) <span class="hljs-comment">#列出所有文件对应的py文件</span><br>SRC := $(filter-out zplot.py, $(SRC))<br>EPS = $(patsubst %.py,%.eps,$(SRC))<br>PDF = $(patsubst %.py,%.pdf,$(SRC)) <span class="hljs-comment">#列出所有文件对应的eps和pdf文件</span><br><br>all: $(EPS) $(PDF)<br><br>%.eps: %.py  <span class="hljs-comment"># 目标文件： 源文件</span><br>$(PY) $&lt; eps  <span class="hljs-comment">#$&lt; 表示源文件  $@表示目标文件//官方解释： $&lt; 表示第一个依赖文件， $@ 表示目标集</span><br><br>%.pdf: %.eps<br>$(EPS2PDF) $&lt;<br>$(CROP) <span class="hljs-variable">$@</span> <span class="hljs-variable">$@</span><br>rm -rf $&lt;<br><br>fig:<br><span class="hljs-comment"># mv -f *.pdf ../../../fig/ #将所有的文件都转移到zplot对应的root目录下面</span><br>mv -f *.pdf ../../<br>rm -rf *.eps *.pdf<br></code></pre></td></tr></table></figure><p>makefile语法的参考链接： <a href="https://seisman.github.io/how-to-write-makefile/rules.html">书写规则 — 跟我一起写Makefile 1.0 文档</a> </p><p>makefig.sh文件分析</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>rm -rf *.pdf <span class="hljs-comment">#这是我自己家的，在执行生成之前，现将之前生成的pdf文件删除，应该是也不用</span><br><br><span class="hljs-keyword">for</span>  dir  <span class="hljs-keyword">in</span>  `find .  -name Makefile`  <span class="hljs-comment">#找到包含Makefile文件的dir</span><br><span class="hljs-keyword">do</span><br>path=`dirname <span class="hljs-variable">$dir</span>` <span class="hljs-comment">#找到dir对应的路径path</span><br>    <span class="hljs-comment"># echo $path</span><br>    <span class="hljs-comment"># echo $dir</span><br><span class="hljs-keyword">if</span>  [ <span class="hljs-variable">$path</span>  !=  . ]<br><span class="hljs-keyword">then</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$path</span> <span class="hljs-comment">#打印出path的路径</span><br><span class="hljs-built_in">cd</span> <span class="hljs-variable">$path</span>  <br>make    <span class="hljs-comment">#执行make和makefig命令</span><br>make fig<br><span class="hljs-built_in">cd</span>  -<br><span class="hljs-keyword">fi</span><br><span class="hljs-keyword">done</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight livecodeserver&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;s</summary>
      
    
    
    
    <category term="工具相关" scheme="http://shu0421.github.io/categories/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="zplot" scheme="http://shu0421.github.io/tags/zplot/"/>
    
  </entry>
  
  <entry>
    <title>Anaconda环境搭建</title>
    <link href="http://shu0421.github.io/2021/12/15/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/anaconda%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%BB%8E%E9%9B%B6%E5%88%B0%E4%B8%80/"/>
    <id>http://shu0421.github.io/2021/12/15/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/anaconda%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%BB%8E%E9%9B%B6%E5%88%B0%E4%B8%80/</id>
    <published>2021-12-15T06:48:24.000Z</published>
    <updated>2023-11-29T02:22:43.982Z</updated>
    
    <content type="html"><![CDATA[<h2 id="任务描述"><a href="#任务描述" class="headerlink" title="任务描述"></a>任务描述</h2><p>一个服务器上已经搭建好的环境，但是需要换另一台机器，或者另外的用户需要访问这个环境， 如果另一台服务器上没有anaconda环境就需要从0开始进行搭建，然后再进行环境的迁移</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ol><li>安装anaconda3<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">wget</span> https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda<span class="hljs-number">3</span>-<span class="hljs-number">5</span>.<span class="hljs-number">3</span>.<span class="hljs-number">1</span>-Linux-x<span class="hljs-number">86</span>_<span class="hljs-number">64</span>.sh<br><span class="hljs-attribute">bash</span> Anaconda<span class="hljs-number">3</span>-<span class="hljs-number">5</span>.<span class="hljs-number">3</span>.<span class="hljs-number">1</span>-Linux-x<span class="hljs-number">86</span>_<span class="hljs-number">64</span>.sh<br></code></pre></td></tr></table></figure></li></ol><p>一般情况下安装是默认设置，在安装vscode的时候可以根据需要选择no或者yes<br>注意在安装installer的时候需要选择yes, 如果选择了no<br>那么可以自行添加环境:<br><a href="https://zhuanlan.zhihu.com/p/64930395">Linux-Centos7下安装Anaconda（2019年新版） - 知乎</a>（也就是激活环境中的方法二）</p><ol start="2"><li>激活环境<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 方法一失效</span><br>输入命令打开配置文件：vim ~/.bashrc<br>在最后添加语句：export PATH=<span class="hljs-regexp">/root/</span>xxx<span class="hljs-regexp">/anaconda3/</span>bin:<span class="hljs-variable">$PATH</span> （<span class="hljs-regexp">/root/</span>xxx 为安装路径）<br>最后输入如下命令，更新配置文件即可：source ~/.bashrc<br><br><span class="hljs-comment">#方法二有效：</span><br>如果conda的初始化时选择了no，则需要自行配置环境变量。<br><br>打开profile文件：<br><br>vi <span class="hljs-regexp">/etc/</span>profile<br>在文件最后加入如下语句（路径需要根据自己的安装位置更改）：<br><br>PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-regexp">/opt/</span>anaconda3/bin<br>export PATH<br>保存文件并退出。最后使用如下命令刷新环境变量即可：<br><br>source <span class="hljs-regexp">/etc/</span>profile<br>echo <span class="hljs-variable">$PATH</span><br></code></pre></td></tr></table></figure></li></ol><p>PS: 如果conda名称弹出问题，使用<code>sudo vi ~/.bashrc</code>查看conda路径是否正确</p><ol start="3"><li>conda相关命令<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs applescript">conda <span class="hljs-built_in">list</span> 查看安装包<br>conda info <span class="hljs-comment">--envs 查看环境</span><br>conda <span class="hljs-built_in">activate</span> XXX 激活环境 （XXX 为环境名称）<br>python -V 检查Python版本<br><br>如果需要卸载anaconda的话，只需要删除anaconda目录即可:<br>rm -rf /root/xxx/anaconda3<br></code></pre></td></tr></table></figure></li><li>使用conda-pack迁移环境</li></ol><p>在源机器：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">conda pack -n env-<span class="hljs-built_in">name</span> <span class="hljs-comment">--ignore-editable-packages（如果没有后面这个会报错）</span><br>得到一个env_name.tar.gz压缩文件<br></code></pre></td></tr></table></figure><p>在目标机器：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">cd ~<span class="hljs-regexp">/anaconda3/</span>envs;<br>mkdir env_name<br>tar -xzvf env_name.tar.gz -C <span class="hljs-regexp">/home/</span>root_name<span class="hljs-regexp">/anaconda3/</span>envs/env_name<br></code></pre></td></tr></table></figure><ol start="5"><li>使用环境<br><code>source activate attnGAN</code></li></ol><p>注意使用conda activate会报错<br>目前找到一个解决方案：<br><a href="https://blog.csdn.net/qq_43828332/article/details/114235922">转载：conda activate和source activate 的命令区别_你倒是点菜啊的博客-CSDN博客</a></p><p>总共耗时 1个半小时左右~</p><h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><ol><li><a href="https://blog.csdn.net/lwgkzl/article/details/89329383">两行代码下载安装Anaconda（linux环境）-CSDN博客</a></li><li><a href="https://www.jianshu.com/p/1fddd11bcd25">Linux安装Anaconda3</a></li><li><a href="https://blog.csdn.net/ds1302__/article/details/120027173">使用conda pack进行环境迁移（步骤很详细）_小舟%的博客-CSDN博客</a></li></ol><p>注意之江实验室hec anaconda3的安装路径是：/nfs/home </p><h2 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h2><p>在终端输入conda info –envs检验anaconda是否安装成功，发现报错：conda: command not found</p><p>原因是因为~/.bashrc文件没有配置好</p><p>解决方案：<br>sudo vim ~/.bashrc<br>在最后一行加上<br>export PATH=$PATH:/home/vincent/anaconda3/bin</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;任务描述&quot;&gt;&lt;a href=&quot;#任务描述&quot; class=&quot;headerlink&quot; title=&quot;任务描述&quot;&gt;&lt;/a&gt;任务描述&lt;/h2&gt;&lt;p&gt;一个服务器上已经搭建好的环境，但是需要换另一台机器，或者另外的用户需要访问这个环境， 如果另一台服务器上没有anaconda</summary>
      
    
    
    
    <category term="工具相关" scheme="http://shu0421.github.io/categories/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="conda environment" scheme="http://shu0421.github.io/tags/conda-environment/"/>
    
  </entry>
  
  <entry>
    <title>RPC related</title>
    <link href="http://shu0421.github.io/2021/12/03/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/rpc/"/>
    <id>http://shu0421.github.io/2021/12/03/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/rpc/</id>
    <published>2021-12-03T02:01:07.000Z</published>
    <updated>2023-11-29T02:21:21.319Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-gRPC"><a href="#1-gRPC" class="headerlink" title="1. gRPC"></a>1. gRPC</h3><ul><li><p>使用步骤：<br>gRPC 可以保证不同语言之间的通讯<br>编写.proto文件，生成指定语言源代码。<br>编写服务端代码<br>编写客户端代码<br><a href="https://www.liwenzhou.com/posts/Go/gRPC/">一个pytho客户端和go服务端的例子</a></p></li><li><p>源文件解析：<br>route_guide_client文件主要是通过stub 和传入的参数调用server的函数<br>route_guide_server里面主要是编写得到输入服务器处理函数逻辑<br>route_guide_pb2_grpc，类似于头文件，定义Stub类和Servicer类，每个类只是定义函数，但不进行具体的实现； 以及一个add_RouteGuideServicer_to_server的函数</p></li></ul><h3 id="2-pytorch提供的rpc框架"><a href="#2-pytorch提供的rpc框架" class="headerlink" title="2. pytorch提供的rpc框架"></a>2. pytorch提供的rpc框架</h3><p>rpc常见方法<br>rpc_sync同步远程调用、rpc_async异步远程调用、remote异步远程调用。</p><p>rpc.init_rpc 初始化rpc，需要在master和worker都进行初始化，方便之后的通讯<br>rpc.rpc_sync  worker端调用在master上进行执行的方法<br>rpc.rpc_async<br>rpc.remote</p><p>dist_autograd.get_gradient(cid) 目前猜测在rpc场景进行前向传播，的梯度反向传播需要使用dist_grad</p><p>TrainNet是worker调用的假的网络，实际的网络是在Net里面调用，每次worker里面数据的前向传播，实际上都是在master里面的调用net进行前向传播</p><h3 id="3-分析rpc-parameter-server代码"><a href="#3-分析rpc-parameter-server代码" class="headerlink" title="3. 分析rpc_parameter_server代码"></a>3. 分析rpc_parameter_server代码</h3><p>master和worker都需要init_rpc</p><p>worker里面主要执行TrainNet：初始化的时候得到远程parameterServer的引用，然后包含二个函数 get_global_param_rref 以及forward函数(均要调用remote_method)<br>master里面执行parameterServer类，：初始的时候，得到真实训练的model, 同时实现三个函数, 对模型参数加上的引用rpc.RRef，使用dist_autograd得到模型参数，以及对输入数据进行前向传播</p><p>在master中加上 uni_sample_score_rref</p><h3 id="4-go语言"><a href="#4-go语言" class="headerlink" title="4. go语言"></a>4. go语言</h3><ul><li><p>前置安装要求</p><ul><li><p>安装go，和protocol buffer编译器<br><a href="https://grpc.io/docs/languages/go/quickstart/#prerequisites">https://grpc.io/docs/languages/go/quickstart/#prerequisites</a></p></li><li><p>go command not found<br>使用export， 重启一个控制台窗口就找不到这个命令了<br>需要使用vim <del>/.bashrc写入文件 将这个命令写进去，然后使用source ~/.bashrc<br>(</del>/.bashrc:是用户相关的终端（shell）的环境设置，通常打开一个新终端时，默认会load里面的设置，在这里的设置不影响其它人。<br>/etc/profile会影响所有的用户)</p></li><li><p>go download超时解决：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">GOPROXY</span>=https://goproxy.cn<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="5-go-软件的安装"><a href="#5-go-软件的安装" class="headerlink" title="5. go 软件的安装"></a>5. go 软件的安装</h3><ol><li><p>直接使用 <code>tar -C /usr/local -xzf go1.4.7.linux-amd64.tar.gz</code> 解压到 local 目录 设置PATH，<code>export PATH=$PATH:/usr/local/go/bin</code></p></li><li><p>假定你想要安装Go的目录为 <code>$GO_INSTALL_DIR</code>，后面替换为相应的目录路径。 解压缩tar.gz包到安装目录下：<code>tar zxvf go1.14.7.linux-amd64.tar.gz -C $GO_INSTALL_DIR</code><br>设置PATH:<code>export PATH=$PATH:$GO_INSTALL_DIR/go/bin</code><br>如果修改用户环境变量：设置 <code>vim ~/.bash_profile</code><br>如果修改系统环境变量：设置 <code>vim /etc/profile</code></p></li><li><p><a href="https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/01.1.md">go安装的三种方法</a></p></li></ol><ol start="4"><li><p>go的插件在vscode命令行中显示失败 i/o time out<br>解决方法：GO111MODULE=on GOPROXY=<a href="https://goproxy.cn,direct/">https://goproxy.cn,direct</a> go install </p></li><li><p>vscode下载go 包的时候一个failed的解决方案（和第4个有点雷同）<br><a href="https://www.cnblogs.com/marshhu/p/11848020.html">golang之vscode环境配置 - 我没有领悟 - 博客园</a></p></li></ol><h3 id="6-利用gRPC通信-一端使用go-一端使用python"><a href="#6-利用gRPC通信-一端使用go-一端使用python" class="headerlink" title="6. 利用gRPC通信 一端使用go 一端使用python"></a>6. 利用gRPC通信 一端使用go 一端使用python</h3><p>一个python小例子：<a href="https://grpc.io/docs/languages/python/quickstart/">Quick start | Python | gRPC</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-gRPC&quot;&gt;&lt;a href=&quot;#1-gRPC&quot; class=&quot;headerlink&quot; title=&quot;1. gRPC&quot;&gt;&lt;/a&gt;1. gRPC&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;使用步骤：&lt;br&gt;gRPC 可以保证不同语言之间的通讯&lt;br&gt;编写.proto文件，生</summary>
      
    
    
    
    <category term="工具相关" scheme="http://shu0421.github.io/categories/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="rpc" scheme="http://shu0421.github.io/tags/rpc/"/>
    
  </entry>
  
  <entry>
    <title>orangefs</title>
    <link href="http://shu0421.github.io/2021/12/01/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/orangefs/"/>
    <id>http://shu0421.github.io/2021/12/01/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/orangefs/</id>
    <published>2021-12-01T07:54:01.000Z</published>
    <updated>2023-11-29T02:21:21.319Z</updated>
    
    <content type="html"><![CDATA[<h2 id="orangefs"><a href="#orangefs" class="headerlink" title="orangefs"></a>orangefs</h2><h3 id="1-genconfig"><a href="#1-genconfig" class="headerlink" title="1. genconfig"></a>1. genconfig</h3><p>genconfig是一个go语言文件，它有一个可选参数oranges-server.conf</p><h3 id="2-init-start-all-sh"><a href="#2-init-start-all-sh" class="headerlink" title="2. init_start_all.sh"></a>2. init_start_all.sh</h3><p>init_start_all.sh相比start_all.sh 多了一个/local500G/orange_store/ 以及多了一条有-f命令的语句 应该是在服务器节点启动pvfs-server<br>orangefs默认的服务器的文件系统挂载的目录是在oranges-server.conf里面进行配置<code>（/nfs/home/yfwang/orangefs/install/etc/oranges-server.conf）</code></p><p>加上f的原因： 第一次启动PVFS2服务要首先分配空间，添加参数-f：<br><code>root@ubuntu:~# pvfs2-server /etc/pvfs2-fs.conf -f</code><br>其后启动服务则不需加参数，或使用-d使得服务运行于前台（占用当前终端窗口，终端窗口关闭后服务终止）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> host <span class="hljs-keyword">in</span> `cat /nfs/home/yfwang/orangefs/install/nodelist`<br><span class="hljs-keyword">do</span><br><span class="hljs-comment">#       ssh -t -t -o StrictHostKeyChecking=no -o PasswordAuthentication=no $USER@$host sudo rm -rf /local500G/orange_store/*</span><br>        ssh -t -t -o StrictHostKeyChecking=no -o PasswordAuthentication=no <span class="hljs-variable">$USER</span>@<span class="hljs-variable">$host</span> sudo /nfs/home/yfwang/orangefs/install/sbin/pvfs2-server -f /nfs/home/yfwang/orangefs/install/etc/oranges-server.conf<br>        ssh -t -t -o StrictHostKeyChecking=no -o PasswordAuthentication=no <span class="hljs-variable">$USER</span>@<span class="hljs-variable">$host</span> sudo /nfs/home/yfwang/orangefs/install/sbin/pvfs2-server /nfs/home/yfwang/orangefs/install/etc/oranges-server.conf<br><span class="hljs-keyword">done</span> <br></code></pre></td></tr></table></figure><h3 id="3-stop-all-sh"><a href="#3-stop-all-sh" class="headerlink" title="3. stop_all.sh"></a>3. stop_all.sh</h3><p>stop_all.sh 停止所有的pvfs-server</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> host <span class="hljs-keyword">in</span> `cat /nfs/home/yfwang/orangefs/install/nodelist`<br><span class="hljs-keyword">do</span><br>        ssh -t -t -o StrictHostKeyChecking=no -o PasswordAuthentication=no <span class="hljs-variable">$USER</span>@<span class="hljs-variable">$host</span> sudo killall pvfs2-server<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><h3 id="4-start-client-sh"><a href="#4-start-client-sh" class="headerlink" title="4. start_client.sh"></a>4. start_client.sh</h3><p>start_client.sh启动客户端orangefs-client， 同时将服务器任意一个节点的位置暴露为客户端，例子是hec09</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo /nfs/home/yfwang/orangefs/install/sbin/pvfs2-client -f -p /nfs/home/yfwang/orangefs/install/sbin/pvfs2-client-core<br>sudo mount -t pvfs2 tcp://hec09:3334/orangefs /mnt/orangefs<br></code></pre></td></tr></table></figure><h3 id="5-nodelist"><a href="#5-nodelist" class="headerlink" title="5. nodelist"></a>5. nodelist</h3><p>nodelist 里面直接写hec10 hec11</p><p><a href="https://github.com/waltligon/orangefs/wiki/Distributions-and-Layouts">Distributions and Layouts · waltligon/orangefs Wiki · GitHub</a> 设置数据不同的放置策略,一个文件放在一个节点使用basic方式 distribution</p><p><a href="https://github.com/waltligon/orangefs/wiki/Programming-Guide">Programming Guide · waltligon/orangefs Wiki · GitHub</a></p><p><code>setfattr -n &quot;user.pvfs2.dist_name&quot; -v &quot;basic_dist&quot; /mnt/pvfs2/directory</code><br><code>./bin/pvfs2-xattr -s -k &quot;user.pvfs2.dist_name&quot; -v &quot;basic-dist&quot; /mnt/shu-orangefs/dataset </code></p><p>orangefs里面有一个PINT_dist函数<br><a href="https://www.mcs.anl.gov/~robl/pvfs2/pvfs2-dox/html/pint-distribution_8c.html#a2">pvfs2: pint-distribution.c File Reference</a></p><h3 id="6-将文件保存在orangefs中一个服务器的方案："><a href="#6-将文件保存在orangefs中一个服务器的方案：" class="headerlink" title="6. 将文件保存在orangefs中一个服务器的方案："></a>6. 将文件保存在orangefs中一个服务器的方案：</h3><p><a href="https://stackoverflow.com/questions/64923445/how-to-configure-orangefs-save-the-file-into-the-same-server-not-split-it">filesystems - How to configure orangefs save the file into the same server, not split it? - Stack Overflow</a><br>使用命令：setfattr -n “user.pvfs2.num_dfiles” -v “1” /mnt/orangefs<br>如果按照这种方式设置会报错：setfattr -n “user.pvfs2.dist_name” -v “basic_dist” /mnt/pvfs2/directory 传输数据会报错</p><h2 id="配置教程"><a href="#配置教程" class="headerlink" title="配置教程"></a>配置教程</h2><p>安装server<br>拷贝已经编译好的程序</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cp -r <span class="hljs-regexp">/nfs/</span>home<span class="hljs-regexp">/yfwang/</span>orangefs<span class="hljs-regexp">/install /</span>nfs<span class="hljs-regexp">/home/</span>weijian<span class="hljs-regexp">/orangefs_install/</span><br></code></pre></td></tr></table></figure><p>配置server</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">.<span class="hljs-regexp">/bin/</span>pvfs2-genconfig <span class="hljs-regexp">/nfs/</span>home<span class="hljs-regexp">/weijian/</span>orangefs_install<span class="hljs-regexp">/install/</span>orangefs-server.conf<br></code></pre></td></tr></table></figure><p>具体的配置项，自己可以先记录下来</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">tcp<br><span class="hljs-number">3336</span><br><span class="hljs-regexp">/local500G/</span>wj-fast<span class="hljs-regexp">/storage/</span>data<br><span class="hljs-regexp">/local500G/</span>wj-fast<span class="hljs-regexp">/storage/m</span>eta<br><span class="hljs-regexp">/var/</span>log/orangefs-server.log<br>hec08,hec09<br></code></pre></td></tr></table></figure><p>配置完成时可以<code>cat /nfs/home/weijian/orangefs_install/install/orangefs-server.conf</code>查看配置项是否符合需求<br>到各个server上，各自初始化存储目录</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">sudo ./sbin/pvfs2-<span class="hljs-keyword">server</span> -f orangefs-<span class="hljs-keyword">server</span>.conf -a &lt;<span class="hljs-keyword">server</span> <span class="hljs-keyword">alias</span>&gt;<br></code></pre></td></tr></table></figure><p>到各个server上，启动服务</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo .<span class="hljs-regexp">/sbin/</span>pvfs2-server  orangefs-server.conf<br></code></pre></td></tr></table></figure><p>安装client<br>拷贝已经编译好的程序（如果已经可以访问就不需要拷贝了）</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">scp -r weijian<span class="hljs-variable">@hec08</span><span class="hljs-symbol">:/nfs/home/yfwang/orangefs/install/</span> /nfs/home/weijian/orangefs_install/<br></code></pre></td></tr></table></figure><p>向内核加载orangefs模块</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo modprobe orangefs</span><br></code></pre></td></tr></table></figure><p>创建挂载点</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo mkdir <span class="hljs-regexp">/mnt/</span>wj-fast-orangefs<br></code></pre></td></tr></table></figure><p>写配置文件</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo sh -c “echo ‘tcp:<span class="hljs-regexp">//</span>hec08:<span class="hljs-number">3336</span><span class="hljs-regexp">/orangefs /m</span>nt<span class="hljs-regexp">/wj-fast-orangefs pvfs2’ &gt;&gt; /</span>etc/pvfs2tab”<br></code></pre></td></tr></table></figure><p>测试与server是否连通</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">.<span class="hljs-regexp">/bin/</span>pvfs2-ping -m <span class="hljs-regexp">/mnt/</span>wj-fast-orangefs<br></code></pre></td></tr></table></figure><p>启动client客户端</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo .<span class="hljs-regexp">/sbin/</span>pvfs2-client -p .<span class="hljs-regexp">/sbin/</span>pvfs2-client-core<br></code></pre></td></tr></table></figure><p>挂载</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo mount -t pvfs2 tcp:<span class="hljs-regexp">//</span>hec08:<span class="hljs-number">3336</span><span class="hljs-regexp">/orangefs /m</span>nt/wj-fast-orangefs<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;orangefs&quot;&gt;&lt;a href=&quot;#orangefs&quot; class=&quot;headerlink&quot; title=&quot;orangefs&quot;&gt;&lt;/a&gt;orangefs&lt;/h2&gt;&lt;h3 id=&quot;1-genconfig&quot;&gt;&lt;a href=&quot;#1-genconfig&quot; class</summary>
      
    
    
    
    <category term="工具相关" scheme="http://shu0421.github.io/categories/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="orangefs" scheme="http://shu0421.github.io/tags/orangefs/"/>
    
  </entry>
  
  <entry>
    <title>二叉树</title>
    <link href="http://shu0421.github.io/2021/11/23/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://shu0421.github.io/2021/11/23/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2021-11-23T02:27:56.000Z</published>
    <updated>2023-11-29T02:21:21.323Z</updated>
    
    <content type="html"><![CDATA[<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="1-验证二叉树的前序序列化"><a href="#1-验证二叉树的前序序列化" class="headerlink" title="1. 验证二叉树的前序序列化"></a>1. 验证二叉树的前序序列化</h3><p>观察规律题或者建树题<br>我的思路是直接建立一颗二叉树，但是建立树代码可以不写；最后树是正确的就是中间不会访问到cur==size的情况，同时最后循环完之后不会再出现#或者数字<br>官方题解是：通过槽位计数，如果遍历到最后槽位为0说明正确，如果中间槽位为0，说明出错<br>因为加上一个#槽位数会–，如果加上一个数字那么槽位数会++（-1+2）<br>注意这道题的易错点是: 字符串中包含’,’而且可能数字包含两个字符 98,7,#</p><h3 id="2-二叉树的宽度"><a href="#2-二叉树的宽度" class="headerlink" title="2. 二叉树的宽度"></a>2. 二叉树的宽度</h3><p> 宽度应该包含一层的节点之间夹杂的空字符，所以为了得到一层的宽度，应该在栈中压入每个节点的下标(左边：2 * pos, 右边：2 * pos+1)，而不是具体的二叉树ListNode</p><h3 id="3-两个子节点的最近公共父节点"><a href="#3-两个子节点的最近公共父节点" class="headerlink" title="3. 两个子节点的最近公共父节点"></a>3. 两个子节点的最近公共父节点</h3><p>如果一个节点为target_one或者target_two那么直接返回当前节点，否则进行dfs, dfs返回的左右节点都是非NULL那么就返回当前节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">ListNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(ListNode* root, ListNode* node1, ListNode* node2)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>||root==p||root==q) <span class="hljs-keyword">return</span> root;<br>    <span class="hljs-keyword">if</span>(root==node1||root==node2)&#123;<br>        <span class="hljs-keyword">return</span> cur;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        ListNode *left=<span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left, node1, node2);<br>        ListNode *right=<span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right, node1, node2);<br>        <span class="hljs-keyword">if</span>(left&amp;&amp;right)&#123;<br>            <span class="hljs-keyword">return</span> cur;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left)&#123;<br>            <span class="hljs-keyword">return</span> left;<br>        &#125;<br>        <span class="hljs-keyword">return</span> right;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>一种离线求多个查询的公共父节点是使用Tarjan离线算法：<a href="https://www.cnblogs.com/wkfvawl/p/9415280.html">LCA最近公共祖先（Tarjan离线算法） - 王陸 - 博客园</a><br>主要思想是使用并查集+dfs, 将每个节点的祖先节点设置为当前的父节点，并且一个节点的所有子节点都dfs完成之后，就将当前节点的父节点标记为上一个节点，遍历与当前节点相关的所有查询：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-number">1</span> <span class="hljs-built_in">Tarjan</span>(u)<span class="hljs-comment">//marge和find为并查集合并函数和查找函数</span><br> 　　<span class="hljs-number">2</span> &#123;<br> 　　<span class="hljs-number">3</span>     <span class="hljs-function"><span class="hljs-keyword">for</span> <span class="hljs-title">each</span><span class="hljs-params">(u,v)</span>    <span class="hljs-comment">//访问所有u子节点v</span></span><br><span class="hljs-function"> 　　4     </span>&#123;<br>　　 <span class="hljs-number">5</span>         <span class="hljs-built_in">Tarjan</span>(v);        <span class="hljs-comment">//继续往下遍历</span><br>　　 <span class="hljs-number">6</span>         <span class="hljs-built_in">marge</span>(u,v);    <span class="hljs-comment">//合并v到u上</span><br>　　 <span class="hljs-number">7</span>         标记v被访问过;<br>　　 <span class="hljs-number">8</span>     &#125;<br>　　 <span class="hljs-number">9</span>     <span class="hljs-function"><span class="hljs-keyword">for</span> <span class="hljs-title">each</span><span class="hljs-params">(u,e)</span>    <span class="hljs-comment">//访问所有和u有询问关系的e</span></span><br><span class="hljs-function">　　10     </span>&#123;<br>　　<span class="hljs-number">11</span>         如果e被访问过;<br>　　<span class="hljs-number">12</span>          u,e的最近公共祖先为<span class="hljs-built_in">find</span>(e);<br>　　<span class="hljs-number">13</span>     &#125;<br>　　<span class="hljs-number">14</span> &#125;<br></code></pre></td></tr></table></figure><h3 id="4-从二叉树一个节点到另一个节点每一步的方向"><a href="#4-从二叉树一个节点到另一个节点每一步的方向" class="headerlink" title="4. 从二叉树一个节点到另一个节点每一步的方向"></a>4. 从二叉树一个节点到另一个节点每一步的方向</h3><p>方法，通过dfs找到根到达startValue和dstValue的具体路径，然后删除路径前面相同的部分，然后到达startValue剩余的size都加上U， 到达dstValue剩余的都加上dst剩余的路径</p><h3 id="5-寻找重复的树，"><a href="#5-寻找重复的树，" class="headerlink" title="5. 寻找重复的树，"></a>5. 寻找重复的树，</h3><p>解决方案：序列化+hash判断子树是否唯一，序列化只能使用# ，以及前序和后序遍历</p><ul><li>注意这道题需要记录空节点，同时，只能使用前序或者后序遍历 唯一判定两棵子树是否相同，而不能使用中序遍历。而且数据与数据应该用，隔开，因为222可以理解为2+2+2也可以理解为2+22 </li><li> ==加上#的这种情况，只有后序遍历和前序遍历能够唯一确定一课子树。中序遍历不行==  </li><li>同样这道题使用二叉树的序列化和反序列化, 因为前序和后序都可以知道根节点，但是中序不行</li></ul><h3 id="6-最长同值路径"><a href="#6-最长同值路径" class="headerlink" title="6. 最长同值路径"></a>6. 最长同值路径</h3><ul><li>和二叉树的直径类似，不过这里需要判断值是否相等，多了一个条件</li><li>为了区分left+right+1 left+1 right+1三种情况，可以使用一个left_mark 如果左边和root相等那么==left_val+1否则为0。那么最后的结果都是left_mark+right_mark+1， 解决了三种情况 返回max(left_mark, right_mark)+1</li></ul><h3 id="7-二叉树中所有距离为-K-的结点"><a href="#7-二叉树中所有距离为-K-的结点" class="headerlink" title="7. 二叉树中所有距离为 K 的结点"></a>7. 二叉树中所有距离为 K 的结点</h3><p>先通过dfs找到每个节点的父节点，然后再对target节点进行dfs 左右和父节点 (或者bfs+vis)</p><h3 id="8-二叉树寻路，使用数学方法"><a href="#8-二叉树寻路，使用数学方法" class="headerlink" title="8. 二叉树寻路，使用数学方法"></a>8. 二叉树寻路，使用数学方法</h3><p>1.先求每个数正常的父亲，然后再对不同的层进行修改<br>2.在进行修改的时候抓住对称的点的和是相同的<br>3.如果层数是偶数，那么只需要修改奇数层的值；如果层数是奇数，那么需要修改偶数层的数据</p><h3 id="9-二叉树中两个节点间的距离"><a href="#9-二叉树中两个节点间的距离" class="headerlink" title="9. 二叉树中两个节点间的距离"></a>9. 二叉树中两个节点间的距离</h3><p>先求两个节点的最近公共祖先，然后从最近公共祖先出发，求祖先节点分别到两个节点的距离(使用dfs两次，target==p||q)，距离之和就是两个节点的最短路径<br>代码：<a href="https://www.jianshu.com/p/cec33f514f69">LeetCode 第 B 题：二叉树任意两节点之间的最短路径 - 简书</a></p><h3 id="10-树的直径问题"><a href="#10-树的直径问题" class="headerlink" title="10. 树的直径问题"></a>10. 树的直径问题</h3><p>任意选择一个节点为根，然后找到离他最远的节点a，然后找到离a最远的节点b，那么a-&gt;b就是最远的路径（树的直径）<br>如果是二叉树有指针的情况可以使用递归</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> result=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxDistance</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> leftLength=<span class="hljs-built_in">maxDistance</span>(root-&gt;left);<br>    <span class="hljs-keyword">int</span> rightLenght=<span class="hljs-built_in">maxDistance</span>(root-&gt;right);<br>    result=<span class="hljs-built_in">max</span>(leftLength+rightLenght+<span class="hljs-number">1</span>, result);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(leftLength, rightLenght)+<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">diameterOfBinaryTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-built_in">maxDistance</span>(root);<br>    <span class="hljs-keyword">return</span> result<span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果是无向图：<br>算法思想<br>①从任意一点P出发，通过DFS寻找离它最远的点Q。<br>②再次从点Q出发，通过DFS寻找离它最远的W。<br>③直径即为WQ。<br>证明：<a href="https://zhuanlan.zhihu.com/p/115966044">【朝夕的ACM笔记】树上问题-树的直径 - 知乎</a></p><p>两次dfs</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> st)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;edge[st].<span class="hljs-built_in">size</span>();i++)<br>    &#123;<br>        <span class="hljs-keyword">int</span> to=edge[st][i];<br>        <span class="hljs-keyword">if</span>(!vis[to])<br>        &#123;<br>            vis[to]=<span class="hljs-number">1</span>;<br>            dis[to]=dis[st]+<span class="hljs-number">1</span>;<span class="hljs-comment">//注意，本代码计算的是无权树的直径，所以边权为1</span><br>            <span class="hljs-comment">//如果是有权树，则这里的1要改为边权</span><br>            <span class="hljs-built_in">dfs</span>(to);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>求最长就是求最大的dis，两次dfs中间需要重新初始化dis=0</p><p><font color="blue">多叉树的直径问题：lc6073. 相邻字符不同的最长路径（hard,周赛题目）</font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> maxlen=<span class="hljs-number">1</span>;<span class="hljs-comment">//根节点</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;vec[index].<span class="hljs-built_in">size</span>();i++)&#123;<br>    <span class="hljs-keyword">int</span> len=<span class="hljs-built_in">dfs</span>(vec[index][i], vec, s); <br>    <span class="hljs-keyword">if</span>(s[vec[index][i]]!=s[index])&#123;<br>        res=<span class="hljs-built_in">max</span>(res, maxlen+len);<span class="hljs-comment">//更新直径</span><br>        maxlen=<span class="hljs-built_in">max</span>(maxlen, len+<span class="hljs-number">1</span>);<span class="hljs-comment">//更新最大</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">return</span> maxlen;<br></code></pre></td></tr></table></figure><p><font color="red">参数一定要记得使用引用，否则就会超时</font></p><h3 id="11-具有所有最深节点的最小子树"><a href="#11-具有所有最深节点的最小子树" class="headerlink" title="11. 具有所有最深节点的最小子树"></a>11. 具有所有最深节点的最小子树</h3><p>在深度优先搜索的时候同时返回结果和计算深度，返回的是一个结构体 node{root, dist}.<br>1)获取当前节点的左右子树的最大深度<br>2)如果两边最大深度相同，则这个节点就是结果<br>3)不相等，那返回深度大的子树的root信息</p><h3 id="12-205-同构字符串-890-查找和替换模式"><a href="#12-205-同构字符串-890-查找和替换模式" class="headerlink" title="12. 205. 同构字符串/890. 查找和替换模式"></a>12. 205. 同构字符串/890. 查找和替换模式</h3><p>查找和对应模式一致的字符串，abb模式。<br>使用双hash,也就是两边都没有映射，才建立映射，或者两边都有映射且未对方，那么continue,否则说明出处</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span>(s2t.<span class="hljs-built_in">find</span>(s[i])==s2t.<span class="hljs-built_in">end</span>()&amp;&amp;t2s.<span class="hljs-built_in">find</span>(t[i])==t2s.<span class="hljs-built_in">end</span>())&#123;<br>    s2t[s[i]]=t[i];<br>    t2s[t[i]]=s[i];<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s2t[s[i]]=t[i]&amp;&amp;t2s[t[i]]==s[i])&#123;<br>    <span class="hljs-keyword">continue</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="13-二叉树的遍历"><a href="#13-二叉树的遍历" class="headerlink" title="13.二叉树的遍历"></a>13.二叉树的遍历</h3><p> 前后序遍历中空间复杂度为O(1)的Morris Traval方法（主要是利用叶子节点的空指针进行映射到下一个节点）<br>    <a href="https://www.cnblogs.com/AnnieKim/archive/2013/06/15/MorrisTraversal.html">Morris Traversal方法遍历二叉树（非递归，不用栈，O(1)空间） - AnnieKim - 博客园</a></p><ul><li><strong>前序遍历</strong><br>  根左右<ol><li>如果当前节点的左孩子为空，那么输出当前节点，并将当前节点设置为当前节点的右孩子</li><li>一个节点的左孩子不为空，那么在当前节点的左子树找到这个节点的前驱节点(左边的最后面一个节点)<br> 如果这个前驱节点的右孩子为空，那么设置右孩子为当前节点，==输出当前节点==（于中序的唯一不同），并当前节点更新为当前节点左孩子<br> 如果这个前驱节点的右孩子为当前节点，那么将右孩子重新设置为空。并更新当前节点为当前节点的右孩子。</li></ol></li></ul><ul><li><strong>中序遍历</strong><br>  左根右<ol><li>如果当前节点的左孩子为空，那么输出当前节点，并将当前节点设置为当前节点的右孩子</li><li>一个节点的左孩子不为空，那么在当前节点的左子树找到这个节点的前驱节点<br> 如果这个前驱节点的右孩子为空，那么设置右孩子为当前节点，并当前节点更新为当前节点左孩子<br> 如果这个前驱节点的右孩子为当前节点，那么将右孩子重新设置为空。<strong>输出当前节点</strong>， 并更新当前节点为当前节点的右孩子<br> 与前序遍历相比一个是回来之后再输出(else)，一个是建立前驱到根节点关系后输出（if）</li></ol></li></ul><ul><li><strong>后序遍历</strong><br>  <strong>需要建立一个临时节点dump</strong>，使该节点的左子树等于root<ol><li>如果当前节点的左孩子为空，那么则将其右孩子作为当前节点</li><li>一个节点的左孩子不为空，那么在当前节点的左子树找到这个节点的前驱节点<br>如果这个前驱节点的右孩子为空，那么设置右孩子为当前节点, 并当前节点更新为当前节点左孩子<br>如果这个前驱节点的右孩子为当前节点，那么还原前驱右孩子为null, ==同时逆序输出从当前节点左孩子到前驱节点的路==，并更新当前节点为右孩子</li></ol></li></ul><p>总结：建立关系后，到左孩子；为空或者一圈回来后到右孩子<br>    一圈回来后，还原关系</p><h3 id="14-将子数组重新排序得到同一个二叉查找树的方案数"><a href="#14-将子数组重新排序得到同一个二叉查找树的方案数" class="headerlink" title="14.  将子数组重新排序得到同一个二叉查找树的方案数"></a>14.  将子数组重新排序得到同一个二叉查找树的方案数</h3><p>题意，交换插入序列，但是得到的二叉搜索树最后的结果相同的序列共有多少个<br>解决：抓住，先插左还是右的顺序是可以变的，但是在插入单边的时候，根节点的插入顺序是不可以变的</p><ul><li>排列组合+dfs</li><li>求排列组合的时候，其实用动态规划的思想 C(n,k)=C(n-1, k-1)+C(n-1,k)</li><li>node-&gt;ans = (long long)c[lsize + rsize][lsize] % mod * lans % mod * rans % mod;</li><li>在使用dfs的时候，使用一个全局的res变量，每次乘以（all, less)的组合结果；划分less, greater的时候，可以用一个新的vector来记录左右子树的节点</li><li>也可以先建立一棵树，使用递归左右指针的方式，树的信息需要包含size ,ans等一些信息<br>另一种出题的方式：<br>  一个数组入栈顺序定了，有多少种出栈的顺序<br>  f(n)=f(1)* f(n-1) + f(2) * f(n-2)+…..f(n-1) f(1);<br>  递推公式的解为：h(n)=c(2n,n)-c(2n,n+1)(n=1,2,3,…)</li></ul><h3 id="15-二叉搜索树删除一个节点"><a href="#15-二叉搜索树删除一个节点" class="headerlink" title="15. 二叉搜索树删除一个节点"></a>15. 二叉搜索树删除一个节点</h3><p>递归删除<br>易错点：<br>    1. 可以根据二叉搜索树的性质，选择向左右递归<br>    2. 找到该节点，如果是叶节点直接删除，如果只有左右子树，也可以直接返回左右子树，否则找到左边最小，然后赋值到当前值，然后递归删除<br>    3. 注意递归删除的的时候，一定要注意返回值，一定要赋值给当前节点的左指针或者右指针; 否则会造成树在中间断裂</p><h3 id="16-lc987-二叉树的垂序遍历"><a href="#16-lc987-二叉树的垂序遍历" class="headerlink" title="16. lc987. 二叉树的垂序遍历"></a>16. lc987. 二叉树的垂序遍历</h3><ul><li>dfs 遍历nodes 记录下每个节点的行号row，列号 col 以及值 value。<br>在遍历完成后，我们按照 col 为第一关键字升序，row 为第二关键字升序，value 为第三关键字升序，对所有的节点进行排序即可。 遍历时将同一col的放到同一vector中</li><li>也可以使用map&lt;int, vector<node>&gt; 这样的话就不用手动分每一个col</node></li></ul><h3 id="17-lc979-在二叉树中分配硬币"><a href="#17-lc979-在二叉树中分配硬币" class="headerlink" title="17. lc979. 在二叉树中分配硬币"></a><font color="red">17. lc979. 在二叉树中分配硬币</font></h3><ul><li>第一种方法：可以考虑后序遍历理解；需要从父节点得到或者获取 root-&gt;val-1个节点，<br>ans+=abs(root-&gt;val-1); return root-&gt;val-1//返回可能是负数</li><li>第二种方法：转为在子树中分配硬币<br>dfs(root)表示root这棵子树冗余的节点数<br>return root-&gt;val+dfs(root-&gt;left)+dfs(root-&gt;right)-1;//自己送给父节点的<br>ans+=abs(dfs(root-&gt;left))+abs(dfs(root-&gt;right)); // 左右节点送给自己的</li></ul><p>其实也可以直接这样：<br>ans+=abs(root-&gt;val+left_val+right_val-1);<br>return root-&gt;val+left_val+right_val-1;</p><h3 id="18-lc99-恢复二叉搜索树"><a href="#18-lc99-恢复二叉搜索树" class="headerlink" title="18.  lc99. 恢复二叉搜索树"></a>18.  lc99. 恢复二叉搜索树</h3><ul><li>二叉树出现位置交换会出现两种情况<br>两次逆序：记录前面x和后面y， 第二次更新y<br>一次逆序：记录前面x和后面y</li><li>时间O(n),空间O(1)</li></ul><h3 id="19-Find-Leaves-of-Binary-Tree-e"><a href="#19-Find-Leaves-of-Binary-Tree-e" class="headerlink" title="19.  Find Leaves of Binary Tree e"></a>19.  Find Leaves of Binary Tree e</h3><ul><li>题意：类似剥洋葱一样，将二叉树从最外到最内</li><li>重新定义二叉树的深度为左右的最大值加一，然后res[depth].push_back(root-&gt;val)<br>if (depth &gt;= res.size()) res.resize(depth + 1);//因为最开始不知道最大的深度，因此不知道如何初始化，所以在最深一层初始化大小</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>主要考察前中后序遍历， 子树（序列化+hash）, 直径(自底向上判断，左右返回最大一个，同时更新结果为根)， 宽度（BFS）， 二叉树的左右节点（index*2, index *2）, 二叉搜索树相关（删除节点）， 自顶向下和自底向上递归</li><li>主要关联的数据结构有栈，队列（BFS/DFS）， hash, 字符串等</li><li>求总数的时候可能会涉及排列组合的知识， </li><li>判断当前子树是否为BST, 不能仅仅靠当前节点的值大于左边最大和右边最小就可以，还需要左右两边都是BST（lc333-最大BST子树）</li><li>注意删除元素的时候记得 节点的值需要更新  node=remove(xx) 防止树之间的连接断掉</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;例题&quot;&gt;&lt;a href=&quot;#例题&quot; class=&quot;headerlink&quot; title=&quot;例题&quot;&gt;&lt;/a&gt;例题&lt;/h2&gt;&lt;h3 id=&quot;1-验证二叉树的前序序列化&quot;&gt;&lt;a href=&quot;#1-验证二叉树的前序序列化&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="leetcode" scheme="http://shu0421.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>链表</title>
    <link href="http://shu0421.github.io/2021/11/16/leetcode/%E9%93%BE%E8%A1%A8/"/>
    <id>http://shu0421.github.io/2021/11/16/leetcode/%E9%93%BE%E8%A1%A8/</id>
    <published>2021-11-16T10:29:23.000Z</published>
    <updated>2023-11-29T02:21:21.322Z</updated>
    
    <content type="html"><![CDATA[<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="1-扁平化多级双向链表"><a href="#1-扁平化多级双向链表" class="headerlink" title="1. 扁平化多级双向链表"></a>1. 扁平化多级双向链表</h3><h3 id="2-有序数组或者链表转为二叉搜索树lc109"><a href="#2-有序数组或者链表转为二叉搜索树lc109" class="headerlink" title="2. 有序数组或者链表转为二叉搜索树lc109"></a>2. 有序数组或者链表转为二叉搜索树lc109</h3><ul><li>常规解法：找到中间节点为当前根节点，分别建立左右子树</li><li>链表找中位数，需要使用快慢指针和断开链表</li><li>为了解决链表找中位数耗时比较大，同时不使用额外空间（不转为数组方法）的方法就是使用中序遍历建树方法：</li><li>我们没有必要“先”找到中间节点：我们可以先构建了左子树，建立结束后，指针自然指向中间结点。那么如何构建左子树呢？其实我们只需要确定子树的大小就可以。所以先用O(n)的时间计算链表长度，之后用中序遍历。当然，指针需要是“引用”。</li><li>为什么要使用指针：因为使用了递归，如果不使用指针，那么递归返回，head就不会被修改，而实际上我们是像达到一个全局变量向前走的效果，因此需要使用指针引用 ListNode* &amp;head</li></ul><h3 id="3-二叉树的最小深度（简单）"><a href="#3-二叉树的最小深度（简单）" class="headerlink" title="3. 二叉树的最小深度（简单）"></a>3. 二叉树的最小深度（简单）</h3><ul><li>注意是叶节点返回1，root==null 返回0， 但是在更新内部节点要判断左右是否为空，若任意一边为空，那么那一边不能加入计算中</li></ul><h3 id="4-二叉树展开为链表"><a href="#4-二叉树展开为链表" class="headerlink" title="4. 二叉树展开为链表"></a>4. 二叉树展开为链表</h3><p>先展开左右两边，然后如果展开的左边不为空，那么将左边展开后返回的头结点插入root-&gt;right, 同时设置root-&gt;left=null, 然后循环找到之前左边（现在右边）中最下面那个点，连接展开的右边返回的头节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">TreeNode* <span class="hljs-title">flattenFunc2</span><span class="hljs-params">(TreeNode *root)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    TreeNode* f_left = <span class="hljs-built_in">flattenFunc2</span>(root-&gt;left);<br>    TreeNode* f_right = <span class="hljs-built_in">flattenFunc2</span>(root-&gt;right);<br>    root-&gt;left=<span class="hljs-literal">nullptr</span>;<br>    TreeNode* res=root; <span class="hljs-comment">//一定要记得记录最开始的头结点</span><br>    <span class="hljs-keyword">if</span>(f_left!=<span class="hljs-literal">nullptr</span>)&#123; <span class="hljs-comment">//1. 左边不为空插入根和右边之间</span><br>        root-&gt;right=f_left;<br>        <span class="hljs-keyword">while</span>(root-&gt;right!=<span class="hljs-literal">nullptr</span>)&#123;<br>            root=root-&gt;right; <span class="hljs-comment">//改变了头结点</span><br>        &#125;<br>        root-&gt;right=f_right;<br>    &#125;<span class="hljs-keyword">else</span>&#123;  <span class="hljs-comment">//2. 否则直接连接根和右边</span><br>        root-&gt;right=f_right;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-lc1019-链表中的下一个更大节点"><a href="#5-lc1019-链表中的下一个更大节点" class="headerlink" title="5. lc1019. 链表中的下一个更大节点"></a>5. lc1019. 链表中的下一个更大节点</h3><ul><li>题意：求链表中每个元素下一个更大的值</li><li>方法1.单独一个vector来记录，单调递减栈下标（从左到右，需要知道前面元素的下标）</li><li>方法2.进行链表的翻转，得到list的len， 同时使用单调递减值栈 (从右到左， 不需要知道下标，只需要存储值)</li></ul><h3 id="6-lc143-重排链表"><a href="#6-lc143-重排链表" class="headerlink" title="6. lc143. 重排链表"></a>6. lc143. 重排链表</h3><ul><li>找到链表终点，后面的链表翻转，链表merge</li><li>这道题既考了快慢指针查找链表中点，还考了链表翻转以及链表merge 字节+阿里面试题</li></ul><h3 id="7-易错点"><a href="#7-易错点" class="headerlink" title="7. 易错点"></a>7. 易错点</h3><ul><li> 判断head是否为null</li><li> 在使用tmp-&gt;next 或者tmp-&gt;prev 一定要注意判断当前节点不能为null<br>也就是if(tmp){</li></ul><p>}</p><ul><li><p>双向链表在进行删除某个节点的时候，先固定前面和后面的关系都可以；但是在插入一个节点的时候一定要先固定后面的</p></li><li><p>LRU cache易错点：再删除需要指针+hash都需要消除，cache.erase(lastNode-&gt;key); delete lastNode;<br>可以用hash.size()定位cache元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"> LRU cache（一个双向链表，一个hash）<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LinkNode</span>&#123;</span><br>    <span class="hljs-keyword">int</span> key,val;<br>    LinkNode* next;<br>    LinkNode* pre;<br>    <span class="hljs-built_in">LinkNode</span>()&#123;<br>        next=<span class="hljs-literal">nullptr</span>;<br>        pre=<span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>LRU： 使用一个双向链表+unordered_map(数组/(key-&gt;*node))</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">unordered_map&lt;<span class="hljs-keyword">int</span>,Node*&gt; cache;<br></code></pre></td></tr></table></figure></li><li><p>LFU, 需要使用双向链表List(key-&gt;*node/ freq_list: (freq-&gt; 链表list头节点，也就是nodelist双向链表))+unordered_map</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">map&lt;<span class="hljs-keyword">int</span>, Node*&gt; key2node;<br>map&lt;<span class="hljs-keyword">int</span>, NodeList*&gt; freq2List;<br></code></pre></td></tr></table></figure></li><li><p>判断两个链表是否相交问题<br><a href="https://blog.csdn.net/jikuidongke5461/article/details/110160868">寻找两个链表相交节点方法（可以是有环链表）-CSDN博客</a><br>两个链表是否同时有环<br>  都有环（入环节点是否相等）<br>  都无环 （栈或者长链表先走lena-lenb）<br>  一个有一个无 (肯定不相交)</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>注意root=null 特殊情况</li><li>在调整树结构的时候一定要注意，返回节点，否则就可能链表断掉</li><li>充分利用二叉搜索树这些信息</li><li>有序链表的合并，一定要注意判断两个链表是否相交，或者链表是否有环的情况，如果遇到这两种情况要特殊处理</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;例题&quot;&gt;&lt;a href=&quot;#例题&quot; class=&quot;headerlink&quot; title=&quot;例题&quot;&gt;&lt;/a&gt;例题&lt;/h2&gt;&lt;h3 id=&quot;1-扁平化多级双向链表&quot;&gt;&lt;a href=&quot;#1-扁平化多级双向链表&quot; class=&quot;headerlink&quot; title=&quot;1. </summary>
      
    
    
    
    <category term="leetcode" scheme="http://shu0421.github.io/categories/leetcode/"/>
    
    
  </entry>
  
</feed>
