<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hello World</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-07-31T09:18:13.870Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>huhu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C# 相关</title>
    <link href="http://example.com/2022/06/13/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/C#/"/>
    <id>http://example.com/2022/06/13/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/C#/</id>
    <published>2022-06-13T02:52:09.000Z</published>
    <updated>2022-07-31T09:18:13.870Z</updated>
    
    <content type="html"><![CDATA[<h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><p>菜鸟教程+ 微软C#官方文档<br><a href="https://www.runoob.com/csharp/csharp-indexer.html">https://www.runoob.com/csharp/csharp-indexer.html</a><br><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/tour-of-csharp/">https://docs.microsoft.com/zh-cn/dotnet/csharp/tour-of-csharp/</a></p><h3 id="目前进展"><a href="#目前进展" class="headerlink" title="目前进展"></a>目前进展</h3><p>下次从C# 高级特性开始看</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;相关资料&quot;&gt;&lt;a href=&quot;#相关资料&quot; class=&quot;headerlink&quot; title=&quot;相关资料&quot;&gt;&lt;/a&gt;相关资料&lt;/h3&gt;&lt;p&gt;菜鸟教程+ 微软C#官方文档&lt;br&gt;&lt;a href=&quot;https://www.runoob.com/csharp/cshar</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>八股文总结</title>
    <link href="http://example.com/2022/06/12/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    <id>http://example.com/2022/06/12/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E5%85%AB%E8%82%A1%E6%96%87/</id>
    <published>2022-06-12T09:47:35.000Z</published>
    <updated>2022-07-31T09:18:13.872Z</updated>
    
    <content type="html"><![CDATA[<h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><p>C++ 多态特性</p><p>虚函数 是在基类中使用关键字 virtual 声明的函数。虚函数允许子类重新定义成员函数，而子类重新定义父类的做法称为覆盖(override)，或者称为重写。C++多态(polymorphism)就是通过虚函数来实现的。<br>纯虚函数 函数虚函数后面有==0。包含纯虚函数的类就是抽象类，这种类不能有对象，比如动物下面有青蛙，狗，但是动物不能有对象</p><p>静态多态性包括 函数重载 运算符重载， 重载就是同一个函数名字，但是不同的参数类型或者参数个数<br>动态多态主要由虚函数实现，也就是子类重写父类的方法</p><p>在类内实现（类成员函数）的运算符重载</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 重载 + 运算符，用于把两个 Box 对象相加</span><br>    Box <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> Box&amp; b) <span class="hljs-comment">//第一个Box代表返回值类型</span><br>    &#123;<br>        Box box;<br>        box.length = <span class="hljs-keyword">this</span>-&gt;length + b.length;<br>        box.breadth = <span class="hljs-keyword">this</span>-&gt;breadth + b.breadth;<br>        box.height = <span class="hljs-keyword">this</span>-&gt;height + b.height;<br>        <span class="hljs-keyword">return</span> box;<br>    &#125;<br></code></pre></td></tr></table></figure><p>友元函数实现的运算符重载 (无this指针)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 友元函数实现运算符重载 类中申明</span><br>    <span class="hljs-keyword">friend</span> Demo &amp; <span class="hljs-keyword">operator</span>+ (Demo &amp; demo, <span class="hljs-keyword">int</span> n);<br><span class="hljs-comment">//类外实现</span><br><br><span class="hljs-comment">// 重载 &quot;+&quot; 运算符</span><br>Demo &amp; <span class="hljs-keyword">operator</span>+ (Demo &amp; demo, <span class="hljs-keyword">int</span> n)<br>&#123;<br>    demo.a += n;<br>    <span class="hljs-keyword">return</span> demo;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>// C#好像没有this指针，即使是在成员函数实现重载方法，还是会传入两个对象</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;C&quot;&gt;&lt;a href=&quot;#C&quot; class=&quot;headerlink&quot; title=&quot;C++&quot;&gt;&lt;/a&gt;C++&lt;/h3&gt;&lt;p&gt;C++ 多态特性&lt;/p&gt;
&lt;p&gt;虚函数 是在基类中使用关键字 virtual 声明的函数。虚函数允许子类重新定义成员函数，而子类重新定义父类</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>毕业论文相关</title>
    <link href="http://example.com/2022/05/29/%E6%97%A5%E5%B8%B8%E8%AE%B0%E4%BA%8B/%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87%E7%9B%B8%E5%85%B3/"/>
    <id>http://example.com/2022/05/29/%E6%97%A5%E5%B8%B8%E8%AE%B0%E4%BA%8B/%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87%E7%9B%B8%E5%85%B3/</id>
    <published>2022-05-29T08:17:07.000Z</published>
    <updated>2022-08-07T08:55:45.636Z</updated>
    
    <content type="html"><![CDATA[<h3 id="毕业论文思路"><a href="#毕业论文思路" class="headerlink" title="毕业论文思路"></a>毕业论文思路</h3><p>5-22 毕业论文计划Update<br>看了一下之前写的论文，目前的打算：</p><ol><li>毕业论文在之前写的算法优化相关的论文上+一些调度/异步重要性/缓存（字典）/分布式训练/pipeline 相关知识<br>从算法+系统上构建一个针对不同瓶颈场景的深度学习训练系统<br>算法上一些理论（使用历史值） 对系统上的优化提供了帮助<br>系统上可从：分布式计算通讯减少，缓存设计/减少冗余数据移动加速IO<br><font color=red>算法上优化目的减少计算时间，系统上优化目的减少通讯和IO时间</font><br><font color=red> 重要性计算(只对重要的数据进行数据增强，有论文，或者对不重要的数据进行增强后缓存)， 重要性IO（高频更新和读取重要的样本，低频读取不重要样本，异步更新重要性）， 重要性通讯（梯度异步通讯，梯度小的就不同步，梯度比较大的同步，这样同步等待时间降低） </font><br>就相当于有三轮重要性过滤，可以通过参数指定是否要使用某种方法</li></ol><p>  a. 把重要性采样算法：转为过滤和打分阶段<br>  b. 通讯：<font color=red>重要性采样算法情况下如何解决重要性采样算法带来的负载不均衡，有的重要性样本多，有的少，有的机器负载重，有的轻</font> 同构场景下也不一定要分配同样多的数据（利用调度思想解决：应该调度多少的样本到一个机器上，按照机器的剩余资源，总线占用来分配，调整batch_size lr/调度感知的通讯 or 梯度同步 or 根据topology结构来进行分组梯度同步）？进行梯度压缩通讯？进行分组异步通讯？异构集群下的通讯优化？算子融合？搜索一个最佳分配方案？超参数搜索的多job场景分布式通讯优化，减少冗余数据加载或搬运（结合Ray）？<br>  c. 数据加载时间减少，第一个batch 优先读取缓存+数据pipeline预取<br>  xxx 感知的 xxxx<br>  eg. 压缩感知的梯度同步，其实就是因为感知，所以可以pipeline，时间覆盖实现加速</p><p>  参考论文：并行与分布式神经网络训练中数据通路的优化<br>  可以将重要性采样算法模式关闭，但是收益于其他的优化点（负载均衡/数据预取预缓存）！</p><ol start="2"><li><p>将重要性采样算法思想迁移到另外一个领域 (GNN?推荐系统？)<br>通过ali的负载分析，大量的任务要么是CPU 密集（GNN， 强化学习， CTR模型） 要么是GPU密集的，没有IO密集的。所以可以针对CPU密集场景设计重要性采样</p></li><li><p>最优的参数，样本数量，数据增强的数量或者种类应该都是随着整个训练过程中动态变化的，而不是静止最优的（pollux论文启发）</p></li></ol><h3 id="题目暂定"><a href="#题目暂定" class="headerlink" title="题目暂定"></a>题目暂定</h3><p>基于样本重要性与参数重要性的深度学习训练加速研究<br>基于样本重要性的深度学习加速框架（数据增强，计算，通讯，IO）<br>基于池化平台的深度学习的任务调度和资源配置研究<br>提出指标-&gt;建立模型-&gt;用模型预测-&gt;选择最佳方案</p><p>知网参考论文：<br>GPU集群环境下基于流水线的分布式深度学习训练优化技术研究与实现（模型并行优化）<br>分布式深度学习系统基于模型结构特性的通信优化（分布式训练通讯优化）<br>对于卷积层,根据每一层的参数规模大小设置层自适应传输率,每次进行权值参数更新时仅选择一些重要的卷积核将其梯度传输给参数服务器,其余卷积核的梯度在本地累积至下一轮参数更新</p><h3 id="论文模板"><a href="#论文模板" class="headerlink" title="论文模板"></a>论文模板</h3><p><a href="https://github.com/TheNetAdmin/zjuthesis">https://github.com/TheNetAdmin/zjuthesis</a></p><h3 id="一些其他思考"><a href="#一些其他思考" class="headerlink" title="一些其他思考"></a>一些其他思考</h3><p>建立每个样本梯度对最终精度（可能在不同训练阶段不同）影响的预测模型，用这个来进行阈值选择</p><p>SVP没有考虑到样本重要性是动态变化，删除就再也不训练<br>AutoAssist:需要另外训练一个模型来预测，而且实际上也是随机选择<br>biggestLoss为了达到最精确，每次都要重计算每个样本，为减少IO时间带来了困难；即使提出历史值方案，也最多只能重用很短2-3epoch时间</p><p>最开始profile时候计算每个样本的loss以及对模型精度的贡献？如何计算？<br><a href="https://zhuanlan.zhihu.com/p/400344124">https://zhuanlan.zhihu.com/p/400344124</a> 遗忘分数删减样本  建立 <font color=red>损失/M - 模型精度关系模型</font> 这样就可能将不同模型归为一类分析</p><p>每个样本对模型精度的影响，好像有个数据增强的论文提到过  就是图片方格的那篇论文</p><ol><li>打印出在不同模型精度下30% 40% 70% acc 下， 不同损失，内部每层梯度的值，求每层梯度的0的比例（或者总的），如果比例大于多少（90%），就说明该损失对模型梯度的影响几乎为0;</li><li>或者直接引用别人如何定义损失和对模型影响两者的关系，拿来用</li></ol><p>5-29 update<br>现有的重要性采样算法只关注计算，系统无感知，因此优化有局限<br>对现有重要性采样算法提出问题（无法动态调整）-&gt; 改进算法+系统角度优化<br>存储端异步GraNd score计算+aggressive training prunning</p><p>重要值频繁更新-&gt; 无用数据加载  不频繁更新-&gt; subset 导致丢弃的样本无法再被计算  ===&gt; 使用异步重要性更新+multi-metric+生命周期感知调整<br>冗余数据 ===&gt; 减少数据加载，用一张图片的多个增强替代；<br>梯度重要性不同 ====&gt; 不再等待一些不重要的梯度,收到超过半数的就返回结果（适应PS）/负载感知样本划分</p><p>框架一个bottleneck profiler+decision maker+算法模型插件方式加入框架 可关闭可开启可单可多metric</p><p>弱化重要性采样算法细节，参数设定等，改为使用模型/函数/强化学习来自动确定  突出其他改进</p><p>5-30 update<br>BytePS重读感想：<br>将一个实现一个目标的多种方案组合起来，比如PS和Ring-AllReduce 这样不会使得CPU资源浪费，同时也不会让CPU成为瓶颈，将不同类型node之间的通讯带宽都利用起来了，CPU-GPU GPU-GPU（混合最优）<br>找到通讯的瓶颈，节点与节点间通讯bottleneck大于节点内部之间的通讯，因此将节点内部数据进行sum汇总之后再进行节点间通讯，减少通讯数据量（分组通讯）<br>将一个动作拆分为多个动作，放在不同模块上执行（模块分离，解决CPU瓶颈）</p><p>池化优势：我感觉CPU interfer&gt; GPU interfer可以使用池化解决，将GPU分给多任务，但是CPU分给单任务</p><p>data diet感想：<br>动态调整不重要样本和噪音样本的比例 判断样本噪音+重要性的准则结合起来作为multi-criterion</p><p>5-31<br>重要性采样算法可能会使得每个类别的数量不相等，可以打印出来看看分析本质原因<br>分析是否是模型无关的！还是数据的属性<br>多个网络选择出来的重要性分数更准确<br>自适应重要性以及噪音检测样本，通过验证集来优化<br>噪音分数指标+重要指标 一同来进行选择</p><p>Linear Mode Connectivity in Multitask and Continual Learning 看<br>…</p><h1 id="calculate-summary-statistics"><a href="#calculate-summary-statistics" class="headerlink" title="calculate summary statistics"></a>calculate summary statistics</h1><p>data_mean, data_std = mean(data), std(data)</p><h1 id="identify-outliers"><a href="#identify-outliers" class="headerlink" title="identify outliers"></a>identify outliers</h1><p>cut_off = data_std * 3<br>或者梯度一直保持在较高很多轮</p><p>, our analysis in Fig. 2 suggests a simple and powerful method to prune data for optimal performance by optimizing just two hyperparameters of a sliding window using a validation set. 利用验证集去调节参数</p><p>重要性作为采样概率，阈值，比例三种采样方式</p><ol><li>always, sometimes, and never samples 频率进行缓存</li><li>This suggests that a large portion of the dataset is composed of<br>samples that are difficult to rank</li></ol><p>评价准则（专家系统进行噪音和重要性样本的分类  Mixture of experts）+剪枝过程+静态动态 都可以进行动态配置<br>当多个任务分配到同一个GPU导致内存不够的时候，使用重要性采样？？<br>滤波器剪枝+数据剪枝 </p><p>6-1<br>Accelerating Deep Learning with Dynamic Data Pruning<br>虽然是动态剪枝，也就是不同轮修剪的样本是不一样的，但是这篇论文是固定间隔将所有子样本的重要性进行计算后选择一个subset进行训练<br>在进行选择的时候使用了EMA（指数移动平均）+ e-greedy(随机从不重要样本以e概率采样) /Upper-confidence bound（均值方差） 的方法，需要设置一个alpha参数。通过分数阈值来进行计算，也是一个aggressive pruning rates。<br>但是问题：随机结果有时候表现比算法好，无法解决噪音问题,而且只是介绍了criterion，但是没说是阈值还是比例采样</p><p>Data Fine-pruning: A Simple Way to Accelerate Neural Network Training<br>prune-epoch和reg-epoch迭代进行，而且也是具有非常多的超参数，一个window包含多个prune-epoch+reg-epoch， 而且每个window最开始的reg epoch都是不一样的; 不同点在于：删除的是loss比较大的bad data本；因为每轮prune多少样本固定，所以可以计算出来时间；而且最后的加速效果只有14%左右</p><p>6-2:<br>Exploring the Memorization-Generalization Continuum in Deep Learning c-score<br><a href="https://github.com/google-research/jax-influence">https://github.com/google-research/jax-influence</a> 判断样本噪音，需要使用test data, 不知道会不会影响最后的加速效果<br>如何区分hard 和noisy的样本，因为hard 样本是有助于提高精度的，但是noisy不是</p><p>6-3：<br>遗忘分数高的样本肯能是困难，也可能是noisy 样本，如何区分它们<br>examples with noisy labels are among the most forgotten examples, along with images with “uncommon” features<br> 现在考虑使用方差，如果是noisy 那么应该波动更大，如果是hard那么损失应该逐渐下降；之后将hard样本+ noisy（对称noisy+非对称noisy）样本 单独提取出来进行分析 (mnist+cifar10)</p><p> 利用数据的重要性来优化其他：增强+batch梯度通信+或者其他与数据相关决定的值！！！！</p><h3 id="毕业参考文献"><a href="#毕业参考文献" class="headerlink" title="毕业参考文献"></a>毕业参考文献</h3><p><a href="https://zhuanlan.zhihu.com/p/400344124">https://zhuanlan.zhihu.com/p/400344124</a> （code NIPS 21）<br><a href="https://github.com/mansheej/data_diet">https://github.com/mansheej/data_diet</a> 上文代码</p><p>通过阅读后发现Data Diet是：<br>提前运行多轮，求得每轮的GradN, forget score, l2-loss 然后进行平均后将mean score保留到一个路径之后进行读取来进行数据的选择；也就是需要先验的处理，同时只有最开始的时候使用了loadsubset，之后的训练过程全部使用的subset</p><p><a href="https://scholar.google.com.hk/scholar?cites=6692350500928309521&amp;as_sdt=2005&amp;sciodt=0,5&amp;hl=zh-CN">https://scholar.google.com.hk/scholar?cites=6692350500928309521&amp;as_sdt=2005&amp;sciodt=0,5&amp;hl=zh-CN</a><br>Accelerating Deep Learning with Dynamic Data Pruning 提出用强化学习/主动学习来动态查找<br>Improving Contrastive Learning on Imbalanced Data via Open-World Sampling(新领域 code NIPS21)</p><h3 id="之后打算"><a href="#之后打算" class="headerlink" title="之后打算"></a>之后打算</h3><p>背景+相关工作一章</p><p>设计一章（框架图+每个部分图表，描述每个部分怎么做）</p><p>实验一章（暂时将之前的实验拿过来）</p><p>尽量将这个事情做深一点</p><p>6-4<br>分析不同epoch的噪音和hard样本的损失， 方差， 或者是forget event的关系<br>猜测hard example损失逐渐减少， forget event几乎为0<br>noisy样本的损失波动很大，因为它可能会被相似的样本学习，forget event会更高<br>Learning from Noisy Labels with Complementary Loss Functions 这篇论文中有hard和noisy样本的损失的关系图</p><p>6-16<br>之后毕业论文打算</p><ol><li>进行主要设计部分的编写</li><li>添加流程图、 表</li><li>添加初步实验数据</li></ol><p>将重要性采样算法扩充到分布式训练可能会面临的问题<br>Furthermore, to scale out on multiple GPUs, PaGraph develops a fast GNN-computation-aware partition algorithm to avoid cross-partition access during data-parallel training and achieves better cache efficiency.</p><p>缓存的东西可能没用了，如何解决同时减少通讯时间</p><p>7.31<br>目前打算将去噪音部分加入重要性采样中<br>原来的重要性采样算法调整为低频+高频数据训练</p><p>算法：去噪 去冗余  重要性三个维度<br>底层：缓存，通讯压缩，负载感知调度</p><p>阅读论文：<a href="https://cloud.tencent.com/developer/article/1771809">https://cloud.tencent.com/developer/article/1771809</a></p><p>支持profiler度量性能瓶颈并输出cpu mem, gpu利用率报告<br>支持以插件形式（score函数单独提出来） 1）增加删除采样算法，以及2）使用单标准或者多标准， 3）分段选择样本：冗余，噪音，重要性三重过滤 （参考k8s的实现原理）<br>支持智能决策系统（RL, 启发式）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;毕业论文思路&quot;&gt;&lt;a href=&quot;#毕业论文思路&quot; class=&quot;headerlink&quot; title=&quot;毕业论文思路&quot;&gt;&lt;/a&gt;毕业论文思路&lt;/h3&gt;&lt;p&gt;5-22 毕业论文计划Update&lt;br&gt;看了一下之前写的论文，目前的打算：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;毕业</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>图</title>
    <link href="http://example.com/2022/05/05/leetcode/%E5%9B%BE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2022/05/05/leetcode/%E5%9B%BE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</id>
    <published>2022-05-05T06:43:54.000Z</published>
    <updated>2022-07-31T09:18:33.270Z</updated>
    
    <content type="html"><![CDATA[<h4 id="图相关"><a href="#图相关" class="headerlink" title="图相关"></a>图相关</h4><p>竞赛第四题 hard lc2097. 合法重新排列数对 //暂时没有看</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    map&lt;<span class="hljs-keyword">int</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; mp;<br>    map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; deg;<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; ans;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sn)</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;e = mp[sn]; <span class="hljs-comment">// 注意这个是引用</span><br>        <span class="hljs-keyword">while</span> (!e.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">int</span> fn = e.<span class="hljs-built_in">back</span>();<br>            e.<span class="hljs-built_in">pop_back</span>();<br>            <span class="hljs-built_in">dfs</span>(fn);<br>            ans.<span class="hljs-built_in">push_back</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;&#123;sn, fn&#125;);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//为什么要先dfs再push_back没看明白</span><br><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">validArrangement</span>(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; pairs) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;pair : pairs) &#123;<br>            mp[pair[<span class="hljs-number">0</span>]].<span class="hljs-built_in">push_back</span>(pair[<span class="hljs-number">1</span>]);<br>            deg[pair[<span class="hljs-number">0</span>]]--; deg[pair[<span class="hljs-number">1</span>]]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = deg.<span class="hljs-built_in">begin</span>(); it != deg.<span class="hljs-built_in">end</span>(); it++) <span class="hljs-keyword">if</span> (it-&gt;second == <span class="hljs-number">-1</span>) <span class="hljs-built_in">dfs</span>(it-&gt;first);<br>        <span class="hljs-keyword">if</span> (ans.<span class="hljs-built_in">empty</span>()) <span class="hljs-built_in">dfs</span>(deg.<span class="hljs-built_in">begin</span>()-&gt;first);<br>        <span class="hljs-built_in">reverse</span>(ans.<span class="hljs-built_in">begin</span>(), ans.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h5 id="有关于有向图和无向图的最短路径，以及有负边和无负边的最短路径"><a href="#有关于有向图和无向图的最短路径，以及有负边和无负边的最短路径" class="headerlink" title="有关于有向图和无向图的最短路径，以及有负边和无负边的最短路径"></a>有关于有向图和无向图的最短路径，以及有负边和无负边的最短路径</h5><ol><li><p>Dijstra算法，适用于单源，有向或者无向的最短路径，不能适用于有负边（注意不是负环，负环情况下，无最短路径）的情况：例子：-1， -5， 2<br>时间复杂度O(n^2))</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><br><br><span class="hljs-keyword">int</span> e[Max][Max];<span class="hljs-comment">//e[i][j]代表从i-&gt;j的距离，不通设为无穷大</span><br><span class="hljs-keyword">int</span> dis[Max];<span class="hljs-comment">//dis[i]代表从起点到i的最短距离</span><br><span class="hljs-keyword">bool</span> book[Max];<span class="hljs-comment">//book[i]代表点i是否在S中</span><br><span class="hljs-keyword">int</span> n;<span class="hljs-comment">//n个顶点</span><br><span class="hljs-keyword">int</span> s;<span class="hljs-comment">//起点</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-comment">//初始化dis数组</span><br>        dis[i]=e[s][i];<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-comment">//初始化book数组</span><br>        book[i]=<span class="hljs-number">0</span>;<br>    dis[s]=<span class="hljs-number">0</span>;<br>    book[s]=<span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n<span class="hljs-number">-1</span>;i++)<span class="hljs-comment">//Dijkstra算法核心语句  注意也是n-1次</span><br>    &#123;<br>        <span class="hljs-keyword">int</span> minDis=INF;<br>        <span class="hljs-keyword">int</span> k;<span class="hljs-comment">//找到与s最近的顶点k</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(book[j]==<span class="hljs-number">0</span> &amp;&amp; dis[j]&lt;minDis)<br>            &#123;<br>                minDis=dis[j];<br>                k=j;<br>            &#125;<br>        &#125;<br>        book[k]=<span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<span class="hljs-comment">//“松弛”过程</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(e[k][j]&lt;INF)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(dis[j]&gt;dis[k]+e[k][j])<br>                    dis[j]=dis[k]+e[k][j];<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>Bellman-ford算法：适用于单源，可有负权，有向或者无向的最短路径 记住只松弛n-1次<br>能够检测出有负环情况<br>dp[i][dst]=min(dp[i][dst], dp[i-1][src]+dist[src][dst]) i==1的时候表示经过的中转站为0</p></li></ol><p>时间复杂度O(n*m)/O(VE)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span>&#123;</span><br>    <span class="hljs-keyword">int</span> u;<span class="hljs-comment">//起</span><br>    <span class="hljs-keyword">int</span> v;<span class="hljs-comment">//终</span><br>    <span class="hljs-keyword">int</span> weight;<span class="hljs-comment">//长度</span><br>&#125;;<br><br>Edge edge[maxm];<span class="hljs-comment">//用来存储所有的边</span><br><span class="hljs-keyword">int</span> dis[maxn];<span class="hljs-comment">//dis[i]表示源点到i的最短距离</span><br><span class="hljs-keyword">int</span> n,m;<span class="hljs-comment">//n个点，m条边</span><br><span class="hljs-keyword">int</span> s;<span class="hljs-comment">//源点</span><br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Bellmen_ford</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-comment">//初始化</span><br>        dis[i]=INF;<br><br>    dis[s]=<span class="hljs-number">0</span>;<span class="hljs-comment">//源节点到自己的距离为0</span><br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)<span class="hljs-comment">//松弛过程，计算最短路径 </span><br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++) <span class="hljs-comment">//m条边</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(dis[edge[j].v]&gt;dis[edge[j].u]+edge[j].weight)<span class="hljs-comment">//比较s-&gt;v与s-&gt;u-&gt;v大小</span><br>                dis[edge[j].v]=dis[edge[j].u]+edge[j].weight;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)<span class="hljs-comment">//判断是否有负边权的边</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(dis[edge[j].v]&gt;dis[edge[j].u]+edge[j].weight)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>SPFA算法：是Bellman-ford算法的队列优化，适用于单源，可有负权，有向或者无向的最短路径 （自身其实无法处理负权）<br>设立一个队列用来保存待优化的点，优化时每次取出队首结点u，并且用u点当前的最短路径估计值对u点所指向的结点v进行松弛操作，如果v点的最短路径估计值有所调整，且v点不在当前的队列中，就将v点放入队尾。这样不断从队列中取出结点来进行松弛操作，直至队列空为止。</li></ol><p>注意，一旦从队列中弹出来，vis就设置为false，感觉负权的情况就会一直循环下去，不会跳出；遍历点，与边无关</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><br><br><span class="hljs-keyword">int</span> dis[MAX];<span class="hljs-comment">//dis[i]表示起点到i的最短距离</span><br><span class="hljs-keyword">bool</span> vis[MAX];<span class="hljs-comment">//是否访问过点i</span><br><span class="hljs-keyword">int</span> e[MAX][MAX];<span class="hljs-comment">//矩阵</span><br><br><span class="hljs-keyword">int</span> n,m;<span class="hljs-comment">//点和边的数量</span><br><span class="hljs-keyword">int</span> s;<span class="hljs-comment">//源点</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SPFA</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-comment">//初始化</span><br>    &#123;<br>        dis[i]=INF;<br>        vis[i]=<span class="hljs-literal">false</span>;<br>    &#125;<br>    queue&lt;<span class="hljs-keyword">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(s);<br>    dis[s]=<span class="hljs-number">0</span>;<br>    vis[s]=<span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        <span class="hljs-keyword">int</span> cur=q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        vis[cur]=<span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-comment">//遍历每一个节点</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(e[cur][i]!=INF&amp;&amp;dis[i]&gt;=dis[cur]+e[cur][i])<br>            &#123;<br>                dis[i]=dis[cur]+e[cur][i];<br>                <span class="hljs-keyword">if</span>(!vis[i])<br>                &#123;<br>                    vis[i]=<span class="hljs-literal">true</span>;<br>                    q.<span class="hljs-built_in">push</span>(i);  <span class="hljs-comment">///之后将start缩小的边才拿出来</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>Floyd算法： Floyd算法是一种利用动态规划思想的计算加权图中多源点之间最短路径的算法。可以正确处理有向图或负权的最短路径问题。</li></ol><p>时间复杂度：O(N^3）</p><p>空间复杂度：O(N^2）</p><p>处理问题：多源、可有负权、有向图、无向图最短路径 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> e[Max][Max];<span class="hljs-comment">//e[i][j]代表从i-&gt;j的距离，不通设为无穷大</span><br><span class="hljs-keyword">int</span> n;<span class="hljs-comment">//n个顶点</span><br><span class="hljs-comment">//Floyd算法</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Floyd</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;k++)<span class="hljs-comment">//遍历所有的中间点</span><br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-comment">//遍历所有的起点</span><br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<span class="hljs-comment">//遍历所有的终点</span><br>            &#123;<br>                <span class="hljs-keyword">if</span> (e[i][j]&gt;e[i][k]+e[k][j])<span class="hljs-comment">//如果当前i-&gt;j的距离大于i-&gt;k-&gt;j的距离之和</span><br>                    e[i][j]=e[i][k]+e[k][j];<span class="hljs-comment">//更新从i-&gt;j的最短路径</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最短路衍生拓展的一类题目：</p><ol><li>最长路径问题：<br>图不为非负权图：当存在正环时无解。<br>如果不存在正环，边权取负后使用Bellman-Ford算法求最短路。</li><li>最长路径，但是路径的计算是权重之间的乘积，而且权重都是0-1之间的值，使用Dijstra算法 （e.g概率最大的路径）<br>Solution:<br> 单独使用Dijstra会导致超时，因此需要结合Dijstra+优先队列<br> 1.现将src点push 到堆进行<br> 2.然后遍历堆中的每个节点，如果当前节点能够松弛它的邻接节点，那么就放入堆中，否则不放入类似于SPFA,但是不同的是，<ul><li>这个使用的优先队列，而SPFA是用的是一般的堆</li><li>这个不仅仅push了节点，也push了当前节点的最大概率，因此没有vis数组来标记当前节点是否在堆中，因为即使在堆中， 概率也可能是不一样的。<br>总的来说这道题使用bellman-ford算法更简单，只要当前没有任何松弛的边，那么直接退出循环</li></ul></li></ol><p>颜色交替的最短路径：使用bellman-ford算法（本质是动态规划）， 只是在距离的转换是需要讨论两种情况<br>dstEndWithRed[end]=min(dstEndWithRed[end], dstEndWithBlue[start]+1);<br>dstEndWithBlue[end]=min(dstEndWithBlue[end], dstEndWithRed[start]+1);</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> edge: redEdges)&#123;<br>        <span class="hljs-keyword">int</span> start=edge[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">int</span> end=edge[<span class="hljs-number">1</span>];<br>        dstEndWithRed[end]=<span class="hljs-built_in">min</span>(dstEndWithRed[end], dstEndWithBlue[start]+<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> edge: blueEdges)&#123;<br>        <span class="hljs-keyword">int</span> start=edge[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">int</span> end=edge[<span class="hljs-number">1</span>];<br>        dstEndWithBlue[end]=<span class="hljs-built_in">min</span>(dstEndWithBlue[end], dstEndWithRed[start]+<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>成语接龙的最长，使用bfs，同时对连接好的成语，再来一次bfs (微软三面)<br><font color=red>4. lc787. K 站中转内最便宜的航班</font></li></ol><ul><li>只能最多经过k个中转站的最短路径</li><li>使用bellman-ford算法，k个中转站就是松弛每条边 k+1次(1~k+1)，然后使用dp[i][dst]记录 中转i次的最短路径<br>最后的结果就是在dp[1][dst] 到dp[k+1][dst]中取最小的一个</li></ul><p>lc6134. 找到离给定两个节点最近的节点</p><ul><li>内向基环树</li><li>求出node1 到每个点的距离， 和node2 到每个点的距离，然后取最小 (两次求距离，然后取最小，最后注意返回的是最近的下标，而不是最近的距离)</li></ul><p>PS, 最开始理解的时候，感觉应该用两个节点的最近公共祖先来解决，但是因为图中可能有环，所以不能使用最近公共祖先的栈或者dfs方法解决</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;图相关&quot;&gt;&lt;a href=&quot;#图相关&quot; class=&quot;headerlink&quot; title=&quot;图相关&quot;&gt;&lt;/a&gt;图相关&lt;/h4&gt;&lt;p&gt;竞赛第四题 hard lc2097. 合法重新排列数对 //暂时没有看&lt;/p&gt;
&lt;figure class=&quot;highlight c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>数学相关问题</title>
    <link href="http://example.com/2022/05/05/leetcode/%E6%95%B0%E5%AD%A6%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2022/05/05/leetcode/%E6%95%B0%E5%AD%A6%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</id>
    <published>2022-05-05T06:42:44.000Z</published>
    <updated>2022-07-31T09:18:13.838Z</updated>
    
    <content type="html"><![CDATA[<h5 id="random类似题目总结："><a href="#random类似题目总结：" class="headerlink" title="random类似题目总结："></a>random类似题目总结：</h5><p>rand5 to rand7<br>rand01p to rand6<br>rand1toM to rand1toN</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-number">1</span>）  二维的方式，使得两个调用rand5在二维矩阵上是大于rand7，然后就可以选取<span class="hljs-number">7</span>的倍数的一段距离对rand7取模<br>    <span class="hljs-keyword">do</span>&#123;<br>        row=<span class="hljs-built_in">rand5</span>()<span class="hljs-number">-1</span>;<br>        col=<span class="hljs-built_in">rand5</span>()<span class="hljs-number">-1</span>;<br>        num=row*<span class="hljs-number">5</span>+col <span class="hljs-comment">//0-24之间</span><br>    &#125;<span class="hljs-keyword">while</span>(num&gt;=<span class="hljs-number">21</span>)<br><br>    <span class="hljs-keyword">return</span> num%<span class="hljs-number">7</span>+<span class="hljs-number">1</span>;<br><br></code></pre></td></tr></table></figure><p>2)<br>首先等概率产生0-1  01 10是等概率残生的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rand01</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">do</span>&#123;<br>        num=<span class="hljs-built_in">rand01p</span>();<br>    &#125;<span class="hljs-keyword">while</span>(num==<span class="hljs-built_in">rand01p</span>());<br>    <span class="hljs-keyword">return</span> num;<br>&#125;<br><br>那么rand03=<span class="hljs-built_in">rand01</span>()*<span class="hljs-number">2</span>+<span class="hljs-built_in">rand01</span>();<br>rand0<span class="hljs-number">-15</span>=<span class="hljs-built_in">rand03</span>()*<span class="hljs-number">4</span>+<span class="hljs-built_in">rand03</span>(); <span class="hljs-comment">//倍数+插空  用进制的方法可以产生rand07()=rand03()+rand01()*4</span><br>那么rand6可由如下产生:<br><span class="hljs-keyword">do</span>&#123;<br>    num=rand0<span class="hljs-number">-15</span>;<br>&#125;<span class="hljs-keyword">while</span>(num&gt;=<span class="hljs-number">12</span>)<br><span class="hljs-keyword">return</span> num%<span class="hljs-number">6</span>+<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>3）k维的方式<br>rand1toM()转为rand1toN()其实就是调用k次（用N的M进制可以求得）的rand1toM, 使得这a* M^(k-1)+b* M^(k-2)+……  +c 比n要小， 然后返回就可以了<br>其实就是用M进制的数来表示N-1，如果随机生成的数是大于N，那么从头进行生成（注意是从头，而不是从当前数重新生成），否则返回这个数<br>步骤：<br>   1、将n-1转换成m进制数，假设结果转换成数组为 k = [a,b,c,d,e]<br>　　2、使用rand1ToM(m)函数产生结果数组 res = [A,B,C,D,E]，如果res所表示的数值大于k所表示的数值，将res丢掉重新随机，直到产生的结果小于或等于k，这时产生的res的范围就在0～n-1之间，但是此时res所表示的数还是m进制的。 //随机生成M进制的每一位数<br>　　3、将res数组转换成10进制整数。<br>　　4、将步骤3的结果加1就是最终的结果。</p><h5 id="数学相关例题"><a href="#数学相关例题" class="headerlink" title="数学相关例题"></a>数学相关例题</h5><ol><li>求num阶层中最后的包含0的个数，因为包含因子2的个数一定比5多，因此可以直接求包含因子5的个数<br>每5个数有一个5，每25个数中有一个数包含两个5<br>同样下面的模板可以用于求任何因子的个数<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(num)&#123;<br>        res+=num/<span class="hljs-number">5</span>;<br>        num=num/<span class="hljs-number">5</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><font color=blue>2. 判断一个点是否在矩形中：叉乘+点乘</font><br>对角向量叉积的点积&gt;=0,（对角向量的叉积方向相同），使用叉积的原因是：一个点在线外还是在线内，叉积的正负不同<br>使用叉积可以判断方向，A = &lt;a1, a2&gt;，B = &lt;b1, b2&gt;<br>AXB=a1* b2-a2 *b1, 叉积向量的方向为法线的方向，上下为第一个向量指向第二个向量，大手指的方向<br>叉乘加内积</li></ol><p>(p1 p2 X p1 p ) * (p3 p4 X p3 p1)  &gt;= 0  （四个边分成两组，每两个对边一组， 看两边的叉积是否同方向）</p><p><font color=blue>3. 相同的题型：判断点是否在三角形中 叉乘</font><br>1）先判断三个点的顺序是否是逆时针方向:逆时针方向叉积小于0；顺时针方向叉积大于等于（注意顺序可能导致结果不同！！！）；如果是顺时针正方向，那么调整点位置<br>2）然后判断这个点x是否都是在三角形每条边的左边，判断过程：三角形每个顶点和边的叉积小于0</p><p>（逆时针，点左侧；判断逆时针，仍然使用点左侧）</p><p>求三个三角形不推荐，因为double类型可能出现误差</p><p><font color=red>4. 路径数组转为统计数组的题目：原地hash, 注意以负数作为标记的话，全部的数都需要转为正数</font><br>要求额外的空间复杂度为O(1)<br>如果要实现空间复杂度为O(1),那么需要在原来的数据上进行运算，那么每个位置存储跳过来的位置（最开始节点存储为-1），直到当前的数为一个负数（表示已经求过距离），然后跳回去的时候就知道来的位置，同时更新当前的距离，<br>为了区分已经判断过的值和未判断过的值，使用负数；求到距离矩阵之后再计算每个距离出现的次数，仍然是使用跳的方式，开始节点记得赋值为0，表示已经访问计算过</p><p>这种方式也出现在”第一个未出现的正数“这道题解决方案中（值与下标相互映射）</p><ol start="5"><li>正数数组的最小不可组成和：<br>dp[0][0]=1<br>使用动态规划<br>for j=0; j=arr.size(); j++:<br> for i = sum to min: //注意反着,因为一个数只能取一次0-1背包<pre><code> if(i&gt;=arr[j]):     dp[i]=dp[i-arr[j]]?True:dp[i]//注意是dp[i]而不是false,也不是dp[i]=dp[i-arr[i]]//因为可能一个数一种方式可以组成，但是另一种不行</code></pre></li></ol><p>PS:没有思路就想暴力算法，然后递归考虑是否能转为动态规划，类似背包问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++">dp[i][j]=dp[i<span class="hljs-number">-1</span>][j-arr[i]]||dp[i<span class="hljs-number">-1</span>][j];<br><br><span class="hljs-keyword">for</span> i in min to sum:<br>    <span class="hljs-keyword">if</span> dp[n][i] == <span class="hljs-literal">false</span>:<br>        <span class="hljs-keyword">return</span> i<br></code></pre></td></tr></table></figure><ol start="6"><li>累加出整个范围最少还需要的数:<br>使用当前可以累加得到的范围，如果范围超过了当前遍历到的arr的第一个数，那么下一个可以累加得到的范围是当前的范围+arr[i];否则下一个差的数应该是touch+1,可以累加得到的数是touch+1+touch</li></ol><p>可以累加得到的数是touch,下一个差的数是touch+1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++">touch=<span class="hljs-number">0</span>;<br>cnt=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;arr.<span class="hljs-built_in">size</span>();i++)&#123;<br>    <span class="hljs-keyword">if</span>(touch+<span class="hljs-number">1</span>&lt;arr[i])&#123;<br>        <span class="hljs-keyword">while</span>(touch&lt;arr[i]+<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//注意这是循环</span><br>            touch+=touch+<span class="hljs-number">1</span>;<br>            cnt++;<br>            <span class="hljs-keyword">if</span>(touch&gt;=range)&#123;<br>                <span class="hljs-keyword">return</span> cnt;<br>            &#125;<br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        touch+=arr[i];<br>        <span class="hljs-keyword">if</span>(touch&gt;=range)&#123;<br>            <span class="hljs-keyword">return</span> cnt;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">while</span>(touch&lt;range)&#123;<br>        touch+=touch+<span class="hljs-number">1</span>;<br>        cnt++;    <br>&#125;<br><br>    <span class="hljs-keyword">return</span> cnt;<br></code></pre></td></tr></table></figure><ol start="7"><li>一种字符串和数字对应的关系 （lc168. Excel表列名称）<br>A -&gt; 1<br>B -&gt; 2<br>C -&gt; 3<br>…<br>Z -&gt; 26<br>AA -&gt; 27<br>AB -&gt; 28<br>从 1开始的的 2626 进制转换题。（每一位至少都有1）</li></ol><ul><li><p>方法1：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++">string res=<span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">while</span>(columnNumber&gt;<span class="hljs-number">0</span>)&#123;<br>    columnNumber--;<br>    res+=(columnNumber%<span class="hljs-number">26</span>+<span class="hljs-string">&#x27;A&#x27;</span>);<br>    columnNumber/=<span class="hljs-number">26</span>;<br>&#125;<br><span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>());<br><span class="hljs-keyword">return</span> res;<br></code></pre></td></tr></table></figure></li><li><p>方法2：注意是K伪进制数，也就是每一个伪至少为1不能为0，因此需要先从右往左计算位数（同时每一位分得1, 因为这个规则每一位至少都有1），然后从左往右分剩下的数字 </p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//先从右往左，减掉一轮，再从左往右看补在哪为 进制如果为3：base=1 3 9</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">int2str</span><span class="hljs-params">()</span></span>&#123;<br>    cur=<span class="hljs-number">1</span>;<span class="hljs-comment">//代表进制的基数</span><br>    k=<span class="hljs-number">0</span><span class="hljs-comment">//代表位数</span><br>    base=<span class="hljs-number">3</span><span class="hljs-comment">//代表进制数，多少个字符就是多少进制</span><br>    <span class="hljs-keyword">while</span>(n&gt;=cur)&#123;<br>        k++;<br>        n-=cur;<br>        cur*=base;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> index=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(k)&#123;<br>        cur/=base;<br>        res[index++]=<span class="hljs-built_in">getchar</span>(n/cur);  <span class="hljs-comment">//当前base的数量应该为n/cur+1,对应的下标就是n/cur</span><br>        n=n%cur; <span class="hljs-comment">//剩下的数可以分多少到下一个进制位中</span><br>        k--;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>str2int类似于K进制</p><p>从N个数中等概率打印M个数,空间复杂度为O(1)：将每次打印的数每次交换到整个数组的末尾，然后下次在生成随机数的时候，减少生成范围（1，n-count）</p><ol start="8"><li>数字的中文表达和英文表达：</li></ol><ul><li>1.中文表达：对于零特殊处理</li><li>2.英文表达：每三个一组进行处理；使用递归或者迭代。递归方式就是分别求出billion million和thousand三个部分的数字，然后加起来，<br>在求每个部分的时候，先判断百位，如果百位有数字的话，那么加上”hundred“,否则分为数字&lt;=10 &lt;20; &lt;=20 &lt;100 and &lt;10 三种情况进行处理</li></ul><ol start="9"><li>实现sqrt函数</li></ol><ul><li><p>方法一：使用二分算法（一个数的平方根不会大于 n/2+1），标准二分，返回right</p></li><li><p>方法二：牛顿迭代算法： y=f(x0)+k(x-x0)<br>令y=0, 得到 x_i+1=(x_i+ C/x_i)  其中C为要求的目标</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">double</span> C = x, x0 = x;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">double</span> xi = <span class="hljs-number">0.5</span> * (x0 + C / x0);<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(x0 - xi) &lt; <span class="hljs-number">1e-7</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            x0 = xi;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(x0);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><ol start="10"><li>小数的十进制转为二进制是*2 取整数部分，如果整数&gt;=1, 那么num-=1,否则当前位为0， 直到num=0; 也可以1连除2，num如果num&gt;base,那么减去base<br>十进制整数转换为二进制整数采用”除2取余，逆序排列”法<br>十进制小数转换成二进制小数采用”乘2取整，顺序排列”法</li></ol><ol start="11"><li>全排列问题，使用交换或者vis+回溯，一定要注意是否有重复的字符，如果有重复的字符，那么下一个交换或者选择的数，一定是当前没有选择的 （可以和当前自己位置进行交换）</li></ol><p><font color=red>12. 树状数组例题：数字流的秩 线段树（平衡树+二叉搜索树，需要初始化4*n区间） 使用频繁更新数组的某一位（后面的位数也需要相应修改），以及求前缀和</font><br>线段树和树状数组的基本功能都是在某一满足结合律的操作(比如加法，乘法，最大值，最小值)下，O(logn)的时间复杂度内修改单个元素并且维护区间信息。不同的是，树状数组只能维护前缀“操作和”(前缀和，前缀积，前缀最大最小)，而线段树可以维护区间操作和。线段数组是真正的数，而树状数组只是一个数组</p><p>树状数组主要是用于求前缀和，（改变原始然后求前缀和；差分数组适用于，某一段的元素被整体加上或者减去一个元素）</p><ul><li>区间查询：求index的前缀和其实就是不断将index的二进制数的最后一个一个1逐渐变为0 的数据对应的值相加；（x-(x&amp;-x)）//不断地去掉二进制数最右边的一个1 （从x到=n）</li><li>单点修改：更新一个index需要更新的其他下标的值相当于 不断加上最后一个1所代表的数字下标对应的值（x+(x&amp;-x)）//从右边起一系列连续的1变为0，再把这一系列1的前一位0变为1,相当与最后一个1+1，导致连续进位<br>其中存储值的下标从1开始，0下标主要是判断循环的终点，不被用来存储值 （从x到0）</li></ul><p>而且树状数组的下标从1开始，常用语频繁更新和频繁求前缀和</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++">建立树状数组：<br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">int</span> a[<span class="hljs-number">1005</span>],c[<span class="hljs-number">1005</span>]; <span class="hljs-comment">//对应原数组和树状数组</span><br><span class="hljs-comment">//范围是[1,n]</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> x&amp;(-x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">updata</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> k)</span></span>&#123;    <span class="hljs-comment">//在i位置加上k</span><br>    <span class="hljs-keyword">while</span>(i &lt;= n)&#123;<br>        c[i] += k;<br>        i += <span class="hljs-built_in">lowbit</span>(i);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getsum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;        <span class="hljs-comment">//求A[1 - i]的和</span><br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i &gt; <span class="hljs-number">0</span>)&#123;<br>        res += c[i];<br>        i -= <span class="hljs-built_in">lowbit</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>树状数组如果输入有0， 那么所有的输入都应该向右边偏移以为（输入x，实际上对应x+1）</p><p>例题：lc5999. 统计数组中好三元组数目<br>这道题是求在一个数的左边，同时小于这个数的数量（数量题）<br>lc307. 区域和检索 - 数组可修改</p><ul><li>这道题是，频繁的修改某个下标的元素值+同时求某个范围元素之间的元素和（值题目）</li><li>数组的大小为arr的范围n， 下标对于树状数组的二进制下标</li><li>需要先将num的值插入树状数组中， 然后更新的时候使用newvalue-ori[index]来更新当前节点后面的值，同时一定要记得更新ori[index]=newvalue !!!!</li><li>一定要记得树状数组的下标是从1开始，但是num的下标从0开始；而且区间范围是两边闭合，所以求区间差的时候，left_index应该减1</li></ul><p><font color=red>lc315. 计算右侧小于当前元素的个数（hard）</font></p><ul><li>注意这道题数据可能为负数，因此需要对数据+10000+1 使数据shift到[1, +无穷]</li><li>使用归并排序，每个i, j 那么num[i]+=j-i-1 (就是在i后面而且比nums[i]小的数的数量)<br>归并排序易错点：需要使用索引数组,同时在进行归并的时候会修改索引数组，一定要记得复制一个新的数组出来，不能使用原来的数组；其次就是注意数组的范围，左右都闭合；归并排序还长用于计算逆序对</li></ul><p>lc493. 翻转对(hard)</p><ul><li>归并排序</li><li>范围映射的树状数组（具体代码可见模板代码）</li></ul><ol start="13"><li>最佳直线，使用暴力枚举的方式， 三重循环<br>枚举直线两个起始端点(i, j)，后面遍历k是否在直线(i, j)上，在的话计算过得点个数进行更新， 最后判断这条直线上最多有多少个同点<br>时间复杂度：O(n^3)<br>空间复杂度：O(1)O(1)</li></ol><ol start="14"><li>枚举题：模式匹配问题，暂时未做，主要是通过a和b的数量来枚举a匹配的字符的长度和b字符的长度，主要是注意边界情况应该先于长度的枚举进行判断<br>example： pattern = “abba”, value = “dogcatcatdog”<br>注意：pattern只包含字母”a”和”b”两种字符， 而且a或者b可以为空串， 而且a 与b映射的字符串不应该相等<br>lena lenb都为0; lena为0; lenb为0;lena lenb都不为0时， 他们映射的字符串不应该相等</li></ol><ol start="15"><li>大数相乘的题目</li></ol><ul><li>使用第二个数的每一位数和第一个数相乘&lt;&lt; i 位，然后将求得的结果相加</li><li>使用第一个数的每一位和第二个数相乘，更新结果的 arr[i+k]位</li></ul><ol start="16"><li>矩形覆盖面积： 公式为area1+area2-inter_area<br>inter_area = max((最小 右上横坐标 - 最大左下横坐标), 0)* max(（最小右上纵坐标 -  最大左下纵坐标, 0)</li></ol><p>注意一定要和0进行比较</p><ol start="16"><li>找众数II:</li></ol><ul><li>使用hash算法</li><li>使用摩尔投票算法</li></ul><p>找到超过 (n/3) 向下取整的数：数学证明这样的数最多2个，选两个数，如果当前的数都不等于前两个数，那么两个投票数都–<br>这种投票算法同样适用于找到超过 n/2</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">majorityElement</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; ans;<br>        <span class="hljs-keyword">int</span> element1 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> element2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> vote1 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> vote2 = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp; num : nums) &#123;<br>            <span class="hljs-keyword">if</span> (vote1 &gt; <span class="hljs-number">0</span> &amp;&amp; num == element1) &#123; <span class="hljs-comment">//如果该元素为第一个元素，则计数加1</span><br>                vote1++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (vote2 &gt; <span class="hljs-number">0</span> &amp;&amp; num == element2) &#123; <span class="hljs-comment">//如果该元素为第二个元素，则计数加1</span><br>                vote2++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (vote1 == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 选择第一个元素</span><br>                element1 = num;<br>                vote1++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (vote2 == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 选择第二个元素</span><br>                element2 = num;<br>                vote2++;<br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//如果三个元素均不相同，则相互抵消1次</span><br>                vote1--;<br>                vote2--;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> cnt1 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> cnt2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp; num : nums) &#123;<br>            <span class="hljs-keyword">if</span> (vote1 &gt; <span class="hljs-number">0</span> &amp;&amp; num == element1) &#123;<br>                cnt1++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (vote2 &gt; <span class="hljs-number">0</span> &amp;&amp; num == element2) &#123;<br>                cnt2++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 检测元素出现的次数是否满足要求</span><br>        <span class="hljs-keyword">if</span> (vote1 &gt; <span class="hljs-number">0</span> &amp;&amp; cnt1 &gt; nums.<span class="hljs-built_in">size</span>() / <span class="hljs-number">3</span>) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(element1);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (vote2 &gt; <span class="hljs-number">0</span> &amp;&amp; cnt2 &gt; nums.<span class="hljs-built_in">size</span>() / <span class="hljs-number">3</span>) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(element2);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><ol start="17"><li>为运算表达式计算优先级<br>使用分治算法, 遍历表达式，找到运算符，将结果分成两个部分， 递归查找。类似二叉树的组成方式查找<br>如果求具体的结果，那么需要使用vector将结果进行push_back,否则可以直接使用动态规划，计算总数</li></ol><ol start="18"><li>摆动序列 如果是需要相邻两个数不能等于的话，只能两个字符串都进行翻转，如果可以相邻等于的话，可以后面的字符串进行翻转就行了 </li></ol><ol start="19"><li><p>中文变为阿拉伯数字和阿拉伯数字变为中文<br>1.中文变为阿拉伯数字<br>使用栈，将文字划分为数字和量纲，遇到量纲，那么从栈中弹出与当前量纲小的数字与当前量纲相乘，然后不断累加，知道栈为空或者栈顶量纲比当前量纲大，然后将当前累加到的数压入栈中；最后的结果就是栈中的数求和</p><p>2.阿拉伯数字变为中文<br>注意：亿，万节之后如果只有0那么不需要输出0，如果千位为0的话那么需要输出0<br>10500，一万零五百， 15000一万五千</p><p>将数组划分为节，然后每节使用一个函数判断<br>如果不是第一节，而且当前的数是大于0，而且小于1000的话那么需要加零</p></li></ol><ol start="20"><li>面试题 16.14. 最佳直线/149. 直线上最多的点数</li></ol><ul><li>暴力方法：使用三重循环，前两个点固定一条直线，后一个点判断是否在直线上，是cnt++,最后找最大的cnt</li><li>hash方法，使用二重循环，遍历两个点，两个点得到一个斜率，然后hash_map中存储该斜率的cnt, 最后取最大值的时候res=max(res, cnt+1)//一定记得+1<br>  因为gcd(5, 0)=5=cd(0, 5) 所以不存在除0情况<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> a = x1 - x2, b = y1 - y2;<br><span class="hljs-keyword">int</span> k = <span class="hljs-built_in">gcd</span>(a, b);<br>String key = (a / k) + <span class="hljs-string">&quot;_&quot;</span> + (b / k); <span class="hljs-comment">//斜率用string存储</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> b == <span class="hljs-number">0</span> ? a : <span class="hljs-built_in">gcd</span>(b, a % b);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><ol start="21"><li>阶层之后的零</li></ol><ul><li> 方法1， 直接计算，n是5的倍数的个数+25倍数个数+…<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> pow=<span class="hljs-number">5</span>;<br><span class="hljs-keyword">while</span>(n&gt;=pow)&#123;<br>    cnt+=n/pow;<br>    pow=pow*<span class="hljs-number">5</span>;<br>&#125;<br><span class="hljs-keyword">return</span> cnt;<br></code></pre></td></tr></table></figure></li><li>方法2， 对1-n中的每一个数计算，能够拆分为多少个5的因子<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">int</span> tmp=i;<br><span class="hljs-keyword">while</span>(tmp%<span class="hljs-number">5</span>==<span class="hljs-number">0</span>)&#123;<br>    tmp=tmp/<span class="hljs-number">5</span>;<br>    cnt++;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><ol start="22"><li>lc277. find-the-celebrity</li></ol><ul><li>所有的人都认识名人，名人谁都不认识，找出名人</li><li>假设法，O(n), 假设0是名人，如果遇到knows(0, i)==true, 说明0不是名人，同时说明[0~i-1]都不是名人，因为他们都不被0知道</li><li>之后再判断一次，如果出现know(ans, i)==true||know(i, ans)==false, 返回-1</li></ul><ol start="23"><li>欧拉筛法/埃及筛法求n以内的质数的个数/一个数的包含的因数的个数</li></ol><p><a href="http://oi-wiki.com/math/number-theory/sieve/#_10">http://oi-wiki.com/math/number-theory/sieve/#_10</a></p><h4 id="蓄水池抽样算法"><a href="#蓄水池抽样算法" class="headerlink" title="蓄水池抽样算法"></a>蓄水池抽样算法</h4><p>模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Solution</span>(ListNode* head) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;head=head;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getRandom</span><span class="hljs-params">()</span> </span>&#123;<br>        ListNode*cur=<span class="hljs-keyword">this</span>-&gt;head;<br>        <span class="hljs-keyword">int</span> pool=<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(cur)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">rand</span>()%i==<span class="hljs-number">0</span>)pool=cur-&gt;val; <span class="hljs-comment">//只选取一个数的情况</span><br>            i++;<br>            cur=cur-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pool;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    ListNode*head;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>例题：</p><ol><li>链表随机节点</li><li>随机索引数 ，找到target数的随机一个index</li></ol><h4 id="摩尔投票算法"><a href="#摩尔投票算法" class="headerlink" title="摩尔投票算法"></a>摩尔投票算法</h4><p>1.求众数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> target_num=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>    <span class="hljs-keyword">if</span>(k==<span class="hljs-number">0</span>)&#123;<br>        target_num=nums[i];<br>        k=<span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">if</span>(nums[i]==target_num)&#123;<br>            k++;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            k--;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//判断target_num的数是否大于n/2;</span><br><span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>    <span class="hljs-keyword">if</span>(nums[i]==target_num)&#123;<br>        cnt++;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">if</span>(cnt&gt;n/<span class="hljs-number">2</span>)&#123;<br>    <span class="hljs-keyword">return</span> target_num;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.求大于n/3 的数<br>这样的数最多只有两个</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> k1=<span class="hljs-number">0</span>;<span class="hljs-comment">//投票的数量</span><br><span class="hljs-keyword">int</span> k2=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> target_num1;<span class="hljs-comment">//具体的数</span><br><span class="hljs-keyword">int</span> target_num2;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>    <span class="hljs-keyword">if</span>(k1&gt;<span class="hljs-number">0</span>&amp;&amp;target_num1==nums[i])&#123;<br>        k1++;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(k2&gt;<span class="hljs-number">0</span>&amp;&amp;target_num2==nums[i])&#123;<br>        k2++;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(k1==<span class="hljs-number">0</span>)&#123;<br>        target_num1=nums[i];<br>        k1=<span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(k2==<span class="hljs-number">0</span>)&#123;<br>        target_num2=nums[i];<br>        k2=<span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        k1--;<br>        k2--;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">int</span> cnt1=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> cnt2=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>    <span class="hljs-keyword">if</span>(k1&gt;<span class="hljs-number">0</span>&amp;&amp;nums[i]==target_num1)&#123;<br>        cnt1++;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(k2&gt;<span class="hljs-number">0</span>&amp;&amp;nums[i]==target_num2)&#123;<br>        cnt2++;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">if</span>(cnt1&gt;n/<span class="hljs-number">3</span>)&#123;<br>    res.<span class="hljs-built_in">push_back</span>(target_num1);<br>&#125;<br><span class="hljs-keyword">if</span>(cnt2&gt;n/<span class="hljs-number">3</span>)&#123;<br>    res.<span class="hljs-built_in">push_back</span>(target_num2);<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;random类似题目总结：&quot;&gt;&lt;a href=&quot;#random类似题目总结：&quot; class=&quot;headerlink&quot; title=&quot;random类似题目总结：&quot;&gt;&lt;/a&gt;random类似题目总结：&lt;/h5&gt;&lt;p&gt;rand5 to rand7&lt;br&gt;rand01p </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Zsim编译</title>
    <link href="http://example.com/2022/04/26/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/zsim%E7%BC%96%E8%AF%91/"/>
    <id>http://example.com/2022/04/26/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/zsim%E7%BC%96%E8%AF%91/</id>
    <published>2022-04-26T13:05:06.000Z</published>
    <updated>2022-07-31T09:18:13.862Z</updated>
    
    <content type="html"><![CDATA[<h4 id="服务器环境"><a href="#服务器环境" class="headerlink" title="服务器环境"></a>服务器环境</h4><p>ubuntu18.04下gcc7.5.0</p><h4 id="主要参考文档"><a href="#主要参考文档" class="headerlink" title="主要参考文档"></a>主要参考文档</h4><p>步骤文档：<br><a href="https://blog.csdn.net/yy1348046572/article/details/118194214">https://blog.csdn.net/yy1348046572/article/details/118194214</a><br>注意使用sudo make &amp;&amp; sudo make install</p><p>安装zsim版本：<a href="https://github.com/SteveY4ng/zsim">https://github.com/SteveY4ng/zsim</a></p><p>除此之外，自己加了一个env.sh文件来添加环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">BASEDIR=$(<span class="hljs-built_in">pwd</span>)<br>PINPATH=<span class="hljs-variable">$BASEDIR</span>/pin-2.14<br>ZSIMPATH=<span class="hljs-variable">$BASEDIR</span>/zsim<br>LIBCONFIGPATH=/nfs/home/siling/zsim/zsim-ubuntu18_04/libconfig-1.7.3<br>HDF5PATH=/nfs/home/siling/zsim/zsim-ubuntu18_04/hdf5-1.12.0<br><span class="hljs-built_in">export</span> CPATH=<span class="hljs-string">&quot;/usr/include/hdf5/serial/&quot;</span><br><span class="hljs-built_in">export</span> ZSIMPATH PINPATH LIBCONFIGPATH POLARSSLPATH<br><span class="hljs-built_in">export</span> CXX=g++ CC=gcc<br></code></pre></td></tr></table></figure><h4 id="遇到的问题及解决"><a href="#遇到的问题及解决" class="headerlink" title="遇到的问题及解决"></a>遇到的问题及解决</h4><p>在安装hdf5使用源文件，出错，因此使用的命令安装 sudo apt-get install libhdf5-dev<br><a href="https://blog.csdn.net/tianminggenie/article/details/110921264">https://blog.csdn.net/tianminggenie/article/details/110921264</a></p><p>遇到的问题1：<br>can’t find file #include&lt;hdf5.h&gt;<br>解决方案：<br>在env.sh中加上<br>export CPATH=”/usr/include/hdf5/serial/“</p><p>遇到的问题2：<br>Cannot find -lhdf5_hl and -lhdf5<br>解决方案：<br>cd /usr/lib/x86_64-linux-gnu<br>\然后根据情况执行下面两句：<br>sudo ln -s libhdf5_serial.so.10.1.0 libhdf5.so<br>sudo ln -s libhdf5_serial_hl.so.10.0.2 libhdf5_hl.so</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;服务器环境&quot;&gt;&lt;a href=&quot;#服务器环境&quot; class=&quot;headerlink&quot; title=&quot;服务器环境&quot;&gt;&lt;/a&gt;服务器环境&lt;/h4&gt;&lt;p&gt;ubuntu18.04下gcc7.5.0&lt;/p&gt;
&lt;h4 id=&quot;主要参考文档&quot;&gt;&lt;a href=&quot;#主要参考文档&quot;</summary>
      
    
    
    
    <category term="工具相关" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/04/26/cplusDNN/project_dnn_cplusplus/Readme/"/>
    <id>http://example.com/2022/04/26/cplusDNN/project_dnn_cplusplus/Readme/</id>
    <published>2022-04-26T05:21:19.828Z</published>
    <updated>2022-04-26T05:21:20.394Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Repo-主要是用c-实现的CNN的小项目"><a href="#Repo-主要是用c-实现的CNN的小项目" class="headerlink" title="Repo 主要是用c++实现的CNN的小项目"></a>Repo 主要是用c++实现的CNN的小项目</h2><h3 id="1-已经完成的功能"><a href="#1-已经完成的功能" class="headerlink" title="1. 已经完成的功能"></a>1. 已经完成的功能</h3><ul><li>用C++实现了CNN的卷积， BN, ReLU层，实现了BN和ReLU的反向传播（还没有调试）</li><li>实现了conv-bn-relu的融合</li><li>运行方式：在main文件的路径下执行:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make clean &amp;&amp; make &amp;&amp; ./main<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-TODO-List"><a href="#2-TODO-List" class="headerlink" title="2. TODO List:"></a>2. TODO List:</h3><ul><li>conv类的反向传播，以及BN, Relu类反向传播的测试</li><li>实现全连接层和损失函数</li><li>用一个实际的train/inference 例子判断计算出来的结果是否相同</li><li>使用 OpenMP, TBB 来进行多线程的加速运算</li><li>分析计算效率（真实计算FLOPS/理论FLOPS）</li></ul><p>backward函数的实现：<br>// <a href="https://zhuanlan.zhihu.com/p/61898234">https://zhuanlan.zhihu.com/p/61898234</a><br>// loss关于y的导数（上一层的x的导数）：原图的delta误差，等于卷积结果的delta误差经过零填充后，与卷积核旋转180度后的卷积<br>// 卷积中w的导数，二维卷积核的导数等于原图对应通道与卷积结果对应通道的delta误差直接进行卷积。<br>// b的导数(列向量)：在反向传播时，它的导数等于卷积结果的delta误差在每一个通道上将所有delta误差进行求和的结果。</p><h3 id="3-文件功能介绍："><a href="#3-文件功能介绍：" class="headerlink" title="3. 文件功能介绍："></a>3. 文件功能介绍：</h3><ul><li>base_layer.cpp base_layer.h: 主要包含matrix以及base_layer的定义<br>  其中matrix 封装一个4维矩阵（4维vector实现），可以传入[batch_size, channel_size, m_size, m_size], 返回用0，或者随机0-1的元素初始化(rand_flag=true)的4维矩阵； base_layer作为其他具体某层的父类，每个具体的类都应该实现类的前传和反传函数</li><li>conv_layer.cpp conv_layer.h: 主要实现了Convolution类</li><li>bn_layer.cpp bn_layer.h: 主要实现了BatchNormalization类</li><li>relu_layer.cpp relu_layer.h: 主要实现了ReLU类</li></ul><h3 id="4-有时间再优化"><a href="#4-有时间再优化" class="headerlink" title="4. 有时间再优化"></a>4. 有时间再优化</h3><p>目前版本使用C++进行卷积的实现，用的4维vector, 为了加速内存的读取效率，可以转化为二维矩阵的运算，使用img2col 以及gemm来进行实现<br>可以参考的文献：</p><ul><li><p><a href="https://zhuanlan.zhihu.com/p/90301095">https://zhuanlan.zhihu.com/p/90301095</a></p></li><li><p><a href="http://giantpandacv.com/academic/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E5%8F%8A%E8%B7%9F%E8%B8%AA/Darknet/%E5%9F%BA%E4%BA%8ECS231N%E5%92%8CDarknet%E8%A7%A3%E6%9E%90BatchNorm%E5%B1%82%E7%9A%84%E5%89%8D%E5%90%91%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/">http://giantpandacv.com/academic/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E5%8F%8A%E8%B7%9F%E8%B8%AA/Darknet/%E5%9F%BA%E4%BA%8ECS231N%E5%92%8CDarknet%E8%A7%A3%E6%9E%90BatchNorm%E5%B1%82%E7%9A%84%E5%89%8D%E5%90%91%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/</a></p></li></ul><p>其他参考文献：</p><ul><li><a href="https://sc18.supercomputing.org/proceedings/tech_poster/poster_files/post155s2-file2.pdf">https://sc18.supercomputing.org/proceedings/tech_poster/poster_files/post155s2-file2.pdf</a></li><li><a href="https://computing.llnl.gov/tutorials/openMP/">https://computing.llnl.gov/tutorials/openMP/</a></li><li>Darknet的C实现: <a href="https://github.com/pjreddie/darknet.git">https://github.com/pjreddie/darknet.git</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Repo-主要是用c-实现的CNN的小项目&quot;&gt;&lt;a href=&quot;#Repo-主要是用c-实现的CNN的小项目&quot; class=&quot;headerlink&quot; title=&quot;Repo 主要是用c++实现的CNN的小项目&quot;&gt;&lt;/a&gt;Repo 主要是用c++实现的CNN的小项目</summary>
      
    
    
    
    <category term="cplusDNN" scheme="http://example.com/categories/cplusDNN/"/>
    
    <category term="project_dnn_cplusplus" scheme="http://example.com/categories/cplusDNN/project-dnn-cplusplus/"/>
    
    
  </entry>
  
  <entry>
    <title>Macos相关环境配置</title>
    <link href="http://example.com/2022/04/23/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/Macos/"/>
    <id>http://example.com/2022/04/23/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/Macos/</id>
    <published>2022-04-23T04:00:05.000Z</published>
    <updated>2022-04-26T05:21:29.530Z</updated>
    
    <content type="html"><![CDATA[<p>macos上下载brew:<br>/bin/zsh -c “$(curl -fsSL <a href="https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot;">https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot;</a></p><p>macos vscode 配置 opencv(C++)</p><p>切换opencv的版本：<br><a href="https://zhuanlan.zhihu.com/p/121721651">https://zhuanlan.zhihu.com/p/121721651</a></p><p>vscode配置opencv4:<br><a href="https://codeantenna.com/a/VAayPeG1xI">https://codeantenna.com/a/VAayPeG1xI</a></p><p>vscode 配置opencv2</p><p>C++使用虚函数一定要记得加上一个大括号：<br>virtual void forward(matrix &amp;input_matrix, matrix &amp;output_matrix){}; 对<br>virtual void forward(matrix &amp;input_matrix, matrix &amp;output_matrix); 错误</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;macos上下载brew:&lt;br&gt;/bin/zsh -c “$(curl -fsSL &lt;a href=&quot;https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&amp;quot;&quot;&gt;https://gitee.com/</summary>
      
    
    
    
    <category term="工具相关" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/"/>
    
    
  </entry>
  
  <entry>
    <title>Hard题目集合</title>
    <link href="http://example.com/2022/04/10/leetcode/hard%E9%A2%98%E7%9B%AE%E5%90%88%E9%9B%86/"/>
    <id>http://example.com/2022/04/10/leetcode/hard%E9%A2%98%E7%9B%AE%E5%90%88%E9%9B%86/</id>
    <published>2022-04-10T08:41:22.000Z</published>
    <updated>2022-07-31T09:18:13.812Z</updated>
    
    <content type="html"><![CDATA[<h3 id="枚举-二分"><a href="#枚举-二分" class="headerlink" title="枚举+二分"></a>枚举+二分</h3><p>lc6040. 花园的最大总美丽值</p><ul><li>主要是在求partial的最小超时, 还有就是一个long long数据类型注意！！</li><li>法一: 从右到左，先枚举完善花园数目，再计算不完善花园数据可以获得的最大<br>解决方案：使用二分+前缀和来求增加后的最小值，而不是一个一个遍历(空间复杂度O(n))</li></ul><p>-法二: 如果是从左到右计算，可以将空间开销降到O(1)，先计算要让所有的花园变为完善花园还剩下的花的数量（可能为负数），然后遍历的时候一个一个加回去，同时不完善花园数目最小值是逐渐增大，所以可以在之前的结果上累加，不用重头计算</p><ul><li>同样类型的题目，+k使最小的数能够达到的最大值，lc6039. K 次增加后的最大乘积（这道题也可以最小堆+1，一个一个加）</li></ul><p>lc 6066. 统计区间中的整数数目</p><ul><li>区间问题，主要是插入多个区间，如何合并得到最后的不重复的区间</li><li>使用hash start_end，那么每次判断的时候需要和前面一个和后面多个区间进行判断 upper_bound, 前面一个区间就是iter–</li><li>如果使用hash end_start(或者set&lt;pair&lt;end, start&gt;&gt;)那么只需要判断后面的多个可能覆盖的区间   lower_bound， iter++</li><li>每次合并区间，一定记得同时更新l_bound和r_bound</li><li>删除hash中的一个元素，并移动到下一个的正确姿势， hash.erase(iter++);</li><li>加速小技巧：为了不每次count都从头计算一次，可以使用插入的时候维护一个全局ans, 之后count的时候直接返回全局ans就可以了；这种利用先计算打表，后面直接使用的思想在前缀和，hulu面试的（组成平行四边形的个数）也可以体现出来<br>在进行i j两两组合的时候可以将，每组的组合方式求加和提前算出来，之后直接使用前缀和思想减掉0 到 i-1，就是当前i对应的组合方式</li></ul><p>lc6077. 巫师的总力量和</p><ul><li>子数组+区间问题</li><li>找到每个最小数的管辖区间（使用单调栈，同时为了避免出现数可能相等的情况使用了左边&gt;=, 右边&gt;的情况）</li><li>求管辖区间的每个子区间的sum, 使用前缀和的前缀和方法，也就是将右边放到一起，左边放到一起，将（a1-b1）+(a2-b2)+….+<br>= （a1+a2+…+an）-(b1+b2+….+bn) 其中a和b都是代表的前缀和</li><li>递推公式：</li></ul><img src="hard题目合集/image-20220522153532000.png" alt="image-20220522153532000" style="zoom:50%;" /><ul><li>补充类似的题目：</li></ul><ol start="907"><li>子数组的最小值之和</li><li>子数组最小乘积的最大值</li><li>子数组范围和<br>都是使用单调栈求一个数作为最大值或者最小值的管辖范围（找到该数i左右两边第一个比这个数，或者大的数）然后包含数i的区间就有（r-i）*(i-l)个，其中r,l都是不包含在区间内，所以不需要+1</li></ol><p>lc 6094. 公司命名</p><ul><li><p>题意，从字典中随便找两个单词，如果找到的单词交换首字母后，新单词都没在字典中出现过，那么res++, 问最后的res是多少</p></li><li><p>解决方案：先遍历一次字典每个单词，计算一个数组cnt[i][j], 表示将字典中单词首字母为 i+’a’ 转为j+’a’，且未在字典中出现的个数，那么结果就是再次遍历字典的每个单词, 将首字母换为26个字母中任意一个，如果该单词没在字典中出现过 则res+=cnt[j][i]</p></li><li><p>利用枚举+互补思想，如果一个单词转为另外一个首字母可行，那么就要判断以另外这个字母为首字母的单词，转为当前单词首字母 一共有多少种情况</p></li><li><p>优化点: 在vector O(n)里面查找的时间复杂度远远高于在set O(1)中，所以如果针对频繁在vec中查找的情况，可以将其转到set中查找</p></li></ul><p>lc903. DI 序列的有效排列</p><ul><li>这道题主要的难点在于使用映射，而不是vis数组来表示已经访问的数据</li><li>得到动态转移方程<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span>(s[i<span class="hljs-number">-1</span>]==<span class="hljs-string">&#x27;D&#x27;</span>)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=j;k&lt;i;k++)&#123; <span class="hljs-comment">//注意这是j to i-1 不是j+1到i, 因为i-1的时候是取不到 i的，因为有一个映射</span><br>        dp[i][j]+=dp[i<span class="hljs-number">-1</span>][k];<br>        dp[i][j]%=MOD;<br>    &#125;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;j;k++)&#123;<br>        dp[i][j]+=dp[i<span class="hljs-number">-1</span>][k];<br>        dp[i][j]%=MOD;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>lc730. 统计不同回文子序列</p><ul><li><p>难点在于使用动态规划找不重复的</p></li><li><p>解决方案：分情况讨论 s[i]， s[j]是否相等 ， 当相等的时候，s[i], s[j]之间有几个和s[i]相同的字符<br><img src="hard%E9%A2%98%E7%9B%AE%E5%90%88%E9%9B%86/image-20220625120018624.png" alt="image-20220625120018624"></p></li></ul><p>lc6109. 知道秘密的人数(显示为medium，但是我感觉类似hard难度)</p><ul><li>一个人知道密码吼，会在[i+delay, i+foraget-1]区间每个时间都告诉一个人， 问第n天知道密码的人</li><li>解决方法：第i天知道密码的人数=第i天新增人数+第i天还没有忘记秘密的人数(但是不是第i天新增的人数)<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>   <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i+delay;j&lt;=<span class="hljs-built_in">min</span>(i+forget<span class="hljs-number">-1</span>, n);j++)&#123;<br>        dp[j]= (dp[j]+dp[i])%MOD; <span class="hljs-comment">// dp[i]表示第i天新增知道的人数</span><br>    &#125; <br>    <span class="hljs-keyword">if</span>(i+forget<span class="hljs-number">-1</span>&gt;=n )&#123;<br>        cnt_a= (cnt_a+dp[i])%MOD; <span class="hljs-comment">//第n天还没有忘记秘密的人数(包括了第n天新增的人数+前面新增且第n天没有忘记)</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> cnt_a % MOD;<br></code></pre></td></tr></table></figure></li><li>类似前缀和的思想， 时间复杂度O(n^2),空间复杂度O(n)</li></ul><p>lc6115. 统计理想数组的数目</p><ul><li><p>我的思路：求dp[i][j][len]的总数，也就是首是i， 尾是j，长度为len的方案的总数， 最后的答案就是 len==n的所有方案总和<br>但是因为O(n^3)所以超时,递推公式如下</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">dp[i][j][len%<span class="hljs-number">2</span>] = (dp[i][j][len%<span class="hljs-number">2</span>] + dp[i][j/k][(len<span class="hljs-number">-1</span>)%<span class="hljs-number">2</span>])%MOD; j/k需要j可以被k整除且j/k&gt;=i<br></code></pre></td></tr></table></figure></li><li><p>官方解答：排列组合题目</p><ol><li>先求到以i结尾的长度为j的个数 dp[i][j]+=dp[k][j-1] k能够被i整除</li><li>再求将长度为n包含互不相同的j个数，一共有多少种方案<br>固定第一个数的方案总数：Cn-1 j-1</li><li>总结就是，找序列不同个数， 找序列不同数的排布</li></ol></li><li><p>关键点，在于找不同数</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;枚举-二分&quot;&gt;&lt;a href=&quot;#枚举-二分&quot; class=&quot;headerlink&quot; title=&quot;枚举+二分&quot;&gt;&lt;/a&gt;枚举+二分&lt;/h3&gt;&lt;p&gt;lc6040. 花园的最大总美丽值&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主要是在求partial的最小超时, 还有就是一个lo</summary>
      
    
    
    
    <category term="leetcode" scheme="http://example.com/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/04/04/dp%E9%97%AE%E9%A2%98%E4%B8%93%E6%A0%8F/DAG+%E6%A0%91%E7%8A%B6+%E5%85%B6%E4%BB%96dp/"/>
    <id>http://example.com/2022/04/04/dp%E9%97%AE%E9%A2%98%E4%B8%93%E6%A0%8F/DAG+%E6%A0%91%E7%8A%B6+%E5%85%B6%E4%BB%96dp/</id>
    <published>2022-04-04T03:54:12.633Z</published>
    <updated>2022-04-05T01:29:14.709Z</updated>
    
    <content type="html"><![CDATA[<p>DAG上的dp</p><p>UVa 437 巴比伦塔 The Tower of Babylon</p><p>这道题求最高的塔，其实就是一个记忆化dfs的过程<br>一些需要注意的点：</p><ol><li>因为不可能出现一个立方体同时叠两次，因此不需要vis</li><li>因为有三种叠法，所以需要3个方向</li><li>因为最开始让谁做底部是不清楚的，所以使用循环遍历方法</li><li>因为一个底确定之后的最高是确定的，因此使用记忆化搜索，避免重复计算</li><li>对于这种题情况多，再加上dfs的题，先分析一两个小的情况（if-else, 三个方向分情况讨论）， 再暴力（dfs）， 再优化（记忆化数组）</li><li>类似最长路问题</li></ol><p>树状dp: dfs+dp<br>主要是针对图有层级结构（没有上司的舞会），或者选择课程这样的dp, 主要是背包和树状dp结合<br>使用dfs+dp</p><ul><li><p>一般解题步骤：</p></li><li><p>先使用dfs记录子节点的状态：dp[i][0]/ dp[i][1]/ dp[i][k]</p></li><li><p>然后计算当前节点的状态转移 (u是父节点， i是子节点)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">dp[u][a+b] = <span class="hljs-built_in">max</span>(dp[u][a+b], dp[u][a]+dp[i][b]) <span class="hljs-comment">//课程的转移方程</span><br>或者<br>dp[u][<span class="hljs-number">0</span>] += <span class="hljs-built_in">max</span>(dp[i][<span class="hljs-number">0</span>], dp[i][<span class="hljs-number">1</span>]); <span class="hljs-comment">//上司的转移方程</span><br>dp[u][<span class="hljs-number">1</span>] += dp[i][<span class="hljs-number">0</span>];<br></code></pre></td></tr></table></figure></li><li><p>例题<br>洛谷 P2014 CTSC1997 选课 （挺难的）</p></li><li><p>加入一门课程，森林转为树，求解dp[0][m+1]</p></li><li><p>我们枚举 u点的每个子结点 ，同时枚举以 i 为根的子树选了几门课程，将子树的结果合并到 u 上。注意这个使用a的取值范围随着访问的子树的数量逐渐增加</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> p = <span class="hljs-number">1</span>;<br>  f[u][<span class="hljs-number">1</span>] = s[u];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : e[u]) &#123;<br>    <span class="hljs-keyword">int</span> siz = <span class="hljs-built_in">dfs</span>(v);<br>    <span class="hljs-comment">// 注意下面两重循环的上界和下界</span><br>    <span class="hljs-comment">// 只考虑已经合并过的子树，以及选的课程数超过 m+1 的状态没有意义</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-built_in">min</span>(p, m + <span class="hljs-number">1</span>); i; i--)<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= siz &amp;&amp; i + j &lt;= m + <span class="hljs-number">1</span>; j++)<br>        f[u][i + j] = <span class="hljs-built_in">max</span>(f[u][i + j], f[u][i] + f[v][j]);  <span class="hljs-comment">// 转移方程</span><br>    p += siz; <span class="hljs-comment">//p逐渐增加</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><p>换根dp: 两次dfs， 找到换根前后dp的转移公式</p><ul><li>树和图dfs不一样，不需要使用vis,只需要记录一下当前index，和当前index的father就能避免访问同一节点</li></ul><p>数位dp感觉比较难</p><p>不要62<br><a href="https://blog.csdn.net/Enjoying_Science/article/details/44082929">https://blog.csdn.net/Enjoying_Science/article/details/44082929</a> 动态规划<br><a href="https://www.cnblogs.com/wenruo/p/4725005.html">https://www.cnblogs.com/wenruo/p/4725005.html</a> 动态规划，解释有点问题<br><a href="http://www.calvinneo.com/2017/09/23/HDU2089%E4%B8%8D%E8%A6%8162/">http://www.calvinneo.com/2017/09/23/HDU2089%E4%B8%8D%E8%A6%8162/</a> dfs<br><a href="https://www.programminghunter.com/article/8939658418/">https://www.programminghunter.com/article/8939658418/</a> dfs</p><ol start="600"><li>不含连续1的非负整数</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;DAG上的dp&lt;/p&gt;
&lt;p&gt;UVa 437 巴比伦塔 The Tower of Babylon&lt;/p&gt;
&lt;p&gt;这道题求最高的塔，其实就是一个记忆化dfs的过程&lt;br&gt;一些需要注意的点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;因为不可能出现一个立方体同时叠两次，因此不需要vis&lt;/li</summary>
      
    
    
    
    <category term="dp问题专栏" scheme="http://example.com/categories/dp%E9%97%AE%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>vscode 配置</title>
    <link href="http://example.com/2022/02/25/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/vscode/"/>
    <id>http://example.com/2022/02/25/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/vscode/</id>
    <published>2022-02-25T01:45:56.000Z</published>
    <updated>2022-04-26T05:52:27.823Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>有关于在macos big sur上配置c/c++程序运行和调试详细步骤：<br>注意需要安装codellb<br><a href="https://blog.csdn.net/weixin_44881648/article/details/111046381">https://blog.csdn.net/weixin_44881648/article/details/111046381</a></p></li><li><p>设置左边菜单栏：（只能通过放大来设置 ctrl+/-）<br>{<br> “editor.fontSize”: 15,<br> “window.zoomLevel”: 0.5,<br>}</p></li></ol><ol start="3"><li>coderunner的设置<br>settings.json里面<br> “code-runner.executorMap”: {<pre><code> &quot;c&quot;: &quot;cd $dir &amp;&amp; gcc $fileName -o $fileNameWithoutExt &amp;&amp; $dir$fileNameWithoutExt&quot;, &quot;cpp&quot;: &quot;cd $dir &amp;&amp; g++ -std=c++11 -stdlib=libc++ $fileName -o $fileNameWithoutExt &amp;&amp; $dir$fileNameWithoutExt&quot;</code></pre> },<br>默认设置（不设置这两句话）运行会报错<br>./forward.cpp:185:42: error: a space is required between consecutive right angle brackets (use ‘&gt; &gt;’)</li></ol><p>下面这个问题是由于运行的不是main函数的文件<br>Undefined symbols for architecture x86_64:<br>  “_main”, referenced from:<br>     implicit entry/start for main executable<br>ld: symbol(s) not found for architecture x86_64<br>clang: error: linker command failed with exit code 1 (use -v to see invocation)</p><p>C文件的编译：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Makefile">cc = gcc<br>prom = calc<br>deps = <span class="hljs-variable">$(<span class="hljs-built_in">shell</span> find ./ -name &quot;*.h&quot;)</span><br>src = <span class="hljs-variable">$(<span class="hljs-built_in">shell</span> find ./ -name &quot;*.c&quot;)</span><br>obj = $(src:%.c=%.o) <br> <br><span class="hljs-variable">$(prom)</span>: <span class="hljs-variable">$(obj)</span><br>    <span class="hljs-variable">$(cc)</span> -o <span class="hljs-variable">$(prom)</span> <span class="hljs-variable">$(obj)</span><br> <br><span class="hljs-section">%.o: %.c <span class="hljs-variable">$(deps)</span></span><br>    <span class="hljs-variable">$(cc)</span> -c <span class="hljs-variable">$&lt;</span> -o <span class="hljs-variable">$@</span><br> <br><span class="hljs-section">clean:</span><br>    rm -rf <span class="hljs-variable">$(obj)</span> <span class="hljs-variable">$(prom)</span><br></code></pre></td></tr></table></figure><p>makefile文件的编写:<br><a href="https://scc.ustc.edu.cn/zlsc/czxt/200910/W020150417520333830657.pdf">https://scc.ustc.edu.cn/zlsc/czxt/200910/W020150417520333830657.pdf</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;p&gt;有关于在macos big sur上配置c/c++程序运行和调试详细步骤：&lt;br&gt;注意需要安装codellb&lt;br&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_44881648/article/details/1110463</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Review Tips</title>
    <link href="http://example.com/2022/02/23/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E9%9D%A2%E8%AF%95tips/"/>
    <id>http://example.com/2022/02/23/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E9%9D%A2%E8%AF%95tips/</id>
    <published>2022-02-23T08:00:36.000Z</published>
    <updated>2022-03-01T05:52:34.744Z</updated>
    
    <content type="html"><![CDATA[<p>实习的时候应该怎么做：<br>写实习日记(internship log),记录你每天在工作中做了什么、遇到哪些困难、你是如何解决的;还可以写参加了哪些会议，你在会议上跟着大boss学到了什么(行业的观念，企业发展方向);还有自己悟出来的道理，比如做行业research时，从龙头公司入手而不是小虾米公司入手，这样更有效率。</p><p>各个案例支持各种结构化面试的答案，比如你如何克服困难。你可以描述实习中你面对大量数据，不会用excel软件整理数据，是如何自学“从入门到精通”的。于是乎简单的学用办公软件的打杂，也变得高端起来。</p><p>面试前好好想想你做过什么、写下来。最好回想一下这些事情，带你的师父教给你了什么?你犯了错误是如何改进的?往往你“犯错-被骂-修改”的这个过程，就是你迅速成长的过程。</p><p>有一种可能，就是实习真的啥也没做，在办公室呆了两个月!可是真正求职的时候，这两个月的办公室经验也是可以派得上用场的!辣么，如何把你什么都没干的实习，说得收获很大一样呢?<br>你可以结合自己的性格，以及在办公室/行业内所学所见，从侧面推荐自己。比如，你做了销售实习，你跟着你的师父去拜访客户，其实也不是你的事情，其实你们根本就吃了闭门羹，啥也没推销出去。可是这个时候，你可以说，你的实习，磨练了你的耐心和耐性、善于沟通、你知道销售工作的礼仪、你勇于尝试去啃难啃的客户和业务。</p><p>就是在一项简单的工作中也要有自己的想法和工作的处理方式，或许在整理资料这样的小事中你也有自己的经验，但是没有提炼成方法论。</p><p>总结：</p><ol><li>思考小事后面学到的方法，逻辑，展现自己的学习能力和潜力；提炼一套方法论</li><li>将每件小事写出自己学到了什么；将每件做对的事写出自己的之后如何经一部优化；自己做错的事，下次如何避免改进，进步；遇到困难如何解决</li><li>自学linux, 在pytorch官网上进行留言， 在stackoverflow上寻找答案；rpc自学，自学231n；了解了岗位和业务需求，从需求出发</li><li>项目优缺点</li></ol><p>项目如何包装：</p><p>遇到的最大挑战或者困难，令人印象深刻的项目或者工作经历<br>建议围绕“背景—我的定位—主要价值—当时挑战和我的解法”的框架展开，</p><p>目标检测任务：<br>困难：小目标，目标不均衡，漏检问题和精度较低<br>最开始学习和了解目标检测的时候，就要完成这个红绿灯交通标志模型的训练。为了完成这样一个任务，我需要快速上手使用公司内部的算法框架训练一个初步模型，同时通过阅读论文和源码了解目标检测模型训练的一些细节<br>在这个过程中因为最初上手公司算法框架和学习目标检测的原因，我也遇到了一些困难，比如最开始的模型训练精度非常差，于是我从数据的输入格式进行检验，从验证输入，到调试查看内部的输入输出是否正常，查找错误的原因，最后发现，因为算法框架内部存在一个错误，内部是硬编码的格式输入，使得传入的参数失效，因此输出结果错误；之后了解到主要还是由于公司并没有将数据处理这块代码进行统一规范化，导致不同人维护一个不同的代码repo，我从仓库里面拷贝的版本是已经过时的，因此在训练会出现这样一个错误。<br>除此之外，导致模型精度差的原因主要是由于数据中小目标和数据量差距大，有的类别数量本身就非常少，因此拉低整体训练精度，要解决这个问题，我主要是在模型训练方法进行了改进，我了解到多尺度的输入，以及FPN可以很好解决小目标的问题，focal loss可以解决样本不均衡的问题，因此在训练时候选择了多尺度输入方式，带有FPN网络和focal loss的损失函数来解决这些问题。之后精度上升到一个比较满意的阈值，但是还不够好。最后就是在一些参数的设定上进行微调，找到一个最佳的训练参数。这个我主要是通过先抓住影响精度几个重要参数值，然后在这几个参数上进行尝试调整，使用表格记录+控制变量方式搜索。最后达到一个较为满意的结果。但是我觉得在参数搜索这一块我还可以尝试一些自动化搜索的方式进行进一步优化。</p><p>个人研究方向的挑战：<br>样本重要性算法部分的设计：1）如何确定样本的动态变化重要性， 设计了一种基于历史值+异步更新的方式计算样本重要性； 2）缓存的设计主要不是我做的，但是主要的思路是小根堆，同时需要周期更新这个堆，因此样本重要性变化，可能会导致建立的堆无效，使用一种COW的思想，在重建堆的时候还是使用之前的重要性来置换，之后建好了再替换；cache size是一个需要在实验中验证的参数</p><p>将重要性采样算法引入IO为瓶颈的场景本身就是一个挑战，这主要是因为目前没有相关在重要性采样结合系统架构的研究工作，现在的算法主要还是关注计算减少量上减少。第二个就是样本的重要性本身就是动态变化的，如果要减少IO就只能尽可能少将数据取到内存进行计算，那么如何更新样本的重要性。这个问题第一个初步解决方案就是使用历史的重要性，就是将之前的重要性延迟更新，这样话的可以提前根据样本的重要性确定样本取不取，但是这种方式也是有局限的，也并没有解决本质问题，而且可能引入新的问题就是历史值使用多久，以及历史值的偏差对精度影响。因此我在此基础上进行改进，使用了一个在存储端计算的思想，就是利用在PFS中，利用近存储端的计算资源进行计算，保障了重要性实时性，同时为IO时间的减少提供了机会。当然这种方法，也会引入存储端模型同步和重要性同步的通信时间，但是通过理论实验数据证明，多数情况下这个时间比重复数据的传输时间小，因此是可以接受的。除此之外，为了解决针对IO的重要性算法适应范围窄的问题，我在此基础上设计了一个自适应选择算法框架，就是将现有的算法融合进来，通过profile确定瓶颈，然后选择对应最佳采样策略，使得算法使用更广。</p><p>难点：进行缓存设计的时候，如何让多进程访问缓存，以及在分布式场景中如何设计缓存<br>使用rpc进行存储和计算端进程之间的通信</p><p>毕业设计的挑战：<br>如何判断哪些参数是冗余的，因此可以删除，哪些是重要的，需要被保留。<br>保留精度敬克能不受影响，最大化压缩率<br>training，pruning，fine-tuning三段式<br>这个问题我主要是通过阅读大量相关文献，得到确定参数的一种常用方法，就是使用L1-正则，通过实验我认为这种方法是比较有效的，因此选用了这种方式；第二个就是参数删除的比例，这个我主要是通过敏感性分析的方式，通过固定其他层，调整某一层，查看设置不同比例对精度的影响来确定，然后predifined确定剪枝的参数；还有一种是automatic的方式，比如ADC（Automated deep compression）方法，根据不同需求（如保证精度还是限制计算量），利用强化学习来学习每一层最优的sparsity ratio</p><p>其他思考：<br>在裁剪后加入可以撤回的这个步骤，那么在精度影响较大的时候，仍然可以恢复回来 （mask/可以扩充的剪枝方案）<br>自动剪枝，使用强化学习<br>将精度、能量消耗和数据一起作为输入，一次裁剪得到多个合适模型<br><a href="https://cloud.tencent.com/developer/article/1631704">https://cloud.tencent.com/developer/article/1631704</a> 比较全面介绍+未来方向指明（2020）</p><p>NUS项目设计的挑战：<br>确定项目选题，也就是挖掘什么的之间关系是比较困难的，因为挖掘的内容一方面需要有心意，那么选择的可能是看似没有什么有关的项目，一方面就是如何天马星空，就可能最后面临失败的结果<br>因此选择的项目必须本身要具有研究的意义</p><h4 id="1-面试官在每个环节重点关注的点"><a href="#1-面试官在每个环节重点关注的点" class="headerlink" title="1. 面试官在每个环节重点关注的点"></a>1. 面试官在每个环节重点关注的点</h4><p>问项目：是否真实，表达能力<br>要把细节表达清楚，而不是面试官问啥答啥，因为对方不了解这个工作<br>日常多看一下工作中的难点与challenges，变为自己的</p><p>做算法：<br>正确的思路<br>corner case（易错点）的设计情况，要设想各种可能的情况（一面的面试官比较关注corner case，二面面试官和三面面试官都比较时空复杂度）<br>    corner case的设计：<br>    有重复无重复元素<br>    奇数还是偶数<br>    是否需要解决输入空格<br>    是否需要解决输入有溢出或者最后的结果有溢出<br>    是否需要担心输入包括0 或者负数<br>    空链表<br>    栈是否为空<br>    空/非法/正负/溢出</p><p>沟通能力：做算法时要多沟通细节，沟通自己不懂的地方<br>代码风格</p><p><a href="https://gxin.yuque.com/docs/share/5eb3fa50-61f3-4b41-ad02-8d88ca29a1d1#">https://gxin.yuque.com/docs/share/5eb3fa50-61f3-4b41-ad02-8d88ca29a1d1?#</a> 别人的整理，重点！！！！</p><p>为什么想要加入这个公司</p><p>在面试得时候一定要思路清晰，在没有想清楚之前不要轻易开口</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;实习的时候应该怎么做：&lt;br&gt;写实习日记(internship log),记录你每天在工作中做了什么、遇到哪些困难、你是如何解决的;还可以写参加了哪些会议，你在会议上跟着大boss学到了什么(行业的观念，企业发展方向);还有自己悟出来的道理，比如做行业research时，从</summary>
      
    
    
    
    <category term="项目相关" scheme="http://example.com/categories/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="review tips" scheme="http://example.com/tags/review-tips/"/>
    
  </entry>
  
  <entry>
    <title>多线程</title>
    <link href="http://example.com/2022/01/26/leetcode/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"/>
    <id>http://example.com/2022/01/26/leetcode/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/</id>
    <published>2022-01-26T04:19:28.000Z</published>
    <updated>2022-03-02T03:53:22.049Z</updated>
    
    <content type="html"><![CDATA[<h3 id="semaphore-信号量"><a href="#semaphore-信号量" class="headerlink" title="semaphore 信号量"></a>semaphore 信号量</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">#<span class="hljs-keyword">include</span> &lt;semaphore.h&gt;<br>sem_t sem1;<span class="hljs-comment">//进行变量申明</span><br><br>sem<span class="hljs-constructor">_init(&amp;<span class="hljs-params">sem1</span>, 1, 0)</span>; <br>第一个参数：指向的信号对象<br>第二个参数：控制信号量的类型，如果其值为<span class="hljs-number">0</span>，就表示信号量是当前进程的局部信号量，否则信号量就可以在多个进程间共享<br>第三个参数：信号量sem的初始值<br><br>sem<span class="hljs-constructor">_post(&amp;<span class="hljs-params">sem1</span>)</span> 信号量值加<span class="hljs-number">1</span><br><br>sem<span class="hljs-constructor">_wait(&amp;<span class="hljs-params">sem1</span>)</span> 信号量值减<span class="hljs-number">1</span><br><br>sem<span class="hljs-constructor">_destroy(&amp;<span class="hljs-params">sem1</span>)</span> 信号量销毁<br></code></pre></td></tr></table></figure><h3 id="互斥锁和条件变量（可以实现一个进程打印5次，另外一个进程打印1次的场景）"><a href="#互斥锁和条件变量（可以实现一个进程打印5次，另外一个进程打印1次的场景）" class="headerlink" title="互斥锁和条件变量（可以实现一个进程打印5次，另外一个进程打印1次的场景）"></a>互斥锁和条件变量（可以实现一个进程打印5次，另外一个进程打印1次的场景）</h3><p>C++： condition_variable C: pthread_cond_t<br>条件变量的一个例子，讲得很详细：<a href="https://blog.csdn.net/jinking01/article/details/110362483">https://blog.csdn.net/jinking01/article/details/110362483</a></p><p>讲述conditon_variable的一个例子：<a href="https://segmentfault.com/a/1190000006679917">https://segmentfault.com/a/1190000006679917</a> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++">伪代码<br>condition_variable cond;<br>mutex p_lock;<br><span class="hljs-keyword">int</span> count=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">process1</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *args)</span></span>&#123;<br>  <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>    p_lock.<span class="hljs-built_in">lock</span>();<br>    count++;<br>    <span class="hljs-keyword">if</span>(count%<span class="hljs-number">5</span>==<span class="hljs-number">0</span>)&#123;<br>      cond.<span class="hljs-built_in">cond_signal</span>(&amp;cond);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>      <span class="hljs-built_in">printFunction</span>(<span class="hljs-string">&quot;this is process 1&quot;</span>);<br>    &#125;<br>    p_lock.<span class="hljs-built_in">unlock</span>();<br><br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">process2</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *args)</span></span>&#123;<br>  <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        p_lock.<span class="hljs-built_in">lock</span>();<br>        <span class="hljs-built_in">cond_wait</span>(&amp;cond);<span class="hljs-comment">//锁内部</span><br>        <span class="hljs-built_in">printFunction</span>(<span class="hljs-string">&quot;this is process 2&quot;</span>);<br>        p_lock.<span class="hljs-built_in">unlock</span>();t<br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>生产者-消费者问题<br>读者-写者问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">sem_t</span> full;<br><span class="hljs-keyword">sem_t</span> empty;<br><span class="hljs-keyword">sem_t</span> mutex;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Producer</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>      <span class="hljs-built_in">down</span>(&amp;empty);<br>      <span class="hljs-built_in">down</span>(&amp;mutex);<br>      <span class="hljs-built_in">produce_item</span>();<br>      <span class="hljs-built_in">up</span>(&amp;mutex);<br>      <span class="hljs-built_in">up</span>(&amp;full);<br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Consumer</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>      <span class="hljs-built_in">down</span>(&amp;full);<br>      <span class="hljs-built_in">down</span>(&amp;mutex);<br>      <span class="hljs-built_in">produce_item</span>();<br>      <span class="hljs-built_in">up</span>(&amp;mutex);<br>      <span class="hljs-built_in">up</span>(&amp;empty);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>读者-写者问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">sem_t</span> data_mutex;<br><span class="hljs-keyword">sem_t</span> count_mutex;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Reader</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>      <span class="hljs-built_in">down</span>(&amp;count_mutex);<br>      count++;<br>      <span class="hljs-keyword">if</span>(count==<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-built_in">down</span>(&amp;data_mutex);<br>      &#125;<br>      <span class="hljs-built_in">up</span>(&amp;count_mutex);<br><br>      <span class="hljs-built_in">read</span>();<span class="hljs-comment">//没有单独加数据锁</span><br><br>      <span class="hljs-built_in">down</span>(&amp;count_mutex);<br>      count--;<br>      <span class="hljs-keyword">if</span>(count==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">up</span>(&amp;data_mutex);<br>      &#125;<br>      <span class="hljs-built_in">up</span>(&amp;count_mutex);<br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">riter</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>      <span class="hljs-built_in">down</span>(&amp;data_mutex);<br>      <span class="hljs-built_in">produce_item</span>();<br>      <span class="hljs-built_in">up</span>(&amp;data_mutex);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>1.<br>引入条件变量一个就是为了避免为了查看条件是否成立而不断轮询的情况<br>总结：互斥锁实现的是线程之间的互斥，条件变量实现的是线程之间的同步。<br>初始化条件变量<br>pthread_cond_t cond = PTHREAD_COND_INITIALIZER;</p><p>该函数用来在一个ConditionVariable上阻塞等待，做以下三步操作：①释放Mutex；②阻塞等待；③当被唤醒时，重新获得Mutex并返回。<br>int pthread_cond_wait(pthread_cond_t &amp;cond_name, pthread_mutex_t &amp;mutex_name);</p><p>唤醒等待线程<br>pthread_cond_signal()：用于唤醒在该条件变量下等待的一个线程，至于哪个被唤醒，取决于线程的优先级和调度策略。<br>pthread_cond_broadcast()：用于唤醒在某个ConditionVariable 上等待的所有线程。使用这种方法时，瞬间唤醒的线程数过多，资源请求过大，容易导致系统不稳定。<br>int pthread_cond_signal(pthread_cond_t &amp;cond_name);<br>int pthread_cond_broadcast(pthread_cond_t &amp;cond_name);</p><ol start="2"><li>和信号量的区别：<br>条件变量的提出是为了解决互斥锁中的循环等待问题，其希望引入一种挂起、唤醒的机制来实现cpu的高效利用<br>（1）使用条件变量可以一次唤醒所有等待者，而这个信号量没有的功能，感觉是最大区别。<br>（2）信号量是有一个值（状态的），而条件变量是没有的，没有地方记录唤醒（发送信号）过多少次，也没有地方记录唤醒线程（wait返回）过多少次。</li></ol><ol start="3"><li>注意！！！！<br>条件变量被通知后，挂起的线程就被唤醒，但是唤醒也有可能是假唤醒，或者是因为超时等异常情况，所以被唤醒的线程仍要检查条件是否满足，所以 wait 是放在条件循环里面。cv.wait(lock, [] { return ready; }); 相当于：while (!ready) { cv.wait(lock); }。</li></ol><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><ol><li>为了实现两个函数的交替打印，可以使用信号量，也可以使用交替锁</li><li>交替打印 FooBar</li></ol><p>solution 1:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++">func1:<br><span class="hljs-built_in">sem_wait</span>(&amp;sem_foo);<br><span class="hljs-built_in">printFoo</span>();<br><span class="hljs-built_in">sem_post</span>(&amp;sem_bar);<br><br><span class="hljs-function">func2</span><br><span class="hljs-function"><span class="hljs-title">sem_wait</span><span class="hljs-params">(&amp;sem_bar)</span></span>;<br><span class="hljs-built_in">printBar</span>();<br><span class="hljs-built_in">sem_post</span>(&amp;sem_foo);<br></code></pre></td></tr></table></figure><p>solution 2 互斥锁（不建议用这种解法，在不同线程加锁解锁确实会出问题）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++">func1:<br>mutex lock1, lock2; <span class="hljs-comment">//这里锁类似条件变量</span><br><br>lock1.<span class="hljs-built_in">lock</span>();<br><span class="hljs-built_in">printFoo</span>();<br>lock2.<span class="hljs-built_in">unlock</span>();<br><br>func2<br>lock2.<span class="hljs-built_in">lock</span>();<br><span class="hljs-built_in">printBar</span>();<br>lock1.<span class="hljs-built_in">unlock</span>();<br></code></pre></td></tr></table></figure><ol start="2"><li>实现一个线程安全的队列<br>在多个线程进行push的时候需要加锁，在push的时候通知pop的线程可以pop<br>使用trypop，如果加锁，判断队列为空，那么直接返回，否则调用pop //不用try pop那么可能出现阻塞<br>pop函数使用使用条件锁 m_cond, 在pop的时候也需要加锁 //在多进程需要使用条件变量，虽然判断了是否为empty再进入的pop，因为可能时间片被其他线程占用导致当前没有元素pop<br>empty(), 加锁判断队列里面是否有元素</li></ol><p>使用条件变量判断队列里面是否有元素，才能pop</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>ok<br>生成者-消费者需要两个信号量用于同步，一个用于给数据加锁<br>条件变量主要是用于达到了某个条件通知另外的进程可以做某件事（5对1，或者队列pop push）<br>读者-写者，写者加数据锁（信号量），读者只需要加count锁，因为多个读者可以同时读<br>队列这种，pop先判断是否为空，为空直接返回；不为空还需要等待条件变量，放置pop的时候被其他pop抢占，或者多个同时判断不为空，但是只有一个元素情况</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;semaphore-信号量&quot;&gt;&lt;a href=&quot;#semaphore-信号量&quot; class=&quot;headerlink&quot; title=&quot;semaphore 信号量&quot;&gt;&lt;/a&gt;semaphore 信号量&lt;/h3&gt;&lt;figure class=&quot;highlight reas</summary>
      
    
    
    
    <category term="leetcode" scheme="http://example.com/categories/leetcode/"/>
    
    
    <category term="多线程并发， 信号量， 互斥锁" scheme="http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%EF%BC%8C-%E4%BF%A1%E5%8F%B7%E9%87%8F%EF%BC%8C-%E4%BA%92%E6%96%A5%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>分布式训练</title>
    <link href="http://example.com/2022/01/26/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%AD%E7%BB%83/"/>
    <id>http://example.com/2022/01/26/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%AD%E7%BB%83/</id>
    <published>2022-01-26T02:50:50.000Z</published>
    <updated>2022-02-14T10:03:35.528Z</updated>
    
    <content type="html"><![CDATA[<h3 id="资料："><a href="#资料：" class="headerlink" title="资料："></a>资料：</h3><p>一个pytorch 分布式 单机多卡/多机多卡的例子<br><a href="https://github.com/lesliejackson/PyTorch-Distributed-Training">https://github.com/lesliejackson/PyTorch-Distributed-Training</a></p><p>常见分布式训练讲解，但是主要命令是启动单机多卡，而不是多机多卡 包括slum, apex, horovod<br><a href="https://github.com/tczhangzhi/pytorch-distributed">https://github.com/tczhangzhi/pytorch-distributed</a> </p><p>pytorch DDP介绍<br><a href="https://zhuanlan.zhihu.com/p/76638962">https://zhuanlan.zhihu.com/p/76638962</a></p><p><a href="https://github.com/richardkxu/distributed-pytorch">https://github.com/richardkxu/distributed-pytorch</a> （也有多机多卡的命令）</p><p>可能会用到：<br>两个机器之间相互免密登录：<a href="https://blog.csdn.net/u010391029/article/details/51126210">https://blog.csdn.net/u010391029/article/details/51126210</a></p><p>DDP time breakdown<br><a href="https://discuss.pytorch.org/t/how-to-measure-ddp-time-breakdown/78925">https://discuss.pytorch.org/t/how-to-measure-ddp-time-breakdown/78925</a><br><a href="https://discuss.pytorch.org/t/how-to-measure-ddp-time-breakdown/78925">https://discuss.pytorch.org/t/how-to-measure-ddp-time-breakdown/78925</a><br><a href="https://discuss.pytorch.org/t/calculating-flops-of-a-given-pytorch-model/3711/4">https://discuss.pytorch.org/t/calculating-flops-of-a-given-pytorch-model/3711/4</a> FLOPS计算</p><p>多进程logging和mkdir设置，分布式inferenc/ 分布式训练的一些小技巧</p><p><a href="https://zhuanlan.zhihu.com/p/250471767">https://zhuanlan.zhihu.com/p/250471767</a> </p><blockquote><p>包括的内容1. 在DDP中引入SyncBN<br>2. DDP下的Gradient Accumulation的进一步加速<br>3. 多机多卡环境下的inference加速<br>4. 保证DDP性能：确保数据的一致性<br>5. 和DDP有关的小技巧<br>6. 1. 控制不同进程的执行顺序<br>   2. 避免DDP带来的冗余输出</p></blockquote><p>Ray分布式执行框架  PyTorch + Ray Tune 调参<br><a href="https://blog.csdn.net/tszupup/article/details/112059788">https://blog.csdn.net/tszupup/article/details/112059788</a></p><p>分布式相关论文源码<br><a href="https://github.com/msr-fiddle/pipedream">https://github.com/msr-fiddle/pipedream</a>  pipedream源码 mini-bath parallism<br><a href="https://github.com/kakaobrain/torchgpipe">https://github.com/kakaobrain/torchgpipe</a></p><p>pytorch分布式训练的时候保存一定要用model.module<br><a href="https://blog.csdn.net/comway_Li/article/details/107531165">https://blog.csdn.net/comway_Li/article/details/107531165</a> 一些需要注意的地方</p><p>horovod多机多卡<br><a href="http://chaopeng.name/2020/01/03/horovod%E5%A4%9A%E6%9C%BA%E5%A4%9A%E5%8D%A1%E5%90%AF%E5%8A%A8%E6%8C%87%E5%8D%97/">http://chaopeng.name/2020/01/03/horovod%E5%A4%9A%E6%9C%BA%E5%A4%9A%E5%8D%A1%E5%90%AF%E5%8A%A8%E6%8C%87%E5%8D%97/</a></p><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ol><li>DP和DDP区别<br>DP是单进程多线程数据并行，将模型copy到每个设备，scatter数据到每个设备进行计算后，将多个GPU输出传到master device(一般为设备0)进行损失计算，（可以优化一下：将loss作为forward 一部分，这样的话每个GPU上自行计算loss，而不用进行模型输出的传输）将损失结果（分发的是各个GPU分别对应的loss）传给每个设备进行反向传播，每个设备将反向传播后的梯度到主设备进行汇聚求平均，然后replicate一份模型的参数到每个设备中，重复上诉的训练过程。</li></ol><ol start="2"><li><p>DDP中all reduce与PS<br> DDP （all reduce）同步的是梯度，不是参数<br> PS，传给master的是梯度，返回的是参数</p><p> 思考：对不重要的梯度进行累积后同步/直接不同步（会不会造成模型的不一致）</p></li><li><p>同步代码<br>分布式训练源代码解读：<a href="https://zhuanlan.zhihu.com/p/343951042">https://zhuanlan.zhihu.com/p/343951042</a></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">手动同步梯度<br><span class="hljs-keyword">for</span> param <span class="hljs-keyword">in</span> ddp_model.parameters<span class="hljs-literal">()</span>: <br>dist.all<span class="hljs-constructor">_reduce(<span class="hljs-params">param</span>.<span class="hljs-params">grad</span>.<span class="hljs-params">data</span>, <span class="hljs-params">op</span>=<span class="hljs-params">dist</span>.<span class="hljs-params">reduce_op</span>.SUM)</span><br>    param.grad.data /= world_size <br><br>手动同步参数：<br>在不重要的样本反向传播后但是不同步参数后，同步梯度<br><span class="hljs-keyword">for</span> param <span class="hljs-keyword">in</span> ddp_model.parameters<span class="hljs-literal">()</span>: <br>dist.all<span class="hljs-constructor">_reduce(<span class="hljs-params">param</span>.<span class="hljs-params">data</span>, <span class="hljs-params">op</span>=<span class="hljs-params">dist</span>.<span class="hljs-params">reduce_op</span>.SUM)</span><br>    param.data /= world_size <br></code></pre></td></tr></table></figure></li></ol><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><h4 id="solution-1-atom版本"><a href="#solution-1-atom版本" class="headerlink" title="solution 1 - atom版本"></a>solution 1 - atom版本</h4><p>裸机 多节点 atom平台</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /workspace/mnt/storage/anchao/ac_file/traffic_iteration/SupreVision &amp;&amp; \<br>./install.sh &amp;&amp; \<br>python -m torch.distributed.launch \<br>        --nnode=4 \<br>        --node_rank=0 \<br>        --nproc_per_node=8 \<br>        --master_addr=<span class="hljs-string">&quot;10.244.55.30&quot;</span> \<br>        --master_port=23467 \<br>        tools/train.py \<br>        --config_file configs/YOLOv3/opencv_pelee_reorg.yml \<br>        SOLVER.IMS_PER_BATCH <span class="hljs-string">&quot;16&quot;</span> \<br>        MODEL.DEVICE_ID <span class="hljs-string">&quot;(&#x27;0,1,2,3,4,5,6,7&#x27;)&quot;</span> \<br>        &gt; detection0.log 2&gt;&amp;1<br></code></pre></td></tr></table></figure><p>单机多卡</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /workspace/mnt/storage/anchao/ac_file/traffic_iteration/SupreVision &amp;&amp; \<br>./install.sh &amp;&amp; \<br>CUDA_VISIBLE_DEVICES=3,4,5,6 python -m torch.distributed.launch \<br>                --nproc_per_node=2 \<br>                --master_port=$((RANDOM + <span class="hljs-number">20000</span>)) \<br>                ./imagenet_final_train_master.py \<br>                --config_file configs/YOLOv3/opencv_pelee_reorg.yml \<br>                &gt; detection0.log 2&gt;&amp;1<br></code></pre></td></tr></table></figure><h4 id="solution-2-简洁版"><a href="#solution-2-简洁版" class="headerlink" title="solution 2 - 简洁版"></a>solution 2 - 简洁版</h4><p>多机多卡<br>suppose we have two machines and one machine have 4 gpus<br>In multi machine multi gpu situation, you have to choose a machine to be master node.<br>we named the machines A and B, and set A to be master node</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">script run at A<br><br>python -m torch.distributed.launch --nproc_per_node=4 --nnode=2 --node_rank=0 --master_addr=A_ip_address master_port=29500 main.py ... <br><br>script run at B<br><br>python -m torch.distributed.launch --nproc_per_node=4 --nnode=2 --node_rank=1 --master_addr=A_ip_address master_port=29500 main.py ... <br></code></pre></td></tr></table></figure><p>单机多卡</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python -m torch.distributed.launch --nproc_per_node=ngpus --master_port=29500 main.py ... <br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;资料：&quot;&gt;&lt;a href=&quot;#资料：&quot; class=&quot;headerlink&quot; title=&quot;资料：&quot;&gt;&lt;/a&gt;资料：&lt;/h3&gt;&lt;p&gt;一个pytorch 分布式 单机多卡/多机多卡的例子&lt;br&gt;&lt;a href=&quot;https://github.com/leslieja</summary>
      
    
    
    
    <category term="工具相关" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/"/>
    
    
  </entry>
  
  <entry>
    <title>md语法相关</title>
    <link href="http://example.com/2022/01/20/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/md%E8%AF%AD%E6%B3%95%E7%9B%B8%E5%85%B3/"/>
    <id>http://example.com/2022/01/20/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/md%E8%AF%AD%E6%B3%95%E7%9B%B8%E5%85%B3/</id>
    <published>2022-01-20T04:11:13.000Z</published>
    <updated>2022-02-14T10:03:35.528Z</updated>
    
    <content type="html"><![CDATA[<p>对代码块进行折叠</p><details>  <summary>点击时的区域标题</summary><pre><p>内容</p></code></details>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;对代码块进行折叠&lt;/p&gt;
&lt;details&gt;
  &lt;summary&gt;点击时的区域标题&lt;/summary&gt;
&lt;pre&gt;

&lt;p&gt;内容&lt;/p&gt;
&lt;/code&gt;
&lt;/details&gt;


</summary>
      
    
    
    
    <category term="工具相关" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="typora, md" scheme="http://example.com/tags/typora-md/"/>
    
  </entry>
  
  <entry>
    <title>系统设计相关题目</title>
    <link href="http://example.com/2022/01/19/leetcode/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    <id>http://example.com/2022/01/19/leetcode/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</id>
    <published>2022-01-19T06:09:24.000Z</published>
    <updated>2022-04-12T12:52:07.484Z</updated>
    
    <content type="html"><![CDATA[<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p><a href="https://github.com/donnemartin/system-design-primer">https://github.com/donnemartin/system-design-primer</a></p><h4 id="题型"><a href="#题型" class="headerlink" title="题型"></a>题型</h4><h5 id="1-标准布隆过滤器hash函数的设置"><a href="#1-标准布隆过滤器hash函数的设置" class="headerlink" title="1.标准布隆过滤器hash函数的设置"></a>1.标准布隆过滤器hash函数的设置</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashFunction</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> cap, seed;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">HashFunction</span>(<span class="hljs-keyword">int</span> cap, <span class="hljs-keyword">int</span> seed) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;cap = cap;<br>        <span class="hljs-keyword">this</span>-&gt;seed = seed;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(string&amp; value)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> n = value.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            ret += seed * ret + value[i];<br>            ret %= cap;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StandardBloomFilter</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> k;<br>    vector&lt;HashFunction*&gt; hashFunc;<br>    bitset&lt;200000&gt; bits;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">StandardBloomFilter</span>(<span class="hljs-keyword">int</span> k) &#123;<br>        <span class="hljs-comment">// initialize your data structure here</span><br>        <span class="hljs-keyword">this</span>-&gt;k = k;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i)<br>            hashFunc.<span class="hljs-built_in">push_back</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">HashFunction</span>(<span class="hljs-number">100000</span> + i, <span class="hljs-number">2</span> * i + <span class="hljs-number">3</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>每个字符串通过这个hash函数可以得到一个值（position），然后将bit[200000]中该位置为1，多个函数，那么就会有多个位置为1;判断某一个字符串是否存在，就是判断多个函数计算出来值是否都在bit中位1，如果有一个不为1，说明该字符串不在</p><h5 id="2-序列化Trie树-Lintcode"><a href="#2-序列化Trie树-Lintcode" class="headerlink" title="2. 序列化Trie树(Lintcode)"></a>2. 序列化Trie树(Lintcode)</h5><p> 这个模板一定要记住，不要用自己的方法，用模板<br> 同类型题目：二叉树的序列化和反序列化， n叉数的序列化和反序列化<br>注意这道题</p><ul><li>在进行序列化：使用dfs, 在遍历完所有的chidren后，加上‘/‘表示退出当前循环</li><li>在进行反序列化时： 使用全局index, index在进入下一层循环和退出循环(注意这里和二叉树不同，有两处)之前都需要+1， 其余情况index保持不变</li><li>注意:<br>(1)在退出训练时候不是返回null, 而是返回一个Trie对象的指针！！！<br>(2)因为一个节点有多个节点，而不是只有二叉树的left和right节点，因此需要使用while判断，如果data[index]==’/‘的时候退出while循环<br>(3)<figure class="highlight c++"><figcaption><span>right</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">TrieNode* tmp=<span class="hljs-keyword">new</span> <span class="hljs-built_in">TrieNode</span>(); <span class="hljs-comment">//注意区分类和结构体</span><br>map&lt;<span class="hljs-keyword">char</span>, TrieNode*&gt; &amp;childs=tmp-&gt;children;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><figcaption><span>wrong</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">TrieNode* tmp; <span class="hljs-comment">//注意区分类和类指针，这里直接申明一个空指针是不对的, 即使是结构体也应该是student s;</span><br>map&lt;<span class="hljs-keyword">char</span>, TrieNode*&gt; childs;<br>tmp-&gt;children=childs;<br></code></pre></td></tr></table></figure></li></ul><p>官方题解使用的<data> 进行序列化+栈的方式进行反序列化：&lt;将当前current入栈 &gt;将栈顶出栈 其余：新建一个Trie对象(current)，将当前data[index]指向这个对象</p><p>//下面模板代码可以用作n叉树的遍历或者trie树遍历，下面的这种方式会将空字符串用&lt;&gt;，如果想要空字符串没有，可以使用dfs2</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition of TrieNode:</span><br><span class="hljs-comment"> * class TrieNode &#123;</span><br><span class="hljs-comment"> * public:</span><br><span class="hljs-comment"> *     TrieNode() &#123;&#125;</span><br><span class="hljs-comment"> *     map&lt;char, TrieNode*&gt; children;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-comment">//适用于n叉数的遍历， 但是这种方式在进行反序列化的时候，每次从栈中弹出一个元素前，需要将栈顶赋值给cur</span><br> <span class="hljs-comment">//&lt;1&lt;3&lt;5&gt;&lt;6&gt;&gt;&lt;2&gt;&lt;4&gt;&gt; null节点无&lt;&gt;</span><br><span class="hljs-comment">//  lc428 每个节点都被&lt;&gt;分开，即使是同一层</span><br><span class="hljs-function">string <span class="hljs-title">dfs</span><span class="hljs-params">(Node* root)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br>    string data;<br>    <span class="hljs-keyword">int</span> size=root-&gt;children.<span class="hljs-built_in">size</span>();<br>    data+=<span class="hljs-built_in">to_string</span>(root-&gt;val);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>        data+=<span class="hljs-built_in">dfs</span>(root-&gt;children[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;&quot;</span>+data+<span class="hljs-string">&quot;&gt;&quot;</span>;<br>&#125;<br><br><span class="hljs-comment">//&lt;a&lt;b&lt;e&lt;&gt;&gt;c&lt;&gt;d&lt;f&lt;&gt;&gt;&gt;&gt; 节点之间可能没有&lt;&gt;分开</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * This method will be invoked first, you should design your own algorithm </span><br><span class="hljs-comment">     * to serialize a trie which denote by a root node to a string which</span><br><span class="hljs-comment">     * can be easily deserialized by your own &quot;deserialize&quot; method later.</span><br><span class="hljs-comment">     */</span><br>     <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(TrieNode* root)</span></span>&#123;<br>        <span class="hljs-function">string <span class="hljs-title">dfs</span><span class="hljs-params">(Node* root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        string data;<br>        <span class="hljs-keyword">int</span> size=root-&gt;children.<span class="hljs-built_in">size</span>();<br>        data+=<span class="hljs-built_in">to_string</span>(root-&gt;val);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>            data+=<span class="hljs-built_in">dfs</span>(root-&gt;children[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;&quot;</span>+data+<span class="hljs-string">&quot;&gt;&quot;</span>;<br>    &#125;<br>    <br>    <span class="hljs-function">string <span class="hljs-title">serialize</span><span class="hljs-params">(TrieNode* root)</span> </span>&#123;<br>        <span class="hljs-comment">// Write your code here</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        string data;<br>        <span class="hljs-keyword">for</span> (map&lt;<span class="hljs-keyword">char</span>, TrieNode*&gt;::iterator it = root-&gt;children.<span class="hljs-built_in">begin</span>();<br>             it != root-&gt;children.<span class="hljs-built_in">end</span>(); ++it) &#123;<br>            data += it-&gt;first;<br>            data += <span class="hljs-built_in">serialize</span>(it-&gt;second);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;&quot;</span> + data + <span class="hljs-string">&quot;&gt;&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * This method will be invoked second, the argument data is what exactly</span><br><span class="hljs-comment">     * you serialized at method &quot;serialize&quot;, that means the data is not given by</span><br><span class="hljs-comment">     * system, it&#x27;s given by your own serialize method. So the format of data is</span><br><span class="hljs-comment">     * designed by yourself, and deserialize it here as you serialize it in </span><br><span class="hljs-comment">     * &quot;serialize&quot; method.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">TrieNode* <span class="hljs-title">deserialize</span><span class="hljs-params">(string data)</span> </span>&#123;<br>        <span class="hljs-comment">// Write your code here</span><br>        <span class="hljs-keyword">if</span> (data.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>        TrieNode* head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TrieNode</span>();<br>        TrieNode* current = head;<br>        stack&lt;TrieNode*&gt; path;<br>        <span class="hljs-keyword">int</span> len = data.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;<br>            <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (data[i]) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>:<br>                    path.<span class="hljs-built_in">push</span>(current);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>:<br>                    <span class="hljs-comment">//如果是null节点无&lt;&gt;情况，那么需要在这里赋值cur=path.top()</span><br>                    path.<span class="hljs-built_in">pop</span>();<br>                    <br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">default</span>:<br>                    current = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TrieNode</span>();<br>                    path.<span class="hljs-built_in">top</span>()-&gt;children[data[i]] = current;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ol start="3"><li>Trie树专题<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">class <span class="hljs-title">Trie</span><span class="hljs-params">()</span></span>&#123;<br>    vector&lt;Trie*&gt; children;<br>    <span class="hljs-keyword">bool</span> isEnd;<br>    <span class="hljs-built_in">Trie</span>()&#123;<br>        <span class="hljs-keyword">this</span>-&gt;child = vector&lt;Trie*&gt;(<span class="hljs-number">26</span>,<span class="hljs-literal">nullptr</span>); <span class="hljs-comment">//一定要记得初始化26个节点，而且都为null</span><br>        <span class="hljs-keyword">this</span>-&gt;isEnd = <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-built_in">search</span>(string s)&#123;<br>        Trie* root=<span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(root-&gt;children[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>]==<span class="hljs-literal">NULL</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            root= root-&gt;children[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> root-&gt;isEnd;<br>    &#125;<br>    <span class="hljs-built_in">insert</span>(string s)&#123;<br>        Trie* root=<span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(root-&gt;children[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>]==<span class="hljs-literal">NULL</span>)&#123;<br>                root-&gt;children[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>]=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Trie</span>();<br>            &#125;<br>            root= root-&gt;children[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        root-&gt;isEnd=<span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ol><p>二叉树的序列化和反序列可以使用前序遍历实现</p><ol start="4"><li>lc355. 设计推特</li></ol><ul><li>需要实现4个功能: 关注， 取消关注， 发表博客， 列出userid和userid最近发表的10条博客</li><li>实现关注和取消关注使用unordered_map&lt;int, unordered_set<int>&gt; hash</li><li>发表博客使用unordered_map&lt;int, node*&gt; , 其中node记录<br>node{<br>  tuiteid, //充当时间戳<br>  userid, //发表用户<br>  node* next; //指向下一个node, 类似于LRU，方便使用头插入方法<br>}</li><li> 列出userid和userid最近发表的10条博客， 使用K个链表的合并，找出前M个数</li><li>为什么使用链表，这样的话扩展非常方便，如果不使用，那么在删除博客的时候就比较麻烦</li></ul><ol start="5"><li>单词自动补全系统</li></ol><ul><li>题意：1. 初始化系统，包括一些句子和句子最初始的频率，一个句子之间可能小写字符或者空格 2. 每次input一个字符应该接着上一个字符，同时输出‘#’表示输出的末尾，这时候需要初始化data=””, cur=root（全局变量）, 更新句子的频率</li><li>解决方案：</li><li><ol><li>使用前缀树+hash(存储句子+频率) 前缀树的每个节点，应该存储一个vector<string> 表示走到这个节点的下面所有字符</li></ol></li><li><ol start="2"><li>注意字符串在进行查找如果cur==null, 那么直接返回空，否则一直在cur的基础上走一步 cur=cur-&gt;children[c]//unordered_map&lt;char, TrieNode*&gt; children;</li></ol></li><li><ol start="3"><li>如果走到‘#’，表示走到了末尾，这时候需要初始化data=””, cur=root, 同时更新句子的频率 +1（句子频率会更新）</li></ol></li><li>参考答案: <a href="https://aaronice.gitbook.io/lintcode/data_structure/design-search-autocomplete-system">https://aaronice.gitbook.io/lintcode/data_structure/design-search-autocomplete-system</a><br><a href="https://zhuanlan.zhihu.com/p/99499171">https://zhuanlan.zhihu.com/p/99499171</a> (有点问题，不应该在每个节点里面记录节点的频率，因为这个随时更新，之后就不准确，应该用一个单独的hashmap来记录)</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>一般是有关于系统， 多个函数的整体设计题目<br>比如：GeoHash, GFS, 布隆过滤器， 心跳设计， 缓存系统， LRU cache设计，二叉树的序列化和反序列化等<br>还有新定义一种数据结构，嵌套返回list leetcode-扁平化嵌套列表迭代器 使用递归方式分解</p><p>为了在vector里面删除元素更快，可以再配合使用一个dict (map)映射特定值对应的index;注意在进行删除元素的时候，除了交换vector中最后一个元素和当前元素，还需要修改hash最后一个元素映射的下标为当前index+从hash中删除key</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;链接&quot;&gt;&lt;a href=&quot;#链接&quot; class=&quot;headerlink&quot; title=&quot;链接&quot;&gt;&lt;/a&gt;链接&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/donnemartin/system-design-primer&quot;&gt;https://</summary>
      
    
    
    
    <category term="leetcode" scheme="http://example.com/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Zplot画图相关知识点</title>
    <link href="http://example.com/2022/01/04/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/zplot/"/>
    <id>http://example.com/2022/01/04/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/zplot/</id>
    <published>2022-01-04T08:04:52.000Z</published>
    <updated>2022-02-14T10:03:35.528Z</updated>
    
    <content type="html"><![CDATA[<p>Zplot-folder<br>|–breakdown<br>    |–Makefile<br>    |–breakdown1.py<br>    |–breakdown1.data<br>    |–breakdown2.py<br>    |–breakdown2.data<br>|–eval_lineplot<br>    |–Makefile<br>|–…<br>|–makefig.sh</p><ol><li>每次运行的时候只需要运行makefig文件就可以了，如果要修改所有生成的pdf在的目录，直接修改makefig.sh</li></ol><p>2。 Makefile里面的文件主要是运行当前py文件生成eps文件，然后使用ps2pdf转为pdf并使用pdf2crop对生成的pdf文件进行裁剪<br>PS：一定要注意python文件的名字一定要和data文件名字相同，否则会报错</p><p>prequisuite</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install zplot <br><span class="hljs-comment">#注意可能会出现list错误，可能是由于python2 和python3的不兼容原因，只需要将zplot.py里面的ListType改为list就可以了</span><br><br>sudo apt-get install texlive-extra-utils  <br></code></pre></td></tr></table></figure><p>Makefile文件分析</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash">PY=python<br>EPS2PDF=ps2pdf<br>CROP=pdfcrop<br><br>SRC := $(wildcard *.py) <span class="hljs-comment">#列出所有文件对应的py文件</span><br>SRC := $(filter-out zplot.py, $(SRC))<br>EPS = $(patsubst %.py,%.eps,$(SRC))<br>PDF = $(patsubst %.py,%.pdf,$(SRC)) <span class="hljs-comment">#列出所有文件对应的eps和pdf文件</span><br><br>all: $(EPS) $(PDF)<br><br>%.eps: %.py  <span class="hljs-comment"># 目标文件： 源文件</span><br>$(PY) $&lt; eps  <span class="hljs-comment">#$&lt; 表示源文件  $@表示目标文件//官方解释： $&lt; 表示第一个依赖文件， $@ 表示目标集</span><br><br>%.pdf: %.eps<br>$(EPS2PDF) $&lt;<br>$(CROP) <span class="hljs-variable">$@</span> <span class="hljs-variable">$@</span><br>rm -rf $&lt;<br><br>fig:<br><span class="hljs-comment"># mv -f *.pdf ../../../fig/ #将所有的文件都转移到zplot对应的root目录下面</span><br>mv -f *.pdf ../../<br>rm -rf *.eps *.pdf<br></code></pre></td></tr></table></figure><p>makefile语法的参考链接： <a href="https://seisman.github.io/how-to-write-makefile/rules.html">https://seisman.github.io/how-to-write-makefile/rules.html</a> </p><p>makefig.sh文件分析</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>rm -rf *.pdf <span class="hljs-comment">#这是我自己家的，在执行生成之前，现将之前生成的pdf文件删除，应该是也不用</span><br><br><span class="hljs-keyword">for</span>  dir  <span class="hljs-keyword">in</span>  `find .  -name Makefile`  <span class="hljs-comment">#找到包含Makefile文件的dir</span><br><span class="hljs-keyword">do</span><br>path=`dirname <span class="hljs-variable">$dir</span>` <span class="hljs-comment">#找到dir对应的路径path</span><br>    <span class="hljs-comment"># echo $path</span><br>    <span class="hljs-comment"># echo $dir</span><br><span class="hljs-keyword">if</span>  [ <span class="hljs-variable">$path</span>  !=  . ]<br><span class="hljs-keyword">then</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$path</span> <span class="hljs-comment">#打印出path的路径</span><br><span class="hljs-built_in">cd</span> <span class="hljs-variable">$path</span>  <br>make    <span class="hljs-comment">#执行make和makefig命令</span><br>make fig<br><span class="hljs-built_in">cd</span>  -<br><span class="hljs-keyword">fi</span><br><span class="hljs-keyword">done</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Zplot-folder&lt;br&gt;|–breakdown&lt;br&gt;    |–Makefile&lt;br&gt;    |–breakdown1.py&lt;br&gt;    |–breakdown1.data&lt;br&gt;    |–breakdown2.py&lt;br&gt;    |–breakdown2.</summary>
      
    
    
    
    <category term="工具相关" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="zplot" scheme="http://example.com/tags/zplot/"/>
    
  </entry>
  
  <entry>
    <title>Anaconda环境搭建</title>
    <link href="http://example.com/2021/12/15/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/anaconda%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%BB%8E%E9%9B%B6%E5%88%B0%E4%B8%80/"/>
    <id>http://example.com/2021/12/15/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/anaconda%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%BB%8E%E9%9B%B6%E5%88%B0%E4%B8%80/</id>
    <published>2021-12-15T06:48:24.000Z</published>
    <updated>2022-02-14T10:03:35.528Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>一个服务器上已经搭建好的环境，但是需要换另一台机器，或者另外的用户需要访问这个环境， 如果另一台服务器上没有anaconda环境就需要从0开始进行搭建，然后再进行环境的迁移</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol><li>安装anaconda3<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">wget</span> https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda<span class="hljs-number">3</span>-<span class="hljs-number">5</span>.<span class="hljs-number">3</span>.<span class="hljs-number">1</span>-Linux-x<span class="hljs-number">86</span>_<span class="hljs-number">64</span>.sh<br><span class="hljs-attribute">bash</span> Anaconda<span class="hljs-number">3</span>-<span class="hljs-number">5</span>.<span class="hljs-number">3</span>.<span class="hljs-number">1</span>-Linux-x<span class="hljs-number">86</span>_<span class="hljs-number">64</span>.sh<br></code></pre></td></tr></table></figure></li></ol><p>一般情况下安装是默认设置，在安装vscode的时候可以根据需要选择no或者yes<br>注意在安装installer的时候需要选择yes, 如果选择了no<br>那么可以自行添加环境:<br><a href="https://zhuanlan.zhihu.com/p/64930395%EF%BC%88%E4%B9%9F%E5%B0%B1%E6%98%AF%E6%BF%80%E6%B4%BB%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%89">https://zhuanlan.zhihu.com/p/64930395（也就是激活环境中的方法二）</a></p><ol start="2"><li>激活环境<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 方法一失效</span><br>输入命令打开配置文件：vim ~/.bashrc<br>在最后添加语句：export PATH=<span class="hljs-regexp">/root/</span>xxx<span class="hljs-regexp">/anaconda3/</span>bin:<span class="hljs-variable">$PATH</span> （<span class="hljs-regexp">/root/</span>xxx 为安装路径）<br>最后输入如下命令，更新配置文件即可：source ~/.bashrc<br><br><span class="hljs-comment">#方法二有效：</span><br>如果conda的初始化时选择了no，则需要自行配置环境变量。<br><br>打开profile文件：<br><br>vi <span class="hljs-regexp">/etc/</span>profile<br>在文件最后加入如下语句（路径需要根据自己的安装位置更改）：<br><br>PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-regexp">/opt/</span>anaconda3/bin<br>export PATH<br>保存文件并退出。最后使用如下命令刷新环境变量即可：<br><br>source <span class="hljs-regexp">/etc/</span>profile<br>echo <span class="hljs-variable">$PATH</span><br></code></pre></td></tr></table></figure></li></ol><p>PS: 如果conda名称弹出问题，使用<code>sudo vi ~/.bashrc</code>查看conda路径是否正确</p><ol start="3"><li>conda相关命令<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs applescript">conda <span class="hljs-built_in">list</span> 查看安装包<br>conda info <span class="hljs-comment">--envs 查看环境</span><br>conda <span class="hljs-built_in">activate</span> XXX 激活环境 （XXX 为环境名称）<br>python -V 检查Python版本<br><br>如果需要卸载anaconda的话，只需要删除anaconda目录即可:<br>rm -rf /root/xxx/anaconda3<br></code></pre></td></tr></table></figure></li><li>使用conda-pack迁移环境</li></ol><p>在源机器：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">conda pack -n env-<span class="hljs-built_in">name</span> <span class="hljs-comment">--ignore-editable-packages（如果没有后面这个会报错）</span><br>得到一个env_name.tar.gz压缩文件<br></code></pre></td></tr></table></figure><p>在目标机器：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">cd ~<span class="hljs-regexp">/anaconda3/</span>envs;<br>mkdir env_name<br>tar -xzvf env_name.tar.gz -C <span class="hljs-regexp">/home/</span>root_name<span class="hljs-regexp">/anaconda3/</span>envs/env_name<br></code></pre></td></tr></table></figure><ol start="5"><li>使用环境<br><code>source activate attnGAN</code></li></ol><p>注意使用conda activate会报错<br>目前找到一个解决方案：<br><a href="https://blog.csdn.net/qq_43828332/article/details/114235922">https://blog.csdn.net/qq_43828332/article/details/114235922</a></p><p>总共耗时 1个半小时左右~</p><h4 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h4><ol><li><a href="https://blog.csdn.net/lwgkzl/article/details/89329383">https://blog.csdn.net/lwgkzl/article/details/89329383</a></li><li><a href="https://www.jianshu.com/p/1fddd11bcd25">https://www.jianshu.com/p/1fddd11bcd25</a></li><li><a href="https://blog.csdn.net/ds1302__/article/details/120027173">https://blog.csdn.net/ds1302__/article/details/120027173</a></li></ol><p>注意之江实验室hec anaconda3的安装路径是：/nfs/home </p><h4 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h4><p>在终端输入conda info –envs检验anaconda是否安装成功，发现报错：conda: command not found</p><p>原因是因为~/.bashrc文件没有配置好</p><p>解决方案：<br>sudo vim ~/.bashrc<br>在最后一行加上<br>export PATH=$PATH:/home/vincent/anaconda3/bin</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h3&gt;&lt;p&gt;一个服务器上已经搭建好的环境，但是需要换另一台机器，或者另外的用户需要访问这个环境， 如果另一台服务器上没有anaconda</summary>
      
    
    
    
    <category term="工具相关" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="conda environment" scheme="http://example.com/tags/conda-environment/"/>
    
  </entry>
  
  <entry>
    <title>RPC related</title>
    <link href="http://example.com/2021/12/03/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/rpc/"/>
    <id>http://example.com/2021/12/03/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/rpc/</id>
    <published>2021-12-03T02:01:07.000Z</published>
    <updated>2022-07-31T09:18:13.858Z</updated>
    
    <content type="html"><![CDATA[<p>gRPC 可以保证不同语言之间的通讯<br>编写.proto文件，生成指定语言源代码。<br>编写服务端代码<br>编写客户端代码<br><a href="https://www.liwenzhou.com/posts/Go/gRPC/">https://www.liwenzhou.com/posts/Go/gRPC/</a>  一个python客户端和go服务端的例子</p><p>pytorch的官网框架<br>rpc常见方法<br>rpc_sync同步远程调用、rpc_async异步远程调用、remote异步远程调用。</p><p>rpc.init_rpc 初始化rpc，需要在master和worker都进行初始化，方便之后的通讯<br>rpc.rpc_sync  worker端调用在master上进行执行的方法<br>rpc.rpc_async<br>rpc.remote</p><p>dist_autograd.get_gradient(cid) 目前猜测在rpc场景进行前向传播，的梯度反向传播需要使用dist_grad</p><p>TrainNet是worker调用的假的网络，实际的网络是在Net里面调用，每次worker里面数据的前向传播，实际上都是在master里面的调用net进行前向传播</p><h3 id="分析rpc-parameter-server代码"><a href="#分析rpc-parameter-server代码" class="headerlink" title="分析rpc_parameter_server代码"></a>分析rpc_parameter_server代码</h3><p>master和worker都需要init_rpc</p><p>worker里面主要执行TrainNet：初始化的时候得到远程parameterServer的引用，然后包含二个函数 get_global_param_rref 以及forward函数(均要调用remote_method)<br>master里面执行parameterServer类，：初始的时候，得到真实训练的model, 同时实现三个函数, 对模型参数加上的引用rpc.RRef，使用dist_autograd得到模型参数，以及对输入数据进行前向传播</p><p>在master中加上</p><p>uni_sample_score_rref</p><h3 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h3><p>route_guide_client文件主要是通过stub 和传入的参数调用server的函数</p><p>route_guide_server里面主要是编写得到输入服务器处理函数逻辑</p><p>route_guide_pb2_grpc，类似于头文件，定义Stub类和Servicer类，每个类只是定义函数，但不进行具体的实现； 以及一个add_RouteGuideServicer_to_server的函数</p><h4 id="使用go语言"><a href="#使用go语言" class="headerlink" title="使用go语言"></a>使用go语言</h4><ul><li>前置安装要求<br>安装go，和protocol buffer编译器<br><a href="https://grpc.io/docs/languages/go/quickstart/#prerequisites">https://grpc.io/docs/languages/go/quickstart/#prerequisites</a></li></ul><p>go command not found<br>使用export， 重启一个控制台窗口就找不到这个命令了<br>需要使用vim <del>/.bashrc写入文件 将这个命令写进去，然后使用source ~/.bashrc<br>(</del>/.bashrc:是用户相关的终端（shell）的环境设置，通常打开一个新终端时，默认会load里面的设置，在这里的设置不影响其它人。<br>/etc/profile会影响所有的用户)</p><p>go download超时解决：<br>export GOPROXY=<a href="https://goproxy.cn/">https://goproxy.cn</a></p><p>go 软件的安装</p><ol><li><p>直接使用 tar -C /usr/local -xzf go1.4.7.linux-amd64.tar.gz 解压到 local 目录 设置PATH，export PATH=$PATH:/usr/local/go/bin</p></li><li><p>假定你想要安装Go的目录为 $GO_INSTALL_DIR，后面替换为相应的目录路径。 解压缩tar.gz包到安装目录下：tar zxvf go1.14.7.linux-amd64.tar.gz -C $GO_INSTALL_DIR。<br>设置PATH，export PATH=$PATH:$GO_INSTALL_DIR/go/bin</p></li></ol><p>如果修改用户环境变量：设置 vim ~/.bash_profile<br>如果修改系统环境变量：设置 vim /etc/profile</p><ol start="3"><li><a href="https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/01.1.md">go安装的三种方法</a></li></ol><ol start="4"><li><p>go的插件在vscode命令行中显示失败 i/o time out<br>解决方法：GO111MODULE=on GOPROXY=<a href="https://goproxy.cn,direct/">https://goproxy.cn,direct</a> go install </p></li><li><p>vscode下载go 包的时候一个failed的解决方案（和第4个有点雷同）<br><a href="https://www.cnblogs.com/marshhu/p/11848020.html">https://www.cnblogs.com/marshhu/p/11848020.html</a></p></li></ol><h4 id="使用python"><a href="#使用python" class="headerlink" title="使用python"></a>使用python</h4><p>一个python小例子：<a href="https://grpc.io/docs/languages/python/quickstart/">https://grpc.io/docs/languages/python/quickstart/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;gRPC 可以保证不同语言之间的通讯&lt;br&gt;编写.proto文件，生成指定语言源代码。&lt;br&gt;编写服务端代码&lt;br&gt;编写客户端代码&lt;br&gt;&lt;a href=&quot;https://www.liwenzhou.com/posts/Go/gRPC/&quot;&gt;https://www.liwen</summary>
      
    
    
    
    <category term="工具相关" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/"/>
    
    
  </entry>
  
  <entry>
    <title>orangefs</title>
    <link href="http://example.com/2021/12/01/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/orangefs/"/>
    <id>http://example.com/2021/12/01/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/orangefs/</id>
    <published>2021-12-01T07:54:01.000Z</published>
    <updated>2022-02-14T10:03:35.528Z</updated>
    
    <content type="html"><![CDATA[<h3 id="orangefs"><a href="#orangefs" class="headerlink" title="orangefs"></a>orangefs</h3><ol><li><p>genconfig是一个go语言文件，它有一个可选参数oranges-server.conf</p></li><li><p>init_start_all.sh相比start_all.sh 多了一个/local500G/orange_store/ 以及多了一条有-f命令的语句 应该是在服务器节点启动pvfs-server<br>orangefs默认的服务器的文件系统挂载的目录是在oranges-server.conf里面进行配置（/nfs/home/yfwang/orangefs/install/etc/oranges-server.conf）</p></li></ol><p>加上f的原因： 第一次启动PVFS2服务要首先分配空间，添加参数-f：<br>root@ubuntu:~# pvfs2-server /etc/pvfs2-fs.conf -f<br>其后启动服务则不需加参数，或使用-d使得服务运行于前台（占用当前终端窗口，终端窗口关闭后服务终止）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> host <span class="hljs-keyword">in</span> `cat /nfs/home/yfwang/orangefs/install/nodelist`<br><span class="hljs-keyword">do</span><br><span class="hljs-comment">#       ssh -t -t -o StrictHostKeyChecking=no -o PasswordAuthentication=no $USER@$host sudo rm -rf /local500G/orange_store/*</span><br>        ssh -t -t -o StrictHostKeyChecking=no -o PasswordAuthentication=no <span class="hljs-variable">$USER</span>@<span class="hljs-variable">$host</span> sudo /nfs/home/yfwang/orangefs/install/sbin/pvfs2-server -f /nfs/home/yfwang/orangefs/install/etc/oranges-server.conf<br>        ssh -t -t -o StrictHostKeyChecking=no -o PasswordAuthentication=no <span class="hljs-variable">$USER</span>@<span class="hljs-variable">$host</span> sudo /nfs/home/yfwang/orangefs/install/sbin/pvfs2-server /nfs/home/yfwang/orangefs/install/etc/oranges-server.conf<br><span class="hljs-keyword">done</span> <br></code></pre></td></tr></table></figure><ol start="4"><li><p>stop_all.sh 停止所有的pvfs-server</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> host <span class="hljs-keyword">in</span> `cat /nfs/home/yfwang/orangefs/install/nodelist`<br><span class="hljs-keyword">do</span><br>        ssh -t -t -o StrictHostKeyChecking=no -o PasswordAuthentication=no <span class="hljs-variable">$USER</span>@<span class="hljs-variable">$host</span> sudo killall pvfs2-server<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure></li><li><p>start_client.sh 启动客户端orangefs-client， 同时将服务器任意一个节点的位置暴露为客户端，例子是hec09</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo /nfs/home/yfwang/orangefs/install/sbin/pvfs2-client -f -p /nfs/home/yfwang/orangefs/install/sbin/pvfs2-client-core<br>sudo mount -t pvfs2 tcp://hec09:3334/orangefs /mnt/orangefs<br></code></pre></td></tr></table></figure><p>nodelist<br>里面直接写hec10 hec11</p><p><a href="https://github.com/waltligon/orangefs/wiki/Distributions-and-Layouts">https://github.com/waltligon/orangefs/wiki/Distributions-and-Layouts</a> 设置数据不同的放置策略,一个文件放在一个节点使用basic方式 distribution</p><p><a href="https://github.com/waltligon/orangefs/wiki/Programming-Guide">https://github.com/waltligon/orangefs/wiki/Programming-Guide</a></p><p>setfattr -n “user.pvfs2.dist_name” -v “basic_dist” /mnt/pvfs2/directory<br>./bin/pvfs2-xattr -s -k “user.pvfs2.dist_name” -v “basic-dist” /mnt/shu-orangefs/dataset</p><p>orangefs里面有一个PINT_dist函数<br><a href="https://www.mcs.anl.gov/~robl/pvfs2/pvfs2-dox/html/pint-distribution_8c.html#a2">https://www.mcs.anl.gov/~robl/pvfs2/pvfs2-dox/html/pint-distribution_8c.html#a2</a></p><h5 id="现在找到将文件保存在一个服务器的方案："><a href="#现在找到将文件保存在一个服务器的方案：" class="headerlink" title="现在找到将文件保存在一个服务器的方案："></a>现在找到将文件保存在一个服务器的方案：</h5><p><a href="https://stackoverflow.com/questions/64923445/how-to-configure-orangefs-save-the-file-into-the-same-server-not-split-it">https://stackoverflow.com/questions/64923445/how-to-configure-orangefs-save-the-file-into-the-same-server-not-split-it</a><br>使用命令：setfattr -n “user.pvfs2.num_dfiles” -v “1” /mnt/orangefs<br>如果按照这种方式设置会报错：setfattr -n “user.pvfs2.dist_name” -v “basic_dist” /mnt/pvfs2/directory 传输数据会报错</p><h3 id="配置教程"><a href="#配置教程" class="headerlink" title="配置教程"></a>配置教程</h3><p>安装server<br>拷贝已经编译好的程序<br>cp -r /nfs/home/yfwang/orangefs/install /nfs/home/weijian/orangefs_install/<br>配置server<br>./bin/pvfs2-genconfig /nfs/home/weijian/orangefs_install/install/orangefs-server.conf<br>具体的配置项，自己可以先记录下来<br>tcp<br>3336<br>/local500G/wj-fast/storage/data<br>/local500G/wj-fast/storage/meta<br>/var/log/orangefs-server.log<br>hec08,hec09<br>配置完成时可以cat /nfs/home/weijian/orangefs_install/install/orangefs-server.conf查看配置项是否符合需求<br>到各个server上，各自初始化存储目录<br>sudo ./sbin/pvfs2-server -f orangefs-server.conf -a <server alias><br>到各个server上，启动服务<br>sudo ./sbin/pvfs2-server  orangefs-server.conf</p><p>安装client<br>拷贝已经编译好的程序（如果已经可以访问就不需要拷贝了）<br>scp -r weijian@hec08:/nfs/home/yfwang/orangefs/install/ /nfs/home/weijian/orangefs_install/<br>向内核加载orangefs模块<br>sudo modprobe orangefs<br>创建挂载点<br>sudo mkdir /mnt/wj-fast-orangefs<br>写配置文件<br>sudo sh -c “echo ‘tcp://hec08:3336/orangefs /mnt/wj-fast-orangefs pvfs2’ &gt;&gt; /etc/pvfs2tab”<br>测试与server是否连通<br>./bin/pvfs2-ping -m /mnt/wj-fast-orangefs<br>启动client客户端<br>sudo ./sbin/pvfs2-client -p ./sbin/pvfs2-client-core<br>挂载<br>sudo mount -t pvfs2 tcp://hec08:3336/orangefs /mnt/wj-fast-orangefs</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;orangefs&quot;&gt;&lt;a href=&quot;#orangefs&quot; class=&quot;headerlink&quot; title=&quot;orangefs&quot;&gt;&lt;/a&gt;orangefs&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;genconfig是一个go语言文件，它有一个可选参数oranges-se</summary>
      
    
    
    
    <category term="工具相关" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/"/>
    
    
  </entry>
  
</feed>
