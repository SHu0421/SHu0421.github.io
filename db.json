{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","path":"css/gitalk.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","path":"img/default.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","path":"img/loading.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","path":"js/boot.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","path":"js/color-schema.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","path":"js/events.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","path":"js/img-lazyload.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","path":"js/leancloud.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","path":"js/plugins.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","path":"xml/local-search.xml","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/lib/hint/hint.min.css","path":"lib/hint/hint.min.css","modified":0,"renderable":1},{"_id":"source/test.cpp","path":"test.cpp","modified":0,"renderable":0},{"_id":"source/tmp.c++","path":"tmp.c++","modified":0,"renderable":0},{"_id":"source/img/bg-favorite.jpg","path":"img/bg-favorite.jpg","modified":0,"renderable":0},{"_id":"source/img/bg-biaoqian.jpg","path":"img/bg-biaoqian.jpg","modified":0,"renderable":0},{"_id":"source/img/bg-fenlei.jpg","path":"img/bg-fenlei.jpg","modified":0,"renderable":0},{"_id":"source/img/bg-guanyu-yuantu.jpeg","path":"img/bg-guanyu-yuantu.jpeg","modified":0,"renderable":0},{"_id":"source/img/bg-guanyu.jpg","path":"img/bg-guanyu.jpg","modified":0,"renderable":0},{"_id":"source/img/bg-guidang.jpg","path":"img/bg-guidang.jpg","modified":0,"renderable":0},{"_id":"source/img/bg-shouye-2.jpg","path":"img/bg-shouye-2.jpg","modified":0,"renderable":0},{"_id":"source/img/bg-shouye-3.jpg","path":"img/bg-shouye-3.jpg","modified":0,"renderable":0},{"_id":"source/img/bg-shouye-4.jpg","path":"img/bg-shouye-4.jpg","modified":0,"renderable":0},{"_id":"source/img/bg-shouye-yuantu.jpg","path":"img/bg-shouye-yuantu.jpg","modified":0,"renderable":0},{"_id":"source/img/bg-shouye.jpg","path":"img/bg-shouye.jpg","modified":0,"renderable":0},{"_id":"source/img/bg-wenzhang-2.jpg","path":"img/bg-wenzhang-2.jpg","modified":0,"renderable":0},{"_id":"source/img/bg-wenzhang-4.jpg","path":"img/bg-wenzhang-4.jpg","modified":0,"renderable":0},{"_id":"source/img/bg-wenzhang-5.jpg","path":"img/bg-wenzhang-5.jpg","modified":0,"renderable":0},{"_id":"source/img/bg-wenzhang.jpg","path":"img/bg-wenzhang.jpg","modified":0,"renderable":0},{"_id":"source/img/bg-zidingyi.jpg","path":"img/bg-zidingyi.jpg","modified":0,"renderable":0},{"_id":"source/img/bg.jpeg","path":"img/bg.jpeg","modified":0,"renderable":0},{"_id":"source/img/logo.png","path":"img/logo.png","modified":0,"renderable":0},{"_id":"source/img/post_default_side.jpeg","path":"img/post_default_side.jpeg","modified":0,"renderable":0},{"_id":"source/img/post_default_side2.jpeg","path":"img/post_default_side2.jpeg","modified":0,"renderable":0},{"_id":"source/img/self.jpg","path":"img/self.jpg","modified":0,"renderable":0}],"Cache":[{"_id":"source/_posts/summer_intern_company/jindong/problem3.cpp","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1647600934131},{"_id":"source/tmp.c++","hash":"d1e70a084e89e0d9046c1450fcb577b761088136","modified":1688985379590},{"_id":"source/test.cpp","hash":"869fcb3c9f619c1f1ed9e3d48a4fded30a1424d2","modified":1688985379590},{"_id":"source/about/index.md","hash":"435b85f924bbae78cdd899d146b9ce3f8e186ebf","modified":1688984832995},{"_id":"source/favorite/index.md","hash":"a6551193b86080c35e0ed759b6d25cae6f61ba3c","modified":1689506241256},{"_id":"source/favorite-reading/index.md","hash":"f939a125336b64f2802331867707e67ae1c448d4","modified":1689506141057},{"_id":"source/favorite-language/index.md","hash":"cd4669d0a3ba7bc9122b83a5a45fd6944c63e17a","modified":1689506133406},{"_id":"source/_posts/tmp.txt","hash":"ecd590e84c3e8aa1ccd39ef49615bea722c0f037","modified":1648087862203},{"_id":"source/.DS_Store","hash":"273242e1ffc40ba301f7bc1d54a807e02dd8d505","modified":1689500033103},{"_id":"source/img/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1689161085011},{"_id":"source/img/logo.png","hash":"6bdff8a1cc249a9dd8c6dd409ff0be4edf4336a0","modified":1689157717182},{"_id":"source/img/post_default_side.jpeg","hash":"9bb40474c02412665eae15dbec9b64511f0be445","modified":1689157717187},{"_id":"source/img/post_default_side2.jpeg","hash":"1b2fb1427e5b9126cd1519f495a57c09d5dbbe97","modified":1689157717184},{"_id":"source/_posts/leetcode/hard题目合集.md","hash":"20b6903f76927cae9606c0c1676254a7c5578af2","modified":1688985379531},{"_id":"source/_posts/leetcode/二分算法.md","hash":"a833564554428a88ace3626a3fe9dc32888ae484","modified":1688985379532},{"_id":"source/_posts/leetcode/二叉树.md","hash":"844629c4fde0aff6f33524be424481938dd2c222","modified":1688985379532},{"_id":"source/_posts/leetcode/位运算.md","hash":"50c140c2dd83046d2d37555dbc383b08ffb4ad9a","modified":1649160297160},{"_id":"source/_posts/leetcode/其他.md","hash":"da5078eae1a715a8d15f125f3a1bbc59f00c30b8","modified":1688985379535},{"_id":"source/_posts/leetcode/动态规划题型.md","hash":"93d106c702fdece6343c11a3903aa5294065c4e5","modified":1688985379537},{"_id":"source/_posts/leetcode/单调栈相关.md","hash":"4d280ee720e3ae4effb0466db3274b3a241d272b","modified":1688985379544},{"_id":"source/_posts/leetcode/双指针.md","hash":"7caf969b6a7af2b472cee50e32c42ed6cfa8244b","modified":1688985379571},{"_id":"source/_posts/leetcode/哈希相关.md","hash":"93941efa10f342d550c46eb8065cecd9254d293d","modified":1688985379572},{"_id":"source/_posts/leetcode/回溯_DFS_BFS.md","hash":"0ab13d821677c00100463e0c2387c18098f23dcc","modified":1688985379572},{"_id":"source/_posts/leetcode/多线程编程.md","hash":"0764d2b4e04da09dce388ca6b36e677d77cb5329","modified":1646193202049},{"_id":"source/_posts/leetcode/.DS_Store","hash":"36c8a5aa4bea1652545903b8edd0fa327677aebc","modified":1688985379530},{"_id":"source/_posts/autumn_recruit/.DS_Store","hash":"ef2b851daa092abe4cf695c69155dcc708fbe36c","modified":1688985379520},{"_id":"source/_posts/leetcode/字符串.md","hash":"004a26cf804c80ddd21836548ef36732c8e32537","modified":1688985379573},{"_id":"source/_posts/leetcode/排序题.md","hash":"9879d263eddfd7f60a30ec688fd2c2194691ea50","modified":1688985379573},{"_id":"source/_posts/leetcode/暂时没看内容.md","hash":"2b680df93ec9c249212c83cf96531c42e1c48c33","modified":1688985379574},{"_id":"source/_posts/leetcode/滑动窗口.md","hash":"de4e08d72567614cc2f00f5ff8d115bf0009f487","modified":1688985379575},{"_id":"source/_posts/leetcode/系统设计.md","hash":"9fcf5ffd51902ef56578a0738f21ab68673d7267","modified":1649767927484},{"_id":"source/_posts/leetcode/贪心算法.md","hash":"baa728ac11676b90499fd981d1aa9ab634964a0e","modified":1688985379575},{"_id":"source/_posts/leetcode/链表.md","hash":"2b1993220a3d6d6c5cab45aabdd1764a66b14f92","modified":1688985379576},{"_id":"source/_posts/dp问题专栏/DAG+树状+其他dp.md","hash":"78e6103043bdb11be9ee7e766076a5a8fce78ace","modified":1689158085675},{"_id":"source/_posts/其他/各类资源.md","hash":"4b911e6e3a6057c96ab7cfc497903cb8618baa8b","modified":1688985379579},{"_id":"source/_posts/工具相关/Linux命令.md","hash":"6c0205050ba3cb6bd68d3820d741fa20d0ba5e88","modified":1688985379581},{"_id":"source/_posts/工具相关/anaconda环境搭建从零到一.md","hash":"cf830c71c6ac5df76016770a7175e0bc214ca527","modified":1644833015528},{"_id":"source/_posts/工具相关/command-related.md","hash":"a941b1da2a9f67892e0d0052c15f38eedcbda0fc","modified":1688985379581},{"_id":"source/_posts/dp问题专栏/背包问题总结.cpp","hash":"cdcfddeed6edf08d022c86c68207f85030cdb86c","modified":1688985379529},{"_id":"source/_posts/工具相关/hello-world.md","hash":"9767cacb227274bdde47082404722e1220d7a5ae","modified":1636806468242},{"_id":"source/_posts/工具相关/hexo-notes.md","hash":"1907639bc8b16c3c29687e4d55d8ba60f585c5c5","modified":1689160460974},{"_id":"source/_posts/工具相关/leetcode-单调栈相关.md","hash":"9435be3e26be665eff3ef1e0fb2b4fb5764ca9c6","modified":1636806406547},{"_id":"source/_posts/工具相关/.DS_Store","hash":"ed90d14dbdf9cb1ce8b4f32e58f2056bec665526","modified":1688985379580},{"_id":"source/_posts/工具相关/orangefs.md","hash":"a8c83937324ed1e89ecb6052dc0b13296466e71b","modified":1644833015528},{"_id":"source/_posts/工具相关/md语法相关.md","hash":"2fc70c68489d0e47bed7555e713f5af28e0d7a0b","modified":1644833015528},{"_id":"source/_posts/工具相关/python相关.md","hash":"18f4e8eaa6d3f66486abb6efd29f1205908f349c","modified":1645754730101},{"_id":"source/_posts/工具相关/rclone.md","hash":"a244c0a8fbd9ffd0ef1bd87dec01496f279abcc6","modified":1636806468242},{"_id":"source/_posts/工具相关/rpc.md","hash":"172d9d53da87c0f414615733d55f1f31efca8ed5","modified":1688985379582},{"_id":"source/_posts/工具相关/scheduler-ralated.md","hash":"7c2a972869d4b3380ad176ca504711075ce200d2","modified":1688985379582},{"_id":"source/_posts/工具相关/secrete.md","hash":"803ce421727d40fb3b89089746c050717a86b655","modified":1636806406675},{"_id":"source/_posts/工具相关/vscode.md","hash":"1bf77ad682e6aee9acb660910dbe7ec54cf16297","modified":1688985379583},{"_id":"source/_posts/工具相关/zplot.md","hash":"4336b9016ffa44b51a568fc3ddde9ce47de47713","modified":1659258692488},{"_id":"source/_posts/dp问题专栏/区间dp.cpp","hash":"a6f974e5194513a79c97e6c9206efe16e1f7961a","modified":1649043561256},{"_id":"source/_posts/工具相关/分布式训练.md","hash":"aed05086a8343903315797cfa6b83976f1496309","modified":1644833015528},{"_id":"source/_posts/工具相关/常见问题及解决方案.md","hash":"bf635fb6619b943a830cf376d8bf5a7a61214ad8","modified":1688985379583},{"_id":"source/_posts/日常记事/每天任务记录.md","hash":"e6622dff0522b5e196d73c12f6d5ca5cbd23ece3","modified":1689163828257},{"_id":"source/_posts/项目相关/C#.md","hash":"e4abaf18ead7ee13e37013fe88f6a5d5278339ac","modified":1689161774861},{"_id":"source/_posts/项目相关/system design.md","hash":"9508a83d29a174889d9404007275249083659f9f","modified":1688985379588},{"_id":"source/_posts/项目相关/基本神经网络总结.md","hash":"9da99002538a631eda59654d566edda97b689290","modified":1688985379588},{"_id":"source/_posts/项目相关/机器学习.md","hash":"5edf003fd76fbd180fe60bd1ae35701342afb1e7","modified":1636806468243},{"_id":"source/_posts/项目相关/笔试.md","hash":"8a2070c8f1dcbebeb3f17ee02e9fa93fea9a0ca6","modified":1688985379589},{"_id":"source/_posts/项目相关/编程语言.md","hash":"0b0948cad0ff054a742b7007a6013e68cf3c3333","modified":1688985379589},{"_id":"source/_posts/项目相关/面试.md","hash":"648f0d0d1c808fe2cb0c5455ed840a922b8c6672","modified":1639048756315},{"_id":"source/_posts/可能会考的代码Demo/iou.py","hash":"d98d071d052eb852bbc61e46a830ed54a3a242b3","modified":1642579182321},{"_id":"source/_posts/项目相关/面试tips.md","hash":"3cf1089437ca1e5d8555514b2c203e502628efb9","modified":1646113954744},{"_id":"source/_posts/模板代码/KMP.cpp","hash":"5836e4c18d884dfd7d575b19d397363c7997bb23","modified":1688985379585},{"_id":"source/_posts/模板代码/N皇后+数独.cpp","hash":"a8b236b2dc83a1bb7a43969bbb23a3528b218127","modified":1649065837281},{"_id":"source/_posts/模板代码/k进制数的加法.cpp","hash":"bc93de85abbcd56b5fe317ffd25607cb2c33b02c","modified":1646271805228},{"_id":"source/_posts/模板代码/tempCodeRunnerFile.cpp","hash":"e540cdd1328b2b21e29a95405c301b9313b7c346","modified":1688985379585},{"_id":"source/_posts/模板代码/132.cpp","hash":"f7f10c793fb1b9757776766117c3053506b6d23e","modified":1648090022291},{"_id":"source/_posts/模板代码/成语接龙.cpp","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1688985379586},{"_id":"source/_posts/模板代码/二叉搜索树的个数+出栈序列的所有情况.cpp","hash":"9476ab263d7b6f45caecd43bef566ee64438babc","modified":1648953647535},{"_id":"source/_posts/模板代码/并查集.cpp","hash":"e5a9b001aa6a1c04a6847862996722a3a3b8804c","modified":1648269783960},{"_id":"source/_posts/模板代码/树的序列化和反序列化.cpp","hash":"65afb3b437f8ca23e1965529ccdbade1360aef85","modified":1648696973708},{"_id":"source/_posts/模板代码/归并排序.cpp","hash":"87af87a43075804ee0d7115f6a7dc477496bb07d","modified":1648521932626},{"_id":"source/_posts/模板代码/换根dp.cpp","hash":"9db0ff3e84326d0c112b819a0b551ad430427449","modified":1649063527354},{"_id":"source/_posts/模板代码/逃脱迷宫.cpp","hash":"c642f6561d5b7e06db99042b013b0f6f706ee841","modified":1688985379587},{"_id":"source/_posts/模板代码/树状数组.cpp","hash":"69cd98967940f8ec009bb238b27c6ad77e075563","modified":1648523407392},{"_id":"source/_posts/模板代码/计算右侧小于当前元素的个数.cpp","hash":"e3a61bda9cecd4345373c23a8eacf596cf2719c5","modified":1647574432923},{"_id":"source/_posts/autumn_recruit/MoganStaney/tempCodeRunnerFile.cpp","hash":"24989d8ee41c1575924630844ad094b55e6b1445","modified":1688985379521},{"_id":"source/_posts/cplusDNN/project_dnn_cplusplus/main.cpp","hash":"25c8e9ddd4d0def5b2b07fcdc178801cb1f357ca","modified":1659259093000},{"_id":"source/_posts/模板代码/验证出栈合法序列_有无重复数据.cpp","hash":"6d22526eead6b3634c8a6c5fe56fd1ebcfb9bc89","modified":1648954303153},{"_id":"source/_posts/autumn_recruit/华为/problem5.cpp","hash":"1360db1e71a8973dfeb18cd1a19ab19a571c6d9b","modified":1688985379524},{"_id":"source/_posts/cplusDNN/project_dnn_cplusplus/Makefile","hash":"fa07bfff287dff10c4096a8704ca2857e43a1ffe","modified":1659259093000},{"_id":"source/_posts/autumn_recruit/海康威视/problem1.cpp","hash":"343b0ef72ce3c508cf61a29dbc7dead04528fce7","modified":1688985379526},{"_id":"source/_posts/autumn_recruit/美团/important.md","hash":"1b870fd868f9c4623d5db1213ca05997bac282d3","modified":1689158056050},{"_id":"source/_posts/autumn_recruit/华为/problem3.cpp","hash":"6d5e1a28027e2e7a299b8a564f6b3a62a37814aa","modified":1688985379523},{"_id":"source/_posts/autumn_recruit/美团/problem2.cpp","hash":"64f80e3edf00df469634ad94c3207f1c6eb9b54c","modified":1688985379527},{"_id":"source/_posts/autumn_recruit/eBay/problem1.cpp","hash":"d08f88df745fa7950b104e4a707a31cfce7b5841","modified":1688985379522},{"_id":"source/_posts/autumn_recruit/MS/problem3.cpp","hash":"b193fb65c316b263e76ab37e002097ca76e2ee22","modified":1662005161000},{"_id":"source/_posts/autumn_recruit/美团/problem3.cpp","hash":"1689001e04b5a64eef71270a5b05990eecd438a9","modified":1688985379528},{"_id":"source/_posts/autumn_recruit/美团/problem4.cpp","hash":"a7da7630e7a774b93118ea887ce3ca1bdae84d85","modified":1688985379528},{"_id":"source/_posts/autumn_recruit/网易/tempCodeRunnerFile.cpp","hash":"7ff18b3505a5fa611f1ea5b0d48bdb954374d4d4","modified":1660981140000},{"_id":"source/_posts/summer_intern_company/MS/problem1.cpp","hash":"f3bb344806e835e1248622e480c0bc42e7f4bea5","modified":1649905798593},{"_id":"source/_posts/summer_intern_company/MS/problem2.cpp","hash":"e360af6dc7eb28ba5dcac647f47549a15c17cf05","modified":1649907711547},{"_id":"source/_posts/summer_intern_company/MorganStaney/check_the_structure.cpp","hash":"415f6e5e6c97bc37c37f34c1bd0bdaa7dde2e09d","modified":1649677681908},{"_id":"source/_posts/summer_intern_company/MS/problem2","hash":"bf7cdb9da031618c099d4a80b062831609f7d7f4","modified":1649907599213},{"_id":"source/_posts/summer_intern_company/MS/problem1","hash":"f83bcdd60a37da52105f8dd9c619e1f45fa7299c","modified":1649904534072},{"_id":"source/_posts/summer_intern_company/MorganStaney/efficient_cost.cpp","hash":"0bbcc871aac8c6e1c511f33338fbb971a14c147e","modified":1649677432383},{"_id":"source/_posts/summer_intern_company/MS/tempCodeRunnerFile.cpp","hash":"654d1a5e9a67d4d79de626bb981933f73496c904","modified":1649904454319},{"_id":"source/_posts/summer_intern_company/about/index.md","hash":"cdf8aaba8b2fe73afa7ffea3a1b282605c014f6c","modified":1688987422002},{"_id":"source/_posts/summer_intern_company/MorganStaney/tempCodeRunnerFile.cpp","hash":"d087637dc4cbf02b79fcc9d7e048f2d5e9371345","modified":1649677029822},{"_id":"source/_posts/summer_intern_company/MorganStaney/efficient_cost","hash":"7ad46c38a30a8163dd6ccd2adf9b104ff1b4f52b","modified":1649677101470},{"_id":"source/_posts/summer_intern_company/hulu/problem1.cpp","hash":"ed31eec3b1fcbe351d78d681993992e06d25a7cc","modified":1647689290831},{"_id":"source/_posts/summer_intern_company/hulu/problem2.cpp","hash":"bd9ea92667d94a5285c883897d28cf17d13bba20","modified":1647343843473},{"_id":"source/_posts/summer_intern_company/hulu/problem1","hash":"c02c9b2e22486dce27336b5b01228e132cbba5e1","modified":1647689657330},{"_id":"source/_posts/summer_intern_company/hulu/problem3","hash":"a406bac7be7ad81cfe50778b58a2a1897c32aea0","modified":1647345157324},{"_id":"source/_posts/summer_intern_company/hulu/problem3.cpp","hash":"093391987c7e1077969495037aa1c7a2b8d3824f","modified":1647345332392},{"_id":"source/_posts/summer_intern_company/hulu/tempCodeRunnerFile.cpp","hash":"9aa2b840d1b7cd559efcd9adf9f741b6f0c94658","modified":1688985379578},{"_id":"source/_posts/summer_intern_company/jindong/problem2.cpp","hash":"cfe2f290df33624f57d7c38573b22dee40266860","modified":1647691182739},{"_id":"source/_posts/summer_intern_company/jindong/problem4.cpp","hash":"4229fecca4e113c2322071889fb44ee7cb09d7df","modified":1647693272977},{"_id":"source/_posts/summer_intern_company/jindong/problem4","hash":"9a2d335a0c7a8acda031ea8a7bd8407370cd778a","modified":1647692036544},{"_id":"source/_posts/summer_intern_company/jindong/tempCodeRunnerFile","hash":"9a2d335a0c7a8acda031ea8a7bd8407370cd778a","modified":1647692003069},{"_id":"source/_posts/summer_intern_company/微软/problem1.cpp","hash":"a577751dfe159e1f0b9c53c4e3d3a5f3db254b57","modified":1642925123091},{"_id":"source/_posts/summer_intern_company/jindong/tempCodeRunnerFile.cpp","hash":"50870edadb1ba2ba7fa993eab51ac705a4aaddde","modified":1647692001873},{"_id":"source/_posts/summer_intern_company/微软/problem2.cpp","hash":"7b358b8f7bddba12fa73bf9a6a8cecbbe13980f7","modified":1642924989034},{"_id":"source/_posts/summer_intern_company/微软/problem4.cpp","hash":"7509e00d6efb9c4484d242612e2da0339837d192","modified":1664161078000},{"_id":"source/_posts/summer_intern_company/微软/阿拉伯数字和中文互换.cpp","hash":"ecc372560073964634c9f2c54c74946799c58386","modified":1688985379579},{"_id":"source/_posts/summer_intern_company/微软/problem3.cpp","hash":"0b908d9ee78bdc67aa53fb19ba54c0c4cbef2d16","modified":1642926376136},{"_id":"source/_posts/summer_intern_company/百度/problem1.cpp","hash":"34d20fab2524e206dcff52e6ac9f2c57f599f033","modified":1647948636610},{"_id":"source/_posts/summer_intern_company/微软/summay.txt","hash":"f0e2a0c89f6b4429c38abd9221135536b7ed4256","modified":1645749963375},{"_id":"source/_posts/summer_intern_company/微软/test.cpp","hash":"b3667ccbd9650490c4b4f56502d9fd0814abe8a2","modified":1645750142317},{"_id":"source/_posts/summer_intern_company/百度/problem2.cpp","hash":"b394785504005404f00c5895fa80b86d0fd041d8","modified":1647949646933},{"_id":"source/_posts/summer_intern_company/百度/tempCodeRunnerFile.cpp","hash":"a95388ed4600e611489b29d44ce861169fffad0e","modified":1647949573385},{"_id":"source/_posts/summer_intern_company/百度/problem3.cpp","hash":"fd0887a1b179d4cf47314432bcc3d36408b3f1ae","modified":1647953338139},{"_id":"source/_posts/summer_intern_company/百度-2/problem1.cpp","hash":"0983bdbee1ec5dd86428f4cb49e49f9ca6fb2644","modified":1648555537095},{"_id":"source/_posts/summer_intern_company/百度-2/problem2.cpp","hash":"0f0942db8bfc5eb688e1dcb3abcd5bdf64d3d116","modified":1648558413886},{"_id":"source/_posts/summer_intern_company/百度-2/problem3.cpp","hash":"c8ce65bcb1026811009e6e5b0dd103aefd6d3ebd","modified":1648552125138},{"_id":"source/_posts/summer_intern_company/百度-2/problem2","hash":"839145541128b31f6d31b91a35ca5b8e6a6af912","modified":1648558370838},{"_id":"source/_posts/工具相关/command-related/image-20211207175530810.png","hash":"855eee917f189a446cde3fc8da826b2876737ade","modified":1638870930811},{"_id":"source/_posts/summer_intern_company/百度-2/tempCodeRunnerFile.cpp","hash":"db2bb41712190231eb508c11531f78054d396802","modified":1648558356455},{"_id":"source/_posts/summer_intern_company/百度-2/tempCodeRunnerFile","hash":"45fdfc26397c3f908699f35ca093eb8969826a13","modified":1648556326515},{"_id":"source/_posts/autumn_recruit/MS/.vscode/settings.json","hash":"d6f66114ea7b5de39350dd92c86c6d522bde48bd","modified":1662003859000},{"_id":"source/_posts/cplusDNN/project_dnn_cplusplus/include/relu_layer.h","hash":"1785eff8704396a74b5af5b5089fc08437b8d4c0","modified":1659259093000},{"_id":"source/_posts/cplusDNN/project_dnn_cplusplus/include/dnn.h","hash":"60b45e59f1de50b4c522b44a1abf0e77988d9aaf","modified":1659259093000},{"_id":"source/img/bg-shouye-4.jpg","hash":"4c0119d70fb1e0078688c466991beb8fd804691c","modified":1689161030888},{"_id":"source/img/bg-shouye-3.jpg","hash":"cb673f2985aa1df77baf4753775f35c02f7edcf1","modified":1689161021687},{"_id":"source/img/bg-shouye.jpg","hash":"993634d3655c2148c0787c62d757b2d523ce951d","modified":1689161849166},{"_id":"source/img/bg-shouye-yuantu.jpg","hash":"2e218535ede26fdb313f1b54361af5784e551064","modified":1689161888084},{"_id":"source/img/bg-shouye-2.jpg","hash":"bc16b1cbe147b23da26000c392029197d070f776","modified":1689161009734},{"_id":"source/img/self.jpg","hash":"f08bc46151cd59a989cd05555484b1472bf9f60a","modified":1689162983756},{"_id":"source/_posts/模板代码/tempCodeRunnerFile","hash":"1eb243399f7df1a4690d16b9d5fe108dccf90c41","modified":1649063228994},{"_id":"source/_posts/模板代码/换根dp","hash":"5c9c240109ad82072219b59541a98eaec1cbaa44","modified":1649063511046},{"_id":"source/_posts/summer_intern_company/hulu/tempCodeRunnerFile","hash":"93d47b19d6049cc2e0175a0d223ac70f66f0302a","modified":1688985379577},{"_id":"source/_posts/summer_intern_company/hulu/problem2","hash":"79b4294b4d6fa18d3295a258dd024533b6e5dc46","modified":1647343845325},{"_id":"source/_posts/summer_intern_company/jindong/problem2","hash":"382c0166ac6f8eca6f8c21d97f26bb165e254d4e","modified":1647691196079},{"_id":"source/_posts/summer_intern_company/百度/problem1","hash":"7435ccd277148d060a4f82d03aeee097de6da100","modified":1647948640331},{"_id":"source/_posts/summer_intern_company/百度/problem3","hash":"b3da475f5aa6fe3fd7776941155af051c1ccb91d","modified":1647950605223},{"_id":"source/_posts/summer_intern_company/百度/problem2","hash":"01c3484d8c59fce3057bc63094e5dc84dbd68f2d","modified":1647949659188},{"_id":"source/_posts/summer_intern_company/百度-2/problem1","hash":"768d2a742df7ac4a28051268cb9f10611f4ffe2d","modified":1648555558480},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1636356415778},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1636356415783},{"_id":"source/_posts/模板代码/验证出栈合法序列_有无重复数据","hash":"85ecc04423a5ae9fb1877147c65c5f49e1db041a","modified":1648954225516},{"_id":"source/img/bg.jpeg","hash":"ecfe3c6b0bc9afe202ccadc86d10a6e704636df3","modified":1689157717176},{"_id":"node_modules/hexo-theme-fluid/.eslintrc","hash":"4bc2b19ce2b8c4d242f97d4ccf2d741e68ab0097","modified":1636356415728},{"_id":"node_modules/hexo-theme-fluid/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":1636356415730},{"_id":"node_modules/hexo-theme-fluid/.editorconfig","hash":"33218fbd623feb43edf5f99f15965392cecc44a6","modified":1636356415727},{"_id":"node_modules/hexo-theme-fluid/LICENSE","hash":"df5b54be535593d5442cebafbea34eb9bd69b987","modified":1636356415731},{"_id":"node_modules/hexo-theme-fluid/package.json","hash":"18f04247801549fe78600c1ee9c601fcbea4cab3","modified":1636356415769},{"_id":"node_modules/hexo-theme-fluid/languages/de.yml","hash":"13a6a799415fc2f6f69ebd1a399fb44426a5d641","modified":1636356415787},{"_id":"node_modules/hexo-theme-fluid/languages/en.yml","hash":"a85dcc5cc21f9cab50df31e5001b8818ee62d1e2","modified":1636356415787},{"_id":"node_modules/hexo-theme-fluid/languages/eo.yml","hash":"a0c7984495d4f2d33b64adfa33adebbf768a5ac3","modified":1636356415787},{"_id":"node_modules/hexo-theme-fluid/languages/ja.yml","hash":"91020031a847c0361a6fd7ab990c7be4bf17529b","modified":1636356415787},{"_id":"node_modules/hexo-theme-fluid/_config.yml","hash":"cd5cbd070b6190aa0b4839400c0a1581e2654470","modified":1636356415786},{"_id":"node_modules/hexo-theme-fluid/languages/zh-CN.yml","hash":"21307b4137c3d9b04bb58243747e75af0abc5a71","modified":1636356415787},{"_id":"node_modules/hexo-theme-fluid/languages/zh-TW.yml","hash":"1a6d415446da11dee5c5f400e7d67544fbe743ea","modified":1636356415787},{"_id":"node_modules/hexo-theme-fluid/layout/404.ejs","hash":"689d9f4efd2a7f5edfd9b24561a7ade69d46617c","modified":1636356415737},{"_id":"node_modules/hexo-theme-fluid/layout/about.ejs","hash":"ad6fed7b646d3ca961db83db0fbe020e3a5d42ad","modified":1636356415737},{"_id":"node_modules/hexo-theme-fluid/layout/categories.ejs","hash":"20c2a195a109d2a263b5fa6e79cbcc62932508ad","modified":1636356415743},{"_id":"node_modules/hexo-theme-fluid/layout/category.ejs","hash":"58291dfec65c36889dfce0ddc603540b67e4c598","modified":1636356415743},{"_id":"node_modules/hexo-theme-fluid/layout/archive.ejs","hash":"472d0813ca5b88000a7bc6039f33b7e27b5a3216","modified":1636356415742},{"_id":"node_modules/hexo-theme-fluid/README.md","hash":"03cfa8e5f149514b57ef80dcb84eb7fea261370d","modified":1636356415771},{"_id":"node_modules/hexo-theme-fluid/README_en.md","hash":"ca8fd19a4948de1f253616a62c0e8a7d81f692f5","modified":1636356415771},{"_id":"node_modules/hexo-theme-fluid/layout/index.ejs","hash":"666476260a2cead2cc2928d51977c4a7ba8de6bb","modified":1636356415747},{"_id":"node_modules/hexo-theme-fluid/layout/links.ejs","hash":"2a7b49f0f9aecf07550b5a0b99242aab5654cf2b","modified":1636356415749},{"_id":"node_modules/hexo-theme-fluid/layout/page.ejs","hash":"1014b901d396f4fc445cb1ffc938d5380d894d71","modified":1636356415751},{"_id":"node_modules/hexo-theme-fluid/layout/layout.ejs","hash":"7f566edf750241e62d7c54abfbb0c504fdab850a","modified":1636356415749},{"_id":"node_modules/hexo-theme-fluid/layout/tag.ejs","hash":"0ad89eb7c92a822980fa9a85285e6d94ad845d1d","modified":1636356415753},{"_id":"node_modules/hexo-theme-fluid/layout/post.ejs","hash":"79e3679a7069351a6172c281b9d09f59d7580484","modified":1636356415752},{"_id":"node_modules/hexo-theme-fluid/layout/tags.ejs","hash":"1d06af34b6cf1d8a20d2eb565e309326ceba309f","modified":1636356415753},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/bug_report.md","hash":"16d33eb89ecf90f4046720fde5395d972c7ba1fd","modified":1636356415770},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/feature_request_zh.md","hash":"ed08574b196447376dd74411cca664ac9227a5d4","modified":1636356415770},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/bug_report_zh.md","hash":"af977ed0792508bb0766ea8afe82d34ef1e8fb3c","modified":1636356415770},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/question.md","hash":"ab5eab9e3ff889c4ba7fd82846e7f5b7ae15bebc","modified":1636356415771},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/feature_request.md","hash":"c134dd57ffd269b93402ccfffe7dbe0f0b583bec","modified":1636356415770},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/archive-list.ejs","hash":"53a4f6029373a40394a87aba9284696a71610f90","modified":1636356415741},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/beian.ejs","hash":"58b4bbe36386de4305a8da5ffd7d56802df23049","modified":1636356415742},{"_id":"node_modules/hexo-theme-fluid/.github/workflows/limit.yaml","hash":"f8bd2edeb4424ee7a055b31583445d5d5dff91a4","modified":1636356415784},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/css.ejs","hash":"c363829a4b80f74fc1c565e41f6dab41c95006ea","modified":1636356415744},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/footer.ejs","hash":"a62278c38a310da495d96c39abacacef266945cb","modified":1636356415746},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/head.ejs","hash":"3a1b5829c004a62d7282faafa7d04153c34e627e","modified":1636810611609},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/question_zh.md","hash":"e24b470f7aa8044499a4f5e39634e5dc43899011","modified":1636356415771},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/nav.ejs","hash":"e71b3c4aa263163597d31b1f91e5a1a877084cfd","modified":1636356415750},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/paginator.ejs","hash":"0f38a2c238169edcb63fc46c23bfc529ff3859b7","modified":1636356415751},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/post-meta.ejs","hash":"32a17edadeed40da6db21d2d8031bd47d2fc9bf4","modified":1636356415751},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/scripts.ejs","hash":"0ee838b6fcd895d21a29d9d67dbb99b752d623d1","modified":1636356415752},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/search.ejs","hash":"cdd7919fa01f6ef7ccc09938d662ff3d77f5d999","modified":1636356415753},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/statistics.ejs","hash":"920bc618d357d48d2b96f8758f6ae8f9488fc4d8","modified":1636356415753},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/toc.ejs","hash":"3d2fb5552f373e5a0c56bc356702d807bcbcb411","modified":1636356415753},{"_id":"node_modules/hexo-theme-fluid/scripts/events/index.js","hash":"44faef3e77ab08b91e4c5c6f1cd9087a9faff443","modified":1636356415764},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/locals.js","hash":"58d0fec976f6b1d35e7ea03edc45414088acf05c","modified":1636356415766},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/local-search.js","hash":"fc2c50405b771b06b7f6cfc4e9de97b992691555","modified":1636356415765},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/post-filter.js","hash":"6c37e9f1ac1d6d00b3c32794e02e244dba942cd9","modified":1636356415768},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/pages.js","hash":"d9971f15fbb6b775e3d31a1b9b45011959395010","modified":1636356415767},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/export-config.js","hash":"cde964c8cd3217268a231de5e018a62c53c2e047","modified":1636356415761},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/page.js","hash":"4607607445233b3029ef20ed5e91de0da0a7f9c5","modified":1636356415767},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/url.js","hash":"2a6a8288176d0e0f6ec008056bf2745a86e8943e","modified":1636356415768},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/utils.js","hash":"3aa5b4ea879cd34d3a32468d88da18d72cbcc8e0","modified":1636356415769},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/wordcount.js","hash":"8e33f915028ac56258f6999d19b1ad8d800cecfe","modified":1636356415769},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/compare-versions.js","hash":"dbbc928c914fc2bd242cd66aa0c45971aec13a5d","modified":1636356415760},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/object.js","hash":"649457796374c79e49a19bd541e4ad8e78fe8995","modified":1636356415767},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/url-join.js","hash":"718aab5e7b2059a06b093ca738de420d9afa44ba","modified":1636356415768},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/button.js","hash":"3eb43a8cdea0a64576ad6b31b4df6c2bf5698d4c","modified":1636356415759},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/checkbox.js","hash":"63468f7875c09d9557fe8315afc97175745d9087","modified":1636356415759},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/group-image.js","hash":"4aeebb797026f1df25646a5d69f7fde79b1bcd26","modified":1636356415762},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/mermaid.js","hash":"75160561e1ef3603b6d2ad2938464ab1cb77fd38","modified":1636356415767},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/label.js","hash":"f05a6d32cca79535b22907dc03edb9d3fa2d8176","modified":1636356415764},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/note.js","hash":"f52f3a005b41f48b4da274ac64710177c8d4502f","modified":1636356415767},{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1636356415734},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","hash":"d5a8a59c8d1fd17d699a951e59c4ce9ae44c419d","modified":1636356415781},{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1636356415771},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","hash":"7bb2b8ee07db305bcadee2985b81b942027ae940","modified":1636356415773},{"_id":"node_modules/hexo-theme-fluid/source/img/favicon.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1636356415774},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1636356415775},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","hash":"3de344ee619da989f6dccf7c2ae459fe91075983","modified":1636356415757},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","hash":"2520c6459b544a4e965b838f8095e2a84390a43c","modified":1636356415759},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1636356415757},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","hash":"4b9d2676c9544db9cc40a8c7d18456792299ba86","modified":1636356415761},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1636356415763},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","hash":"4a787cfce27045aa0a92ec22e84f2ccf30cabc4c","modified":1636356415765},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","hash":"633f0142c657805359b0197f287e12ae4bcde731","modified":1636356415766},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","hash":"d058f30bd09b28769c4d8313428ff23dfc8d52dd","modified":1636356415768},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","hash":"4a43f2700e91937650bef511fd438825b001c4c6","modified":1636356415769},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1636356415784},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/changyan.ejs","hash":"c9b2d68ed3d375f1953e7007307d2a3f75ed6249","modified":1636356415743},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/cusdis.ejs","hash":"5f9dc012be27040bbe874d0c093c0d53958cc987","modified":1636356415745},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/disqus.ejs","hash":"aab4a4d24c55231a37db308ae94414319cecdd9b","modified":1636356415745},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/gitalk.ejs","hash":"843bc141a4545eb20d1c92fb63c85d459b4271ec","modified":1636356415746},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/remark42.ejs","hash":"d4e9532feeb02aed61bd15eda536b5b631454dac","modified":1636356415752},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/livere.ejs","hash":"2264758fed57542a7389c7aa9f00f1aefa17eb87","modified":1636356415749},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/waline.ejs","hash":"21e00443054802e893aac1f668b69d5bb4b39b3a","modified":1636356415755},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/twikoo.ejs","hash":"1af53bc0be642610a3a4d4e7c05287854a821508","modified":1636356415754},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/utterances.ejs","hash":"e1ed6530dfd7310f91060a75766a93ac3c39be3a","modified":1636356415754},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/valine.ejs","hash":"4052ab2a8f78efa92f0fe17abe8f66135943390a","modified":1636356415754},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/math.ejs","hash":"a7ed1d3079c32497c8955ca75f5fb6992e5ffb8b","modified":1636356415749},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/analytics.ejs","hash":"557077a8825fffc0a2c7fe2b29f319287950244f","modified":1636356415740},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/mermaid.ejs","hash":"10ed1f9a611449d37736e17c4e251127b38b3772","modified":1636356415750},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/nprogress.ejs","hash":"4c2d39ce816b8a6dcd6b53113c8695f8bd650a23","modified":1636356415750},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/compatible-configs.js","hash":"b5fd5a2d9c463eb59318af0f47c591c485b6ad27","modified":1636356415760},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/typed.ejs","hash":"ece659572cf4e12638a1607fca512c25098bbd82","modified":1636356415754},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/hello.js","hash":"28e186c32576eb3d5d923273471a001c47fe8071","modified":1636356415763},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/highlight.js","hash":"deed966f38cf0c8dee3f72e5b1f2e878510db0e1","modified":1636356415763},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/footnote.js","hash":"3b2abc5f5e3b681874637e98e047dc4969eb1983","modified":1636356415762},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/lazyload.js","hash":"9ba0d4bc224e22af8a5a48d6ff13e5a0fcfee2a4","modified":1636356415764},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/pages.styl","hash":"b8e887bc7fb3b765a1f8ec9448eff8603a41984f","modified":1636356415781},{"_id":"node_modules/hexo-theme-fluid/source/css/_mixins/base.styl","hash":"542e306ee9494e8a78e44d6d7d409605d94caeb3","modified":1636356415776},{"_id":"node_modules/hexo-theme-fluid/source/css/_variables/base.styl","hash":"d420160c4649d7896fec620cdbb9f47dea558fb3","modified":1636810628681},{"_id":"node_modules/hexo-theme-fluid/source/css/_functions/base.styl","hash":"2e46f3f4e2c9fe34c1ff1c598738fc7349ae8188","modified":1636356415776},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/merge-configs.js","hash":"c1db1a4f9eca6e36b660530641e3a4fb6a30c8d8","modified":1636356415767},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_about/about.styl","hash":"97fe42516ea531fdad771489b68aa8b2a7f6ae46","modified":1636356415775},{"_id":"node_modules/hexo-theme-fluid/source/lib/hint/hint.min.css","hash":"b38df228460ebfb4c0b6085336ee2878fe85aafe","modified":1636356415735},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_archive/archive.styl","hash":"6e6f22b664199772370b59ce1678b0c148b5849f","modified":1636356415775},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/color-schema.styl","hash":"32fb938d72b2d86159cb315a98b086bd17fa4415","modified":1636356415778},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/base.styl","hash":"cd55a2dce6b9d3e165a0a26d0b5bf7f649006bcd","modified":1636356415777},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/inline.styl","hash":"d547ab0b91f84eb0acd0bc0c5d716ce17c30361a","modified":1636356415780},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/keyframes.styl","hash":"94065ea50f5bef7566d184f2422f6ac20866ba22","modified":1636356415780},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/categories.styl","hash":"1ab7db37c2f7dc7ccdb994dcb41c16a4c8920397","modified":1636356415777},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/rewrite.styl","hash":"c66e0da2c0d05e76a686a77ab4e74f0d2e89777d","modified":1636356415782},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_index/index.styl","hash":"616c1f7147078c3d532dd1cfd2af09c0c3a816f0","modified":1636356415780},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_links/links.styl","hash":"7e32a3268accf3d524209c213e15e2d5d5e2e1a6","modified":1636356415781},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/post.styl","hash":"3a6b4f8a29648d9d2c1e99b52a7b42df3f15cf62","modified":1636356415782},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/tag_plugin.styl","hash":"b89b96c8a6a433a6f372b42710554b05cab85a24","modified":1636356415783},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tags.styl","hash":"65bfc01c76abc927fa1a23bf2422892b0d566c3f","modified":1636356415783},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/board.styl","hash":"32d90bcc8bf2fd5d8d78e86a567973d4b69bcfa1","modified":1636356415777},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/banner.styl","hash":"30f8fab95a5214d79df0ccc02b937df8bd885676","modified":1636356415776},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footer.styl","hash":"0ce7552dc4993926426019398d73e817cfd841a1","modified":1636356415779},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/copy-btn.styl","hash":"9f932ca3f9625c13aa5353f58319881e62c0c653","modified":1636356415779},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/header.styl","hash":"d8011325756eb6e4ce619b3e7b4d6d80c2de8a57","modified":1636356415780},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footnote.styl","hash":"ae9289cc89649af2042907f8a003303b987f3404","modified":1636356415780},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/qrcode.styl","hash":"78704a94c0436097abfb0e0a57abeb3429c749b7","modified":1636356415782},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/scroll-btn.styl","hash":"55e10a6965462f8f62f85e75fd5e143af02a4b44","modified":1636356415783},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/search.styl","hash":"10f7e91a91e681fb9fe46f9df7707b9ef78707c8","modified":1636356415783},{"_id":"source/_posts/项目相关/编程语言/image-20220122202312622.png","hash":"12142d5d9905e020c67841321dc54b02875b73ab","modified":1642854192627},{"_id":"source/img/bg-guanyu.jpg","hash":"7e7e8129ad6a11167b32b1055d330731098e7846","modified":1689160773240},{"_id":"source/img/bg-wenzhang.jpg","hash":"30538429322fda4313459305c085d2006abf44a3","modified":1689157717174},{"_id":"source/img/bg-favorite.jpg","hash":"f43bef7c3daffec32bf2013aad5e1bac40bc7e7d","modified":1689500222043},{"_id":"source/img/bg-guanyu-yuantu.jpeg","hash":"1c157da3354b8c34e9f2296bac12d0068591d416","modified":1689160788838},{"_id":"source/img/bg-wenzhang-4.jpg","hash":"738e19554455fff8218f295c8c419f3159ff4784","modified":1689161402966},{"_id":"source/img/bg-wenzhang-2.jpg","hash":"414e42dcf974629b45f128ec1a053b5609048c2d","modified":1689159192644},{"_id":"source/img/bg-fenlei.jpg","hash":"d113187b8d1a067221e3b20c102b6410cabb08c3","modified":1689159079187},{"_id":"source/img/bg-guidang.jpg","hash":"d9149cb6888cb3e7b25bb64a5d6362b54af75f95","modified":1689159114794},{"_id":"source/img/bg-biaoqian.jpg","hash":"18e6c8ddbad20775065da0c2acf333f4f8f42b18","modified":1689159097364},{"_id":"source/img/bg-zidingyi.jpg","hash":"ec3a29099438351a152af7a27817b09e60b7def7","modified":1689159212079},{"_id":"source/img/bg-wenzhang-5.jpg","hash":"f0173b5ab23f391b46a48829a3ed11ede0058fc8","modified":1689161868145},{"_id":"public/baidusitemap.xml","hash":"68cb655d85c1cb3398046e5db414ed3aca9b2203","modified":1689506255460},{"_id":"public/atom.xml","hash":"b4ebe5d391fc588431e603dbdb53c79d6375ae05","modified":1689506255460},{"_id":"public/search.xml","hash":"a98946b99bae34131007869452962a1cdd345aac","modified":1689506255460},{"_id":"public/local-search.xml","hash":"54434f75e556baff20013237c1c4d705d9be9ff4","modified":1689506255460},{"_id":"public/sitemap.xml","hash":"2b7ca07d225c86fa10c8e8184f611a1855f8086d","modified":1689506255460},{"_id":"public/favorite/index.html","hash":"612e43f8b6c8f4d060bbf40c6d2e1aabc63a2880","modified":1689506255460},{"_id":"public/about/index.html","hash":"43fbdf9b96756ea14261f06c60ffea229efc3bdf","modified":1689506255460},{"_id":"public/favorite-language/index.html","hash":"a3de21e5f6ffd8d4c9d336b54e1377c50a2743c0","modified":1689506255460},{"_id":"public/favorite-reading/index.html","hash":"6a5751fecf59ec887cbf63ad157fed9f5d7aaffc","modified":1689506255460},{"_id":"public/2022/08/21/autumn_recruit/美团/important/index.html","hash":"a5a25a6e6c3319c143ef819c7ed5c079a439ef4c","modified":1689506255460},{"_id":"public/2022/06/13/项目相关/C#/index.html","hash":"dcc61ce0a49362271a2459c6f39ab75b839b4903","modified":1689506255460},{"_id":"public/2022/02/25/工具相关/vscode/index.html","hash":"dc901e12993a0a64099c9a7df47937bd9ef465a7","modified":1689506255460},{"_id":"public/2022/01/20/工具相关/md语法相关/index.html","hash":"6dcff1edc85fced534094d6d41a0dfbfbe7746e8","modified":1689506255460},{"_id":"public/2021/11/13/工具相关/leetcode-单调栈相关/index.html","hash":"2cb5af155b59934f1e2a59a3d4e6776103b8d146","modified":1689506255460},{"_id":"public/2021/11/10/工具相关/secrete/index.html","hash":"a341383e92f622c3eec761c66be96fdb5a5dee48","modified":1689506255460},{"_id":"public/2021/11/08/summer_intern_company/about/index/index.html","hash":"07a7c567a370bc26cdf48175fc3df1de24e13cb0","modified":1689506255460},{"_id":"public/archives/index.html","hash":"bf7987a0f4d97c829133f3e64843b17536332acb","modified":1689506255460},{"_id":"public/archives/page/2/index.html","hash":"c3f3d9f1ee78d24b535595a23d0f1c7cadcf6a07","modified":1689506255460},{"_id":"public/archives/page/3/index.html","hash":"a3dafd83e5d3adc8c99876f3ec13e08d237976be","modified":1689506255460},{"_id":"public/archives/page/4/index.html","hash":"f0e8fcecf90821cb75baa422b619254ec4beee9c","modified":1689506255460},{"_id":"public/archives/page/5/index.html","hash":"349954874a2b9250afbc563cc6c8e59c30f253c4","modified":1689506255460},{"_id":"public/archives/2021/index.html","hash":"0955010e1584874eed62fc94782f7238de4b2c6b","modified":1689506255460},{"_id":"public/archives/2021/page/2/index.html","hash":"e56b98e99f8af613f2d3f12e4c511e56a25964ce","modified":1689506255460},{"_id":"public/archives/2021/page/3/index.html","hash":"26c0ea6ab4b49e520b1c87414cfc1063a4e45fd3","modified":1689506255460},{"_id":"public/archives/2021/page/4/index.html","hash":"474439342779d2b54b05ac41f291bebd7b25bc02","modified":1689506255460},{"_id":"public/archives/2021/11/index.html","hash":"5a83d085d3629af613e83a3122871acd0970b329","modified":1689506255460},{"_id":"public/archives/2021/11/page/2/index.html","hash":"dfba86ccc1a15c237a433ce136fcc6de427d78bb","modified":1689506255460},{"_id":"public/archives/2021/11/page/3/index.html","hash":"6125a10bf92aaa4d1307b1331912138f59a39297","modified":1689506255460},{"_id":"public/archives/2021/11/page/4/index.html","hash":"85bf00ceeac51e9a72eadac10838a3217fa043c9","modified":1689506255460},{"_id":"public/archives/2021/12/index.html","hash":"5013a7100d1d154e8d97fa361ef43dd6011d5172","modified":1689506255460},{"_id":"public/archives/2022/page/2/index.html","hash":"3e7eaf2da2918ed4cb708e5e128e3529cb9f249c","modified":1689506255460},{"_id":"public/archives/2022/index.html","hash":"5e56fccccfca7bf5734db6a6bf5114601c5c46ce","modified":1689506255460},{"_id":"public/archives/2022/01/index.html","hash":"cb706eed0634ee35680c77c25760a63089a80298","modified":1689506255460},{"_id":"public/archives/2022/02/index.html","hash":"c4ba549940e587a3ffd6c75e0a88f9620fa67da6","modified":1689506255460},{"_id":"public/archives/2022/04/index.html","hash":"530699008136a50bdebdfd208849bff083171f2b","modified":1689506255460},{"_id":"public/archives/2022/06/index.html","hash":"2b5056088808e34b6576ae30ef55b5bc97a653ce","modified":1689506255460},{"_id":"public/archives/2022/08/index.html","hash":"be78269dd1a5cb91c5b8e7434f48c711b32b8a92","modified":1689506255460},{"_id":"public/categories/leetcode/index.html","hash":"67d6916b6d16d7b30f6a59188bf40a2c220b73bb","modified":1689506255460},{"_id":"public/categories/leetcode/page/2/index.html","hash":"ad04a5b90c6ed277a5101ff337f5515c84d1afe7","modified":1689506255460},{"_id":"public/categories/dp问题专栏/index.html","hash":"c053f11c16db7136e1395c04fc1bd4569df5cf72","modified":1689506255460},{"_id":"public/categories/其他/index.html","hash":"fbda2aeb2e6748044d287cff8bf22872c0a66751","modified":1689506255460},{"_id":"public/categories/工具相关/index.html","hash":"7da7bd18d0e93b33837ac7d05251cbea084f0cf0","modified":1689506255460},{"_id":"public/categories/项目相关/index.html","hash":"0dd50aa40d67fc13102bde84f62c739ea95636f6","modified":1689506255460},{"_id":"public/categories/autumn-recruit/index.html","hash":"a7ea91bbad56a79bb7a8bf033dbbf37cc3ed15ae","modified":1689506255460},{"_id":"public/categories/autumn-recruit/美团/index.html","hash":"794f9ea7af5e3ec855ce697fdfc585049d11ed25","modified":1689506255460},{"_id":"public/tags/二分/index.html","hash":"f9dc9fe9b6c8f28b5c8bf5000eb2a9263f3d7239","modified":1689506255460},{"_id":"public/tags/其他/index.html","hash":"7f7d519f29ca28c3a6cb9db65ae16fede516af97","modified":1689506255460},{"_id":"public/tags/dp/index.html","hash":"1fae4b94673a3533314b06b0459568fe69ee835a","modified":1689506255460},{"_id":"public/tags/栈-单调栈/index.html","hash":"2f70cbeb5bf5173b12de287fda3882f3e6f4fe58","modified":1689506255460},{"_id":"public/tags/双指针/index.html","hash":"0bcbe6ede19a0b4e06cef8723971f19dcee2c1c1","modified":1689506255460},{"_id":"public/tags/回溯算法-DFS-BFS/index.html","hash":"a52d1994fe6339e1eb264055d0724189275707f0","modified":1689506255460},{"_id":"public/tags/多线程并发，-信号量，-互斥锁/index.html","hash":"1d023b34a6f69274168165ad11846e072fd5bdc9","modified":1689506255460},{"_id":"public/tags/Linux-command/index.html","hash":"1343affdd907c91d9da1c02a856a12f2a9c658cd","modified":1689506255460},{"_id":"public/tags/conda-environment/index.html","hash":"cf53fa4df9d596a67b4b5165639ac76c8fb99b65","modified":1689506255460},{"_id":"public/tags/typora-md/index.html","hash":"3d8f918231a15f74f22a7456c7a2ede34c33f303","modified":1689506255460},{"_id":"public/tags/scheduler/index.html","hash":"a0255f8adacbab8517458e9caecad22ea8bb4823","modified":1689506255460},{"_id":"public/tags/private/index.html","hash":"98beb6dd22478e61a82c5602290b3f80571c058e","modified":1689506255460},{"_id":"public/tags/zplot/index.html","hash":"36f693bc8e5894a15c266dde071580b727d3beef","modified":1689506255460},{"_id":"public/tags/vscode-python/index.html","hash":"67d62f61ee69e5c4c45f4524ba54ff32fa810d01","modified":1689506255460},{"_id":"public/tags/machine-learning/index.html","hash":"42dd2d60e01ab499222a527cfaae2ab839e0bf67","modified":1689506255460},{"_id":"public/tags/八股文/index.html","hash":"09def32f43c100cce5e9ab589bcd5057740228b5","modified":1689506255460},{"_id":"public/tags/python-C/index.html","hash":"8adcc4f5d515a626091e0c9060cc5f4b5ae8f489","modified":1689506255460},{"_id":"public/tags/review-tips/index.html","hash":"d77e41908a1ba559929be1f430e262055b69d0d5","modified":1689506255460},{"_id":"public/404.html","hash":"77bdeba51b2bd1bfee0f67beddf2e16f523bee8b","modified":1689506255460},{"_id":"public/tags/index.html","hash":"f09d8a2187884c4c460ac74eb934bd2af0b8e897","modified":1689506255460},{"_id":"public/links/index.html","hash":"989271a63a6cc48ff4d5deb46ab40ceacdacdbb8","modified":1689506255460},{"_id":"public/2022/04/10/leetcode/hard题目合集/index.html","hash":"9cf8ccf8d9abb534c420ee084f45d2e004d7a0b0","modified":1689506255460},{"_id":"public/2022/04/04/dp问题专栏/DAG+树状+其他dp/index.html","hash":"10b79b3dec010329cf3afbd1289967c08aa0efe6","modified":1689506255460},{"_id":"public/2022/02/23/项目相关/面试tips/index.html","hash":"c51bbe4734b430cdaed3ffca6e92d4942982e643","modified":1689506255460},{"_id":"public/2022/01/26/leetcode/多线程编程/index.html","hash":"8c61e573904060fc94b888e14627d11eb66f4b03","modified":1689506255460},{"_id":"public/2022/01/26/工具相关/分布式训练/index.html","hash":"0834f1c86c70f847380e5ea3c33dc0a437ddb867","modified":1689506255460},{"_id":"public/2022/01/19/leetcode/系统设计/index.html","hash":"128150b79d8ec0a95266608f88986db21b01f2d4","modified":1689506255460},{"_id":"public/2022/01/04/工具相关/zplot/index.html","hash":"adb7840abdd9ee3376233999e9aeee1b139bd1c5","modified":1689506255460},{"_id":"public/2021/12/15/工具相关/anaconda环境搭建从零到一/index.html","hash":"544a221e7ada5967ee3ba709236e61d9b3f0e033","modified":1689506255460},{"_id":"public/2021/12/03/工具相关/rpc/index.html","hash":"d4e60912d3a8ab5e6badaaa664b55482c458ab4e","modified":1689506255460},{"_id":"public/2021/12/01/工具相关/orangefs/index.html","hash":"59a215178aef0d70a72d56b1ca7f8b8bcc233707","modified":1689506255460},{"_id":"public/2021/11/24/项目相关/system design/index.html","hash":"53cd19b0f3041edb65768ca89d10b34852c4d5d6","modified":1689506255460},{"_id":"public/2021/11/23/leetcode/二叉树/index.html","hash":"e4e66187977d617b52278cceee62c5a581a5b79e","modified":1689506255460},{"_id":"public/2021/11/16/leetcode/链表/index.html","hash":"8cb9ab6e3bd2de56c8d5889f58e6e8a137bd9a9b","modified":1689506255460},{"_id":"public/2021/11/16/其他/各类资源/index.html","hash":"2be7cc86e926cc9b569bd7b492704a6912e0410d","modified":1689506255460},{"_id":"public/2021/11/15/日常记事/每天任务记录/index.html","hash":"da27142fcd0c0f0e444a745e685f66b6c3e59066","modified":1689506255460},{"_id":"public/2021/11/13/工具相关/hello-world/index.html","hash":"29c05e7ace28e68146368e4e6ea84100d8605dcd","modified":1689506255460},{"_id":"public/2021/11/13/项目相关/基本神经网络总结/index.html","hash":"0980c77150687c02e1191e69326e63f52e3a6b94","modified":1689506255460},{"_id":"public/2021/11/13/项目相关/机器学习/index.html","hash":"6c9f318f1bdd31d1cc55376376b8bac106dc15ca","modified":1689506255460},{"_id":"public/2021/11/13/项目相关/编程语言/index.html","hash":"c4ed576975c49094ac5bcc3986227056cdd71b95","modified":1689506255460},{"_id":"public/2021/11/13/项目相关/面试/index.html","hash":"60952340bbb0948102234a4c4a94d81da0f357d0","modified":1689506255460},{"_id":"public/2021/11/13/项目相关/笔试/index.html","hash":"6c489361ae910fe2103dbb0b5f36a30958b42efd","modified":1689506255460},{"_id":"public/2021/11/13/leetcode/哈希相关/index.html","hash":"e06c53cc9b3dfae2d25be85bdabd5716db6d66f7","modified":1689506255460},{"_id":"public/2021/11/13/leetcode/回溯_DFS_BFS/index.html","hash":"c2d8d740bd0810a004d92edb4818354f4e99c817","modified":1689506255460},{"_id":"public/2021/11/13/leetcode/字符串/index.html","hash":"a048b56254e0b6f7ec013c76940e18f46c858756","modified":1689506255460},{"_id":"public/2021/11/13/leetcode/暂时没看内容/index.html","hash":"695f2ea86d0dbf60697376a28db4b6e5e0ffe942","modified":1689506255460},{"_id":"public/2021/11/13/leetcode/位运算/index.html","hash":"da064a1ccdd7908f263e89dd24f95a6239b52a7e","modified":1689506255460},{"_id":"public/2021/11/13/leetcode/贪心算法/index.html","hash":"7de31e1b50621e442097d65b86a5dcfc86093036","modified":1689506255460},{"_id":"public/2021/11/13/leetcode/其他/index.html","hash":"50a366ff75b7735434ef156ada5506597bda20c5","modified":1689506255460},{"_id":"public/2021/11/13/leetcode/双指针/index.html","hash":"9cb2728c26fc8eb380c94c6850990a67debd34da","modified":1689506255460},{"_id":"public/2021/11/13/leetcode/排序题/index.html","hash":"bb443546bc913080f71898d979582d87ba2b8e03","modified":1689506255460},{"_id":"public/2021/11/13/leetcode/滑动窗口/index.html","hash":"dbb67f0ac118b92831bf57fb4a54a338388b4501","modified":1689506255460},{"_id":"public/2021/11/13/leetcode/二分算法/index.html","hash":"ac1b73488cc520dedacd21ef5076a1b32f65ed08","modified":1689506255460},{"_id":"public/2021/11/13/leetcode/动态规划题型/index.html","hash":"c5067242677c04cca72f55ca4dbabaa327733112","modified":1689506255460},{"_id":"public/2021/11/13/leetcode/单调栈相关/index.html","hash":"090bc2ef35d3fd6cb90bf88aa6df179793da734e","modified":1689506255460},{"_id":"public/2021/11/12/工具相关/scheduler-ralated/index.html","hash":"3929c235a9a2de7ddf9094756d58a7d0d264b603","modified":1689506255460},{"_id":"public/2021/11/11/工具相关/python相关/index.html","hash":"83644694d9862221ca5f34c14f029c049458a5f1","modified":1689506255460},{"_id":"public/2021/11/11/工具相关/常见问题及解决方案/index.html","hash":"165aa10bcfdde4d4c40f98a03f92cf94bdc3ff6c","modified":1689506255460},{"_id":"public/2021/11/11/工具相关/Linux命令/index.html","hash":"de696a18c8bf7743e0cf2be87db44cd09c897b06","modified":1689506255460},{"_id":"public/2021/11/08/工具相关/rclone/index.html","hash":"6b508cf2f36acfc00b16653aea0ecb2c2e722383","modified":1689506255460},{"_id":"public/2021/11/08/工具相关/command-related/index.html","hash":"13d6f4102b5ccf9580e5a815778ef29d84c6aff9","modified":1689506255460},{"_id":"public/2021/11/08/工具相关/hexo-notes/index.html","hash":"2265a22b840875ff152c4279263e2ccc573e4119","modified":1689506255460},{"_id":"public/page/3/index.html","hash":"5fc8aae09b8e8ee9f8f2453abd42e95e2587cd7d","modified":1689506255460},{"_id":"public/page/2/index.html","hash":"ace5e79822c7b9552e421f81a3bbb1348830a9e7","modified":1689506255460},{"_id":"public/index.html","hash":"fff3490b4b7d825783a22ab2d08c88c1e50614ff","modified":1689506255460},{"_id":"public/page/4/index.html","hash":"9f2b9fc3d1411bb4acbce910ff4bbdbdacbcef1e","modified":1689506255460},{"_id":"public/page/5/index.html","hash":"fb85116006f8c72effd064ad0d5ecb6e2bb45199","modified":1689506255460},{"_id":"public/categories/index.html","hash":"4066f44dd72967bb09c6a1a4b5943fd172680823","modified":1689506255460},{"_id":"public/img/favicon.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1689506255460},{"_id":"public/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1689506255460},{"_id":"public/img/default.png","hash":"7bb2b8ee07db305bcadee2985b81b942027ae940","modified":1689506255460},{"_id":"public/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1689506255460},{"_id":"public/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1689506255460},{"_id":"public/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1689506255460},{"_id":"public/tmp.c++","hash":"d1e70a084e89e0d9046c1450fcb577b761088136","modified":1689506255460},{"_id":"public/img/logo.png","hash":"6bdff8a1cc249a9dd8c6dd409ff0be4edf4336a0","modified":1689506255460},{"_id":"public/img/post_default_side2.jpeg","hash":"1b2fb1427e5b9126cd1519f495a57c09d5dbbe97","modified":1689506255460},{"_id":"public/img/post_default_side.jpeg","hash":"9bb40474c02412665eae15dbec9b64511f0be445","modified":1689506255460},{"_id":"public/2021/11/08/工具相关/command-related/image-20211207175530810.png","hash":"855eee917f189a446cde3fc8da826b2876737ade","modified":1689506255460},{"_id":"public/test.cpp","hash":"869fcb3c9f619c1f1ed9e3d48a4fded30a1424d2","modified":1689506255460},{"_id":"public/css/hbe.style.css","hash":"b0a0077cb588c0941823905fcc383aa7509ade73","modified":1689506255460},{"_id":"public/lib/hbe.js","hash":"136dba00826bdd086153bf0acb5473aea7183ad1","modified":1689506255460},{"_id":"public/img/bg-shouye-3.jpg","hash":"cb673f2985aa1df77baf4753775f35c02f7edcf1","modified":1689506255460},{"_id":"public/img/bg-shouye-2.jpg","hash":"bc16b1cbe147b23da26000c392029197d070f776","modified":1689506255460},{"_id":"public/img/bg-shouye-4.jpg","hash":"4c0119d70fb1e0078688c466991beb8fd804691c","modified":1689506255460},{"_id":"public/img/bg-shouye-yuantu.jpg","hash":"2e218535ede26fdb313f1b54361af5784e551064","modified":1689506255460},{"_id":"public/img/bg-shouye.jpg","hash":"993634d3655c2148c0787c62d757b2d523ce951d","modified":1689506255460},{"_id":"public/img/self.jpg","hash":"f08bc46151cd59a989cd05555484b1472bf9f60a","modified":1689506255460},{"_id":"public/js/boot.js","hash":"3de344ee619da989f6dccf7c2ae459fe91075983","modified":1689506255460},{"_id":"public/js/color-schema.js","hash":"2520c6459b544a4e965b838f8095e2a84390a43c","modified":1689506255460},{"_id":"public/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1689506255460},{"_id":"public/js/events.js","hash":"4b9d2676c9544db9cc40a8c7d18456792299ba86","modified":1689506255460},{"_id":"public/js/leancloud.js","hash":"4a787cfce27045aa0a92ec22e84f2ccf30cabc4c","modified":1689506255460},{"_id":"public/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1689506255460},{"_id":"public/js/local-search.js","hash":"633f0142c657805359b0197f287e12ae4bcde731","modified":1689506255460},{"_id":"public/js/plugins.js","hash":"d058f30bd09b28769c4d8313428ff23dfc8d52dd","modified":1689506255460},{"_id":"public/js/utils.js","hash":"4a43f2700e91937650bef511fd438825b001c4c6","modified":1689506255460},{"_id":"public/lib/hint/hint.min.css","hash":"b38df228460ebfb4c0b6085336ee2878fe85aafe","modified":1689506255460},{"_id":"public/css/main.css","hash":"26301329cbcef3ddeb7183dcdfdda7e9ccf7df62","modified":1689506255460},{"_id":"public/img/bg.jpeg","hash":"ecfe3c6b0bc9afe202ccadc86d10a6e704636df3","modified":1689506255460},{"_id":"public/2021/11/13/项目相关/编程语言/image-20220122202312622.png","hash":"12142d5d9905e020c67841321dc54b02875b73ab","modified":1689506255460},{"_id":"public/img/bg-guanyu.jpg","hash":"7e7e8129ad6a11167b32b1055d330731098e7846","modified":1689506255460},{"_id":"public/img/bg-wenzhang.jpg","hash":"30538429322fda4313459305c085d2006abf44a3","modified":1689506255460},{"_id":"public/img/bg-favorite.jpg","hash":"f43bef7c3daffec32bf2013aad5e1bac40bc7e7d","modified":1689506255460},{"_id":"public/img/bg-guanyu-yuantu.jpeg","hash":"1c157da3354b8c34e9f2296bac12d0068591d416","modified":1689506255460},{"_id":"public/img/bg-wenzhang-4.jpg","hash":"738e19554455fff8218f295c8c419f3159ff4784","modified":1689506255460},{"_id":"public/img/bg-wenzhang-2.jpg","hash":"414e42dcf974629b45f128ec1a053b5609048c2d","modified":1689506255460},{"_id":"public/img/bg-fenlei.jpg","hash":"d113187b8d1a067221e3b20c102b6410cabb08c3","modified":1689506255460},{"_id":"public/img/bg-guidang.jpg","hash":"d9149cb6888cb3e7b25bb64a5d6362b54af75f95","modified":1689506255460},{"_id":"public/img/bg-biaoqian.jpg","hash":"18e6c8ddbad20775065da0c2acf333f4f8f42b18","modified":1689506255460},{"_id":"public/img/bg-zidingyi.jpg","hash":"ec3a29099438351a152af7a27817b09e60b7def7","modified":1689506255460},{"_id":"public/img/bg-wenzhang-5.jpg","hash":"f0173b5ab23f391b46a48829a3ed11ede0058fc8","modified":1689506255460}],"Category":[{"name":"leetcode","_id":"clk5ceinb0004jpjb49b53tjn"},{"name":"dp问题专栏","_id":"clk5ceinx001ijpjbhpng3pj9"},{"name":"其他","_id":"clk5ceio1001qjpjbeooq6wz9"},{"name":"工具相关","_id":"clk5ceio4001xjpjbaz797nty"},{"name":"日常记事","_id":"clk5ceioe002zjpjb04eahyod"},{"name":"项目相关","_id":"clk5ceiog0035jpjb5sp73q2q"},{"name":"autumn_recruit","_id":"clk5ceion003sjpjb5i158ex7"},{"name":"美团","parent":"clk5ceion003sjpjb5i158ex7","_id":"clk5ceiop003zjpjb6bc1b5m4"}],"Data":[],"Page":[{"title":"about","date":"2021-11-08T07:30:16.000Z","layout":"about","_content":"\nHello, my name is Shuang Hu. I have graduated from Zhejiang University as a postgraduate in March, 2023. Now, I am working at my hometown Chongqing.\n\nI have two-year research experience in the fields of Deep Learning and Software Development. I have worked on several projects in these areas (details in CV), and have gained valuable skills and knowledge along the way.\n\nI am a passionate learner and always eager to expand my knowledge and skills. Besides, I also love to take on new challenges. I believe that every challenge presents an opportunity for growth and development, and I am always ready to step up and take on new tasks and responsibilities.\n\nFinally, I take pride in my work and am fully responsible for every task that I undertake. I expect to have a chance to work with you!","source":"about/index.md","raw":"---\ntitle: about\ndate: 2021-11-08 15:30:16\nlayout: about\n---\n\nHello, my name is Shuang Hu. I have graduated from Zhejiang University as a postgraduate in March, 2023. Now, I am working at my hometown Chongqing.\n\nI have two-year research experience in the fields of Deep Learning and Software Development. I have worked on several projects in these areas (details in CV), and have gained valuable skills and knowledge along the way.\n\nI am a passionate learner and always eager to expand my knowledge and skills. Besides, I also love to take on new challenges. I believe that every challenge presents an opportunity for growth and development, and I am always ready to step up and take on new tasks and responsibilities.\n\nFinally, I take pride in my work and am fully responsible for every task that I undertake. I expect to have a chance to work with you!","updated":"2023-07-10T10:27:12.995Z","path":"about/index.html","comments":1,"_id":"clk5cein20000jpjbbshrdn0b","content":"<p>Hello, my name is Shuang Hu. I have graduated from Zhejiang University as a postgraduate in March, 2023. Now, I am working at my hometown Chongqing.</p>\n<p>I have two-year research experience in the fields of Deep Learning and Software Development. I have worked on several projects in these areas (details in CV), and have gained valuable skills and knowledge along the way.</p>\n<p>I am a passionate learner and always eager to expand my knowledge and skills. Besides, I also love to take on new challenges. I believe that every challenge presents an opportunity for growth and development, and I am always ready to step up and take on new tasks and responsibilities.</p>\n<p>Finally, I take pride in my work and am fully responsible for every task that I undertake. I expect to have a chance to work with you!</p>\n","site":{"data":{}},"wordcount":651,"excerpt":"","more":"<p>Hello, my name is Shuang Hu. I have graduated from Zhejiang University as a postgraduate in March, 2023. Now, I am working at my hometown Chongqing.</p>\n<p>I have two-year research experience in the fields of Deep Learning and Software Development. I have worked on several projects in these areas (details in CV), and have gained valuable skills and knowledge along the way.</p>\n<p>I am a passionate learner and always eager to expand my knowledge and skills. Besides, I also love to take on new challenges. I believe that every challenge presents an opportunity for growth and development, and I am always ready to step up and take on new tasks and responsibilities.</p>\n<p>Finally, I take pride in my work and am fully responsible for every task that I undertake. I expect to have a chance to work with you!</p>\n"},{"title":"爱好","subtitle":"我的兴趣爱好","date":"2023-07-16T09:09:19.000Z","comment":"valine","_content":"\n<div class=\"markdown-body\">\n在这里主要展示除了技术外我的一些兴趣爱好，之后会考虑分页面展示，现在只是列个大纲，开个坑吧~\n\n在学习的空闲之余，我喜欢阅读、烹饪、学习新的语言和运动。\n\n- 关于阅读，我喜欢阅读不同的题材的文章，包括小说、散文、游记等。我主要将阅读笔记记载在oneNote上，希望之后有机会能够更新在这里\n\n- 关于烹饪，我喜欢做家常菜和烘焙 （PS: 我喜欢做菜但不喜欢洗碗）。我感觉将不同的原料变成美食像魔术一样神奇，在毕业后尝试做过一些普通的炒菜和汤，希望之后能够更加熟练，学会更多的菜品。烘焙的话，我喜欢烘焙蛋糕面包类（无奶油和少糖类），但是目前停留在理论知识，希望之后有机会能躬行此事。\n\n- 关于语言，在学校我们学习了英语，但是我希望通过之后能够通过阅读英文杂志，听英文博客等扩展自己的知识面将这种语言工具运用起来，而不是应对考试\n同时我也开始学习日语，主要是日语的文字和发音和中文很像，我也很喜欢看动漫，有机会接触这门语言，所以选择日语作为第三门语言，我希望今后能够学习更多的语言，通过语言的桥梁抵达世界各种丰富资源的彼岸。\n\n- 生命在于运动。运动中，我比较喜欢简单的比如跑步、羽毛瑜伽类，希望我能一直坚持运动的习惯，因为我们不仅仅需要精神粮食的滋养，更需要一个健康强壮的身体。未来希望有机会学习一些其他的运动，比如乒乓，游泳等。\n\n“当你意识到生命只有一次的时候，你就拥有了第二次的生命”，除了坚持学习专业知识和技术，我希望今后能挖掘自己更多的兴趣爱好，永远热爱生命，拥抱生活！\n\n</div>\n","source":"favorite/index.md","raw":"---\ntitle: 爱好\nsubtitle: 我的兴趣爱好\ndate: 2023-07-16 17:09:19\ncomment: 'valine'\n---\n\n<div class=\"markdown-body\">\n在这里主要展示除了技术外我的一些兴趣爱好，之后会考虑分页面展示，现在只是列个大纲，开个坑吧~\n\n在学习的空闲之余，我喜欢阅读、烹饪、学习新的语言和运动。\n\n- 关于阅读，我喜欢阅读不同的题材的文章，包括小说、散文、游记等。我主要将阅读笔记记载在oneNote上，希望之后有机会能够更新在这里\n\n- 关于烹饪，我喜欢做家常菜和烘焙 （PS: 我喜欢做菜但不喜欢洗碗）。我感觉将不同的原料变成美食像魔术一样神奇，在毕业后尝试做过一些普通的炒菜和汤，希望之后能够更加熟练，学会更多的菜品。烘焙的话，我喜欢烘焙蛋糕面包类（无奶油和少糖类），但是目前停留在理论知识，希望之后有机会能躬行此事。\n\n- 关于语言，在学校我们学习了英语，但是我希望通过之后能够通过阅读英文杂志，听英文博客等扩展自己的知识面将这种语言工具运用起来，而不是应对考试\n同时我也开始学习日语，主要是日语的文字和发音和中文很像，我也很喜欢看动漫，有机会接触这门语言，所以选择日语作为第三门语言，我希望今后能够学习更多的语言，通过语言的桥梁抵达世界各种丰富资源的彼岸。\n\n- 生命在于运动。运动中，我比较喜欢简单的比如跑步、羽毛瑜伽类，希望我能一直坚持运动的习惯，因为我们不仅仅需要精神粮食的滋养，更需要一个健康强壮的身体。未来希望有机会学习一些其他的运动，比如乒乓，游泳等。\n\n“当你意识到生命只有一次的时候，你就拥有了第二次的生命”，除了坚持学习专业知识和技术，我希望今后能挖掘自己更多的兴趣爱好，永远热爱生命，拥抱生活！\n\n</div>\n","updated":"2023-07-16T11:17:21.256Z","path":"favorite/index.html","comments":1,"layout":"page","_id":"clk5cein90002jpjb3a5a0eg9","content":"<div class=\"markdown-body\">\n在这里主要展示除了技术外我的一些兴趣爱好，之后会考虑分页面展示，现在只是列个大纲，开个坑吧~\n\n<p>在学习的空闲之余，我喜欢阅读、烹饪、学习新的语言和运动。</p>\n<ul>\n<li><p>关于阅读，我喜欢阅读不同的题材的文章，包括小说、散文、游记等。我主要将阅读笔记记载在oneNote上，希望之后有机会能够更新在这里</p>\n</li>\n<li><p>关于烹饪，我喜欢做家常菜和烘焙 （PS: 我喜欢做菜但不喜欢洗碗）。我感觉将不同的原料变成美食像魔术一样神奇，在毕业后尝试做过一些普通的炒菜和汤，希望之后能够更加熟练，学会更多的菜品。烘焙的话，我喜欢烘焙蛋糕面包类（无奶油和少糖类），但是目前停留在理论知识，希望之后有机会能躬行此事。</p>\n</li>\n<li><p>关于语言，在学校我们学习了英语，但是我希望通过之后能够通过阅读英文杂志，听英文博客等扩展自己的知识面将这种语言工具运用起来，而不是应对考试<br>同时我也开始学习日语，主要是日语的文字和发音和中文很像，我也很喜欢看动漫，有机会接触这门语言，所以选择日语作为第三门语言，我希望今后能够学习更多的语言，通过语言的桥梁抵达世界各种丰富资源的彼岸。</p>\n</li>\n<li><p>生命在于运动。运动中，我比较喜欢简单的比如跑步、羽毛瑜伽类，希望我能一直坚持运动的习惯，因为我们不仅仅需要精神粮食的滋养，更需要一个健康强壮的身体。未来希望有机会学习一些其他的运动，比如乒乓，游泳等。</p>\n</li>\n</ul>\n<p>“当你意识到生命只有一次的时候，你就拥有了第二次的生命”，除了坚持学习专业知识和技术，我希望今后能挖掘自己更多的兴趣爱好，永远热爱生命，拥抱生活！</p>\n</div>\n","site":{"data":{}},"wordcount":618,"excerpt":"","more":"<div class=\"markdown-body\">\n在这里主要展示除了技术外我的一些兴趣爱好，之后会考虑分页面展示，现在只是列个大纲，开个坑吧~\n\n<p>在学习的空闲之余，我喜欢阅读、烹饪、学习新的语言和运动。</p>\n<ul>\n<li><p>关于阅读，我喜欢阅读不同的题材的文章，包括小说、散文、游记等。我主要将阅读笔记记载在oneNote上，希望之后有机会能够更新在这里</p>\n</li>\n<li><p>关于烹饪，我喜欢做家常菜和烘焙 （PS: 我喜欢做菜但不喜欢洗碗）。我感觉将不同的原料变成美食像魔术一样神奇，在毕业后尝试做过一些普通的炒菜和汤，希望之后能够更加熟练，学会更多的菜品。烘焙的话，我喜欢烘焙蛋糕面包类（无奶油和少糖类），但是目前停留在理论知识，希望之后有机会能躬行此事。</p>\n</li>\n<li><p>关于语言，在学校我们学习了英语，但是我希望通过之后能够通过阅读英文杂志，听英文博客等扩展自己的知识面将这种语言工具运用起来，而不是应对考试<br>同时我也开始学习日语，主要是日语的文字和发音和中文很像，我也很喜欢看动漫，有机会接触这门语言，所以选择日语作为第三门语言，我希望今后能够学习更多的语言，通过语言的桥梁抵达世界各种丰富资源的彼岸。</p>\n</li>\n<li><p>生命在于运动。运动中，我比较喜欢简单的比如跑步、羽毛瑜伽类，希望我能一直坚持运动的习惯，因为我们不仅仅需要精神粮食的滋养，更需要一个健康强壮的身体。未来希望有机会学习一些其他的运动，比如乒乓，游泳等。</p>\n</li>\n</ul>\n<p>“当你意识到生命只有一次的时候，你就拥有了第二次的生命”，除了坚持学习专业知识和技术，我希望今后能挖掘自己更多的兴趣爱好，永远热爱生命，拥抱生活！</p>\n</div>\n"},{"title":"语言学习","subtitle":"我的兴趣爱好之语言学习","date":"2023-07-16T11:10:26.000Z","_content":"\n\n\n<div class=\"markdown-body\">\n\n1. 我正在学习的外语\n    - 英语\n        - 口语\n        - 听力\n        - 阅读\n\n    - 日语\n        -教材\n\n\n2. 一些资源记录\n\n</div>","source":"favorite-language/index.md","raw":"---\ntitle: 语言学习\nsubtitle: 我的兴趣爱好之语言学习\ndate: 2023-07-16 19:10:26\n---\n\n\n\n<div class=\"markdown-body\">\n\n1. 我正在学习的外语\n    - 英语\n        - 口语\n        - 听力\n        - 阅读\n\n    - 日语\n        -教材\n\n\n2. 一些资源记录\n\n</div>","updated":"2023-07-16T11:15:33.406Z","path":"favorite-language/index.html","comments":1,"layout":"page","_id":"clk5ceinc0005jpjbc8zhfs76","content":"<div class=\"markdown-body\">\n\n<ol>\n<li><p>我正在学习的外语</p>\n<ul>\n<li><p>英语</p>\n<ul>\n<li>口语</li>\n<li>听力</li>\n<li>阅读</li>\n</ul>\n</li>\n<li><p>日语<br>  -教材</p>\n</li>\n</ul>\n</li>\n</ol>\n<ol start=\"2\">\n<li>一些资源记录</li>\n</ol>\n</div>","site":{"data":{}},"wordcount":27,"excerpt":"","more":"<div class=\"markdown-body\">\n\n<ol>\n<li><p>我正在学习的外语</p>\n<ul>\n<li><p>英语</p>\n<ul>\n<li>口语</li>\n<li>听力</li>\n<li>阅读</li>\n</ul>\n</li>\n<li><p>日语<br>  -教材</p>\n</li>\n</ul>\n</li>\n</ol>\n<ol start=\"2\">\n<li>一些资源记录</li>\n</ol>\n</div>"},{"title":"阅读","subtitle":"我的兴趣爱好之阅读","date":"2023-07-16T09:09:19.000Z","comment":"valine","_content":"\n<div class=\"markdown-body\">\n阅读ing\n\n1. 我的阅读书单\n\n    - 小说\n\n    - 游记\n\n    - 国外文学\n\n2. 最喜欢的作者\n\n</div>\n\n\n","source":"favorite-reading/index.md","raw":"---\ntitle: 阅读\nsubtitle: 我的兴趣爱好之阅读\ndate: 2023-07-16 17:09:19\ncomment: 'valine'\n---\n\n<div class=\"markdown-body\">\n阅读ing\n\n1. 我的阅读书单\n\n    - 小说\n\n    - 游记\n\n    - 国外文学\n\n2. 最喜欢的作者\n\n</div>\n\n\n","updated":"2023-07-16T11:15:41.057Z","path":"favorite-reading/index.html","comments":1,"layout":"page","_id":"clk5ceine0008jpjb4h2d8shg","content":"<div class=\"markdown-body\">\n阅读ing\n\n<ol>\n<li><p>我的阅读书单</p>\n<ul>\n<li><p>小说</p>\n</li>\n<li><p>游记</p>\n</li>\n<li><p>国外文学</p>\n</li>\n</ul>\n</li>\n<li><p>最喜欢的作者</p>\n</li>\n</ol>\n</div>\n\n\n","site":{"data":{}},"wordcount":25,"excerpt":"","more":"<div class=\"markdown-body\">\n阅读ing\n\n<ol>\n<li><p>我的阅读书单</p>\n<ul>\n<li><p>小说</p>\n</li>\n<li><p>游记</p>\n</li>\n<li><p>国外文学</p>\n</li>\n</ul>\n</li>\n<li><p>最喜欢的作者</p>\n</li>\n</ol>\n</div>\n\n\n"}],"Post":[{"title":"Hard题目集合","date":"2022-04-10T08:41:22.000Z","_content":"\n\n### 枚举+二分\nlc6040. 花园的最大总美丽值\n\n- 主要是在求partial的最小超时, 还有就是一个long long数据类型注意！！\n-法一: 从右到左，先枚举完善花园数目，再计算不完善花园数据可以获得的最大\n解决方案：使用二分+前缀和来求增加后的最小值，而不是一个一个遍历(空间复杂度O(n))\n\n-法二: 如果是从左到右计算，可以将空间开销降到O(1)，先计算要让所有的花园变为完善花园还剩下的花的数量（可能为负数），然后遍历的时候一个一个加回去，同时不完善花园数目最小值是逐渐增大，所以可以在之前的结果上累加，不用重头计算\n\n- 同样类型的题目，+k使最小的数能够达到的最大值，lc6039. K 次增加后的最大乘积（这道题也可以最小堆+1，一个一个加）","source":"_posts/leetcode/hard题目合集.md","raw":"---\ntitle: Hard题目集合\ncategories:\n  - leetcode\ndate: 2022-04-10 16:41:22\ntags:\n---\n\n\n### 枚举+二分\nlc6040. 花园的最大总美丽值\n\n- 主要是在求partial的最小超时, 还有就是一个long long数据类型注意！！\n-法一: 从右到左，先枚举完善花园数目，再计算不完善花园数据可以获得的最大\n解决方案：使用二分+前缀和来求增加后的最小值，而不是一个一个遍历(空间复杂度O(n))\n\n-法二: 如果是从左到右计算，可以将空间开销降到O(1)，先计算要让所有的花园变为完善花园还剩下的花的数量（可能为负数），然后遍历的时候一个一个加回去，同时不完善花园数目最小值是逐渐增大，所以可以在之前的结果上累加，不用重头计算\n\n- 同样类型的题目，+k使最小的数能够达到的最大值，lc6039. K 次增加后的最大乘积（这道题也可以最小堆+1，一个一个加）","slug":"leetcode/hard题目合集","published":1,"updated":"2023-07-10T10:36:19.531Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clk5cein50001jpjbgl0i7soq","content":"<h3 id=\"枚举-二分\"><a href=\"#枚举-二分\" class=\"headerlink\" title=\"枚举+二分\"></a>枚举+二分</h3><p>lc6040. 花园的最大总美丽值</p>\n<ul>\n<li>主要是在求partial的最小超时, 还有就是一个long long数据类型注意！！</li>\n<li>法一: 从右到左，先枚举完善花园数目，再计算不完善花园数据可以获得的最大<br>解决方案：使用二分+前缀和来求增加后的最小值，而不是一个一个遍历(空间复杂度O(n))</li>\n</ul>\n<p>-法二: 如果是从左到右计算，可以将空间开销降到O(1)，先计算要让所有的花园变为完善花园还剩下的花的数量（可能为负数），然后遍历的时候一个一个加回去，同时不完善花园数目最小值是逐渐增大，所以可以在之前的结果上累加，不用重头计算</p>\n<ul>\n<li>同样类型的题目，+k使最小的数能够达到的最大值，lc6039. K 次增加后的最大乘积（这道题也可以最小堆+1，一个一个加）</li>\n</ul>\n","site":{"data":{}},"wordcount":312,"excerpt":"","more":"<h3 id=\"枚举-二分\"><a href=\"#枚举-二分\" class=\"headerlink\" title=\"枚举+二分\"></a>枚举+二分</h3><p>lc6040. 花园的最大总美丽值</p>\n<ul>\n<li>主要是在求partial的最小超时, 还有就是一个long long数据类型注意！！</li>\n<li>法一: 从右到左，先枚举完善花园数目，再计算不完善花园数据可以获得的最大<br>解决方案：使用二分+前缀和来求增加后的最小值，而不是一个一个遍历(空间复杂度O(n))</li>\n</ul>\n<p>-法二: 如果是从左到右计算，可以将空间开销降到O(1)，先计算要让所有的花园变为完善花园还剩下的花的数量（可能为负数），然后遍历的时候一个一个加回去，同时不完善花园数目最小值是逐渐增大，所以可以在之前的结果上累加，不用重头计算</p>\n<ul>\n<li>同样类型的题目，+k使最小的数能够达到的最大值，lc6039. K 次增加后的最大乘积（这道题也可以最小堆+1，一个一个加）</li>\n</ul>\n"},{"title":"二分算法","catogory":["leetcode 题目汇总"],"date":"2021-11-13T09:21:34.000Z","_content":"\n#### 模板\n> 参考链接：[二分查找专题]（https://blog.csdn.net/qq_41221520/article/details/108277801）\n\n<font color=red>提型： 第一个大于，第一个大于等于， 等于的左右边界</font>\n（1）某一个数\n（2）最后一个小于目标值target的数\n（3）最后一个小于等于目标值target的数\n（3）第一个大于目标值target的数\n（5）第一个大于等于目标值target的数\n\n1. 如果找左右边界2 4 4 4 4 5（第一个等于，最后一个等于），那么使用left<right以及找左右边界，控制右边；找右边界，控制左边的口诀；\n2. 如果找第一个大于target,第一个大于等于target；小于target, 最后一个小于等于target\n那么使用常规二分算法，left<=right 以及题目中有等号，等式中无，以及大于对应left=mid+1在前，小于对应right=mid-1在前的口诀\n\n<font color =red>统一：\n第一个大于等于target，转为左边界；\n最后一个小于等于target，转换为右边界.\n其余等于，大于，或者小于都转为标准二分\n注意标准二分记得返回的时候判断l， r是否在范围内（-1 size，判断）； 左右边界不用判断是否在返回内\n记住大于目标值的第一个数，并不一定是等于target的右边界+1对应的下标</font>\n\n```C++\n//找到第一个大于target的数\nint l=0, r=arr.size()-1;\nwhile(l<=r){ \n    int mid=l+(r-l)/2;\n    if(arr[mid]>x){\n        r=mid-1;\n    }else{ //等于情况应该为mid+1\n        l=mid+1;\n    }\n}\nif(l>=size){\n    return error\n}\nreturn l;\n```\n\n第一个大于不能转为左边界：\n[0] 当size=1的时候不行，会直接退出循环，然后返回0， 实际上应该返回1\n\n``` C++\n左右边界\n//左边界\nint left_bound(int left, int right, int arr, int target){\n    while(left<right){\n        int mid=left+(right-left)/2;\n        if(arr[mid]<target){\n            left=mid+1;\n        }else{\n            right=mid;\n        }\n    }\n    return arr[left];\n}\n\n//右边界\nint right_bound(int left, int right, int arr, int target){\n    while(left<right){\n        int mid=left+(right-left)/2+1;\n        if(arr[mid]<=target){\n            left=mid;\n        }else{\n            right=mid-1;\n        }\n    }\n    return arr[right];\n}\n\n\n标准：\nwhile(left<=right){\n    int mid=(left+right)/2;\n    if(arr[mid]<target){\n        left=mid+1;\n    }else if(arr[mid]>target){\n        right=mid-1;\n    }else{\n        return mid;\n    }\n}\n```\n\n\n#### 例题\n\n<font color=red>0. lc34. 在排序数组中查找元素的第一个和最后一个位置</font>\n这道题元素可能存在可能不存在，使用左右边界的方法，同时需要判断最后结果是否是target\n\n\n1. 在数组中找到一个局部最小值（不一定要在排序数组中使用二分算法，只要能确定二分两侧的某一侧肯定存在你要找的内容，就可以使用二分查找。\n\n\n<font color=red>2. 寻找旋转排序数组中的最小值（一个是可能包含重复数据，一个是不包含重复数据）</font>\n两个都是arr可能经过一次旋转处理，可能没有\n(1)不包含重复，那么比较中间的值和右边的值，如果小于则说明右边顺序没变，right=mid,否则，left=mid+1\n(2)可能包含重复数据就是在不包含重复数据基础上 添加一个如果nums[r]==nums[mid]，那么r--,一直到右边不等于mid\n\n    **注意**: 一定是右边的数和中间的数进行比较，因为要考虑没有旋转的这种情况\n\n3. 有序旋转数组中找到一个数 target\nSolution:为了方便记忆，仍然使用右边的数和中间的数进行对比\n``` C++\nwhile(left<=right){\n    int mid=left+(right-left)/2;\n    if(arr[mid]==target){\n        return arr[mid];\n    }else{\n        if(arr[mid]==arr[right]){\n            right--;\n            continue;\n        }else if(arr[mid]<arr[right]){\n            if(target>arr[mid]&&target<=arr[right]){\n                left=mid+1;\n            }else{\n                right=mid-1;\n            }\n        }else{\n            if(target>=arr[left]&&target<arr[mid]){\n                right=mid-1\n            }else{\n                left=mid+1;\n            }\n        }\n    }\n}\nreturn -1;\n```\n\n4. H指数 计数排序 O(n)（计数的数组应该为size+1, 每个index的数量，如果>=n全部计算为count[n]）或者二分查找(O(logn))\nH指数II多了一个已经拍好序，以及O(logn)因此不能遍历求citation的范围；所以只能二分查找数组，不能二分查找h_指数，同时返回的应该是个数，而不是引用量\n根据分割点右边论文的个数与分割点 citations[x] 的大小关系进行二分 。\n\n\n<font color=red> 5. 寻找排序矩阵中的第k个数</font>\n二分查找算法，假设第k个数的值，然后判断小于他的数据是不是k\n 计算mid值，查找，大于等于这个数的数量，然后right=mid  如果数量小于这个数量， left=mid+1\n注意抓住矩阵横向和纵向都是有序的特点\n同时在计算小于k的数量的时候，是每列每列的计算（从左下角）,因为是mid对矩阵进行划分\n\n<font color=blue> 6. 蜡烛之间的盘子,可以直接使用vector自带的函数进行二分查找</font>\nlower_bound(vec.begin(), vec.end(), target)-vec.begin()\n==只有两种数据， 比如0，1 找最近：使用下标的二分查找，而不是循环往前遍历==\n\n7. 寻找右区间， 二分查找+hash \n    - 按照左边排序+遍历每个区间右边，在区间二分查找，找到最近那个\n    - 因为是interval (vector<int>), 因此自己实现二分，而不是使用标准库函数里面的方法\n\n\n<font color=red> 8. 我的日程安排表I </font>\n题意，就是判断是否能向当前的区间继续插入，插入之前如何高效判断，以及以如何形式表示已经插入了该区间，提示，不使用vector<interval>结构表示插入\n    方法一：暴力算法\n    方法二：使用map对key进行排序，之后使用二分查找，查找当前区间应该插入的位置\n    两个考点：\n    1.map的lower_bound and upper_bound\n    2. 插入的时候使用mp[end]=start\n    查找的时候查找start所在end后面的位置，这样的话就不用和左右两边进行对比，只需要对比一边就好了\n    插入end查找start; 插入start, 查找end, 这样判断只需要判断一边\n    方法三：使用二叉搜索树, 每个数节点，包含left,right指针，以及start,和end两个val\n\nPS 我的日程安排II III都是使用边界计数来实现，就是mp[start]++ mp[end]--\n\n**总结：**二分算法解决区间题目， 这三道题都比较简单，前两道是判断是否有三重或者多重预定，最后一个是判断有几重预定。但是微软有一个题目是删除最少的区间，使得预定数重叠不超过2（可以等于2）：\n微软这道题：\n- 按照左边边排序，同时用一个优先队列记录现在ok的序列，同时优先队列按照右边排序（我们贪心地删除右边能扩展到最远的那个）\n- 依次遍历排好序的区间，如果当前区间和优先队列中的前两个区间都有交集，那么将当区间压入优先队列中，并弹出一个区间；否则直接压入，不弹出\n\n这个其实也是上下车题目的模板代码，思想就是差分数组，只需要在两端进行标记\n```C++\nint maxConcurrent (vecotr<vecotr<int>>& time){\n    map<int, int> record;\n    for(auto& t : time){\n        record[t[0]] += 1;\n        record[t[1]] -= 1;\n    }\n    int ans = 0, concurrent = 0;\n    for(auto& p : record){\n        concurrent += p.second;\n        ans = max(ans, concurrent);\n    }\n    return ans;\n}\n```\n\n\n9. 在 D 天内送达包裹的能力\n使用二分搜索，查找船最低的容量，使得能在days内完成传输\n易错点：一定要记得left 应该为里面最大的val，而不是0\n\n10. 制作 m 束花所需的最少天数\n二分查找天数的下限，使得至少能够制作要求的花束\nPS: 一定要注意没有找到的情况下，应该返回-1\n\n\n11. 同时运行 N 台电脑的最长时间(hard)\nS=min(barries[i], mid)  Sum/mid>=n\nleft=1, right=sum(barries)/n\n也就是如果当前假设的值大于电池容量，电池就会被榨干，否则电池会被用掉mid (因此电池不会同时被多台电脑用，因此最多用掉假设t这么多的电量)\n\n<font color=blue>  12.  转变数组后最接近目标值的数组和 </font>\n二分，但是因为是绝对值，所以需要比较mid计算值比target小还是大，决定搜索那边\n第一种思路： 这道题使用二分，但是因为是找target更近的点，因此mid的和是大于target或者小于target都有可能，虽然整体上left和right应该向target靠拢，但是最终的结果应该有另外的变量记录。==/</> target的时候都不是找到了最终结果，而是候选结果。\n\n也就是结果和left/right的变化是两个逻辑，不在一条线上\n```C++\n    if(abs(sum-target)<dist){\n        res=mid;\n        dist=abs(sum-target);\n    }\n    if(abs(sum-target)==dist){\n        if(res>mid){\n            res=mid;\n        }\n    }\n    if(sum>=target){\n        maxvalue=mid-1; //right\n    }else{\n        minvalue=mid+1; //left\n    }\n```\n第二种思路: 要想确定差的绝对值最小，可以先求出比target大的最小值，结果必出在最小值和最小值-1，二选一，比较下即可\n\n<font color=red>12. 搜索旋转排序数组 （寻找里面的某个元素target/或者里面的最小值）</font>\n    1） 无重复数据，直接返回下标，那么使用标准二分查找\n    2） 有重复数据，返回true或者false\n    3)  有重复数据，同时返回==target的最小的下标 (<font color=red>面试题 10.03. 搜索旋转数组</font>)\n        a. 需要对比mid的左边的元素，因为是找到最小index b. 需要加一些条件判断，方便直接退出\n        if(nums[left]==target) 直接返回left; if(nums[mid]==target) right=mid \n        b. 因为需要最小的下标，所以只看中和左，不看右边\n        c. 对左边和中间相等的端点进行单独处理， 只有确定target>mid的时候，才left=mid+1; target==mid的时候不能left=mid+1；需要加一些预处理的命令\n    4） 寻找旋转排序数组的最小值-无重复元素 \n    5)  寻找旋转排序数组的最小值-有重复元素\n    6） 旋转数组， 让数组向右移动k个位置，        \n        reverse(0,n-1)\n        reverse(0,k-1)\n        reverse(k,n-1)\n\n    总结：前三个为标准的二分查找 4，5个 为边界类型的二分查找（right=mid）；找最小值的时候比较mid和right的值，找target的最小下标使用left, mid进行比较，其余情况两种都可以\n\n\n12. 面试题 10.10. 数字流的秩\n- 先随机插入一些数，如何找到小于等于x的数据个数\n- 方法1：插入的时候顺序插入，在查找的时候，使用二分查找\n- 方法2：使用树状数组\n\n13. lc363. 矩形区域不超过 K 的最大数值和(二维前缀和问题)\n- 求一个矩阵内部一个矩阵和小于k的最大数值和\n- 枚举上下两边，然后求和时累加前面（减少空间复杂度），查找的时候使用二分查找（nlogn），大于sum[i]-k的最小值(lower_bound因为是大于等于)\n\n\n14. lc373. 查找和最小的 K 对数字\n优先队列+使用多路归并：\nnums1[0]: nums2[0]-nums2[9]\nnums1[1]: nums2[0]-nums2[9]\n...\nnums1[9]: nums2[0]-nums2[9]\n多条路，每条路都是压入第一个元素\n从优先队列中弹出一个元素（压入），看他在哪条路中，然后压入这条路的后一个元素\n\n\n15. lc1235. 规划兼职工作\n- 题意：找到不重叠而且profit最大的区间段\n- 解决方法：使用dp+二分算法， 首先将区间按照endTime进行排序，然后定义dp为 0-i之间的最大的利益，然后使用二分找到0到i-1之间endTime< i start_time的最后的区间，然后进行状态转移\nf[i]=f[i-1]\nf[i] = max(f[i], f[r] + q[i][2]); \n- 为了减少区间0的判断，区间的编号可以直接从1开始向后\n- 易错点：最主要在进行动态规划的时候dp[i]不能定义为以i结尾的最大profit，只能定义为前i个最大的profit, 因为在进行二分的时候，可能有多个endTime相同，因此选择哪个i是未知的，如果dp定义为区间段，那么就知道选择的是最右边的i\n\n\n\n#### 二分查找总结\nok\n结果是整数, 数组排好序，或者数值选择有规律\n时间复杂度要求O(nlogn)\n类似于一种缩小范围的随机查找, 有方向的猜测\n寻找类型题，可以考虑二分，如果是最大最小题，可以试试动态规划或者二分算法\n找第k个数，不一定需要排序，可以直接二分猜测+计数验证\n\n区间问题，感觉总是出错，一般用二分或者贪心算法\n\n\n\n","source":"_posts/leetcode/二分算法.md","raw":"---\ntitle: 二分算法\ncatogory:\n  - leetcode 题目汇总\ntags: 二分\ncategories:\n  - leetcode\ndate: 2021-11-13 17:21:34\n---\n\n#### 模板\n> 参考链接：[二分查找专题]（https://blog.csdn.net/qq_41221520/article/details/108277801）\n\n<font color=red>提型： 第一个大于，第一个大于等于， 等于的左右边界</font>\n（1）某一个数\n（2）最后一个小于目标值target的数\n（3）最后一个小于等于目标值target的数\n（3）第一个大于目标值target的数\n（5）第一个大于等于目标值target的数\n\n1. 如果找左右边界2 4 4 4 4 5（第一个等于，最后一个等于），那么使用left<right以及找左右边界，控制右边；找右边界，控制左边的口诀；\n2. 如果找第一个大于target,第一个大于等于target；小于target, 最后一个小于等于target\n那么使用常规二分算法，left<=right 以及题目中有等号，等式中无，以及大于对应left=mid+1在前，小于对应right=mid-1在前的口诀\n\n<font color =red>统一：\n第一个大于等于target，转为左边界；\n最后一个小于等于target，转换为右边界.\n其余等于，大于，或者小于都转为标准二分\n注意标准二分记得返回的时候判断l， r是否在范围内（-1 size，判断）； 左右边界不用判断是否在返回内\n记住大于目标值的第一个数，并不一定是等于target的右边界+1对应的下标</font>\n\n```C++\n//找到第一个大于target的数\nint l=0, r=arr.size()-1;\nwhile(l<=r){ \n    int mid=l+(r-l)/2;\n    if(arr[mid]>x){\n        r=mid-1;\n    }else{ //等于情况应该为mid+1\n        l=mid+1;\n    }\n}\nif(l>=size){\n    return error\n}\nreturn l;\n```\n\n第一个大于不能转为左边界：\n[0] 当size=1的时候不行，会直接退出循环，然后返回0， 实际上应该返回1\n\n``` C++\n左右边界\n//左边界\nint left_bound(int left, int right, int arr, int target){\n    while(left<right){\n        int mid=left+(right-left)/2;\n        if(arr[mid]<target){\n            left=mid+1;\n        }else{\n            right=mid;\n        }\n    }\n    return arr[left];\n}\n\n//右边界\nint right_bound(int left, int right, int arr, int target){\n    while(left<right){\n        int mid=left+(right-left)/2+1;\n        if(arr[mid]<=target){\n            left=mid;\n        }else{\n            right=mid-1;\n        }\n    }\n    return arr[right];\n}\n\n\n标准：\nwhile(left<=right){\n    int mid=(left+right)/2;\n    if(arr[mid]<target){\n        left=mid+1;\n    }else if(arr[mid]>target){\n        right=mid-1;\n    }else{\n        return mid;\n    }\n}\n```\n\n\n#### 例题\n\n<font color=red>0. lc34. 在排序数组中查找元素的第一个和最后一个位置</font>\n这道题元素可能存在可能不存在，使用左右边界的方法，同时需要判断最后结果是否是target\n\n\n1. 在数组中找到一个局部最小值（不一定要在排序数组中使用二分算法，只要能确定二分两侧的某一侧肯定存在你要找的内容，就可以使用二分查找。\n\n\n<font color=red>2. 寻找旋转排序数组中的最小值（一个是可能包含重复数据，一个是不包含重复数据）</font>\n两个都是arr可能经过一次旋转处理，可能没有\n(1)不包含重复，那么比较中间的值和右边的值，如果小于则说明右边顺序没变，right=mid,否则，left=mid+1\n(2)可能包含重复数据就是在不包含重复数据基础上 添加一个如果nums[r]==nums[mid]，那么r--,一直到右边不等于mid\n\n    **注意**: 一定是右边的数和中间的数进行比较，因为要考虑没有旋转的这种情况\n\n3. 有序旋转数组中找到一个数 target\nSolution:为了方便记忆，仍然使用右边的数和中间的数进行对比\n``` C++\nwhile(left<=right){\n    int mid=left+(right-left)/2;\n    if(arr[mid]==target){\n        return arr[mid];\n    }else{\n        if(arr[mid]==arr[right]){\n            right--;\n            continue;\n        }else if(arr[mid]<arr[right]){\n            if(target>arr[mid]&&target<=arr[right]){\n                left=mid+1;\n            }else{\n                right=mid-1;\n            }\n        }else{\n            if(target>=arr[left]&&target<arr[mid]){\n                right=mid-1\n            }else{\n                left=mid+1;\n            }\n        }\n    }\n}\nreturn -1;\n```\n\n4. H指数 计数排序 O(n)（计数的数组应该为size+1, 每个index的数量，如果>=n全部计算为count[n]）或者二分查找(O(logn))\nH指数II多了一个已经拍好序，以及O(logn)因此不能遍历求citation的范围；所以只能二分查找数组，不能二分查找h_指数，同时返回的应该是个数，而不是引用量\n根据分割点右边论文的个数与分割点 citations[x] 的大小关系进行二分 。\n\n\n<font color=red> 5. 寻找排序矩阵中的第k个数</font>\n二分查找算法，假设第k个数的值，然后判断小于他的数据是不是k\n 计算mid值，查找，大于等于这个数的数量，然后right=mid  如果数量小于这个数量， left=mid+1\n注意抓住矩阵横向和纵向都是有序的特点\n同时在计算小于k的数量的时候，是每列每列的计算（从左下角）,因为是mid对矩阵进行划分\n\n<font color=blue> 6. 蜡烛之间的盘子,可以直接使用vector自带的函数进行二分查找</font>\nlower_bound(vec.begin(), vec.end(), target)-vec.begin()\n==只有两种数据， 比如0，1 找最近：使用下标的二分查找，而不是循环往前遍历==\n\n7. 寻找右区间， 二分查找+hash \n    - 按照左边排序+遍历每个区间右边，在区间二分查找，找到最近那个\n    - 因为是interval (vector<int>), 因此自己实现二分，而不是使用标准库函数里面的方法\n\n\n<font color=red> 8. 我的日程安排表I </font>\n题意，就是判断是否能向当前的区间继续插入，插入之前如何高效判断，以及以如何形式表示已经插入了该区间，提示，不使用vector<interval>结构表示插入\n    方法一：暴力算法\n    方法二：使用map对key进行排序，之后使用二分查找，查找当前区间应该插入的位置\n    两个考点：\n    1.map的lower_bound and upper_bound\n    2. 插入的时候使用mp[end]=start\n    查找的时候查找start所在end后面的位置，这样的话就不用和左右两边进行对比，只需要对比一边就好了\n    插入end查找start; 插入start, 查找end, 这样判断只需要判断一边\n    方法三：使用二叉搜索树, 每个数节点，包含left,right指针，以及start,和end两个val\n\nPS 我的日程安排II III都是使用边界计数来实现，就是mp[start]++ mp[end]--\n\n**总结：**二分算法解决区间题目， 这三道题都比较简单，前两道是判断是否有三重或者多重预定，最后一个是判断有几重预定。但是微软有一个题目是删除最少的区间，使得预定数重叠不超过2（可以等于2）：\n微软这道题：\n- 按照左边边排序，同时用一个优先队列记录现在ok的序列，同时优先队列按照右边排序（我们贪心地删除右边能扩展到最远的那个）\n- 依次遍历排好序的区间，如果当前区间和优先队列中的前两个区间都有交集，那么将当区间压入优先队列中，并弹出一个区间；否则直接压入，不弹出\n\n这个其实也是上下车题目的模板代码，思想就是差分数组，只需要在两端进行标记\n```C++\nint maxConcurrent (vecotr<vecotr<int>>& time){\n    map<int, int> record;\n    for(auto& t : time){\n        record[t[0]] += 1;\n        record[t[1]] -= 1;\n    }\n    int ans = 0, concurrent = 0;\n    for(auto& p : record){\n        concurrent += p.second;\n        ans = max(ans, concurrent);\n    }\n    return ans;\n}\n```\n\n\n9. 在 D 天内送达包裹的能力\n使用二分搜索，查找船最低的容量，使得能在days内完成传输\n易错点：一定要记得left 应该为里面最大的val，而不是0\n\n10. 制作 m 束花所需的最少天数\n二分查找天数的下限，使得至少能够制作要求的花束\nPS: 一定要注意没有找到的情况下，应该返回-1\n\n\n11. 同时运行 N 台电脑的最长时间(hard)\nS=min(barries[i], mid)  Sum/mid>=n\nleft=1, right=sum(barries)/n\n也就是如果当前假设的值大于电池容量，电池就会被榨干，否则电池会被用掉mid (因此电池不会同时被多台电脑用，因此最多用掉假设t这么多的电量)\n\n<font color=blue>  12.  转变数组后最接近目标值的数组和 </font>\n二分，但是因为是绝对值，所以需要比较mid计算值比target小还是大，决定搜索那边\n第一种思路： 这道题使用二分，但是因为是找target更近的点，因此mid的和是大于target或者小于target都有可能，虽然整体上left和right应该向target靠拢，但是最终的结果应该有另外的变量记录。==/</> target的时候都不是找到了最终结果，而是候选结果。\n\n也就是结果和left/right的变化是两个逻辑，不在一条线上\n```C++\n    if(abs(sum-target)<dist){\n        res=mid;\n        dist=abs(sum-target);\n    }\n    if(abs(sum-target)==dist){\n        if(res>mid){\n            res=mid;\n        }\n    }\n    if(sum>=target){\n        maxvalue=mid-1; //right\n    }else{\n        minvalue=mid+1; //left\n    }\n```\n第二种思路: 要想确定差的绝对值最小，可以先求出比target大的最小值，结果必出在最小值和最小值-1，二选一，比较下即可\n\n<font color=red>12. 搜索旋转排序数组 （寻找里面的某个元素target/或者里面的最小值）</font>\n    1） 无重复数据，直接返回下标，那么使用标准二分查找\n    2） 有重复数据，返回true或者false\n    3)  有重复数据，同时返回==target的最小的下标 (<font color=red>面试题 10.03. 搜索旋转数组</font>)\n        a. 需要对比mid的左边的元素，因为是找到最小index b. 需要加一些条件判断，方便直接退出\n        if(nums[left]==target) 直接返回left; if(nums[mid]==target) right=mid \n        b. 因为需要最小的下标，所以只看中和左，不看右边\n        c. 对左边和中间相等的端点进行单独处理， 只有确定target>mid的时候，才left=mid+1; target==mid的时候不能left=mid+1；需要加一些预处理的命令\n    4） 寻找旋转排序数组的最小值-无重复元素 \n    5)  寻找旋转排序数组的最小值-有重复元素\n    6） 旋转数组， 让数组向右移动k个位置，        \n        reverse(0,n-1)\n        reverse(0,k-1)\n        reverse(k,n-1)\n\n    总结：前三个为标准的二分查找 4，5个 为边界类型的二分查找（right=mid）；找最小值的时候比较mid和right的值，找target的最小下标使用left, mid进行比较，其余情况两种都可以\n\n\n12. 面试题 10.10. 数字流的秩\n- 先随机插入一些数，如何找到小于等于x的数据个数\n- 方法1：插入的时候顺序插入，在查找的时候，使用二分查找\n- 方法2：使用树状数组\n\n13. lc363. 矩形区域不超过 K 的最大数值和(二维前缀和问题)\n- 求一个矩阵内部一个矩阵和小于k的最大数值和\n- 枚举上下两边，然后求和时累加前面（减少空间复杂度），查找的时候使用二分查找（nlogn），大于sum[i]-k的最小值(lower_bound因为是大于等于)\n\n\n14. lc373. 查找和最小的 K 对数字\n优先队列+使用多路归并：\nnums1[0]: nums2[0]-nums2[9]\nnums1[1]: nums2[0]-nums2[9]\n...\nnums1[9]: nums2[0]-nums2[9]\n多条路，每条路都是压入第一个元素\n从优先队列中弹出一个元素（压入），看他在哪条路中，然后压入这条路的后一个元素\n\n\n15. lc1235. 规划兼职工作\n- 题意：找到不重叠而且profit最大的区间段\n- 解决方法：使用dp+二分算法， 首先将区间按照endTime进行排序，然后定义dp为 0-i之间的最大的利益，然后使用二分找到0到i-1之间endTime< i start_time的最后的区间，然后进行状态转移\nf[i]=f[i-1]\nf[i] = max(f[i], f[r] + q[i][2]); \n- 为了减少区间0的判断，区间的编号可以直接从1开始向后\n- 易错点：最主要在进行动态规划的时候dp[i]不能定义为以i结尾的最大profit，只能定义为前i个最大的profit, 因为在进行二分的时候，可能有多个endTime相同，因此选择哪个i是未知的，如果dp定义为区间段，那么就知道选择的是最右边的i\n\n\n\n#### 二分查找总结\nok\n结果是整数, 数组排好序，或者数值选择有规律\n时间复杂度要求O(nlogn)\n类似于一种缩小范围的随机查找, 有方向的猜测\n寻找类型题，可以考虑二分，如果是最大最小题，可以试试动态规划或者二分算法\n找第k个数，不一定需要排序，可以直接二分猜测+计数验证\n\n区间问题，感觉总是出错，一般用二分或者贪心算法\n\n\n\n","slug":"leetcode/二分算法","published":1,"updated":"2023-07-10T10:36:19.532Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clk5cein90003jpjbeljo9bty","content":"<h4 id=\"模板\"><a href=\"#模板\" class=\"headerlink\" title=\"模板\"></a>模板</h4><blockquote>\n<p>参考链接：[二分查找专题]（<a href=\"https://blog.csdn.net/qq_41221520/article/details/108277801%EF%BC%89\">https://blog.csdn.net/qq_41221520/article/details/108277801）</a></p>\n</blockquote>\n<p><font color=\"red\">提型： 第一个大于，第一个大于等于， 等于的左右边界</font><br>（1）某一个数<br>（2）最后一个小于目标值target的数<br>（3）最后一个小于等于目标值target的数<br>（3）第一个大于目标值target的数<br>（5）第一个大于等于目标值target的数</p>\n<ol>\n<li>如果找左右边界2 4 4 4 4 5（第一个等于，最后一个等于），那么使用left&lt;right以及找左右边界，控制右边；找右边界，控制左边的口诀；</li>\n<li>如果找第一个大于target,第一个大于等于target；小于target, 最后一个小于等于target<br>那么使用常规二分算法，left&lt;=right 以及题目中有等号，等式中无，以及大于对应left=mid+1在前，小于对应right=mid-1在前的口诀</li>\n</ol>\n<p><font color=\"red\">统一：<br>第一个大于等于target，转为左边界；<br>最后一个小于等于target，转换为右边界.<br>其余等于，大于，或者小于都转为标准二分<br>注意标准二分记得返回的时候判断l， r是否在范围内（-1 size，判断）； 左右边界不用判断是否在返回内<br>记住大于目标值的第一个数，并不一定是等于target的右边界+1对应的下标</font></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-comment\">//找到第一个大于target的数</span><br><span class=\"hljs-keyword\">int</span> l=<span class=\"hljs-number\">0</span>, r=arr.<span class=\"hljs-built_in\">size</span>()<span class=\"hljs-number\">-1</span>;<br><span class=\"hljs-keyword\">while</span>(l&lt;=r)&#123; <br>    <span class=\"hljs-keyword\">int</span> mid=l+(r-l)/<span class=\"hljs-number\">2</span>;<br>    <span class=\"hljs-keyword\">if</span>(arr[mid]&gt;x)&#123;<br>        r=mid<span class=\"hljs-number\">-1</span>;<br>    &#125;<span class=\"hljs-keyword\">else</span>&#123; <span class=\"hljs-comment\">//等于情况应该为mid+1</span><br>        l=mid+<span class=\"hljs-number\">1</span>;<br>    &#125;<br>&#125;<br><span class=\"hljs-keyword\">if</span>(l&gt;=size)&#123;<br>    <span class=\"hljs-keyword\">return</span> error<br>&#125;<br><span class=\"hljs-keyword\">return</span> l;<br></code></pre></td></tr></table></figure>\n\n<p>第一个大于不能转为左边界：<br>[0] 当size=1的时候不行，会直接退出循环，然后返回0， 实际上应该返回1</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">左右边界<br><span class=\"hljs-comment\">//左边界</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">left_bound</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> left, <span class=\"hljs-keyword\">int</span> right, <span class=\"hljs-keyword\">int</span> arr, <span class=\"hljs-keyword\">int</span> target)</span></span>&#123;<br>    <span class=\"hljs-keyword\">while</span>(left&lt;right)&#123;<br>        <span class=\"hljs-keyword\">int</span> mid=left+(right-left)/<span class=\"hljs-number\">2</span>;<br>        <span class=\"hljs-keyword\">if</span>(arr[mid]&lt;target)&#123;<br>            left=mid+<span class=\"hljs-number\">1</span>;<br>        &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>            right=mid;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> arr[left];<br>&#125;<br><br><span class=\"hljs-comment\">//右边界</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">right_bound</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> left, <span class=\"hljs-keyword\">int</span> right, <span class=\"hljs-keyword\">int</span> arr, <span class=\"hljs-keyword\">int</span> target)</span></span>&#123;<br>    <span class=\"hljs-keyword\">while</span>(left&lt;right)&#123;<br>        <span class=\"hljs-keyword\">int</span> mid=left+(right-left)/<span class=\"hljs-number\">2</span>+<span class=\"hljs-number\">1</span>;<br>        <span class=\"hljs-keyword\">if</span>(arr[mid]&lt;=target)&#123;<br>            left=mid;<br>        &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>            right=mid<span class=\"hljs-number\">-1</span>;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> arr[right];<br>&#125;<br><br><br>标准：<br><span class=\"hljs-keyword\">while</span>(left&lt;=right)&#123;<br>    <span class=\"hljs-keyword\">int</span> mid=(left+right)/<span class=\"hljs-number\">2</span>;<br>    <span class=\"hljs-keyword\">if</span>(arr[mid]&lt;target)&#123;<br>        left=mid+<span class=\"hljs-number\">1</span>;<br>    &#125;<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(arr[mid]&gt;target)&#123;<br>        right=mid<span class=\"hljs-number\">-1</span>;<br>    &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>        <span class=\"hljs-keyword\">return</span> mid;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n<h4 id=\"例题\"><a href=\"#例题\" class=\"headerlink\" title=\"例题\"></a>例题</h4><p><font color=\"red\">0. lc34. 在排序数组中查找元素的第一个和最后一个位置</font><br>这道题元素可能存在可能不存在，使用左右边界的方法，同时需要判断最后结果是否是target</p>\n<ol>\n<li>在数组中找到一个局部最小值（不一定要在排序数组中使用二分算法，只要能确定二分两侧的某一侧肯定存在你要找的内容，就可以使用二分查找。</li>\n</ol>\n<p><font color=\"red\">2. 寻找旋转排序数组中的最小值（一个是可能包含重复数据，一个是不包含重复数据）</font><br>两个都是arr可能经过一次旋转处理，可能没有<br>(1)不包含重复，那么比较中间的值和右边的值，如果小于则说明右边顺序没变，right=mid,否则，left=mid+1<br>(2)可能包含重复数据就是在不包含重复数据基础上 添加一个如果nums[r]==nums[mid]，那么r–,一直到右边不等于mid</p>\n<pre><code>**注意**: 一定是右边的数和中间的数进行比较，因为要考虑没有旋转的这种情况\n</code></pre>\n<ol start=\"3\">\n<li><p>有序旋转数组中找到一个数 target<br>Solution:为了方便记忆，仍然使用右边的数和中间的数进行对比</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">while</span>(left&lt;=right)&#123;<br>    <span class=\"hljs-keyword\">int</span> mid=left+(right-left)/<span class=\"hljs-number\">2</span>;<br>    <span class=\"hljs-keyword\">if</span>(arr[mid]==target)&#123;<br>        <span class=\"hljs-keyword\">return</span> arr[mid];<br>    &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>        <span class=\"hljs-keyword\">if</span>(arr[mid]==arr[right])&#123;<br>            right--;<br>            <span class=\"hljs-keyword\">continue</span>;<br>        &#125;<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(arr[mid]&lt;arr[right])&#123;<br>            <span class=\"hljs-keyword\">if</span>(target&gt;arr[mid]&amp;&amp;target&lt;=arr[right])&#123;<br>                left=mid+<span class=\"hljs-number\">1</span>;<br>            &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>                right=mid<span class=\"hljs-number\">-1</span>;<br>            &#125;<br>        &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>            <span class=\"hljs-keyword\">if</span>(target&gt;=arr[left]&amp;&amp;target&lt;arr[mid])&#123;<br>                right=mid<span class=\"hljs-number\">-1</span><br>            &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>                left=mid+<span class=\"hljs-number\">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br></code></pre></td></tr></table></figure></li>\n<li><p>H指数 计数排序 O(n)（计数的数组应该为size+1, 每个index的数量，如果&gt;=n全部计算为count[n]）或者二分查找(O(logn))<br>H指数II多了一个已经拍好序，以及O(logn)因此不能遍历求citation的范围；所以只能二分查找数组，不能二分查找h_指数，同时返回的应该是个数，而不是引用量<br>根据分割点右边论文的个数与分割点 citations[x] 的大小关系进行二分 。</p>\n</li>\n</ol>\n<p><font color=\"red\"> 5. 寻找排序矩阵中的第k个数</font><br>二分查找算法，假设第k个数的值，然后判断小于他的数据是不是k<br> 计算mid值，查找，大于等于这个数的数量，然后right=mid  如果数量小于这个数量， left=mid+1<br>注意抓住矩阵横向和纵向都是有序的特点<br>同时在计算小于k的数量的时候，是每列每列的计算（从左下角）,因为是mid对矩阵进行划分</p>\n<p><font color=\"blue\"> 6. 蜡烛之间的盘子,可以直接使用vector自带的函数进行二分查找</font><br>lower_bound(vec.begin(), vec.end(), target)-vec.begin()<br>==只有两种数据， 比如0，1 找最近：使用下标的二分查找，而不是循环往前遍历==</p>\n<ol start=\"7\">\n<li>寻找右区间， 二分查找+hash <ul>\n<li>按照左边排序+遍历每个区间右边，在区间二分查找，找到最近那个</li>\n<li>因为是interval (vector<int>), 因此自己实现二分，而不是使用标准库函数里面的方法</int></li>\n</ul>\n</li>\n</ol>\n<p><font color=\"red\"> 8. 我的日程安排表I </font><br>题意，就是判断是否能向当前的区间继续插入，插入之前如何高效判断，以及以如何形式表示已经插入了该区间，提示，不使用vector<interval>结构表示插入<br>    方法一：暴力算法<br>    方法二：使用map对key进行排序，之后使用二分查找，查找当前区间应该插入的位置<br>    两个考点：<br>    1.map的lower_bound and upper_bound<br>    2. 插入的时候使用mp[end]=start<br>    查找的时候查找start所在end后面的位置，这样的话就不用和左右两边进行对比，只需要对比一边就好了<br>    插入end查找start; 插入start, 查找end, 这样判断只需要判断一边<br>    方法三：使用二叉搜索树, 每个数节点，包含left,right指针，以及start,和end两个val</interval></p>\n<p>PS 我的日程安排II III都是使用边界计数来实现，就是mp[start]++ mp[end]–</p>\n<p><strong>总结：</strong>二分算法解决区间题目， 这三道题都比较简单，前两道是判断是否有三重或者多重预定，最后一个是判断有几重预定。但是微软有一个题目是删除最少的区间，使得预定数重叠不超过2（可以等于2）：<br>微软这道题：</p>\n<ul>\n<li>按照左边边排序，同时用一个优先队列记录现在ok的序列，同时优先队列按照右边排序（我们贪心地删除右边能扩展到最远的那个）</li>\n<li>依次遍历排好序的区间，如果当前区间和优先队列中的前两个区间都有交集，那么将当区间压入优先队列中，并弹出一个区间；否则直接压入，不弹出</li>\n</ul>\n<p>这个其实也是上下车题目的模板代码，思想就是差分数组，只需要在两端进行标记</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">maxConcurrent</span> <span class=\"hljs-params\">(vecotr&lt;vecotr&lt;<span class=\"hljs-keyword\">int</span>&gt;&gt;&amp; time)</span></span>&#123;<br>    map&lt;<span class=\"hljs-keyword\">int</span>, <span class=\"hljs-keyword\">int</span>&gt; record;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">auto</span>&amp; t : time)&#123;<br>        record[t[<span class=\"hljs-number\">0</span>]] += <span class=\"hljs-number\">1</span>;<br>        record[t[<span class=\"hljs-number\">1</span>]] -= <span class=\"hljs-number\">1</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">int</span> ans = <span class=\"hljs-number\">0</span>, concurrent = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">auto</span>&amp; p : record)&#123;<br>        concurrent += p.second;<br>        ans = <span class=\"hljs-built_in\">max</span>(ans, concurrent);<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n<ol start=\"9\">\n<li><p>在 D 天内送达包裹的能力<br>使用二分搜索，查找船最低的容量，使得能在days内完成传输<br>易错点：一定要记得left 应该为里面最大的val，而不是0</p>\n</li>\n<li><p>制作 m 束花所需的最少天数<br>二分查找天数的下限，使得至少能够制作要求的花束<br>PS: 一定要注意没有找到的情况下，应该返回-1</p>\n</li>\n</ol>\n<ol start=\"11\">\n<li>同时运行 N 台电脑的最长时间(hard)<br>S=min(barries[i], mid)  Sum/mid&gt;=n<br>left=1, right=sum(barries)/n<br>也就是如果当前假设的值大于电池容量，电池就会被榨干，否则电池会被用掉mid (因此电池不会同时被多台电脑用，因此最多用掉假设t这么多的电量)</li>\n</ol>\n<p><font color=\"blue\">  12.  转变数组后最接近目标值的数组和 </font><br>二分，但是因为是绝对值，所以需要比较mid计算值比target小还是大，决定搜索那边<br>第一种思路： 这道题使用二分，但是因为是找target更近的点，因此mid的和是大于target或者小于target都有可能，虽然整体上left和right应该向target靠拢，但是最终的结果应该有另外的变量记录。==/&lt;/&gt; target的时候都不是找到了最终结果，而是候选结果。</p>\n<p>也就是结果和left/right的变化是两个逻辑，不在一条线上</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">abs</span>(sum-target)&lt;dist)&#123;<br>    res=mid;<br>    dist=<span class=\"hljs-built_in\">abs</span>(sum-target);<br>&#125;<br><span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">abs</span>(sum-target)==dist)&#123;<br>    <span class=\"hljs-keyword\">if</span>(res&gt;mid)&#123;<br>        res=mid;<br>    &#125;<br>&#125;<br><span class=\"hljs-keyword\">if</span>(sum&gt;=target)&#123;<br>    maxvalue=mid<span class=\"hljs-number\">-1</span>; <span class=\"hljs-comment\">//right</span><br>&#125;<span class=\"hljs-keyword\">else</span>&#123;<br>    minvalue=mid+<span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">//left</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>第二种思路: 要想确定差的绝对值最小，可以先求出比target大的最小值，结果必出在最小值和最小值-1，二选一，比较下即可</p>\n<p><font color=\"red\">12. 搜索旋转排序数组 （寻找里面的某个元素target/或者里面的最小值）</font><br>    1） 无重复数据，直接返回下标，那么使用标准二分查找<br>    2） 有重复数据，返回true或者false<br>    3)  有重复数据，同时返回==target的最小的下标 (<font color=\"red\">面试题 10.03. 搜索旋转数组</font>)<br>        a. 需要对比mid的左边的元素，因为是找到最小index b. 需要加一些条件判断，方便直接退出<br>        if(nums[left]==target) 直接返回left; if(nums[mid]==target) right=mid<br>        b. 因为需要最小的下标，所以只看中和左，不看右边<br>        c. 对左边和中间相等的端点进行单独处理， 只有确定target&gt;mid的时候，才left=mid+1; target==mid的时候不能left=mid+1；需要加一些预处理的命令<br>    4） 寻找旋转排序数组的最小值-无重复元素<br>    5)  寻找旋转排序数组的最小值-有重复元素<br>    6） 旋转数组， 让数组向右移动k个位置，<br>        reverse(0,n-1)<br>        reverse(0,k-1)<br>        reverse(k,n-1)</p>\n<pre><code>总结：前三个为标准的二分查找 4，5个 为边界类型的二分查找（right=mid）；找最小值的时候比较mid和right的值，找target的最小下标使用left, mid进行比较，其余情况两种都可以\n</code></pre>\n<ol start=\"12\">\n<li>面试题 10.10. 数字流的秩</li>\n</ol>\n<ul>\n<li>先随机插入一些数，如何找到小于等于x的数据个数</li>\n<li>方法1：插入的时候顺序插入，在查找的时候，使用二分查找</li>\n<li>方法2：使用树状数组</li>\n</ul>\n<ol start=\"13\">\n<li>lc363. 矩形区域不超过 K 的最大数值和(二维前缀和问题)</li>\n</ol>\n<ul>\n<li>求一个矩阵内部一个矩阵和小于k的最大数值和</li>\n<li>枚举上下两边，然后求和时累加前面（减少空间复杂度），查找的时候使用二分查找（nlogn），大于sum[i]-k的最小值(lower_bound因为是大于等于)</li>\n</ul>\n<ol start=\"14\">\n<li>lc373. 查找和最小的 K 对数字<br>优先队列+使用多路归并：<br>nums1[0]: nums2[0]-nums2[9]<br>nums1[1]: nums2[0]-nums2[9]<br>…<br>nums1[9]: nums2[0]-nums2[9]<br>多条路，每条路都是压入第一个元素<br>从优先队列中弹出一个元素（压入），看他在哪条路中，然后压入这条路的后一个元素</li>\n</ol>\n<ol start=\"15\">\n<li>lc1235. 规划兼职工作</li>\n</ol>\n<ul>\n<li>题意：找到不重叠而且profit最大的区间段</li>\n<li>解决方法：使用dp+二分算法， 首先将区间按照endTime进行排序，然后定义dp为 0-i之间的最大的利益，然后使用二分找到0到i-1之间endTime&lt; i start_time的最后的区间，然后进行状态转移<br>f[i]=f[i-1]<br>f[i] = max(f[i], f[r] + q[i][2]); </li>\n<li>为了减少区间0的判断，区间的编号可以直接从1开始向后</li>\n<li>易错点：最主要在进行动态规划的时候dp[i]不能定义为以i结尾的最大profit，只能定义为前i个最大的profit, 因为在进行二分的时候，可能有多个endTime相同，因此选择哪个i是未知的，如果dp定义为区间段，那么就知道选择的是最右边的i</li>\n</ul>\n<h4 id=\"二分查找总结\"><a href=\"#二分查找总结\" class=\"headerlink\" title=\"二分查找总结\"></a>二分查找总结</h4><p>ok<br>结果是整数, 数组排好序，或者数值选择有规律<br>时间复杂度要求O(nlogn)<br>类似于一种缩小范围的随机查找, 有方向的猜测<br>寻找类型题，可以考虑二分，如果是最大最小题，可以试试动态规划或者二分算法<br>找第k个数，不一定需要排序，可以直接二分猜测+计数验证</p>\n<p>区间问题，感觉总是出错，一般用二分或者贪心算法</p>\n","site":{"data":{}},"wordcount":6083,"excerpt":"","more":"<h4 id=\"模板\"><a href=\"#模板\" class=\"headerlink\" title=\"模板\"></a>模板</h4><blockquote>\n<p>参考链接：[二分查找专题]（<a href=\"https://blog.csdn.net/qq_41221520/article/details/108277801%EF%BC%89\">https://blog.csdn.net/qq_41221520/article/details/108277801）</a></p>\n</blockquote>\n<p><font color=\"red\">提型： 第一个大于，第一个大于等于， 等于的左右边界</font><br>（1）某一个数<br>（2）最后一个小于目标值target的数<br>（3）最后一个小于等于目标值target的数<br>（3）第一个大于目标值target的数<br>（5）第一个大于等于目标值target的数</p>\n<ol>\n<li>如果找左右边界2 4 4 4 4 5（第一个等于，最后一个等于），那么使用left&lt;right以及找左右边界，控制右边；找右边界，控制左边的口诀；</li>\n<li>如果找第一个大于target,第一个大于等于target；小于target, 最后一个小于等于target<br>那么使用常规二分算法，left&lt;=right 以及题目中有等号，等式中无，以及大于对应left=mid+1在前，小于对应right=mid-1在前的口诀</li>\n</ol>\n<p><font color=\"red\">统一：<br>第一个大于等于target，转为左边界；<br>最后一个小于等于target，转换为右边界.<br>其余等于，大于，或者小于都转为标准二分<br>注意标准二分记得返回的时候判断l， r是否在范围内（-1 size，判断）； 左右边界不用判断是否在返回内<br>记住大于目标值的第一个数，并不一定是等于target的右边界+1对应的下标</font></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-comment\">//找到第一个大于target的数</span><br><span class=\"hljs-keyword\">int</span> l=<span class=\"hljs-number\">0</span>, r=arr.<span class=\"hljs-built_in\">size</span>()<span class=\"hljs-number\">-1</span>;<br><span class=\"hljs-keyword\">while</span>(l&lt;=r)&#123; <br>    <span class=\"hljs-keyword\">int</span> mid=l+(r-l)/<span class=\"hljs-number\">2</span>;<br>    <span class=\"hljs-keyword\">if</span>(arr[mid]&gt;x)&#123;<br>        r=mid<span class=\"hljs-number\">-1</span>;<br>    &#125;<span class=\"hljs-keyword\">else</span>&#123; <span class=\"hljs-comment\">//等于情况应该为mid+1</span><br>        l=mid+<span class=\"hljs-number\">1</span>;<br>    &#125;<br>&#125;<br><span class=\"hljs-keyword\">if</span>(l&gt;=size)&#123;<br>    <span class=\"hljs-keyword\">return</span> error<br>&#125;<br><span class=\"hljs-keyword\">return</span> l;<br></code></pre></td></tr></table></figure>\n\n<p>第一个大于不能转为左边界：<br>[0] 当size=1的时候不行，会直接退出循环，然后返回0， 实际上应该返回1</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">左右边界<br><span class=\"hljs-comment\">//左边界</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">left_bound</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> left, <span class=\"hljs-keyword\">int</span> right, <span class=\"hljs-keyword\">int</span> arr, <span class=\"hljs-keyword\">int</span> target)</span></span>&#123;<br>    <span class=\"hljs-keyword\">while</span>(left&lt;right)&#123;<br>        <span class=\"hljs-keyword\">int</span> mid=left+(right-left)/<span class=\"hljs-number\">2</span>;<br>        <span class=\"hljs-keyword\">if</span>(arr[mid]&lt;target)&#123;<br>            left=mid+<span class=\"hljs-number\">1</span>;<br>        &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>            right=mid;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> arr[left];<br>&#125;<br><br><span class=\"hljs-comment\">//右边界</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">right_bound</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> left, <span class=\"hljs-keyword\">int</span> right, <span class=\"hljs-keyword\">int</span> arr, <span class=\"hljs-keyword\">int</span> target)</span></span>&#123;<br>    <span class=\"hljs-keyword\">while</span>(left&lt;right)&#123;<br>        <span class=\"hljs-keyword\">int</span> mid=left+(right-left)/<span class=\"hljs-number\">2</span>+<span class=\"hljs-number\">1</span>;<br>        <span class=\"hljs-keyword\">if</span>(arr[mid]&lt;=target)&#123;<br>            left=mid;<br>        &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>            right=mid<span class=\"hljs-number\">-1</span>;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> arr[right];<br>&#125;<br><br><br>标准：<br><span class=\"hljs-keyword\">while</span>(left&lt;=right)&#123;<br>    <span class=\"hljs-keyword\">int</span> mid=(left+right)/<span class=\"hljs-number\">2</span>;<br>    <span class=\"hljs-keyword\">if</span>(arr[mid]&lt;target)&#123;<br>        left=mid+<span class=\"hljs-number\">1</span>;<br>    &#125;<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(arr[mid]&gt;target)&#123;<br>        right=mid<span class=\"hljs-number\">-1</span>;<br>    &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>        <span class=\"hljs-keyword\">return</span> mid;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n<h4 id=\"例题\"><a href=\"#例题\" class=\"headerlink\" title=\"例题\"></a>例题</h4><p><font color=\"red\">0. lc34. 在排序数组中查找元素的第一个和最后一个位置</font><br>这道题元素可能存在可能不存在，使用左右边界的方法，同时需要判断最后结果是否是target</p>\n<ol>\n<li>在数组中找到一个局部最小值（不一定要在排序数组中使用二分算法，只要能确定二分两侧的某一侧肯定存在你要找的内容，就可以使用二分查找。</li>\n</ol>\n<p><font color=\"red\">2. 寻找旋转排序数组中的最小值（一个是可能包含重复数据，一个是不包含重复数据）</font><br>两个都是arr可能经过一次旋转处理，可能没有<br>(1)不包含重复，那么比较中间的值和右边的值，如果小于则说明右边顺序没变，right=mid,否则，left=mid+1<br>(2)可能包含重复数据就是在不包含重复数据基础上 添加一个如果nums[r]==nums[mid]，那么r–,一直到右边不等于mid</p>\n<pre><code>**注意**: 一定是右边的数和中间的数进行比较，因为要考虑没有旋转的这种情况\n</code></pre>\n<ol start=\"3\">\n<li><p>有序旋转数组中找到一个数 target<br>Solution:为了方便记忆，仍然使用右边的数和中间的数进行对比</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">while</span>(left&lt;=right)&#123;<br>    <span class=\"hljs-keyword\">int</span> mid=left+(right-left)/<span class=\"hljs-number\">2</span>;<br>    <span class=\"hljs-keyword\">if</span>(arr[mid]==target)&#123;<br>        <span class=\"hljs-keyword\">return</span> arr[mid];<br>    &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>        <span class=\"hljs-keyword\">if</span>(arr[mid]==arr[right])&#123;<br>            right--;<br>            <span class=\"hljs-keyword\">continue</span>;<br>        &#125;<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(arr[mid]&lt;arr[right])&#123;<br>            <span class=\"hljs-keyword\">if</span>(target&gt;arr[mid]&amp;&amp;target&lt;=arr[right])&#123;<br>                left=mid+<span class=\"hljs-number\">1</span>;<br>            &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>                right=mid<span class=\"hljs-number\">-1</span>;<br>            &#125;<br>        &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>            <span class=\"hljs-keyword\">if</span>(target&gt;=arr[left]&amp;&amp;target&lt;arr[mid])&#123;<br>                right=mid<span class=\"hljs-number\">-1</span><br>            &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>                left=mid+<span class=\"hljs-number\">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br></code></pre></td></tr></table></figure></li>\n<li><p>H指数 计数排序 O(n)（计数的数组应该为size+1, 每个index的数量，如果&gt;=n全部计算为count[n]）或者二分查找(O(logn))<br>H指数II多了一个已经拍好序，以及O(logn)因此不能遍历求citation的范围；所以只能二分查找数组，不能二分查找h_指数，同时返回的应该是个数，而不是引用量<br>根据分割点右边论文的个数与分割点 citations[x] 的大小关系进行二分 。</p>\n</li>\n</ol>\n<p><font color=\"red\"> 5. 寻找排序矩阵中的第k个数</font><br>二分查找算法，假设第k个数的值，然后判断小于他的数据是不是k<br> 计算mid值，查找，大于等于这个数的数量，然后right=mid  如果数量小于这个数量， left=mid+1<br>注意抓住矩阵横向和纵向都是有序的特点<br>同时在计算小于k的数量的时候，是每列每列的计算（从左下角）,因为是mid对矩阵进行划分</p>\n<p><font color=\"blue\"> 6. 蜡烛之间的盘子,可以直接使用vector自带的函数进行二分查找</font><br>lower_bound(vec.begin(), vec.end(), target)-vec.begin()<br>==只有两种数据， 比如0，1 找最近：使用下标的二分查找，而不是循环往前遍历==</p>\n<ol start=\"7\">\n<li>寻找右区间， 二分查找+hash <ul>\n<li>按照左边排序+遍历每个区间右边，在区间二分查找，找到最近那个</li>\n<li>因为是interval (vector<int>), 因此自己实现二分，而不是使用标准库函数里面的方法</int></li>\n</ul>\n</li>\n</ol>\n<p><font color=\"red\"> 8. 我的日程安排表I </font><br>题意，就是判断是否能向当前的区间继续插入，插入之前如何高效判断，以及以如何形式表示已经插入了该区间，提示，不使用vector<interval>结构表示插入<br>    方法一：暴力算法<br>    方法二：使用map对key进行排序，之后使用二分查找，查找当前区间应该插入的位置<br>    两个考点：<br>    1.map的lower_bound and upper_bound<br>    2. 插入的时候使用mp[end]=start<br>    查找的时候查找start所在end后面的位置，这样的话就不用和左右两边进行对比，只需要对比一边就好了<br>    插入end查找start; 插入start, 查找end, 这样判断只需要判断一边<br>    方法三：使用二叉搜索树, 每个数节点，包含left,right指针，以及start,和end两个val</interval></p>\n<p>PS 我的日程安排II III都是使用边界计数来实现，就是mp[start]++ mp[end]–</p>\n<p><strong>总结：</strong>二分算法解决区间题目， 这三道题都比较简单，前两道是判断是否有三重或者多重预定，最后一个是判断有几重预定。但是微软有一个题目是删除最少的区间，使得预定数重叠不超过2（可以等于2）：<br>微软这道题：</p>\n<ul>\n<li>按照左边边排序，同时用一个优先队列记录现在ok的序列，同时优先队列按照右边排序（我们贪心地删除右边能扩展到最远的那个）</li>\n<li>依次遍历排好序的区间，如果当前区间和优先队列中的前两个区间都有交集，那么将当区间压入优先队列中，并弹出一个区间；否则直接压入，不弹出</li>\n</ul>\n<p>这个其实也是上下车题目的模板代码，思想就是差分数组，只需要在两端进行标记</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">maxConcurrent</span> <span class=\"hljs-params\">(vecotr&lt;vecotr&lt;<span class=\"hljs-keyword\">int</span>&gt;&gt;&amp; time)</span></span>&#123;<br>    map&lt;<span class=\"hljs-keyword\">int</span>, <span class=\"hljs-keyword\">int</span>&gt; record;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">auto</span>&amp; t : time)&#123;<br>        record[t[<span class=\"hljs-number\">0</span>]] += <span class=\"hljs-number\">1</span>;<br>        record[t[<span class=\"hljs-number\">1</span>]] -= <span class=\"hljs-number\">1</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">int</span> ans = <span class=\"hljs-number\">0</span>, concurrent = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">auto</span>&amp; p : record)&#123;<br>        concurrent += p.second;<br>        ans = <span class=\"hljs-built_in\">max</span>(ans, concurrent);<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n<ol start=\"9\">\n<li><p>在 D 天内送达包裹的能力<br>使用二分搜索，查找船最低的容量，使得能在days内完成传输<br>易错点：一定要记得left 应该为里面最大的val，而不是0</p>\n</li>\n<li><p>制作 m 束花所需的最少天数<br>二分查找天数的下限，使得至少能够制作要求的花束<br>PS: 一定要注意没有找到的情况下，应该返回-1</p>\n</li>\n</ol>\n<ol start=\"11\">\n<li>同时运行 N 台电脑的最长时间(hard)<br>S=min(barries[i], mid)  Sum/mid&gt;=n<br>left=1, right=sum(barries)/n<br>也就是如果当前假设的值大于电池容量，电池就会被榨干，否则电池会被用掉mid (因此电池不会同时被多台电脑用，因此最多用掉假设t这么多的电量)</li>\n</ol>\n<p><font color=\"blue\">  12.  转变数组后最接近目标值的数组和 </font><br>二分，但是因为是绝对值，所以需要比较mid计算值比target小还是大，决定搜索那边<br>第一种思路： 这道题使用二分，但是因为是找target更近的点，因此mid的和是大于target或者小于target都有可能，虽然整体上left和right应该向target靠拢，但是最终的结果应该有另外的变量记录。==/&lt;/&gt; target的时候都不是找到了最终结果，而是候选结果。</p>\n<p>也就是结果和left/right的变化是两个逻辑，不在一条线上</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">abs</span>(sum-target)&lt;dist)&#123;<br>    res=mid;<br>    dist=<span class=\"hljs-built_in\">abs</span>(sum-target);<br>&#125;<br><span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">abs</span>(sum-target)==dist)&#123;<br>    <span class=\"hljs-keyword\">if</span>(res&gt;mid)&#123;<br>        res=mid;<br>    &#125;<br>&#125;<br><span class=\"hljs-keyword\">if</span>(sum&gt;=target)&#123;<br>    maxvalue=mid<span class=\"hljs-number\">-1</span>; <span class=\"hljs-comment\">//right</span><br>&#125;<span class=\"hljs-keyword\">else</span>&#123;<br>    minvalue=mid+<span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">//left</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>第二种思路: 要想确定差的绝对值最小，可以先求出比target大的最小值，结果必出在最小值和最小值-1，二选一，比较下即可</p>\n<p><font color=\"red\">12. 搜索旋转排序数组 （寻找里面的某个元素target/或者里面的最小值）</font><br>    1） 无重复数据，直接返回下标，那么使用标准二分查找<br>    2） 有重复数据，返回true或者false<br>    3)  有重复数据，同时返回==target的最小的下标 (<font color=\"red\">面试题 10.03. 搜索旋转数组</font>)<br>        a. 需要对比mid的左边的元素，因为是找到最小index b. 需要加一些条件判断，方便直接退出<br>        if(nums[left]==target) 直接返回left; if(nums[mid]==target) right=mid<br>        b. 因为需要最小的下标，所以只看中和左，不看右边<br>        c. 对左边和中间相等的端点进行单独处理， 只有确定target&gt;mid的时候，才left=mid+1; target==mid的时候不能left=mid+1；需要加一些预处理的命令<br>    4） 寻找旋转排序数组的最小值-无重复元素<br>    5)  寻找旋转排序数组的最小值-有重复元素<br>    6） 旋转数组， 让数组向右移动k个位置，<br>        reverse(0,n-1)<br>        reverse(0,k-1)<br>        reverse(k,n-1)</p>\n<pre><code>总结：前三个为标准的二分查找 4，5个 为边界类型的二分查找（right=mid）；找最小值的时候比较mid和right的值，找target的最小下标使用left, mid进行比较，其余情况两种都可以\n</code></pre>\n<ol start=\"12\">\n<li>面试题 10.10. 数字流的秩</li>\n</ol>\n<ul>\n<li>先随机插入一些数，如何找到小于等于x的数据个数</li>\n<li>方法1：插入的时候顺序插入，在查找的时候，使用二分查找</li>\n<li>方法2：使用树状数组</li>\n</ul>\n<ol start=\"13\">\n<li>lc363. 矩形区域不超过 K 的最大数值和(二维前缀和问题)</li>\n</ol>\n<ul>\n<li>求一个矩阵内部一个矩阵和小于k的最大数值和</li>\n<li>枚举上下两边，然后求和时累加前面（减少空间复杂度），查找的时候使用二分查找（nlogn），大于sum[i]-k的最小值(lower_bound因为是大于等于)</li>\n</ul>\n<ol start=\"14\">\n<li>lc373. 查找和最小的 K 对数字<br>优先队列+使用多路归并：<br>nums1[0]: nums2[0]-nums2[9]<br>nums1[1]: nums2[0]-nums2[9]<br>…<br>nums1[9]: nums2[0]-nums2[9]<br>多条路，每条路都是压入第一个元素<br>从优先队列中弹出一个元素（压入），看他在哪条路中，然后压入这条路的后一个元素</li>\n</ol>\n<ol start=\"15\">\n<li>lc1235. 规划兼职工作</li>\n</ol>\n<ul>\n<li>题意：找到不重叠而且profit最大的区间段</li>\n<li>解决方法：使用dp+二分算法， 首先将区间按照endTime进行排序，然后定义dp为 0-i之间的最大的利益，然后使用二分找到0到i-1之间endTime&lt; i start_time的最后的区间，然后进行状态转移<br>f[i]=f[i-1]<br>f[i] = max(f[i], f[r] + q[i][2]); </li>\n<li>为了减少区间0的判断，区间的编号可以直接从1开始向后</li>\n<li>易错点：最主要在进行动态规划的时候dp[i]不能定义为以i结尾的最大profit，只能定义为前i个最大的profit, 因为在进行二分的时候，可能有多个endTime相同，因此选择哪个i是未知的，如果dp定义为区间段，那么就知道选择的是最右边的i</li>\n</ul>\n<h4 id=\"二分查找总结\"><a href=\"#二分查找总结\" class=\"headerlink\" title=\"二分查找总结\"></a>二分查找总结</h4><p>ok<br>结果是整数, 数组排好序，或者数值选择有规律<br>时间复杂度要求O(nlogn)<br>类似于一种缩小范围的随机查找, 有方向的猜测<br>寻找类型题，可以考虑二分，如果是最大最小题，可以试试动态规划或者二分算法<br>找第k个数，不一定需要排序，可以直接二分猜测+计数验证</p>\n<p>区间问题，感觉总是出错，一般用二分或者贪心算法</p>\n"},{"title":"二叉树","date":"2021-11-23T02:27:56.000Z","_content":"\n1. 验证二叉树的前序序列化\n    观察规律题或者建树题\n    我的思路是直接建立一颗二叉树，但是建立树代码可以不写；最后树是正确的就是中间不会访问到cur==size的情况，同时最后循环完之后不会再出现#或者数字\n    官方题解是：通过槽位计数，如果遍历到最后槽位为0说明正确，如果中间槽位为0，说明出错\n    因为加上一个#槽位数会--，如果加上一个数字那么槽位数会++（-1+2）\n    注意这道题的易错点是: 字符串中包含','而且可能数字包含两个字符 98,7,#\n\n2. 二叉树的宽度： 宽度应该包含一层的节点之间夹杂的空字符，所以为了得到一层的宽度，应该在栈中压入每个节点的下标(左边：2 * pos, 右边：2 * pos+1)，而不是具体的二叉树ListNode\n\n3. 两个子节点的最近公共父节点\n\n如果一个节点为target_one或者target_two那么直接返回当前节点，否则进行dfs, dfs返回的左右节点都是非NULL那么就返回当前节点\n```C++\nListNode* lowestCommonAncestor(ListNode* root, ListNode* node1, ListNode* node2){\n    if(root==NULL||root==p||root==q) return root;\n    if(root==node1||root==node2){\n        return cur;\n    }\n    else{\n        ListNode *left=lowestCommonAncestor(root->left, node1, node2);\n        ListNode *right=lowestCommonAncestor(root->right, node1, node2);\n        if(left&&right){\n            return cur;\n        }else if(left){\n            return left;\n        }\n        return right;\n    }\n}\n\n```\n\n4. 从二叉树一个节点到另一个节点每一步的方向\n\n方法，通过dfs找到到达startValue和dstValue的具体路径，然后删除路径前面相同的部分，然后到达startValue剩余的size都加上U， 到达dstValue剩余的都加上dst剩余的路径\n\n\n5. 寻找重复的树， \n    解决方案：序列化+hash判断子树是否唯一，序列化只能使用# ，以及前序和后序遍历\n    - 注意这道题需要记录空节点，同时，只能使用前序或者后序遍历 唯一判定两棵子树是否相同，而不能使用中序遍历。而且数据与数据应该用，隔开，因为222可以理解为2+2+2也可以理解为2+22 \n    -  ==加上#的这种情况，只有后序遍历和前序遍历能够唯一确定一课子树。中序遍历不行==  \n    - 同样这道题使用二叉树的序列化和反序列化, 因为前序和后序都可以知道根节点，但是中序不行\n\n6. 最长同值路径\n    - 和二叉树的直径类似，不过这里需要判断值是否相等，多了一个条件\n    - 为了区分left+right+1 left+1 right+1三种情况，可以使用一个left_mark 如果左边和root相等那么==left_val+1否则为0。那么最后的结果都是left_mark+right_mark+1， 解决了三种情况 返回max(left_mark, right_mark)+1\n\n7. 二叉树中所有距离为 K 的结点\n先通过dfs找到每个节点的父节点，然后再对target节点进行dfs 左右和父节点 (或者bfs+vis)\n\n8. 二叉树寻路，使用数学方法\n    1.先求每个数正常的父亲，然后再对不同的层进行修改\n    2.在进行修改的时候抓住对称的点的和是相同的\n    3.如果层数是偶数，那么只需要修改奇数层的值；如果层数是奇数，那么需要修改偶数层的数据\n\n9. 二叉树中两个节点间的距离\n先求两个节点的最近公共祖先，然后从最近公共祖先出发，求祖先节点分别到两个节点的距离(使用dfs两次，target==p||q)，距离之和就是两个节点的最短路径\n代码：https://www.jianshu.com/p/cec33f514f69\n\n\n10. 树的直径问题\n任意选择一个节点为根，然后找到离他最远的节点a，然后找到离a最远的节点b，那么a->b就是最远的路径（数的直径）\n如果是二叉树有指针的情况可以使用递归\n```C++\n    int result=0;\n    int maxDistance(TreeNode* root){\n        if(root==NULL){\n            return 0;\n        }\n        int leftLength=maxDistance(root->left);\n        int rightLenght=maxDistance(root->right);\n        result=max(leftLength+rightLenght+1, result);\n        return max(leftLength, rightLenght)+1;\n    }\n    int diameterOfBinaryTree(TreeNode* root) {\n        maxDistance(root);\n        return result-1;\n    }\n```\n如果是无向图：\n算法思想\n①从任意一点P出发，通过DFS寻找离它最远的点Q。\n②再次从点Q出发，通过DFS寻找离它最远的W。\n③直径即为WQ。\n证明：https://zhuanlan.zhihu.com/p/115966044\n\n两次dfs\n```C++\nvoid dfs(int st)\n{\n    for(int i=0;i<edge[st].size();i++)\n    {\n        int to=edge[st][i];\n        if(!vis[to])\n        {\n            vis[to]=1;\n            dis[to]=dis[st]+1;//注意，本代码计算的是无权树的直径，所以边权为1\n            //如果是有权树，则这里的1要改为边权\n            dfs(to);\n        }\n    }\n}\n```\n求最长就是求最大的dis，两次dfs中间需要重新初始化dis=0\n\n\n11. 具有所有最深节点的最小子树\n\n在深度优先搜索的时候同时返回结果和计算深度，返回的是一个结构体 node{root, dist}.\n1)获取当前节点的左右子树的最大深度\n2)如果两边最大深度相同，则这个节点就是结果\n3)不相等，那返回深度大的子树的root信息\n\n12. 205. 同构字符串/890. 查找和替换模式\n查找和对应模式一致的字符串，abb模式。\n使用双hash,也就是两边都没有映射，才建立映射，或者两边都有映射且未对方，那么continue,否则说明出处\n```C++\nif(s2t.find(s[i])==s2t.end()&&t2s.find(t[i])==t2s.end()){\n    s2t[s[i]]=t[i];\n    t2s[t[i]]=s[i];\n}else if(s2t[s[i]]=t[i]&&t2s[t[i]]==s[i]){\n    continue;\n}else{\n    return false;\n}\n```\n\n\n12. 前后序遍历中空间复杂度为O(1)的Morris Traval方法（主要是利用叶子节点的空指针进行映射到下一个节点）\n    https://www.cnblogs.com/AnnieKim/archive/2013/06/15/MorrisTraversal.html\n- **前序遍历**\n    根左右\n    1. 如果当前节点的左孩子为空，那么输出当前节点，并将当前节点设置为当前节点的右孩子\n    2. 一个节点的左孩子不为空，那么在当前节点的左子树找到这个节点的前驱节点\n        如果这个前驱节点的右孩子为空，那么设置右孩子为当前节点，==输出当前节点==（于中序的唯一不同），并当前节点更新为当前节点左孩子\n        如果这个前驱节点的右孩子为当前节点，那么将右孩子重新设置为空。并更新当前节点为当前节点的右孩子。\n\n\n- **中序遍历**\n    左根右\n    1. 如果当前节点的左孩子为空，那么输出当前节点，并将当前节点设置为当前节点的右孩子\n    2. 一个节点的左孩子不为空，那么在当前节点的左子树找到这个节点的前驱节点\n        如果这个前驱节点的右孩子为空，那么设置右孩子为当前节点，并当前节点更新为当前节点左孩子\n        如果这个前驱节点的右孩子为当前节点，那么将右孩子重新设置为空。**输出当前节点**， 并更新当前节点为当前节点的右孩子\n        与前序遍历相比一个是回来之后再输出(else)，一个是建立前驱到根节点关系后输出（if）\n\n\n- **后序遍历**\n    **需要建立一个临时节点dump**，使该节点的左子树等于root\n    1. 如果当前节点的左孩子为空，那么则将其右孩子作为当前节点\n    2. 一个节点的左孩子不为空，那么在当前节点的左子树找到这个节点的前驱节点\n    如果这个前驱节点的右孩子为空，那么设置右孩子为当前节点, 并当前节点更新为当前节点左孩子\n    如果这个前驱节点的右孩子为当前节点，那么还原前驱右孩子为null, ==同时逆序输出从当前节点左孩子到前驱节点的路==，并更新当前节点为右孩子\n\n\n总结：建立关系后，到左孩子；为空或者一圈回来后到右孩子\n    一圈回来后，还原关系\n\n\n13.  将子数组重新排序得到同一个二叉查找树的方案数\n题意，交换插入序列，但是得到的二叉搜索树最后的结果相同的序列共有多少个\n解决：抓住，先插左还是右的顺序是可以变的，但是在插入单边的时候，根节点的插入顺序是不可以变的\n- 排列组合+dfs\n- 求排列组合的时候，其实用动态规划的思想 C(n,k)=C(n-1, k-1)+C(n-1,k)\n- node->ans = (long long)c[lsize + rsize][lsize] % mod * lans % mod * rans % mod;\n- 在使用dfs的时候，使用一个全局的res变量，每次乘以（all, less)的组合结果；划分less, greater的时候，可以用一个新的vector来记录左右子树的节点\n- 也可以先建立一棵树，使用递归左右指针的方式，树的信息需要包含size ,ans等一些信息\n另一种出题的方式：\n    一个数组入栈顺序定了，有多少种出栈的顺序\n    f(n)=f(1)* f(n-1) + f(2) * f(n-2)+.....f(n-1) f(1);\n    递推公式的解为：h(n)=c(2n,n)-c(2n,n+1)(n=1,2,3,...)\n\n14. 二叉搜索树删除一个节点\n递归删除\n易错点：\n    1. 可以根据二叉搜索树的性质，选择向左右递归 \n    2. 找到该节点，如果是叶节点直接删除，如果只有左右子树，也可以直接返回左右子树，否则找到左边最小，然后赋值到当前值，然后递归删除\n    3. 注意递归删除的的时候，一定要注意返回值，一定要赋值给当前节点的左指针或者右指针; 否则会造成树在中间断裂\n\n\n15. lc987. 二叉树的垂序遍历\n- dfs 遍历nodes 记录下每个节点的行号row，列号 col 以及值 value。\n在遍历完成后，我们按照 col 为第一关键字升序，row 为第二关键字升序，value 为第三关键字升序，对所有的节点进行排序即可。 遍历时将同一col的放到同一vector中\n- 也可以使用map<int, vector<node>> 这样的话就不用手动分每一个col\n\n<font color=red>16. lc979. 在二叉树中分配硬币</font>\n\n- 第一种方法：可以考虑后序遍历理解；需要从父节点得到或者获取 root->val-1个节点， \nans+=abs(root->val-1); return root->val-1//返回可能是负数\n- 第二种方法：转为在子树中分配硬币\ndfs(root)表示root这棵子树冗余的节点数\nroot->val+dfs(root->left)+dfs(root->right)-1;\nans+=abs(dfs(root->left))+abs(dfs(root->right));\n\n16.  lc99. 恢复二叉搜索树\n- 二叉树出现位置交换会出现两种情况\n两次逆序：记录前面x和后面y， 第二次更新y\n一次逆序：记录前面x和后面y\n- 时间O(n),空间O(1)\n\n17.  Find Leaves of Binary Tree 找二叉树的叶节点\n- 题意：类似剥洋葱一样，将二叉树从最外到最内\n- 重新定义二叉树的深度为最优深度最大值加一，然后res[depth].push_back(root->val)\nif (depth >= res.size()) res.resize(depth + 1);//因为最开始不知道最大的深度，因此不知道如何初始化，所以在最深一层初始化大小\n\n\n\n#### 总结\nok ok\n1. 主要考察前中后序遍历， 子树（序列化+hash）, 直径(自底向上判断，左右返回最大一个，同时更新结果为根)， 宽度（BFS）， 二叉树的左右节点（index*2, index *2）, 二叉搜索树相关（删除节点）， 自顶向下和自底向上递归\n2. 主要关联的数据结构有栈，队列（BFS/DFS）， hash, 字符串等\n3. 求总数的时候可能会涉及排列组合的知识， \n4. 判断当前子树是否为BST, 不能仅仅靠当前节点的值大于左边最大和右边最小就可以，还需要左右两边都是BST（lc333-最大BST子树）\n\n\n","source":"_posts/leetcode/二叉树.md","raw":"---\ntitle: 二叉树\ncategories:\n  - leetcode\ndate: 2021-11-23 10:27:56\ntags:\n---\n\n1. 验证二叉树的前序序列化\n    观察规律题或者建树题\n    我的思路是直接建立一颗二叉树，但是建立树代码可以不写；最后树是正确的就是中间不会访问到cur==size的情况，同时最后循环完之后不会再出现#或者数字\n    官方题解是：通过槽位计数，如果遍历到最后槽位为0说明正确，如果中间槽位为0，说明出错\n    因为加上一个#槽位数会--，如果加上一个数字那么槽位数会++（-1+2）\n    注意这道题的易错点是: 字符串中包含','而且可能数字包含两个字符 98,7,#\n\n2. 二叉树的宽度： 宽度应该包含一层的节点之间夹杂的空字符，所以为了得到一层的宽度，应该在栈中压入每个节点的下标(左边：2 * pos, 右边：2 * pos+1)，而不是具体的二叉树ListNode\n\n3. 两个子节点的最近公共父节点\n\n如果一个节点为target_one或者target_two那么直接返回当前节点，否则进行dfs, dfs返回的左右节点都是非NULL那么就返回当前节点\n```C++\nListNode* lowestCommonAncestor(ListNode* root, ListNode* node1, ListNode* node2){\n    if(root==NULL||root==p||root==q) return root;\n    if(root==node1||root==node2){\n        return cur;\n    }\n    else{\n        ListNode *left=lowestCommonAncestor(root->left, node1, node2);\n        ListNode *right=lowestCommonAncestor(root->right, node1, node2);\n        if(left&&right){\n            return cur;\n        }else if(left){\n            return left;\n        }\n        return right;\n    }\n}\n\n```\n\n4. 从二叉树一个节点到另一个节点每一步的方向\n\n方法，通过dfs找到到达startValue和dstValue的具体路径，然后删除路径前面相同的部分，然后到达startValue剩余的size都加上U， 到达dstValue剩余的都加上dst剩余的路径\n\n\n5. 寻找重复的树， \n    解决方案：序列化+hash判断子树是否唯一，序列化只能使用# ，以及前序和后序遍历\n    - 注意这道题需要记录空节点，同时，只能使用前序或者后序遍历 唯一判定两棵子树是否相同，而不能使用中序遍历。而且数据与数据应该用，隔开，因为222可以理解为2+2+2也可以理解为2+22 \n    -  ==加上#的这种情况，只有后序遍历和前序遍历能够唯一确定一课子树。中序遍历不行==  \n    - 同样这道题使用二叉树的序列化和反序列化, 因为前序和后序都可以知道根节点，但是中序不行\n\n6. 最长同值路径\n    - 和二叉树的直径类似，不过这里需要判断值是否相等，多了一个条件\n    - 为了区分left+right+1 left+1 right+1三种情况，可以使用一个left_mark 如果左边和root相等那么==left_val+1否则为0。那么最后的结果都是left_mark+right_mark+1， 解决了三种情况 返回max(left_mark, right_mark)+1\n\n7. 二叉树中所有距离为 K 的结点\n先通过dfs找到每个节点的父节点，然后再对target节点进行dfs 左右和父节点 (或者bfs+vis)\n\n8. 二叉树寻路，使用数学方法\n    1.先求每个数正常的父亲，然后再对不同的层进行修改\n    2.在进行修改的时候抓住对称的点的和是相同的\n    3.如果层数是偶数，那么只需要修改奇数层的值；如果层数是奇数，那么需要修改偶数层的数据\n\n9. 二叉树中两个节点间的距离\n先求两个节点的最近公共祖先，然后从最近公共祖先出发，求祖先节点分别到两个节点的距离(使用dfs两次，target==p||q)，距离之和就是两个节点的最短路径\n代码：https://www.jianshu.com/p/cec33f514f69\n\n\n10. 树的直径问题\n任意选择一个节点为根，然后找到离他最远的节点a，然后找到离a最远的节点b，那么a->b就是最远的路径（数的直径）\n如果是二叉树有指针的情况可以使用递归\n```C++\n    int result=0;\n    int maxDistance(TreeNode* root){\n        if(root==NULL){\n            return 0;\n        }\n        int leftLength=maxDistance(root->left);\n        int rightLenght=maxDistance(root->right);\n        result=max(leftLength+rightLenght+1, result);\n        return max(leftLength, rightLenght)+1;\n    }\n    int diameterOfBinaryTree(TreeNode* root) {\n        maxDistance(root);\n        return result-1;\n    }\n```\n如果是无向图：\n算法思想\n①从任意一点P出发，通过DFS寻找离它最远的点Q。\n②再次从点Q出发，通过DFS寻找离它最远的W。\n③直径即为WQ。\n证明：https://zhuanlan.zhihu.com/p/115966044\n\n两次dfs\n```C++\nvoid dfs(int st)\n{\n    for(int i=0;i<edge[st].size();i++)\n    {\n        int to=edge[st][i];\n        if(!vis[to])\n        {\n            vis[to]=1;\n            dis[to]=dis[st]+1;//注意，本代码计算的是无权树的直径，所以边权为1\n            //如果是有权树，则这里的1要改为边权\n            dfs(to);\n        }\n    }\n}\n```\n求最长就是求最大的dis，两次dfs中间需要重新初始化dis=0\n\n\n11. 具有所有最深节点的最小子树\n\n在深度优先搜索的时候同时返回结果和计算深度，返回的是一个结构体 node{root, dist}.\n1)获取当前节点的左右子树的最大深度\n2)如果两边最大深度相同，则这个节点就是结果\n3)不相等，那返回深度大的子树的root信息\n\n12. 205. 同构字符串/890. 查找和替换模式\n查找和对应模式一致的字符串，abb模式。\n使用双hash,也就是两边都没有映射，才建立映射，或者两边都有映射且未对方，那么continue,否则说明出处\n```C++\nif(s2t.find(s[i])==s2t.end()&&t2s.find(t[i])==t2s.end()){\n    s2t[s[i]]=t[i];\n    t2s[t[i]]=s[i];\n}else if(s2t[s[i]]=t[i]&&t2s[t[i]]==s[i]){\n    continue;\n}else{\n    return false;\n}\n```\n\n\n12. 前后序遍历中空间复杂度为O(1)的Morris Traval方法（主要是利用叶子节点的空指针进行映射到下一个节点）\n    https://www.cnblogs.com/AnnieKim/archive/2013/06/15/MorrisTraversal.html\n- **前序遍历**\n    根左右\n    1. 如果当前节点的左孩子为空，那么输出当前节点，并将当前节点设置为当前节点的右孩子\n    2. 一个节点的左孩子不为空，那么在当前节点的左子树找到这个节点的前驱节点\n        如果这个前驱节点的右孩子为空，那么设置右孩子为当前节点，==输出当前节点==（于中序的唯一不同），并当前节点更新为当前节点左孩子\n        如果这个前驱节点的右孩子为当前节点，那么将右孩子重新设置为空。并更新当前节点为当前节点的右孩子。\n\n\n- **中序遍历**\n    左根右\n    1. 如果当前节点的左孩子为空，那么输出当前节点，并将当前节点设置为当前节点的右孩子\n    2. 一个节点的左孩子不为空，那么在当前节点的左子树找到这个节点的前驱节点\n        如果这个前驱节点的右孩子为空，那么设置右孩子为当前节点，并当前节点更新为当前节点左孩子\n        如果这个前驱节点的右孩子为当前节点，那么将右孩子重新设置为空。**输出当前节点**， 并更新当前节点为当前节点的右孩子\n        与前序遍历相比一个是回来之后再输出(else)，一个是建立前驱到根节点关系后输出（if）\n\n\n- **后序遍历**\n    **需要建立一个临时节点dump**，使该节点的左子树等于root\n    1. 如果当前节点的左孩子为空，那么则将其右孩子作为当前节点\n    2. 一个节点的左孩子不为空，那么在当前节点的左子树找到这个节点的前驱节点\n    如果这个前驱节点的右孩子为空，那么设置右孩子为当前节点, 并当前节点更新为当前节点左孩子\n    如果这个前驱节点的右孩子为当前节点，那么还原前驱右孩子为null, ==同时逆序输出从当前节点左孩子到前驱节点的路==，并更新当前节点为右孩子\n\n\n总结：建立关系后，到左孩子；为空或者一圈回来后到右孩子\n    一圈回来后，还原关系\n\n\n13.  将子数组重新排序得到同一个二叉查找树的方案数\n题意，交换插入序列，但是得到的二叉搜索树最后的结果相同的序列共有多少个\n解决：抓住，先插左还是右的顺序是可以变的，但是在插入单边的时候，根节点的插入顺序是不可以变的\n- 排列组合+dfs\n- 求排列组合的时候，其实用动态规划的思想 C(n,k)=C(n-1, k-1)+C(n-1,k)\n- node->ans = (long long)c[lsize + rsize][lsize] % mod * lans % mod * rans % mod;\n- 在使用dfs的时候，使用一个全局的res变量，每次乘以（all, less)的组合结果；划分less, greater的时候，可以用一个新的vector来记录左右子树的节点\n- 也可以先建立一棵树，使用递归左右指针的方式，树的信息需要包含size ,ans等一些信息\n另一种出题的方式：\n    一个数组入栈顺序定了，有多少种出栈的顺序\n    f(n)=f(1)* f(n-1) + f(2) * f(n-2)+.....f(n-1) f(1);\n    递推公式的解为：h(n)=c(2n,n)-c(2n,n+1)(n=1,2,3,...)\n\n14. 二叉搜索树删除一个节点\n递归删除\n易错点：\n    1. 可以根据二叉搜索树的性质，选择向左右递归 \n    2. 找到该节点，如果是叶节点直接删除，如果只有左右子树，也可以直接返回左右子树，否则找到左边最小，然后赋值到当前值，然后递归删除\n    3. 注意递归删除的的时候，一定要注意返回值，一定要赋值给当前节点的左指针或者右指针; 否则会造成树在中间断裂\n\n\n15. lc987. 二叉树的垂序遍历\n- dfs 遍历nodes 记录下每个节点的行号row，列号 col 以及值 value。\n在遍历完成后，我们按照 col 为第一关键字升序，row 为第二关键字升序，value 为第三关键字升序，对所有的节点进行排序即可。 遍历时将同一col的放到同一vector中\n- 也可以使用map<int, vector<node>> 这样的话就不用手动分每一个col\n\n<font color=red>16. lc979. 在二叉树中分配硬币</font>\n\n- 第一种方法：可以考虑后序遍历理解；需要从父节点得到或者获取 root->val-1个节点， \nans+=abs(root->val-1); return root->val-1//返回可能是负数\n- 第二种方法：转为在子树中分配硬币\ndfs(root)表示root这棵子树冗余的节点数\nroot->val+dfs(root->left)+dfs(root->right)-1;\nans+=abs(dfs(root->left))+abs(dfs(root->right));\n\n16.  lc99. 恢复二叉搜索树\n- 二叉树出现位置交换会出现两种情况\n两次逆序：记录前面x和后面y， 第二次更新y\n一次逆序：记录前面x和后面y\n- 时间O(n),空间O(1)\n\n17.  Find Leaves of Binary Tree 找二叉树的叶节点\n- 题意：类似剥洋葱一样，将二叉树从最外到最内\n- 重新定义二叉树的深度为最优深度最大值加一，然后res[depth].push_back(root->val)\nif (depth >= res.size()) res.resize(depth + 1);//因为最开始不知道最大的深度，因此不知道如何初始化，所以在最深一层初始化大小\n\n\n\n#### 总结\nok ok\n1. 主要考察前中后序遍历， 子树（序列化+hash）, 直径(自底向上判断，左右返回最大一个，同时更新结果为根)， 宽度（BFS）， 二叉树的左右节点（index*2, index *2）, 二叉搜索树相关（删除节点）， 自顶向下和自底向上递归\n2. 主要关联的数据结构有栈，队列（BFS/DFS）， hash, 字符串等\n3. 求总数的时候可能会涉及排列组合的知识， \n4. 判断当前子树是否为BST, 不能仅仅靠当前节点的值大于左边最大和右边最小就可以，还需要左右两边都是BST（lc333-最大BST子树）\n\n\n","slug":"leetcode/二叉树","published":1,"updated":"2023-07-10T10:36:19.532Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clk5ceind0006jpjb2xdhbow5","content":"<ol>\n<li><p>验证二叉树的前序序列化<br> 观察规律题或者建树题<br> 我的思路是直接建立一颗二叉树，但是建立树代码可以不写；最后树是正确的就是中间不会访问到cur==size的情况，同时最后循环完之后不会再出现#或者数字<br> 官方题解是：通过槽位计数，如果遍历到最后槽位为0说明正确，如果中间槽位为0，说明出错<br> 因为加上一个#槽位数会–，如果加上一个数字那么槽位数会++（-1+2）<br> 注意这道题的易错点是: 字符串中包含’,’而且可能数字包含两个字符 98,7,#</p>\n</li>\n<li><p>二叉树的宽度： 宽度应该包含一层的节点之间夹杂的空字符，所以为了得到一层的宽度，应该在栈中压入每个节点的下标(左边：2 * pos, 右边：2 * pos+1)，而不是具体的二叉树ListNode</p>\n</li>\n<li><p>两个子节点的最近公共父节点</p>\n</li>\n</ol>\n<p>如果一个节点为target_one或者target_two那么直接返回当前节点，否则进行dfs, dfs返回的左右节点都是非NULL那么就返回当前节点</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\">ListNode* <span class=\"hljs-title\">lowestCommonAncestor</span><span class=\"hljs-params\">(ListNode* root, ListNode* node1, ListNode* node2)</span></span>&#123;<br>    <span class=\"hljs-keyword\">if</span>(root==<span class=\"hljs-literal\">NULL</span>||root==p||root==q) <span class=\"hljs-keyword\">return</span> root;<br>    <span class=\"hljs-keyword\">if</span>(root==node1||root==node2)&#123;<br>        <span class=\"hljs-keyword\">return</span> cur;<br>    &#125;<br>    <span class=\"hljs-keyword\">else</span>&#123;<br>        ListNode *left=<span class=\"hljs-built_in\">lowestCommonAncestor</span>(root-&gt;left, node1, node2);<br>        ListNode *right=<span class=\"hljs-built_in\">lowestCommonAncestor</span>(root-&gt;right, node1, node2);<br>        <span class=\"hljs-keyword\">if</span>(left&amp;&amp;right)&#123;<br>            <span class=\"hljs-keyword\">return</span> cur;<br>        &#125;<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(left)&#123;<br>            <span class=\"hljs-keyword\">return</span> left;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> right;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>从二叉树一个节点到另一个节点每一步的方向</li>\n</ol>\n<p>方法，通过dfs找到到达startValue和dstValue的具体路径，然后删除路径前面相同的部分，然后到达startValue剩余的size都加上U， 到达dstValue剩余的都加上dst剩余的路径</p>\n<ol start=\"5\">\n<li><p>寻找重复的树，<br> 解决方案：序列化+hash判断子树是否唯一，序列化只能使用# ，以及前序和后序遍历</p>\n<ul>\n<li>注意这道题需要记录空节点，同时，只能使用前序或者后序遍历 唯一判定两棵子树是否相同，而不能使用中序遍历。而且数据与数据应该用，隔开，因为222可以理解为2+2+2也可以理解为2+22 </li>\n<li> ==加上#的这种情况，只有后序遍历和前序遍历能够唯一确定一课子树。中序遍历不行==  </li>\n<li>同样这道题使用二叉树的序列化和反序列化, 因为前序和后序都可以知道根节点，但是中序不行</li>\n</ul>\n</li>\n<li><p>最长同值路径</p>\n<ul>\n<li>和二叉树的直径类似，不过这里需要判断值是否相等，多了一个条件</li>\n<li>为了区分left+right+1 left+1 right+1三种情况，可以使用一个left_mark 如果左边和root相等那么==left_val+1否则为0。那么最后的结果都是left_mark+right_mark+1， 解决了三种情况 返回max(left_mark, right_mark)+1</li>\n</ul>\n</li>\n<li><p>二叉树中所有距离为 K 的结点<br>先通过dfs找到每个节点的父节点，然后再对target节点进行dfs 左右和父节点 (或者bfs+vis)</p>\n</li>\n<li><p>二叉树寻路，使用数学方法<br> 1.先求每个数正常的父亲，然后再对不同的层进行修改<br> 2.在进行修改的时候抓住对称的点的和是相同的<br> 3.如果层数是偶数，那么只需要修改奇数层的值；如果层数是奇数，那么需要修改偶数层的数据</p>\n</li>\n<li><p>二叉树中两个节点间的距离<br>先求两个节点的最近公共祖先，然后从最近公共祖先出发，求祖先节点分别到两个节点的距离(使用dfs两次，target==p||q)，距离之和就是两个节点的最短路径<br>代码：<a href=\"https://www.jianshu.com/p/cec33f514f69\">https://www.jianshu.com/p/cec33f514f69</a></p>\n</li>\n</ol>\n<ol start=\"10\">\n<li>树的直径问题<br>任意选择一个节点为根，然后找到离他最远的节点a，然后找到离a最远的节点b，那么a-&gt;b就是最远的路径（数的直径）<br>如果是二叉树有指针的情况可以使用递归<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">int</span> result=<span class=\"hljs-number\">0</span>;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">maxDistance</span><span class=\"hljs-params\">(TreeNode* root)</span></span>&#123;<br>    <span class=\"hljs-keyword\">if</span>(root==<span class=\"hljs-literal\">NULL</span>)&#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">int</span> leftLength=<span class=\"hljs-built_in\">maxDistance</span>(root-&gt;left);<br>    <span class=\"hljs-keyword\">int</span> rightLenght=<span class=\"hljs-built_in\">maxDistance</span>(root-&gt;right);<br>    result=<span class=\"hljs-built_in\">max</span>(leftLength+rightLenght+<span class=\"hljs-number\">1</span>, result);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">max</span>(leftLength, rightLenght)+<span class=\"hljs-number\">1</span>;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">diameterOfBinaryTree</span><span class=\"hljs-params\">(TreeNode* root)</span> </span>&#123;<br>    <span class=\"hljs-built_in\">maxDistance</span>(root);<br>    <span class=\"hljs-keyword\">return</span> result<span class=\"hljs-number\">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n如果是无向图：<br>算法思想<br>①从任意一点P出发，通过DFS寻找离它最远的点Q。<br>②再次从点Q出发，通过DFS寻找离它最远的W。<br>③直径即为WQ。<br>证明：<a href=\"https://zhuanlan.zhihu.com/p/115966044\">https://zhuanlan.zhihu.com/p/115966044</a></li>\n</ol>\n<p>两次dfs</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">dfs</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> st)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;edge[st].<span class=\"hljs-built_in\">size</span>();i++)<br>    &#123;<br>        <span class=\"hljs-keyword\">int</span> to=edge[st][i];<br>        <span class=\"hljs-keyword\">if</span>(!vis[to])<br>        &#123;<br>            vis[to]=<span class=\"hljs-number\">1</span>;<br>            dis[to]=dis[st]+<span class=\"hljs-number\">1</span>;<span class=\"hljs-comment\">//注意，本代码计算的是无权树的直径，所以边权为1</span><br>            <span class=\"hljs-comment\">//如果是有权树，则这里的1要改为边权</span><br>            <span class=\"hljs-built_in\">dfs</span>(to);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>求最长就是求最大的dis，两次dfs中间需要重新初始化dis=0</p>\n<ol start=\"11\">\n<li>具有所有最深节点的最小子树</li>\n</ol>\n<p>在深度优先搜索的时候同时返回结果和计算深度，返回的是一个结构体 node{root, dist}.<br>1)获取当前节点的左右子树的最大深度<br>2)如果两边最大深度相同，则这个节点就是结果<br>3)不相等，那返回深度大的子树的root信息</p>\n<ol start=\"12\">\n<li><ol start=\"205\">\n<li>同构字符串/890. 查找和替换模式<br>查找和对应模式一致的字符串，abb模式。<br>使用双hash,也就是两边都没有映射，才建立映射，或者两边都有映射且未对方，那么continue,否则说明出处<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">if</span>(s2t.<span class=\"hljs-built_in\">find</span>(s[i])==s2t.<span class=\"hljs-built_in\">end</span>()&amp;&amp;t2s.<span class=\"hljs-built_in\">find</span>(t[i])==t2s.<span class=\"hljs-built_in\">end</span>())&#123;<br>    s2t[s[i]]=t[i];<br>    t2s[t[i]]=s[i];<br>&#125;<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(s2t[s[i]]=t[i]&amp;&amp;t2s[t[i]]==s[i])&#123;<br>    <span class=\"hljs-keyword\">continue</span>;<br>&#125;<span class=\"hljs-keyword\">else</span>&#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n</ol>\n</li>\n</ol>\n<ol start=\"12\">\n<li>前后序遍历中空间复杂度为O(1)的Morris Traval方法（主要是利用叶子节点的空指针进行映射到下一个节点）<br><a href=\"https://www.cnblogs.com/AnnieKim/archive/2013/06/15/MorrisTraversal.html\">https://www.cnblogs.com/AnnieKim/archive/2013/06/15/MorrisTraversal.html</a></li>\n</ol>\n<ul>\n<li><strong>前序遍历</strong><br>  根左右<ol>\n<li>如果当前节点的左孩子为空，那么输出当前节点，并将当前节点设置为当前节点的右孩子</li>\n<li>一个节点的左孩子不为空，那么在当前节点的左子树找到这个节点的前驱节点<br> 如果这个前驱节点的右孩子为空，那么设置右孩子为当前节点，==输出当前节点==（于中序的唯一不同），并当前节点更新为当前节点左孩子<br> 如果这个前驱节点的右孩子为当前节点，那么将右孩子重新设置为空。并更新当前节点为当前节点的右孩子。</li>\n</ol>\n</li>\n</ul>\n<ul>\n<li><strong>中序遍历</strong><br>  左根右<ol>\n<li>如果当前节点的左孩子为空，那么输出当前节点，并将当前节点设置为当前节点的右孩子</li>\n<li>一个节点的左孩子不为空，那么在当前节点的左子树找到这个节点的前驱节点<br> 如果这个前驱节点的右孩子为空，那么设置右孩子为当前节点，并当前节点更新为当前节点左孩子<br> 如果这个前驱节点的右孩子为当前节点，那么将右孩子重新设置为空。<strong>输出当前节点</strong>， 并更新当前节点为当前节点的右孩子<br> 与前序遍历相比一个是回来之后再输出(else)，一个是建立前驱到根节点关系后输出（if）</li>\n</ol>\n</li>\n</ul>\n<ul>\n<li><strong>后序遍历</strong><br>  <strong>需要建立一个临时节点dump</strong>，使该节点的左子树等于root<ol>\n<li>如果当前节点的左孩子为空，那么则将其右孩子作为当前节点</li>\n<li>一个节点的左孩子不为空，那么在当前节点的左子树找到这个节点的前驱节点<br>如果这个前驱节点的右孩子为空，那么设置右孩子为当前节点, 并当前节点更新为当前节点左孩子<br>如果这个前驱节点的右孩子为当前节点，那么还原前驱右孩子为null, ==同时逆序输出从当前节点左孩子到前驱节点的路==，并更新当前节点为右孩子</li>\n</ol>\n</li>\n</ul>\n<p>总结：建立关系后，到左孩子；为空或者一圈回来后到右孩子<br>    一圈回来后，还原关系</p>\n<ol start=\"13\">\n<li> 将子数组重新排序得到同一个二叉查找树的方案数<br>题意，交换插入序列，但是得到的二叉搜索树最后的结果相同的序列共有多少个<br>解决：抓住，先插左还是右的顺序是可以变的，但是在插入单边的时候，根节点的插入顺序是不可以变的</li>\n</ol>\n<ul>\n<li>排列组合+dfs</li>\n<li>求排列组合的时候，其实用动态规划的思想 C(n,k)=C(n-1, k-1)+C(n-1,k)</li>\n<li>node-&gt;ans = (long long)c[lsize + rsize][lsize] % mod * lans % mod * rans % mod;</li>\n<li>在使用dfs的时候，使用一个全局的res变量，每次乘以（all, less)的组合结果；划分less, greater的时候，可以用一个新的vector来记录左右子树的节点</li>\n<li>也可以先建立一棵树，使用递归左右指针的方式，树的信息需要包含size ,ans等一些信息<br>另一种出题的方式：<br>  一个数组入栈顺序定了，有多少种出栈的顺序<br>  f(n)=f(1)* f(n-1) + f(2) * f(n-2)+…..f(n-1) f(1);<br>  递推公式的解为：h(n)=c(2n,n)-c(2n,n+1)(n=1,2,3,…)</li>\n</ul>\n<ol start=\"14\">\n<li>二叉搜索树删除一个节点<br>递归删除<br>易错点：<ol>\n<li>可以根据二叉搜索树的性质，选择向左右递归 </li>\n<li>找到该节点，如果是叶节点直接删除，如果只有左右子树，也可以直接返回左右子树，否则找到左边最小，然后赋值到当前值，然后递归删除</li>\n<li>注意递归删除的的时候，一定要注意返回值，一定要赋值给当前节点的左指针或者右指针; 否则会造成树在中间断裂</li>\n</ol>\n</li>\n</ol>\n<ol start=\"15\">\n<li>lc987. 二叉树的垂序遍历</li>\n</ol>\n<ul>\n<li>dfs 遍历nodes 记录下每个节点的行号row，列号 col 以及值 value。<br>在遍历完成后，我们按照 col 为第一关键字升序，row 为第二关键字升序，value 为第三关键字升序，对所有的节点进行排序即可。 遍历时将同一col的放到同一vector中</li>\n<li>也可以使用map&lt;int, vector<node>&gt; 这样的话就不用手动分每一个col</node></li>\n</ul>\n<p><font color=\"red\">16. lc979. 在二叉树中分配硬币</font></p>\n<ul>\n<li>第一种方法：可以考虑后序遍历理解；需要从父节点得到或者获取 root-&gt;val-1个节点，<br>ans+=abs(root-&gt;val-1); return root-&gt;val-1//返回可能是负数</li>\n<li>第二种方法：转为在子树中分配硬币<br>dfs(root)表示root这棵子树冗余的节点数<br>root-&gt;val+dfs(root-&gt;left)+dfs(root-&gt;right)-1;<br>ans+=abs(dfs(root-&gt;left))+abs(dfs(root-&gt;right));</li>\n</ul>\n<ol start=\"16\">\n<li> lc99. 恢复二叉搜索树</li>\n</ol>\n<ul>\n<li>二叉树出现位置交换会出现两种情况<br>两次逆序：记录前面x和后面y， 第二次更新y<br>一次逆序：记录前面x和后面y</li>\n<li>时间O(n),空间O(1)</li>\n</ul>\n<ol start=\"17\">\n<li> Find Leaves of Binary Tree 找二叉树的叶节点</li>\n</ol>\n<ul>\n<li>题意：类似剥洋葱一样，将二叉树从最外到最内</li>\n<li>重新定义二叉树的深度为最优深度最大值加一，然后res[depth].push_back(root-&gt;val)<br>if (depth &gt;= res.size()) res.resize(depth + 1);//因为最开始不知道最大的深度，因此不知道如何初始化，所以在最深一层初始化大小</li>\n</ul>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>ok ok</p>\n<ol>\n<li>主要考察前中后序遍历， 子树（序列化+hash）, 直径(自底向上判断，左右返回最大一个，同时更新结果为根)， 宽度（BFS）， 二叉树的左右节点（index*2, index *2）, 二叉搜索树相关（删除节点）， 自顶向下和自底向上递归</li>\n<li>主要关联的数据结构有栈，队列（BFS/DFS）， hash, 字符串等</li>\n<li>求总数的时候可能会涉及排列组合的知识， </li>\n<li>判断当前子树是否为BST, 不能仅仅靠当前节点的值大于左边最大和右边最小就可以，还需要左右两边都是BST（lc333-最大BST子树）</li>\n</ol>\n","site":{"data":{}},"wordcount":5218,"excerpt":"","more":"<ol>\n<li><p>验证二叉树的前序序列化<br> 观察规律题或者建树题<br> 我的思路是直接建立一颗二叉树，但是建立树代码可以不写；最后树是正确的就是中间不会访问到cur==size的情况，同时最后循环完之后不会再出现#或者数字<br> 官方题解是：通过槽位计数，如果遍历到最后槽位为0说明正确，如果中间槽位为0，说明出错<br> 因为加上一个#槽位数会–，如果加上一个数字那么槽位数会++（-1+2）<br> 注意这道题的易错点是: 字符串中包含’,’而且可能数字包含两个字符 98,7,#</p>\n</li>\n<li><p>二叉树的宽度： 宽度应该包含一层的节点之间夹杂的空字符，所以为了得到一层的宽度，应该在栈中压入每个节点的下标(左边：2 * pos, 右边：2 * pos+1)，而不是具体的二叉树ListNode</p>\n</li>\n<li><p>两个子节点的最近公共父节点</p>\n</li>\n</ol>\n<p>如果一个节点为target_one或者target_two那么直接返回当前节点，否则进行dfs, dfs返回的左右节点都是非NULL那么就返回当前节点</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\">ListNode* <span class=\"hljs-title\">lowestCommonAncestor</span><span class=\"hljs-params\">(ListNode* root, ListNode* node1, ListNode* node2)</span></span>&#123;<br>    <span class=\"hljs-keyword\">if</span>(root==<span class=\"hljs-literal\">NULL</span>||root==p||root==q) <span class=\"hljs-keyword\">return</span> root;<br>    <span class=\"hljs-keyword\">if</span>(root==node1||root==node2)&#123;<br>        <span class=\"hljs-keyword\">return</span> cur;<br>    &#125;<br>    <span class=\"hljs-keyword\">else</span>&#123;<br>        ListNode *left=<span class=\"hljs-built_in\">lowestCommonAncestor</span>(root-&gt;left, node1, node2);<br>        ListNode *right=<span class=\"hljs-built_in\">lowestCommonAncestor</span>(root-&gt;right, node1, node2);<br>        <span class=\"hljs-keyword\">if</span>(left&amp;&amp;right)&#123;<br>            <span class=\"hljs-keyword\">return</span> cur;<br>        &#125;<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(left)&#123;<br>            <span class=\"hljs-keyword\">return</span> left;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> right;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>从二叉树一个节点到另一个节点每一步的方向</li>\n</ol>\n<p>方法，通过dfs找到到达startValue和dstValue的具体路径，然后删除路径前面相同的部分，然后到达startValue剩余的size都加上U， 到达dstValue剩余的都加上dst剩余的路径</p>\n<ol start=\"5\">\n<li><p>寻找重复的树，<br> 解决方案：序列化+hash判断子树是否唯一，序列化只能使用# ，以及前序和后序遍历</p>\n<ul>\n<li>注意这道题需要记录空节点，同时，只能使用前序或者后序遍历 唯一判定两棵子树是否相同，而不能使用中序遍历。而且数据与数据应该用，隔开，因为222可以理解为2+2+2也可以理解为2+22 </li>\n<li> ==加上#的这种情况，只有后序遍历和前序遍历能够唯一确定一课子树。中序遍历不行==  </li>\n<li>同样这道题使用二叉树的序列化和反序列化, 因为前序和后序都可以知道根节点，但是中序不行</li>\n</ul>\n</li>\n<li><p>最长同值路径</p>\n<ul>\n<li>和二叉树的直径类似，不过这里需要判断值是否相等，多了一个条件</li>\n<li>为了区分left+right+1 left+1 right+1三种情况，可以使用一个left_mark 如果左边和root相等那么==left_val+1否则为0。那么最后的结果都是left_mark+right_mark+1， 解决了三种情况 返回max(left_mark, right_mark)+1</li>\n</ul>\n</li>\n<li><p>二叉树中所有距离为 K 的结点<br>先通过dfs找到每个节点的父节点，然后再对target节点进行dfs 左右和父节点 (或者bfs+vis)</p>\n</li>\n<li><p>二叉树寻路，使用数学方法<br> 1.先求每个数正常的父亲，然后再对不同的层进行修改<br> 2.在进行修改的时候抓住对称的点的和是相同的<br> 3.如果层数是偶数，那么只需要修改奇数层的值；如果层数是奇数，那么需要修改偶数层的数据</p>\n</li>\n<li><p>二叉树中两个节点间的距离<br>先求两个节点的最近公共祖先，然后从最近公共祖先出发，求祖先节点分别到两个节点的距离(使用dfs两次，target==p||q)，距离之和就是两个节点的最短路径<br>代码：<a href=\"https://www.jianshu.com/p/cec33f514f69\">https://www.jianshu.com/p/cec33f514f69</a></p>\n</li>\n</ol>\n<ol start=\"10\">\n<li>树的直径问题<br>任意选择一个节点为根，然后找到离他最远的节点a，然后找到离a最远的节点b，那么a-&gt;b就是最远的路径（数的直径）<br>如果是二叉树有指针的情况可以使用递归<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">int</span> result=<span class=\"hljs-number\">0</span>;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">maxDistance</span><span class=\"hljs-params\">(TreeNode* root)</span></span>&#123;<br>    <span class=\"hljs-keyword\">if</span>(root==<span class=\"hljs-literal\">NULL</span>)&#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">int</span> leftLength=<span class=\"hljs-built_in\">maxDistance</span>(root-&gt;left);<br>    <span class=\"hljs-keyword\">int</span> rightLenght=<span class=\"hljs-built_in\">maxDistance</span>(root-&gt;right);<br>    result=<span class=\"hljs-built_in\">max</span>(leftLength+rightLenght+<span class=\"hljs-number\">1</span>, result);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">max</span>(leftLength, rightLenght)+<span class=\"hljs-number\">1</span>;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">diameterOfBinaryTree</span><span class=\"hljs-params\">(TreeNode* root)</span> </span>&#123;<br>    <span class=\"hljs-built_in\">maxDistance</span>(root);<br>    <span class=\"hljs-keyword\">return</span> result<span class=\"hljs-number\">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n如果是无向图：<br>算法思想<br>①从任意一点P出发，通过DFS寻找离它最远的点Q。<br>②再次从点Q出发，通过DFS寻找离它最远的W。<br>③直径即为WQ。<br>证明：<a href=\"https://zhuanlan.zhihu.com/p/115966044\">https://zhuanlan.zhihu.com/p/115966044</a></li>\n</ol>\n<p>两次dfs</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">dfs</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> st)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;edge[st].<span class=\"hljs-built_in\">size</span>();i++)<br>    &#123;<br>        <span class=\"hljs-keyword\">int</span> to=edge[st][i];<br>        <span class=\"hljs-keyword\">if</span>(!vis[to])<br>        &#123;<br>            vis[to]=<span class=\"hljs-number\">1</span>;<br>            dis[to]=dis[st]+<span class=\"hljs-number\">1</span>;<span class=\"hljs-comment\">//注意，本代码计算的是无权树的直径，所以边权为1</span><br>            <span class=\"hljs-comment\">//如果是有权树，则这里的1要改为边权</span><br>            <span class=\"hljs-built_in\">dfs</span>(to);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>求最长就是求最大的dis，两次dfs中间需要重新初始化dis=0</p>\n<ol start=\"11\">\n<li>具有所有最深节点的最小子树</li>\n</ol>\n<p>在深度优先搜索的时候同时返回结果和计算深度，返回的是一个结构体 node{root, dist}.<br>1)获取当前节点的左右子树的最大深度<br>2)如果两边最大深度相同，则这个节点就是结果<br>3)不相等，那返回深度大的子树的root信息</p>\n<ol start=\"12\">\n<li><ol start=\"205\">\n<li>同构字符串/890. 查找和替换模式<br>查找和对应模式一致的字符串，abb模式。<br>使用双hash,也就是两边都没有映射，才建立映射，或者两边都有映射且未对方，那么continue,否则说明出处<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">if</span>(s2t.<span class=\"hljs-built_in\">find</span>(s[i])==s2t.<span class=\"hljs-built_in\">end</span>()&amp;&amp;t2s.<span class=\"hljs-built_in\">find</span>(t[i])==t2s.<span class=\"hljs-built_in\">end</span>())&#123;<br>    s2t[s[i]]=t[i];<br>    t2s[t[i]]=s[i];<br>&#125;<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(s2t[s[i]]=t[i]&amp;&amp;t2s[t[i]]==s[i])&#123;<br>    <span class=\"hljs-keyword\">continue</span>;<br>&#125;<span class=\"hljs-keyword\">else</span>&#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n</ol>\n</li>\n</ol>\n<ol start=\"12\">\n<li>前后序遍历中空间复杂度为O(1)的Morris Traval方法（主要是利用叶子节点的空指针进行映射到下一个节点）<br><a href=\"https://www.cnblogs.com/AnnieKim/archive/2013/06/15/MorrisTraversal.html\">https://www.cnblogs.com/AnnieKim/archive/2013/06/15/MorrisTraversal.html</a></li>\n</ol>\n<ul>\n<li><strong>前序遍历</strong><br>  根左右<ol>\n<li>如果当前节点的左孩子为空，那么输出当前节点，并将当前节点设置为当前节点的右孩子</li>\n<li>一个节点的左孩子不为空，那么在当前节点的左子树找到这个节点的前驱节点<br> 如果这个前驱节点的右孩子为空，那么设置右孩子为当前节点，==输出当前节点==（于中序的唯一不同），并当前节点更新为当前节点左孩子<br> 如果这个前驱节点的右孩子为当前节点，那么将右孩子重新设置为空。并更新当前节点为当前节点的右孩子。</li>\n</ol>\n</li>\n</ul>\n<ul>\n<li><strong>中序遍历</strong><br>  左根右<ol>\n<li>如果当前节点的左孩子为空，那么输出当前节点，并将当前节点设置为当前节点的右孩子</li>\n<li>一个节点的左孩子不为空，那么在当前节点的左子树找到这个节点的前驱节点<br> 如果这个前驱节点的右孩子为空，那么设置右孩子为当前节点，并当前节点更新为当前节点左孩子<br> 如果这个前驱节点的右孩子为当前节点，那么将右孩子重新设置为空。<strong>输出当前节点</strong>， 并更新当前节点为当前节点的右孩子<br> 与前序遍历相比一个是回来之后再输出(else)，一个是建立前驱到根节点关系后输出（if）</li>\n</ol>\n</li>\n</ul>\n<ul>\n<li><strong>后序遍历</strong><br>  <strong>需要建立一个临时节点dump</strong>，使该节点的左子树等于root<ol>\n<li>如果当前节点的左孩子为空，那么则将其右孩子作为当前节点</li>\n<li>一个节点的左孩子不为空，那么在当前节点的左子树找到这个节点的前驱节点<br>如果这个前驱节点的右孩子为空，那么设置右孩子为当前节点, 并当前节点更新为当前节点左孩子<br>如果这个前驱节点的右孩子为当前节点，那么还原前驱右孩子为null, ==同时逆序输出从当前节点左孩子到前驱节点的路==，并更新当前节点为右孩子</li>\n</ol>\n</li>\n</ul>\n<p>总结：建立关系后，到左孩子；为空或者一圈回来后到右孩子<br>    一圈回来后，还原关系</p>\n<ol start=\"13\">\n<li> 将子数组重新排序得到同一个二叉查找树的方案数<br>题意，交换插入序列，但是得到的二叉搜索树最后的结果相同的序列共有多少个<br>解决：抓住，先插左还是右的顺序是可以变的，但是在插入单边的时候，根节点的插入顺序是不可以变的</li>\n</ol>\n<ul>\n<li>排列组合+dfs</li>\n<li>求排列组合的时候，其实用动态规划的思想 C(n,k)=C(n-1, k-1)+C(n-1,k)</li>\n<li>node-&gt;ans = (long long)c[lsize + rsize][lsize] % mod * lans % mod * rans % mod;</li>\n<li>在使用dfs的时候，使用一个全局的res变量，每次乘以（all, less)的组合结果；划分less, greater的时候，可以用一个新的vector来记录左右子树的节点</li>\n<li>也可以先建立一棵树，使用递归左右指针的方式，树的信息需要包含size ,ans等一些信息<br>另一种出题的方式：<br>  一个数组入栈顺序定了，有多少种出栈的顺序<br>  f(n)=f(1)* f(n-1) + f(2) * f(n-2)+…..f(n-1) f(1);<br>  递推公式的解为：h(n)=c(2n,n)-c(2n,n+1)(n=1,2,3,…)</li>\n</ul>\n<ol start=\"14\">\n<li>二叉搜索树删除一个节点<br>递归删除<br>易错点：<ol>\n<li>可以根据二叉搜索树的性质，选择向左右递归 </li>\n<li>找到该节点，如果是叶节点直接删除，如果只有左右子树，也可以直接返回左右子树，否则找到左边最小，然后赋值到当前值，然后递归删除</li>\n<li>注意递归删除的的时候，一定要注意返回值，一定要赋值给当前节点的左指针或者右指针; 否则会造成树在中间断裂</li>\n</ol>\n</li>\n</ol>\n<ol start=\"15\">\n<li>lc987. 二叉树的垂序遍历</li>\n</ol>\n<ul>\n<li>dfs 遍历nodes 记录下每个节点的行号row，列号 col 以及值 value。<br>在遍历完成后，我们按照 col 为第一关键字升序，row 为第二关键字升序，value 为第三关键字升序，对所有的节点进行排序即可。 遍历时将同一col的放到同一vector中</li>\n<li>也可以使用map&lt;int, vector<node>&gt; 这样的话就不用手动分每一个col</node></li>\n</ul>\n<p><font color=\"red\">16. lc979. 在二叉树中分配硬币</font></p>\n<ul>\n<li>第一种方法：可以考虑后序遍历理解；需要从父节点得到或者获取 root-&gt;val-1个节点，<br>ans+=abs(root-&gt;val-1); return root-&gt;val-1//返回可能是负数</li>\n<li>第二种方法：转为在子树中分配硬币<br>dfs(root)表示root这棵子树冗余的节点数<br>root-&gt;val+dfs(root-&gt;left)+dfs(root-&gt;right)-1;<br>ans+=abs(dfs(root-&gt;left))+abs(dfs(root-&gt;right));</li>\n</ul>\n<ol start=\"16\">\n<li> lc99. 恢复二叉搜索树</li>\n</ol>\n<ul>\n<li>二叉树出现位置交换会出现两种情况<br>两次逆序：记录前面x和后面y， 第二次更新y<br>一次逆序：记录前面x和后面y</li>\n<li>时间O(n),空间O(1)</li>\n</ul>\n<ol start=\"17\">\n<li> Find Leaves of Binary Tree 找二叉树的叶节点</li>\n</ol>\n<ul>\n<li>题意：类似剥洋葱一样，将二叉树从最外到最内</li>\n<li>重新定义二叉树的深度为最优深度最大值加一，然后res[depth].push_back(root-&gt;val)<br>if (depth &gt;= res.size()) res.resize(depth + 1);//因为最开始不知道最大的深度，因此不知道如何初始化，所以在最深一层初始化大小</li>\n</ul>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>ok ok</p>\n<ol>\n<li>主要考察前中后序遍历， 子树（序列化+hash）, 直径(自底向上判断，左右返回最大一个，同时更新结果为根)， 宽度（BFS）， 二叉树的左右节点（index*2, index *2）, 二叉搜索树相关（删除节点）， 自顶向下和自底向上递归</li>\n<li>主要关联的数据结构有栈，队列（BFS/DFS）， hash, 字符串等</li>\n<li>求总数的时候可能会涉及排列组合的知识， </li>\n<li>判断当前子树是否为BST, 不能仅仅靠当前节点的值大于左边最大和右边最小就可以，还需要左右两边都是BST（lc333-最大BST子树）</li>\n</ol>\n"},{"title":"位运算","catogory":["leetcode 题目汇总"],"date":"2021-11-13T09:22:58.000Z","_content":"#### 总结\n注意位运算的优先级问题：使用位运算一定要多打括号\n```C++\n// 错误写法\nif (a & b == 0) {\n    ...;\n}\n\n// 正确写法\nif ((a & b) == 0) {\n    ...;\n}\n```\n\n\na + (b&c) 不管是+/-/*/ 还是==， 只要和位运算在一起，位运算都应该大括号！！！！\n\n\n#### 例题\n1. 使用位运算来判断a b的大小（注意出现溢出的情况）\n位运算可以用来判断a b的正负，以及a-b的正负，因此分情况讨论a b的符号是否相等，如果相等，a-c大于0返回a;如果不等，a的符号大于0返回a\n其余情况(flip(return A))返回B\n```C++\nint flip(int a){\n    return a^1;\n}\n```\n\n2. 用位运算实现加减法：注意不用区分正负\n左移，正负数都是右边添加0（也就是负数左移，是会移走最左边的符号位）\n右移若干位，正数左补0，负数左补1\n```C++\nint add(a, b){\n    int sum=a;\n    while(b!=0){\n        sum=a^b;\n        b= (unsigned int)(a&b)<<1; //unsigned int非常重要\n        a=sum;\n    }\n}\n\nint neg(int a){\n    return add(~a, 1);\n}\nint sub(int a, int b){\n    return add(a, neg(b));\n}\n\n用位运算实现乘除法：\n\nint multi(int a, int b){\n    int res=0;\n    while(b!=0){\n        if((b&1)!=0){\n             res=add(res, a);\n        }\n        a=a<<1;\n        b=b>>1;\n    }\n}\n\n//注意div考虑如果是负数是INT_MIN如何处理，不能直接转为整数\n\nint sign(int a){\n    return a<0;\n}\n\nint div(int a, int b){\n    int res=0;\n    int x=sign(a)? neg(a):a;\n    int y=sign(b)? neg(a):a;  //转为整数进行运算\n    for(int i=31;i>=0;sub(i, 1)){\n        if((x>>i)>=y){ //注意这里不是y<<i  因为可能出现溢出\n            res|= （1<<i）;\n            x = sub(x, y<<i);\n        }\n    }\n\n    return sign(a)^sign(b)? neg(res): res;\n}\n\nint divide(int a, int b){\n    if(b==0){\n        return error;\n    }else if(a==INT_MIN&&b==INT_MIN){\n        return 1;\n    }else if(b==INT_MIN||a==0){\n        return 0;\n    }else if(a==INT_MIN){\n        int tmp=div(add(a, 1),b);\n        int rest=div(sub(a, mul(tmp, b)), b);\n        return add(tmp, rest); //相当于分成两个部分计算\n    }else{\n        return div(a, b);\n    }\n}\n\n```\n3. 一些位运算技巧\n  - 移除最右边的1\n ```n = n&(n-1)```\n\n   - 得到最右边的1 \n ```n & (~n + 1)```\n\n   - 用位运算计算一个二进制数的1个数\n```C++\n    int res=0;\n    while(n!=0){\n        n=n&(n-1);//不断消掉右边的1，但是问题是当n=-INT_MIN n-1不会溢出么，那么如何计算最左边的1呢\n        res+=1;\n    }\n```\n4. 使用位运算实现八皇后\n\n5. 绘制直线，bit计算对应的int数组的下标(求得每个像素点对应的数的位数)\n\n6. 两整数之和，不使用+实现两个整数之和 使用异或以及与运算，一定要注意 carry要使用unsigned int 使用int会报错\n(unsigned int) carry=(unsigned int) (a&b)<<1\n\n<font color=red>7. 数组中两个数的最大异或值</font>\n- 方法一：31位的每一位只有两种情况，因此可以猜测执行\n    对异或结果的每一位(32位，从31-0)从大到小进行猜测可以取到的数1或者0 运用了a^b=x 那么x^a=b,也就是查看猜测的这个数和集合里面的进行异或是否能够在集合里面找到另外一个数 （31*n的时间复杂度仍然是O(n)）\n- 方法二：使用字典树，然后遍历每个数，得到针对这个数可以取到的异或最大值i，然后取最大；（这里的trie树是一颗二叉树）\n\n8. lc201. 数字范围按位与\n- 转为求左右的公共前缀\n\n\n\n### 总结\nok ok\n1. 位运算优先级注意, 同时一定要注意INT_MAX或者INT_MIN可能会导致左移/右移 /-1溢出\n2. 位运算实现加减乘除\n3. 在有的题目中取最右边的1的时候使用x^(~x+1)可能出现溢出，因此使用tmp=1; while((tmp&xore)==0) tmp=(tmp<<1); 找最右边的1（lc260. 只出现一次的数字 III）\n\n\n\n\n\n","source":"_posts/leetcode/位运算.md","raw":"---\ntitle: 位运算\ncatogory:\n  - leetcode 题目汇总\ncategories:\n  - leetcode\ndate: 2021-11-13 17:22:58\ntags:\n---\n#### 总结\n注意位运算的优先级问题：使用位运算一定要多打括号\n```C++\n// 错误写法\nif (a & b == 0) {\n    ...;\n}\n\n// 正确写法\nif ((a & b) == 0) {\n    ...;\n}\n```\n\n\na + (b&c) 不管是+/-/*/ 还是==， 只要和位运算在一起，位运算都应该大括号！！！！\n\n\n#### 例题\n1. 使用位运算来判断a b的大小（注意出现溢出的情况）\n位运算可以用来判断a b的正负，以及a-b的正负，因此分情况讨论a b的符号是否相等，如果相等，a-c大于0返回a;如果不等，a的符号大于0返回a\n其余情况(flip(return A))返回B\n```C++\nint flip(int a){\n    return a^1;\n}\n```\n\n2. 用位运算实现加减法：注意不用区分正负\n左移，正负数都是右边添加0（也就是负数左移，是会移走最左边的符号位）\n右移若干位，正数左补0，负数左补1\n```C++\nint add(a, b){\n    int sum=a;\n    while(b!=0){\n        sum=a^b;\n        b= (unsigned int)(a&b)<<1; //unsigned int非常重要\n        a=sum;\n    }\n}\n\nint neg(int a){\n    return add(~a, 1);\n}\nint sub(int a, int b){\n    return add(a, neg(b));\n}\n\n用位运算实现乘除法：\n\nint multi(int a, int b){\n    int res=0;\n    while(b!=0){\n        if((b&1)!=0){\n             res=add(res, a);\n        }\n        a=a<<1;\n        b=b>>1;\n    }\n}\n\n//注意div考虑如果是负数是INT_MIN如何处理，不能直接转为整数\n\nint sign(int a){\n    return a<0;\n}\n\nint div(int a, int b){\n    int res=0;\n    int x=sign(a)? neg(a):a;\n    int y=sign(b)? neg(a):a;  //转为整数进行运算\n    for(int i=31;i>=0;sub(i, 1)){\n        if((x>>i)>=y){ //注意这里不是y<<i  因为可能出现溢出\n            res|= （1<<i）;\n            x = sub(x, y<<i);\n        }\n    }\n\n    return sign(a)^sign(b)? neg(res): res;\n}\n\nint divide(int a, int b){\n    if(b==0){\n        return error;\n    }else if(a==INT_MIN&&b==INT_MIN){\n        return 1;\n    }else if(b==INT_MIN||a==0){\n        return 0;\n    }else if(a==INT_MIN){\n        int tmp=div(add(a, 1),b);\n        int rest=div(sub(a, mul(tmp, b)), b);\n        return add(tmp, rest); //相当于分成两个部分计算\n    }else{\n        return div(a, b);\n    }\n}\n\n```\n3. 一些位运算技巧\n  - 移除最右边的1\n ```n = n&(n-1)```\n\n   - 得到最右边的1 \n ```n & (~n + 1)```\n\n   - 用位运算计算一个二进制数的1个数\n```C++\n    int res=0;\n    while(n!=0){\n        n=n&(n-1);//不断消掉右边的1，但是问题是当n=-INT_MIN n-1不会溢出么，那么如何计算最左边的1呢\n        res+=1;\n    }\n```\n4. 使用位运算实现八皇后\n\n5. 绘制直线，bit计算对应的int数组的下标(求得每个像素点对应的数的位数)\n\n6. 两整数之和，不使用+实现两个整数之和 使用异或以及与运算，一定要注意 carry要使用unsigned int 使用int会报错\n(unsigned int) carry=(unsigned int) (a&b)<<1\n\n<font color=red>7. 数组中两个数的最大异或值</font>\n- 方法一：31位的每一位只有两种情况，因此可以猜测执行\n    对异或结果的每一位(32位，从31-0)从大到小进行猜测可以取到的数1或者0 运用了a^b=x 那么x^a=b,也就是查看猜测的这个数和集合里面的进行异或是否能够在集合里面找到另外一个数 （31*n的时间复杂度仍然是O(n)）\n- 方法二：使用字典树，然后遍历每个数，得到针对这个数可以取到的异或最大值i，然后取最大；（这里的trie树是一颗二叉树）\n\n8. lc201. 数字范围按位与\n- 转为求左右的公共前缀\n\n\n\n### 总结\nok ok\n1. 位运算优先级注意, 同时一定要注意INT_MAX或者INT_MIN可能会导致左移/右移 /-1溢出\n2. 位运算实现加减乘除\n3. 在有的题目中取最右边的1的时候使用x^(~x+1)可能出现溢出，因此使用tmp=1; while((tmp&xore)==0) tmp=(tmp<<1); 找最右边的1（lc260. 只出现一次的数字 III）\n\n\n\n\n\n","slug":"leetcode/位运算","published":1,"updated":"2022-04-05T12:04:57.160Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clk5ceine0009jpjbh97y1n9t","content":"<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>注意位运算的优先级问题：使用位运算一定要多打括号</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-comment\">// 错误写法</span><br><span class=\"hljs-keyword\">if</span> (a &amp; b == <span class=\"hljs-number\">0</span>) &#123;<br>    ...;<br>&#125;<br><br><span class=\"hljs-comment\">// 正确写法</span><br><span class=\"hljs-keyword\">if</span> ((a &amp; b) == <span class=\"hljs-number\">0</span>) &#123;<br>    ...;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n<p>a + (b&amp;c) 不管是+/-/*/ 还是==， 只要和位运算在一起，位运算都应该大括号！！！！</p>\n<h4 id=\"例题\"><a href=\"#例题\" class=\"headerlink\" title=\"例题\"></a>例题</h4><ol>\n<li><p>使用位运算来判断a b的大小（注意出现溢出的情况）<br>位运算可以用来判断a b的正负，以及a-b的正负，因此分情况讨论a b的符号是否相等，如果相等，a-c大于0返回a;如果不等，a的符号大于0返回a<br>其余情况(flip(return A))返回B</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">flip</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> a)</span></span>&#123;<br>    <span class=\"hljs-keyword\">return</span> a^<span class=\"hljs-number\">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li><p>用位运算实现加减法：注意不用区分正负<br>左移，正负数都是右边添加0（也就是负数左移，是会移走最左边的符号位）<br>右移若干位，正数左补0，负数左补1</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">add</span><span class=\"hljs-params\">(a, b)</span></span>&#123;<br>    <span class=\"hljs-keyword\">int</span> sum=a;<br>    <span class=\"hljs-keyword\">while</span>(b!=<span class=\"hljs-number\">0</span>)&#123;<br>        sum=a^b;<br>        b= (<span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span>)(a&amp;b)&lt;&lt;<span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">//unsigned int非常重要</span><br>        a=sum;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">neg</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> a)</span></span>&#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">add</span>(~a, <span class=\"hljs-number\">1</span>);<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">sub</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> a, <span class=\"hljs-keyword\">int</span> b)</span></span>&#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">add</span>(a, <span class=\"hljs-built_in\">neg</span>(b));<br>&#125;<br><br>用位运算实现乘除法：<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">multi</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> a, <span class=\"hljs-keyword\">int</span> b)</span></span>&#123;<br>    <span class=\"hljs-keyword\">int</span> res=<span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">while</span>(b!=<span class=\"hljs-number\">0</span>)&#123;<br>        <span class=\"hljs-keyword\">if</span>((b&amp;<span class=\"hljs-number\">1</span>)!=<span class=\"hljs-number\">0</span>)&#123;<br>             res=<span class=\"hljs-built_in\">add</span>(res, a);<br>        &#125;<br>        a=a&lt;&lt;<span class=\"hljs-number\">1</span>;<br>        b=b&gt;&gt;<span class=\"hljs-number\">1</span>;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">//注意div考虑如果是负数是INT_MIN如何处理，不能直接转为整数</span><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">sign</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> a)</span></span>&#123;<br>    <span class=\"hljs-keyword\">return</span> a&lt;<span class=\"hljs-number\">0</span>;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">div</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> a, <span class=\"hljs-keyword\">int</span> b)</span></span>&#123;<br>    <span class=\"hljs-keyword\">int</span> res=<span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">int</span> x=<span class=\"hljs-built_in\">sign</span>(a)? <span class=\"hljs-built_in\">neg</span>(a):a;<br>    <span class=\"hljs-keyword\">int</span> y=<span class=\"hljs-built_in\">sign</span>(b)? <span class=\"hljs-built_in\">neg</span>(a):a;  <span class=\"hljs-comment\">//转为整数进行运算</span><br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">31</span>;i&gt;=<span class=\"hljs-number\">0</span>;<span class=\"hljs-built_in\">sub</span>(i, <span class=\"hljs-number\">1</span>))&#123;<br>        <span class=\"hljs-keyword\">if</span>((x&gt;&gt;i)&gt;=y)&#123; <span class=\"hljs-comment\">//注意这里不是y&lt;&lt;i  因为可能出现溢出</span><br>            res|= （<span class=\"hljs-number\">1</span>&lt;&lt;i）;<br>            x = <span class=\"hljs-built_in\">sub</span>(x, y&lt;&lt;i);<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">sign</span>(a)^<span class=\"hljs-built_in\">sign</span>(b)? <span class=\"hljs-built_in\">neg</span>(res): res;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">divide</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> a, <span class=\"hljs-keyword\">int</span> b)</span></span>&#123;<br>    <span class=\"hljs-keyword\">if</span>(b==<span class=\"hljs-number\">0</span>)&#123;<br>        <span class=\"hljs-keyword\">return</span> error;<br>    &#125;<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(a==INT_MIN&amp;&amp;b==INT_MIN)&#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br>    &#125;<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(b==INT_MIN||a==<span class=\"hljs-number\">0</span>)&#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>    &#125;<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(a==INT_MIN)&#123;<br>        <span class=\"hljs-keyword\">int</span> tmp=<span class=\"hljs-built_in\">div</span>(<span class=\"hljs-built_in\">add</span>(a, <span class=\"hljs-number\">1</span>),b);<br>        <span class=\"hljs-keyword\">int</span> rest=<span class=\"hljs-built_in\">div</span>(<span class=\"hljs-built_in\">sub</span>(a, <span class=\"hljs-built_in\">mul</span>(tmp, b)), b);<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">add</span>(tmp, rest); <span class=\"hljs-comment\">//相当于分成两个部分计算</span><br>    &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">div</span>(a, b);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li>\n<li><p>一些位运算技巧</p>\n</li>\n</ol>\n<ul>\n<li><p>移除最右边的1<br><code>n = n&amp;(n-1)</code></p>\n</li>\n<li><p>得到最右边的1<br><code>n &amp; (~n + 1)</code></p>\n</li>\n<li><p>用位运算计算一个二进制数的1个数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">int</span> res=<span class=\"hljs-number\">0</span>;<br><span class=\"hljs-keyword\">while</span>(n!=<span class=\"hljs-number\">0</span>)&#123;<br>    n=n&amp;(n<span class=\"hljs-number\">-1</span>);<span class=\"hljs-comment\">//不断消掉右边的1，但是问题是当n=-INT_MIN n-1不会溢出么，那么如何计算最左边的1呢</span><br>    res+=<span class=\"hljs-number\">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n</ul>\n<ol start=\"4\">\n<li><p>使用位运算实现八皇后</p>\n</li>\n<li><p>绘制直线，bit计算对应的int数组的下标(求得每个像素点对应的数的位数)</p>\n</li>\n<li><p>两整数之和，不使用+实现两个整数之和 使用异或以及与运算，一定要注意 carry要使用unsigned int 使用int会报错<br>(unsigned int) carry=(unsigned int) (a&amp;b)&lt;&lt;1</p>\n</li>\n</ol>\n<p><font color=\"red\">7. 数组中两个数的最大异或值</font></p>\n<ul>\n<li>方法一：31位的每一位只有两种情况，因此可以猜测执行<br>  对异或结果的每一位(32位，从31-0)从大到小进行猜测可以取到的数1或者0 运用了a^b=x 那么x^a=b,也就是查看猜测的这个数和集合里面的进行异或是否能够在集合里面找到另外一个数 （31*n的时间复杂度仍然是O(n)）</li>\n<li>方法二：使用字典树，然后遍历每个数，得到针对这个数可以取到的异或最大值i，然后取最大；（这里的trie树是一颗二叉树）</li>\n</ul>\n<ol start=\"8\">\n<li>lc201. 数字范围按位与</li>\n</ol>\n<ul>\n<li>转为求左右的公共前缀</li>\n</ul>\n<h3 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>ok ok</p>\n<ol>\n<li>位运算优先级注意, 同时一定要注意INT_MAX或者INT_MIN可能会导致左移/右移 /-1溢出</li>\n<li>位运算实现加减乘除</li>\n<li>在有的题目中取最右边的1的时候使用x^(~x+1)可能出现溢出，因此使用tmp=1; while((tmp&amp;xore)==0) tmp=(tmp&lt;&lt;1); 找最右边的1（lc260. 只出现一次的数字 III）</li>\n</ol>\n","site":{"data":{}},"wordcount":2239,"excerpt":"","more":"<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>注意位运算的优先级问题：使用位运算一定要多打括号</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-comment\">// 错误写法</span><br><span class=\"hljs-keyword\">if</span> (a &amp; b == <span class=\"hljs-number\">0</span>) &#123;<br>    ...;<br>&#125;<br><br><span class=\"hljs-comment\">// 正确写法</span><br><span class=\"hljs-keyword\">if</span> ((a &amp; b) == <span class=\"hljs-number\">0</span>) &#123;<br>    ...;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n<p>a + (b&amp;c) 不管是+/-/*/ 还是==， 只要和位运算在一起，位运算都应该大括号！！！！</p>\n<h4 id=\"例题\"><a href=\"#例题\" class=\"headerlink\" title=\"例题\"></a>例题</h4><ol>\n<li><p>使用位运算来判断a b的大小（注意出现溢出的情况）<br>位运算可以用来判断a b的正负，以及a-b的正负，因此分情况讨论a b的符号是否相等，如果相等，a-c大于0返回a;如果不等，a的符号大于0返回a<br>其余情况(flip(return A))返回B</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">flip</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> a)</span></span>&#123;<br>    <span class=\"hljs-keyword\">return</span> a^<span class=\"hljs-number\">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li><p>用位运算实现加减法：注意不用区分正负<br>左移，正负数都是右边添加0（也就是负数左移，是会移走最左边的符号位）<br>右移若干位，正数左补0，负数左补1</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">add</span><span class=\"hljs-params\">(a, b)</span></span>&#123;<br>    <span class=\"hljs-keyword\">int</span> sum=a;<br>    <span class=\"hljs-keyword\">while</span>(b!=<span class=\"hljs-number\">0</span>)&#123;<br>        sum=a^b;<br>        b= (<span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span>)(a&amp;b)&lt;&lt;<span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">//unsigned int非常重要</span><br>        a=sum;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">neg</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> a)</span></span>&#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">add</span>(~a, <span class=\"hljs-number\">1</span>);<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">sub</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> a, <span class=\"hljs-keyword\">int</span> b)</span></span>&#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">add</span>(a, <span class=\"hljs-built_in\">neg</span>(b));<br>&#125;<br><br>用位运算实现乘除法：<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">multi</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> a, <span class=\"hljs-keyword\">int</span> b)</span></span>&#123;<br>    <span class=\"hljs-keyword\">int</span> res=<span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">while</span>(b!=<span class=\"hljs-number\">0</span>)&#123;<br>        <span class=\"hljs-keyword\">if</span>((b&amp;<span class=\"hljs-number\">1</span>)!=<span class=\"hljs-number\">0</span>)&#123;<br>             res=<span class=\"hljs-built_in\">add</span>(res, a);<br>        &#125;<br>        a=a&lt;&lt;<span class=\"hljs-number\">1</span>;<br>        b=b&gt;&gt;<span class=\"hljs-number\">1</span>;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">//注意div考虑如果是负数是INT_MIN如何处理，不能直接转为整数</span><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">sign</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> a)</span></span>&#123;<br>    <span class=\"hljs-keyword\">return</span> a&lt;<span class=\"hljs-number\">0</span>;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">div</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> a, <span class=\"hljs-keyword\">int</span> b)</span></span>&#123;<br>    <span class=\"hljs-keyword\">int</span> res=<span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">int</span> x=<span class=\"hljs-built_in\">sign</span>(a)? <span class=\"hljs-built_in\">neg</span>(a):a;<br>    <span class=\"hljs-keyword\">int</span> y=<span class=\"hljs-built_in\">sign</span>(b)? <span class=\"hljs-built_in\">neg</span>(a):a;  <span class=\"hljs-comment\">//转为整数进行运算</span><br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">31</span>;i&gt;=<span class=\"hljs-number\">0</span>;<span class=\"hljs-built_in\">sub</span>(i, <span class=\"hljs-number\">1</span>))&#123;<br>        <span class=\"hljs-keyword\">if</span>((x&gt;&gt;i)&gt;=y)&#123; <span class=\"hljs-comment\">//注意这里不是y&lt;&lt;i  因为可能出现溢出</span><br>            res|= （<span class=\"hljs-number\">1</span>&lt;&lt;i）;<br>            x = <span class=\"hljs-built_in\">sub</span>(x, y&lt;&lt;i);<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">sign</span>(a)^<span class=\"hljs-built_in\">sign</span>(b)? <span class=\"hljs-built_in\">neg</span>(res): res;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">divide</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> a, <span class=\"hljs-keyword\">int</span> b)</span></span>&#123;<br>    <span class=\"hljs-keyword\">if</span>(b==<span class=\"hljs-number\">0</span>)&#123;<br>        <span class=\"hljs-keyword\">return</span> error;<br>    &#125;<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(a==INT_MIN&amp;&amp;b==INT_MIN)&#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br>    &#125;<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(b==INT_MIN||a==<span class=\"hljs-number\">0</span>)&#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>    &#125;<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(a==INT_MIN)&#123;<br>        <span class=\"hljs-keyword\">int</span> tmp=<span class=\"hljs-built_in\">div</span>(<span class=\"hljs-built_in\">add</span>(a, <span class=\"hljs-number\">1</span>),b);<br>        <span class=\"hljs-keyword\">int</span> rest=<span class=\"hljs-built_in\">div</span>(<span class=\"hljs-built_in\">sub</span>(a, <span class=\"hljs-built_in\">mul</span>(tmp, b)), b);<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">add</span>(tmp, rest); <span class=\"hljs-comment\">//相当于分成两个部分计算</span><br>    &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">div</span>(a, b);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li>\n<li><p>一些位运算技巧</p>\n</li>\n</ol>\n<ul>\n<li><p>移除最右边的1<br><code>n = n&amp;(n-1)</code></p>\n</li>\n<li><p>得到最右边的1<br><code>n &amp; (~n + 1)</code></p>\n</li>\n<li><p>用位运算计算一个二进制数的1个数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">int</span> res=<span class=\"hljs-number\">0</span>;<br><span class=\"hljs-keyword\">while</span>(n!=<span class=\"hljs-number\">0</span>)&#123;<br>    n=n&amp;(n<span class=\"hljs-number\">-1</span>);<span class=\"hljs-comment\">//不断消掉右边的1，但是问题是当n=-INT_MIN n-1不会溢出么，那么如何计算最左边的1呢</span><br>    res+=<span class=\"hljs-number\">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n</ul>\n<ol start=\"4\">\n<li><p>使用位运算实现八皇后</p>\n</li>\n<li><p>绘制直线，bit计算对应的int数组的下标(求得每个像素点对应的数的位数)</p>\n</li>\n<li><p>两整数之和，不使用+实现两个整数之和 使用异或以及与运算，一定要注意 carry要使用unsigned int 使用int会报错<br>(unsigned int) carry=(unsigned int) (a&amp;b)&lt;&lt;1</p>\n</li>\n</ol>\n<p><font color=\"red\">7. 数组中两个数的最大异或值</font></p>\n<ul>\n<li>方法一：31位的每一位只有两种情况，因此可以猜测执行<br>  对异或结果的每一位(32位，从31-0)从大到小进行猜测可以取到的数1或者0 运用了a^b=x 那么x^a=b,也就是查看猜测的这个数和集合里面的进行异或是否能够在集合里面找到另外一个数 （31*n的时间复杂度仍然是O(n)）</li>\n<li>方法二：使用字典树，然后遍历每个数，得到针对这个数可以取到的异或最大值i，然后取最大；（这里的trie树是一颗二叉树）</li>\n</ul>\n<ol start=\"8\">\n<li>lc201. 数字范围按位与</li>\n</ol>\n<ul>\n<li>转为求左右的公共前缀</li>\n</ul>\n<h3 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>ok ok</p>\n<ol>\n<li>位运算优先级注意, 同时一定要注意INT_MAX或者INT_MIN可能会导致左移/右移 /-1溢出</li>\n<li>位运算实现加减乘除</li>\n<li>在有的题目中取最右边的1的时候使用x^(~x+1)可能出现溢出，因此使用tmp=1; while((tmp&amp;xore)==0) tmp=(tmp&lt;&lt;1); 找最右边的1（lc260. 只出现一次的数字 III）</li>\n</ol>\n"},{"title":"其他问题","catogory":["leetcode 题目汇总"],"date":"2021-11-13T09:22:38.000Z","_content":"\n#### 数组相关问题\n要将数字放在对应的位置上，使用原地交换的方式\n1. 旋转矩阵  这个好像不行，需要记录交换过来的值的同时，记录交换过来的下标\n2. 自然数数组的排序\n3. 奇数下标是奇数，偶数下标是偶数\n\n- 第一种方法，使用一个环来进行数据的交换\n- 第二种方法，每个数据与当前的数据进行交换，然后判断当前交换过来的数据应该放到的位置，重复这样的过程，知道当前交换过来的数是应该放置的数\n\n举个例子：\n//如果下标i应该放的数据是 i+1 index和value之间存在映射\n```C++\ntmp=a[i];\nwhile(a[i]!=i+1){\n    int next=a[tmp-1];\n    a[tmp-1]=tmp;\n    tmp=next;\n}\n\nwhile(a[i]!=i+1){\n    swap(a[i], a[a[i]-1]);\n}\n```\n\n4. 最大子矩阵的和转为最大子数组的和，枚举每一行开始  i从0 ~ n-1,每次换开始的时候重新初始化数组s; j从i ~ n-1\n二维转为一维\n```C++\nfor(int i=0;i<matrix.size();i++){ //枚举row1\n    int s[matrix[0].size()];\n    for(int j=i;j<matrix.size();j++){ //枚举row2\n        int cur=0;//从头开始\n        for(int k=0;k<matrix[0].size();k++){ //转为最大子数组和\n            s[k]+=matrix[j][k];\n            cur+=s[k]; //利用之前加的值，加上现在的值\n            res=max(res, cur);\n            if(cur<0){\n                cur=0;\n            }\n        }\n    }\n}\n```\n\n5. 边界都是1的最大正方形：\n这种问题先想个暴力算法，然后考虑如何用空间换时间，加速判断的过程\n- 1.先循环，找到每个点的right down数组，注意边界要单独赋值，从右往左，从下网上计算\n- 2.遍历size（最开始初始化为m.size()和m[0].size()的最小值）, 每个size下遍历每个点，看左右边长以及右上角和左下角的right down是否都大于size,\n如果是返回true,否则返回false\n\n\n6. 数组partition的调整\n使用双指针，一个指针指向排序好的末尾，一个指针指向待排序序列的头结点\n```C++\nint left=0;\nint right=1;\nwhile(right<length){\n    if(arr[left]!=arr[right]){\n        left++;\n        swap(arr[left], arr[right]);\n        right++;\n        \n    }\n}\n```\n\n此类型的拓展问题，红蓝白球的排序，以及 0 1 2的排序\n解决方案：记录一个左节点（初始化-1）右节点（length）中间节点：\n```C++\nint left=-1;\nint right=length;//排好序的头\nint index=0;\nwhile(index<right){\n    if(arr[index]==0){\n        swap(arr[++left], arr[index]);\n        index++;\n    }else if(arr[index]==2){\n        swap(arr[--right], arr[index]);//注意这种情况index还要继续判断，因此不能index++\n    }else{\n        index++;\n    }\n}\n\n```\n\n7. 网格中的最短路径和最短通路问题：\n- 1.一定要分清楚是用dp还是bfs\n- 2.如果是只能从左上往右下走，那么是dp,否则应该用bfs,同时因为是路径，因此需要一个额外的二维数组判断到当前节点需要的步数，或者另外申明一个node,\n这个node里面记录到这个节点的步数\n\n\n<font color=red>8. 缺失的第一个正数： /引申缺失的最大负数（原位hash或者置换）</font>\n- 方法一：如何在原数组上进行hash,但是保留那个位置的数不变使用- 符号；(负数 0全部变为size)\n  同时如果原来有符号，那么为了避免混淆，将原来为符号的数变为我们不关心的正数\n- 方法二：使用置换的方式，这种方式一定要注意进入死循环的方式因此在交换的时候判断。nums[nums[i]-1]!=nums[i]\n\n\n\n##### random类似题目总结：\n\nrand5 to rand7\nrand01p to rand6\nrand1toM to rand1toN\n\n```C++\n1）  二维的方式，使得两个调用rand5在二维矩阵上是大于rand7，然后就可以选取7的倍数的一段距离对rand7取模\n    do{\n        row=rand5()-1;\n        col=rand5()-1;\n        num=row*5+col //0-24之间\n    }while(num>=21)\n\n    return num%7+1;\n\n```\n2)\n首先等概率产生0-1  01 10是等概率残生的\n```C++\nint rand01(){\n    do{\n        num=rand01p();\n    }while(num==rand01p());\n    return num;\n}\n\n那么rand03=rand01()*2+rand01();\nrand0-15=rand03()*4+rand03(); //倍数+插空  用进制的方法可以产生rand07()=rand03()+rand01()*4\n那么rand6可由如下产生:\ndo{\n    num=rand0-15;\n}while(num>=12)\nreturn num%6+1;\n```\n\n3）k维的方式\nrand1toM()转为rand1toN()其实就是调用k次（用N的M进制可以求得）的rand1toM, 使得这a* M^(k-1)+b* M^(k-2)+……  +c 比n要小， 然后返回就可以了\n其实就是用M进制的数来表示N-1，如果随机生成的数是大于N，那么从头进行生成（注意是从头，而不是从当前数重新生成），否则返回这个数\n步骤：\n   1、将n-1转换成m进制数，假设结果转换成数组为 k = [a,b,c,d,e]\n　　2、使用rand1ToM(m)函数产生结果数组 res = [A,B,C,D,E]，如果res所表示的数值大于k所表示的数值，将res丢掉重新随机，直到产生的结果小于或等于k，这时产生的res的范围就在0～n-1之间，但是此时res所表示的数还是m进制的。 //随机生成M进制的每一位数\n　　3、将res数组转换成10进制整数。\n　　4、将步骤3的结果加1就是最终的结果。\n\n\n##### 数学相关问题\n1. 求num阶层中最后的包含0的个数，因为包含因子2的个数一定比5多，因此可以直接求包含因子5的个数\n每5个数有一个5，每25个数中有一个数包含两个5\n同样下面的模板可以用于求任何因子的个数\n```C++\nint func(int num){\n    int res=0;\n    while(num){\n        res+=num/5;\n        num=num/5;\n    }\n    return res;\n}\n```\n<font color=blue>2. 判断一个点是否在矩形中：叉乘+点乘</font>\n对角向量叉积的点积>=0,（对角向量的叉积方向相同），使用叉积的原因是：一个点在线外还是在线内，叉积的正负不同\n使用叉积可以判断方向，A = <a1, a2>，B = <b1, b2>\nAXB=a1* b2-a2 *b1, 叉积向量的方向为法线的方向，上下为第一个向量指向第二个向量，大手指的方向\n叉乘加内积\n\n(p1 p2 X p1 p ) * (p3 p4 X p3 p1)  >= 0  （四个边分成两组，每两个对边一组， 看两边的叉积是否同方向）\n\n<font color=blue>3. 相同的题型：判断点是否在三角形中 叉乘</font>\n1）先判断三个点的顺序是否是逆时针方向:逆时针方向叉积小于0；顺时针方向叉积大于等于（注意顺序可能导致结果不同！！！）；如果是顺时针正方向，那么调整点位置\n2）然后判断这个点x是否都是在三角形每条边的左边，判断过程：三角形每个顶点和边的叉积小于0\n\n（逆时针，点左侧；判断逆时针，仍然使用点左侧）\n\n求三个三角形不推荐，因为double类型可能出现误差\n\n\n<font color=red>4. 路径数组转为统计数组的题目：原地hash, 注意以负数作为标记的话，全部的数都需要转为正数</font>\n要求额外的空间复杂度为O(1)\n如果要实现空间复杂度为O(1),那么需要在原来的数据上进行运算，那么每个位置存储跳过来的位置（最开始节点存储为-1），直到当前的数为一个负数（表示已经求过距离），然后跳回去的时候就知道来的位置，同时更新当前的距离，\n为了区分已经判断过的值和未判断过的值，使用负数；求到距离矩阵之后再计算每个距离出现的次数，仍然是使用跳的方式，开始节点记得赋值为0，表示已经访问计算过\n\n这种方式也出现在”第一个未出现的正数“这道题解决方案中（值与下标相互映射）\n\n\n5. 正数数组的最小不可组成和：\ndp[0][0]=1\n使用动态规划\nfor j=0; j=arr.size(); j++:\n    for i = sum to min: //注意反着,因为一个数只能取一次0-1背包\n        if(i>=arr[j]):\n            dp[i]=dp[i-arr[j]]?True:dp[i]//注意是dp[i]而不是false,也不是dp[i]=dp[i-arr[i]]//因为可能一个数一种方式可以组成，但是另一种不行\n\nPS:没有思路就想暴力算法，然后递归考虑是否能转为动态规划，类似背包问题\n```C++\ndp[i][j]=dp[i-1][j-arr[i]]||dp[i-1][j];\n\nfor i in min to sum:\n    if dp[n][i] == false:\n        return i\n```\n\n6. 累加出整个范围最少还需要的数:\n使用当前可以累加得到的范围，如果范围超过了当前遍历到的arr的第一个数，那么下一个可以累加得到的范围是当前的范围+arr[i];否则下一个差的数应该是touch+1,可以累加得到的数是touch+1+touch\n\n可以累加得到的数是touch,下一个差的数是touch+1\n```C++\ntouch=0;\ncnt=0;\nfor(int i=0;i<arr.size();i++){\n    if(touch+1<arr[i]){\n        while(touch<arr[i]+1){//注意这是循环\n            touch+=touch+1;\n            cnt++;\n            if(touch>=range){\n                return cnt;\n            }\n        }\n    }else{\n        touch+=arr[i];\n        if(touch>=range){\n            return cnt;\n        }\n    }\n}\nwhile(touch<range){\n        touch+=touch+1;\n        cnt++;    \n}\n\n    return cnt;\n```\n\n7. 一种字符串和数字对应的关系 （lc168. Excel表列名称）\nA -> 1\nB -> 2\nC -> 3\n...\nZ -> 26\nAA -> 27\nAB -> 28 \n从 1开始的的 2626 进制转换题。（每一位至少都有1）\n- 方法1：\n```C++\nstring res=\"\";\nwhile(columnNumber>0){\n    columnNumber--;\n    res+=(columnNumber%26+'A');\n    columnNumber/=26;\n}\nreverse(res.begin(), res.end());\nreturn res;\n```\n\n- 方法2：注意是K伪进制数，也就是每一个伪至少为1不能为0，因此需要先从右往左计算位数（同时每一位分得1, 因为这个规则每一位至少都有1），然后从左往右分剩下的数字 \n\n```C++\n//先从右往左，减掉一轮，再从左往右看补在哪为 进制如果为3：base=1 3 9\nvoid int2str(){\n    cur=1;//代表进制的基数\n    k=0//代表位数\n    base=3//代表进制数，多少个字符就是多少进制\n    while(n>=cur){\n        k++;\n        n-=cur;\n        cur*=base;\n    }\n\n    int index=0;\n    while(k){\n        cur/=base;\n        res[index++]=getchar(n/cur);  //当前base的数量应该为n/cur+1,对应的下标就是n/cur\n        n=n%cur; //剩下的数可以分多少到下一个进制位中\n        k--;\n    }\n}\n```\n\n\nstr2int类似于K进制\n\n从N个数中等概率打印M个数,空间复杂度为O(1)：将每次打印的数每次交换到整个数组的末尾，然后下次在生成随机数的时候，减少生成范围（1，n-count）\n\n\n\n\n8. 数字的中文表达和英文表达：\n- 1.中文表达：对于零特殊处理\n- 2.英文表达：每三个一组进行处理；使用递归或者迭代。递归方式就是分别求出billion million和thousand三个部分的数字，然后加起来，\n在求每个部分的时候，先判断百位，如果百位有数字的话，那么加上”hundred“,否则分为数字<=10 <20; <=20 <100 and <10 三种情况进行处理\n\n\n9. 实现sqrt函数\n- 方法一：使用二分算法（一个数的平方根不会大于 n/2+1），标准二分，返回right\n\n- 方法二：牛顿迭代算法： y=f(x0)+k(x-x0)\n令y=0, 得到 x_i+1=(x_i+ C/x_i)  其中C为要求的目标\n```C++\nclass Solution {\npublic:\n    int mySqrt(int x) {\n        if (x == 0) {\n            return 0;\n        }\n\n        double C = x, x0 = x;\n        while (true) {\n            double xi = 0.5 * (x0 + C / x0);\n            if (fabs(x0 - xi) < 1e-7) {\n                break;\n            }\n            x0 = xi;\n        }\n        return int(x0);\n    }\n};\n```\n\n10. 小数的十进制转为二进制是*2 取整数部分，如果整数>=1, 那么num-=1,否则当前位为0， 直到num=0; 也可以1连除2，num如果num>base,那么减去base\n十进制整数转换为二进制整数采用\"除2取余，逆序排列\"法\n十进制小数转换成二进制小数采用\"乘2取整，顺序排列\"法\n\n\n11. 全排列问题，使用交换或者vis+回溯，一定要注意是否有重复的字符，如果有重复的字符，那么下一个交换或者选择的数，一定是当前没有选择的 （可以和当前自己位置进行交换）\n\n\n<font color=red>12. 树状数组例题：数字流的秩 线段树（平衡树+二叉搜索树，需要初始化4*n区间） 使用频繁更新数组的某一位（后面的位数也需要相应修改），以及求前缀和</font>\n线段树和树状数组的基本功能都是在某一满足结合律的操作(比如加法，乘法，最大值，最小值)下，O(logn)的时间复杂度内修改单个元素并且维护区间信息。不同的是，树状数组只能维护前缀“操作和”(前缀和，前缀积，前缀最大最小)，而线段树可以维护区间操作和。线段数组是真正的数，而树状数组只是一个数组\n\n树状数组主要是用于求前缀和，（改变原始然后求前缀和；差分数组适用于，某一段的元素被整体加上或者减去一个元素）\n- 区间查询：求index的前缀和其实就是不断将index的二进制数的最后一个一个1逐渐变为0 的数据对应的值相加；（x-(x&-x)）//不断地去掉二进制数最右边的一个1 （从x到=n）\n- 单点修改：更新一个index需要更新的其他下标的值相当于 不断加上最后一个1所代表的数字下标对应的值（x+(x&-x)）//从右边起一系列连续的1变为0，再把这一系列1的前一位0变为1,相当与最后一个1+1，导致连续进位\n其中存储值的下标从1开始，0下标主要是判断循环的终点，不被用来存储值 （从x到0）\n\n而且树状数组的下标从1开始，常用语频繁更新和频繁求前缀和\n```C++\n建立树状数组：\nint n;\nint a[1005],c[1005]; //对应原数组和树状数组\n//范围是[1,n]\nint lowbit(int x){\n    return x&(-x);\n}\n\nvoid updata(int i,int k){    //在i位置加上k\n    while(i <= n){\n        c[i] += k;\n        i += lowbit(i);\n    }\n}\n\nint getsum(int i){        //求A[1 - i]的和\n    int res = 0;\n    while(i > 0){\n        res += c[i];\n        i -= lowbit(i);\n    }\n    return res;\n}\n```\n树状数组如果输入有0， 那么所有的输入都应该向右边偏移以为（输入x，实际上对应x+1）\n\n例题：lc5999. 统计数组中好三元组数目\n这道题是求在一个数的左边，同时小于这个数的数量（数量题）\nlc307. 区域和检索 - 数组可修改\n- 这道题是，频繁的修改某个下标的元素值+同时求某个范围元素之间的元素和（值题目）\n- 数组的大小为arr的范围n， 下标对于树状数组的二进制下标\n- 需要先将num的值插入树状数组中， 然后更新的时候使用newvalue-ori[index]来更新当前节点后面的值，同时一定要记得更新ori[index]=newvalue !!!!\n- 一定要记得树状数组的下标是从1开始，但是num的下标从0开始；而且区间范围是两边闭合，所以求区间差的时候，left_index应该减1\n\n<font color=red>lc315. 计算右侧小于当前元素的个数（hard）</font>\n- 注意这道题数据可能为负数，因此需要对数据+10000+1 使数据shift到[1, +无穷]\n- 使用归并排序，每个i, j 那么num[i]+=j-i-1 (就是在i后面而且比nums[i]小的数的数量)\n归并排序易错点：需要使用索引数组,同时在进行归并的时候会修改索引数组，一定要记得复制一个新的数组出来，不能使用原来的数组；其次就是注意数组的范围，左右都闭合；归并排序还长用于计算逆序对\n\nlc493. 翻转对(hard)\n- 归并排序\n- 范围映射的树状数组（具体代码可见模板代码）\n\n\n13. 最佳直线，使用暴力枚举的方式， 三重循环\n    枚举直线两个起始端点(i, j)，后面遍历k是否在直线(i, j)上，在的话计算过得点个数进行更新， 最后判断这条直线上最多有多少个同点\n    时间复杂度：O(n^3)\n    空间复杂度：O(1)O(1)\n\n\n14. 枚举题：模式匹配问题，暂时未做，主要是通过a和b的数量来枚举a匹配的字符的长度和b字符的长度，主要是注意边界情况应该先于长度的枚举进行判断\n    example： pattern = \"abba\", value = \"dogcatcatdog\"\n    注意：pattern只包含字母\"a\"和\"b\"两种字符， 而且a或者b可以为空串， 而且a 与b映射的字符串不应该相等\n    lena lenb都为0; lena为0; lenb为0;lena lenb都不为0时， 他们映射的字符串不应该相等\n\n\n15. 大数相乘的题目\n- 使用第二个数的每一位数和第一个数相乘<< i 位，然后将求得的结果相加\n- 使用第一个数的每一位和第二个数相乘，更新结果的 arr[i+k]位\n\n16. 矩形覆盖面积： 公式为area1+area2-inter_area\ninter_area = max((最小 右上横坐标 - 最大左下横坐标), 0)* max(（最小右上纵坐标 -  最大左下纵坐标, 0)\n\n注意一定要和0进行比较\n\n\n16. 找众数II:\n- 使用hash算法\n- 使用摩尔投票算法\n\n找到超过 (n/3) 向下取整的数：数学证明这样的数最多2个，选两个数，如果当前的数都不等于前两个数，那么两个投票数都--\n这种投票算法同样适用于找到超过 n/2\n\n```C++\nclass Solution {\npublic:\n    vector<int> majorityElement(vector<int>& nums) {\n        vector<int> ans;\n        int element1 = 0;\n        int element2 = 0;\n        int vote1 = 0;\n        int vote2 = 0;\n\n        for (auto & num : nums) {\n            if (vote1 > 0 && num == element1) { //如果该元素为第一个元素，则计数加1\n                vote1++;\n            } else if (vote2 > 0 && num == element2) { //如果该元素为第二个元素，则计数加1\n                vote2++;\n            } else if (vote1 == 0) { // 选择第一个元素\n                element1 = num;\n                vote1++;\n            } else if (vote2 == 0) { // 选择第二个元素\n                element2 = num;\n                vote2++;\n            } else { //如果三个元素均不相同，则相互抵消1次\n                vote1--;\n                vote2--;\n            }\n        }\n\n        int cnt1 = 0;\n        int cnt2 = 0;\n        for (auto & num : nums) {\n            if (vote1 > 0 && num == element1) {\n                cnt1++;\n            }\n            if (vote2 > 0 && num == element2) {\n                cnt2++;\n            }\n        }\n        // 检测元素出现的次数是否满足要求\n        if (vote1 > 0 && cnt1 > nums.size() / 3) {\n            ans.push_back(element1);\n        }\n        if (vote2 > 0 && cnt2 > nums.size() / 3) {\n            ans.push_back(element2);\n        }\n\n        return ans;\n    }\n};\n\n```\n\n\n17. 为运算表达式计算优先级\n使用分治算法, 遍历表达式，找到运算符，将结果分成两个部分， 递归查找。类似二叉树的组成方式查找\n如果求具体的结果，那么需要使用vector将结果进行push_back,否则可以直接使用动态规划，计算总数\n\n\n18. 摆动序列 如果是需要相邻两个数不能等于的话，只能两个字符串都进行翻转，如果可以相邻等于的话，可以后面的字符串进行翻转就行了 \n\n\n19. 中文变为阿拉伯数字和阿拉伯数字变为中文\n    1.中文变为阿拉伯数字\n    使用栈，将文字划分为数字和量纲，遇到量纲，那么从栈中弹出与当前量纲小的数字与当前量纲相乘，然后不断累加，知道栈为空或者栈顶量纲比当前量纲大，然后将当前累加到的数压入栈中；最后的结果就是栈中的数求和\n\n    2.阿拉伯数字变为中文\n    注意：亿，万节之后如果只有0那么不需要输出0，如果千位为0的话那么需要输出0\n    10500，一万零五百， 15000一万五千\n    \n    将数组划分为节，然后每节使用一个函数判断\n    如果不是第一节，而且当前的数是大于0，而且小于1000的话那么需要加零\n\n\n20. 面试题 16.14. 最佳直线/149. 直线上最多的点数\n- 暴力方法：使用三重循环，前两个点固定一条直线，后一个点判断是否在直线上，是cnt++,最后找最大的cnt\n- hash方法，使用二重循环，遍历两个点，两个点得到一个斜率，然后hash_map中存储该斜率的cnt, 最后取最大值的时候res=max(res, cnt+1)//一定记得+1\n    因为gcd(5, 0)=5=cd(0, 5) 所以不存在除0情况\n```C++\nint a = x1 - x2, b = y1 - y2;\nint k = gcd(a, b);\nString key = (a / k) + \"_\" + (b / k); //斜率用string存储\n\nint gcd(int a, int b) {\n    return b == 0 ? a : gcd(b, a % b);\n}\n```\n\n21. 阶层之后的零\n-  方法1， 直接计算，n是5的倍数的个数+25倍数个数+...\n```C++\nint pow=5;\nwhile(n>=pow){\n    cnt+=n/pow;\n    pow=pow*5;\n}\nreturn cnt;\n```\n- 方法2， 对1-n中的每一个数计算，能够拆分为多少个5的因子\n```C++\nfor(int i=1;i<=n;i++){\nint tmp=i;\nwhile(tmp%5==0){\n    tmp=tmp/5;\n    cnt++;\n}\n```\n\n22. lc277. find-the-celebrity\n- 所有的人都认识名人，名人谁都不认识，找出名人\n- 假设法，O(n), 假设0是名人，如果遇到knows(0, i)==true, 说明0不是名人，同时说明[0~i-1]都不是名人，因为他们都不被0知道\n- 之后再判断一次，如果出现know(ans, i)==true||know(i, ans)==false, 返回-1\n\n\n\n\n #####  19.交换数据的位置\n（1）打标记方法： 这种方式理解起来更轻松, 注意这种方式，如果元数据中包含0或者小于0，但是目标数据中是大于0的([1, size])， 那可以将0，负数转为size+1; 否则如果元数据有0， 目标数据也有0的话，打标记是无法解决的\n\n1. 缺失的第一个正数 （用负号在原地打标记代替hash方法，或者用置换方法，一定要将负数和>size都转为size+1；同时对于target_index和当前index数据相同时，退出循环）\n2. 丢失的数字\n3. 数组中重复的数据\n\n将当前的数在对应的下标中打上标记，同时为了找到被覆盖数据的元数据，可以使用+n（这种可以找到重复3次， 4次都可以）,或者变为负数的这种做法\n但是变负数的这种方式，不能适用于含有0的这种情况，因为-0和0是一样的，无法判断是否出现过这个数字\n\n找到的条件是 nums[i]>=0 退出\n``` C++\n   int firstMissingPositive(vector<int>& nums) {\n        int n = nums.size();\n        for (int& num: nums) {\n            if (num <= 0) {\n                num = n + 1;\n            }\n        }\n        for (int i = 0; i < n; ++i) {\n            int num = abs(nums[i]);\n            if (num <= n) {\n                nums[num - 1] = -abs(nums[num - 1]);\n            }\n        }\n        for (int i = 0; i < n; ++i) {\n            if (nums[i] > 0) {\n                return i + 1;\n            }\n        }\n        return n + 1;\n    }\n\n```\n\n（2）置换\n1. 缺失的第一个正数 把数据放在对应的位置\n\n将当前的数放在当前数据对应的下标中\n\n找到的条件是 nums[i]！=i+1 退出\n```C++\n    int firstMissingPositive(vector<int>& nums) {\n        int n = nums.size();\n        for (int i = 0; i < n; ++i) {\n            while (nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i]) {\n                swap(nums[nums[i] - 1], nums[i]); //要和它交换的数不能等于它本身\n            }\n        }\n        for (int i = 0; i < n; ++i) {\n            if (nums[i] != i + 1) {\n                return i + 1;\n            }\n        }\n        return n + 1;\n    }\n```\n（3） 二分算法，查找小于mid的数据量，如果是大于mid的话说明重复的数小于等于mid,因此r=mid-1 and ans=mid(或者r=mid), 否则l=mid+1\n (4) 数组版快慢指针，index->nums[index] 那么有一个数会被指向两次，那么存在环\n - 映射找环法， 找冗余的数据，其实就是找环路的起点\n - https://segmentfault.com/a/1190000003817671\n ```C++\n class Solution {\n    public:\n        int findDuplicate(vector<int>& nums) {\n            int slow = 0, fast = 0;\n            do {\n                slow = nums[slow];\n                fast = nums[nums[fast]];\n            } while (slow != fast);\n            slow = 0;\n            while (slow != fast) {\n                slow = nums[slow];\n                fast = nums[fast];\n            }\n            return slow;\n        }\n    };\n ```\n\n4. lc 440和lc386 按照字典序排序，和按照字典序排序的第k个数字\n我们输入两个值n和k，n表示我们有从1到n个整数，然后将这些整数都字符串化之后按字典排序，找出其中第K大的。例如:n=15,k=5.那么1-15字符串化之后排序如下:1,10,11,12,13,14,15,2,3,4,5,6,7,8,9。其中第5大的就为13。\n实际上多叉树从到右进行计数\n\n每次求解二叉树相邻两个节点之间(base 和base+1)包含的数据，如果k>num那么直接更新k 然后当前数+1(base=base+1), 否则递归求里面的数据(base=base*10)\n\n\n<font color=red>20. 字符串相乘</font>\n- 模板代码：\n    ```C++ 关键代码\n    vector<int> res(size1+size2+1, 0);\n    reverse(num1.begin(), num1.end());\n    reverse(num2.begin(), num2.end());\n    for(int i=0;i<size1;i++){\n        for(int j=0;j<size2;j++){\n            res[i+j]=res[i+j]+(num1[i]-'0')*(num2[j]-'0');\n\n        }\n    }\n    ```\n- 知识点：字符ASCII码和数字的相互转换\n    char a='0'+81;\n    char b=a-81;\n    int c=a-'0';\n    cout<<a<< \" \"<<b<<\" \"<<c<<endl;\n    注意c最终打印的结果为-175, 而不是81！！！！ 所以在初始化字符串相乘的数组只能用int类型不能用string类型\n    char m='A'+1;//打印输出'B'\n\n- 初始化一个m+n的数组（注意一定要为int类型，不能为string类型），然后循环计算每一位应该的值，最后从低位到高位进行进位更新\n- 易错点：str1和str2需要翻转，之后的结果需要去前缀零以及翻转回来\n如果不翻转，那么nums1[i]和nums2[j]对应nums[i+j+1]的数组\n\n\n21. 分数到小数，模拟除法\n\n使用hash记录余数到下标的隐射，如果出现重复余数，说明出现了重复的小数循环体\n注意易错点：\n- 1.可能存在负数，但是不能直接对负数取反（因为可能为INT_MIN），需要转为long型\n    判断结果为负数使用异或\n    if (numeratorLong < 0 ^ denominatorLong < 0) {//异号为负数\n        sb.append('-');\n    }\n\n\n22. lc670. 最大交换\n- 一个数字交换一次，如何使得交换后的数最大 输入: 2736 输出: 7236\n- 先遍历字符串求得每个数最靠后的下标（因为小于当前的数，应该换到越靠后面越好）\n- 然后从左遍历每个数的时候，遍历 '9'到s[i]-'0'看是否有比当前数大的数，而且在这个数后面，如果有，那么交换，然后退出\n- 因为第二重循环只是从9到s[i]-'0'， 因此总的时间复杂度还是O(N)\n\n\n\n#### 分而治之专题\n\n1. 超级次方， 也类似观察规律的题目，就是在定义一种新的运算的时候，将它化简为熟知的运算。同时运用规律“对乘法的结果求模，等价于先对每个因子都求模，然后对因子相乘的结果再求模”\n不能直接使用系统自带的pow,只能自己实现pow因为，在求乘方过程随时会出现溢出，所以要为每一个中间结果取模\n\n2. 第K个语法符号\n找第n个的数的第k个字符是什么，转为找第n-1个数的对应f(k)位上面的数据（左半边不取反，右半边取反）\n易错点在：一个数的时候会add两次如何解决, 那么就在返回的时候，只有一个数的时候，说明出现了[[num, []]]的这种情况，那么直接return result.getInterger, 否则直接返回result\n\n#### 递归相关，表达式相关专题\n\n1. 迷你语法分析器： \n注意在进行递归的时候， 递归进去直接初始化一个NestInterger res, 来加入[]里面的数字， 遇到循环递归调用，然后返回时直接res.add\n另外一个易错点是，注意负数的处理\n\n\n#### 蓄水池抽样算法\n\n模板\n```C++\nclass Solution {\npublic:\n    Solution(ListNode* head) {\n        this->head=head;\n    }\n    \n    int getRandom() {\n        ListNode*cur=this->head;\n        int pool=-1;\n        int i=1;\n        while(cur){\n            if(rand()%i==0)pool=cur->val; //只选取一个数的情况\n            i++;\n            cur=cur->next;\n        }\n        return pool;\n    }\n\nprivate:\n    ListNode*head;\n};\n\n```\n\n例题：\n1. 链表随机节点\n2. 随机索引数 ，找到target数的随机一个index\n\n\n\n#### 并查集专题\n相关例题：\n\n除法求值：并查集的变形，除了要判断各个数字是否连通，还需添加一个数组记录节点之间的权重 weight(当前节点到其父节点的权重); 而且注意如何a/b那么应该是a的父亲节点是b, a指向b的权重为a/b, 反过来的话不对 **一定要注意这个权重的更新，应该为当前的权重 * 他原来父亲的现在的权重**\n\n易错点：\n- 在进行节点merge的时候一定要注意权重的更新，weight代表的是两个节点之间的权重，而不是一个节点到根节点的权重\n- find的时候返回的是father[a]而不是a !!!!!!\n- fa!=fb的时候应该是father[fa]=fb, 与两个孩子节点a b无关\n- 递归寻找father的时候，应该使用father[index]作为函数的参数而不是index(会陷入无限死循环中)\n- 在并查集的时候，可以直接使用string作为头节点，不一定要转为int类型  unordered_map<string, string> father; unordered_map<string, int>num\n例题：面试题 17.07. 婴儿名字\n- 可以使用string的find函数来对字符串进行分割（带括号或者，形式的分割）\n\n并查集模板：具体可见vscode里面的代码，两个模板 带size和不带size的情况\n\n\n例题2：lc947. 移除最多的同行或同列石头\n- 这个是二维坐标的，横坐标或者纵坐标相同都在一个并查集，因此需要将横纵坐标放在两个范围中，防止重叠；因为x, y在[0,1000]之间，一次你可以将横坐标放在+10001, 使得x y范围错开\n\n剑指 Offer II 111. 计算除法\n- 使用并查集或者BFS/DFS\n- 并查集注意分母为儿子（大），分子为父亲\n- BFS的时候正向，反向都要连接\n\n\n\n\n\n\n#### 图相关\n\n竞赛第四题 hard lc2097. 合法重新排列数对 //暂时没有看\n```C++\nclass Solution {\n    map<int, vector<int>> mp;\n    map<int, int> deg;\n    vector<vector<int>> ans;\n\n    void dfs(int sn) {\n        vector<int> &e = mp[sn]; // 注意这个是引用\n        while (!e.empty()) {\n            int fn = e.back();\n            e.pop_back();\n            dfs(fn);\n            ans.push_back(vector<int>{sn, fn});\n        }\n    }\n    //为什么要先dfs再push_back没看明白\n\npublic:\n    vector<vector<int>> validArrangement(vector<vector<int>>& pairs) {\n        for (auto &pair : pairs) {\n            mp[pair[0]].push_back(pair[1]);\n            deg[pair[0]]--; deg[pair[1]]++;\n        }\n        for (auto it = deg.begin(); it != deg.end(); it++) if (it->second == -1) dfs(it->first);\n        if (ans.empty()) dfs(deg.begin()->first);\n        reverse(ans.begin(), ans.end());\n        return ans;\n    }\n};\n\n```\n\n\n##### 有关于有向图和无向图的最短路径，以及有负边和无负边的最短路径\n\n1. Dijstra算法，适用于单源，有向或者无向的最短路径，不能适用于有负边（注意不是负环，负环情况下，无最短路径）的情况：例子：-1， -5， 2\n时间复杂度O(n^2))\n```C++\n#define INF 0x3f3f3f3f\n\nint e[Max][Max];//e[i][j]代表从i->j的距离，不通设为无穷大\nint dis[Max];//dis[i]代表从起点到i的最短距离\nbool book[Max];//book[i]代表点i是否在S中\nint n;//n个顶点\nint s;//起点\n\nvoid Dijkstra()\n{\n    for(int i=1;i<=n;i++)//初始化dis数组\n        dis[i]=e[s][i];\n\n    for(int i=1;i<=n;i++)//初始化book数组\n        book[i]=0;\n    dis[s]=0;\n    book[s]=1;\n\n    for(int i=1;i<=n-1;i++)//Dijkstra算法核心语句  注意也是n-1次\n    {\n        int minDis=INF;\n        int k;//找到与s最近的顶点k\n        for(int j=1;j<=n;j++)\n        {\n            if(book[j]==0 && dis[j]<minDis)\n            {\n                minDis=dis[j];\n                k=j;\n            }\n        }\n        book[k]=1;\n\n        for(int j=1;j<=n;j++)//“松弛”过程\n        {\n            if(e[k][j]<INF)\n            {\n                if(dis[j]>dis[k]+e[k][j])\n                    dis[j]=dis[k]+e[k][j];\n            }\n        }\n    }\n}\n```\n\n2. Bellman-ford算法：适用于单源，可有负权，有向或者无向的最短路径 记住只松弛n-1次\n能够检测出有负环情况\ndp[i][dst]=min(dp[i][dst], dp[i-1][src]+dist[src][dst]) i==1的时候表示经过的中转站为0\n\n时间复杂度O(n*m)/O(VE)\n\n```C++\n#define INF 0x3f3f3f3f\n\nstruct Edge{\n    int u;//起\n    int v;//终\n    int weight;//长度\n};\n\nEdge edge[maxm];//用来存储所有的边\nint dis[maxn];//dis[i]表示源点到i的最短距离\nint n,m;//n个点，m条边\nint s;//源点\n\nbool Bellmen_ford()\n{\n    for(int i=1;i<=n;i++)//初始化\n        dis[i]=INF;\n\n    dis[s]=0;//源节点到自己的距离为0\n\n    for(int i=1;i<n;i++)//松弛过程，计算最短路径 \n    {\n        for(int j=1;j<=m;j++) //m条边\n        {\n            if(dis[edge[j].v]>dis[edge[j].u]+edge[j].weight)//比较s->v与s->u->v大小\n                dis[edge[j].v]=dis[edge[j].u]+edge[j].weight;\n        }\n    }\n\n    for(int j=1;j<=m;j++)//判断是否有负边权的边\n    {\n        if(dis[edge[j].v]>dis[edge[j].u]+edge[j].weight)\n            return false;\n    }\n\n    return true;\n}\n```\n\n\n3. SPFA算法：是Bellman-ford算法的队列优化，适用于单源，可有负权，有向或者无向的最短路径 （自身其实无法处理负权）  \n设立一个队列用来保存待优化的点，优化时每次取出队首结点u，并且用u点当前的最短路径估计值对u点所指向的结点v进行松弛操作，如果v点的最短路径估计值有所调整，且v点不在当前的队列中，就将v点放入队尾。这样不断从队列中取出结点来进行松弛操作，直至队列空为止。\n\n注意，一旦从队列中弹出来，vis就设置为false，感觉负权的情况就会一直循环下去，不会跳出；遍历点，与边无关\n```C++\n#define INF 0x3f3f3f3f\n\nint dis[MAX];//dis[i]表示起点到i的最短距离\nbool vis[MAX];//是否访问过点i\nint e[MAX][MAX];//矩阵\n\nint n,m;//点和边的数量\nint s;//源点\n\nvoid SPFA()\n{\n    for(int i=1;i<=n;i++)//初始化\n    {\n        dis[i]=INF;\n        vis[i]=false;\n    }\n    queue<int> q;\n    q.push(s);\n    dis[s]=0;\n    vis[s]=true;\n\n    while(!q.empty())\n    {\n        int cur=q.front();\n        q.pop();\n        vis[cur]=false;\n        for(int i=1;i<=n;i++) //遍历每一个节点\n        {\n            if(e[cur][i]!=INF&&dis[i]>=dis[cur]+e[cur][i])\n            {\n                dis[i]=dis[cur]+e[cur][i];\n                if(!vis[i])\n                {\n                    vis[i]=true;\n                    q.push(i);  ///之后将start缩小的边才拿出来\n                }\n            }\n        }\n    }\n}\n```\n\n4. Floyd算法： Floyd算法是一种利用动态规划思想的计算加权图中多源点之间最短路径的算法。可以正确处理有向图或负权的最短路径问题。\n\n时间复杂度：O(N^3）\n\n空间复杂度：O(N^2）\n\n处理问题：多源、可有负权、有向图、无向图最短路径 \n```C++\nint e[Max][Max];//e[i][j]代表从i->j的距离，不通设为无穷大\nint n;//n个顶点\n//Floyd算法\nvoid Floyd()\n{\n    for(int k=1;k<=n;k++)//遍历所有的中间点\n    {\n        for(int i=1;i<=n;i++)//遍历所有的起点\n        {\n            for(int j=1;j<=n;j++)//遍历所有的终点\n            {\n                if (e[i][j]>e[i][k]+e[k][j])//如果当前i->j的距离大于i->k->j的距离之和\n                    e[i][j]=e[i][k]+e[k][j];//更新从i->j的最短路径\n            }\n        }\n    }\n}\n```\n\n最短路衍生拓展的一类题目：\n1. 最长路径问题：\n图不为非负权图：当存在正环时无解。\n如果不存在正环，边权取负后使用Bellman-Ford算法求最短路。\n2. 最长路径，但是路径的计算是权重之间的乘积，而且权重都是0-1之间的值，使用Dijstra算法 （e.g概率最大的路径）\nSolution: \n    单独使用Dijstra会导致超时，因此需要结合Dijstra+优先队列\n    1.现将src点push 到堆进行\n    2.然后遍历堆中的每个节点，如果当前节点能够松弛它的邻接节点，那么就放入堆中，否则不放入类似于SPFA,但是不同的是，\n    - 这个使用的优先队列，而SPFA是用的是一般的堆\n    - 这个不仅仅push了节点，也push了当前节点的最大概率，因此没有vis数组来标记当前节点是否在堆中，因为即使在堆中， 概率也可能是不一样的。\n    总的来说这道题使用bellman-ford算法更简单，只要当前没有任何松弛的边，那么直接退出循环\n\n颜色交替的最短路径：使用bellman-ford算法（本质是动态规划）， 只是在距离的转换是需要讨论两种情况\ndstEndWithRed[end]=min(dstEndWithRed[end], dstEndWithBlue[start]+1);\ndstEndWithBlue[end]=min(dstEndWithBlue[end], dstEndWithRed[start]+1);\n```C++\nfor(int i=0;i<n-1;i++){\n    for(auto edge: redEdges){\n        int start=edge[0];\n        int end=edge[1];\n        dstEndWithRed[end]=min(dstEndWithRed[end], dstEndWithBlue[start]+1);\n    }\n    for(auto edge: blueEdges){\n        int start=edge[0];\n        int end=edge[1];\n        dstEndWithBlue[end]=min(dstEndWithBlue[end], dstEndWithRed[start]+1);\n    }\n}\n```\n3. 成语接龙的最长，使用bfs，同时对连接好的成语，再来一次bfs (微软三面)\n\n<font color=red>4. lc787. K 站中转内最便宜的航班</font>\n- 只能最多经过k个中转站的最短路径\n- 使用bellman-ford算法，k个中转站就是松弛每条边 k+1次(1~k+1)，然后使用dp[i][dst]记录 中转i次的最短路径\n最后的结果就是在dp[1][dst] 到dp[k+1][dst]中取最小的一个\n\nlc6134. 找到离给定两个节点最近的节点\n- 内向基环树\n- 求出node1 到每个点的距离， 和node2 到每个点的距离，然后取最小 (两次求距离，然后取最小，最后注意返回的是最近的下标，而不是最近的距离)\n\nPS, 最开始理解的时候，感觉应该用两个节点的最近公共祖先来解决，但是因为图中可能有环，所以不能使用最近公共祖先的栈或者dfs方法解决\n\n### 前缀和和差分数组相关\n一般是有关于矩阵的一维前缀和， 二维前缀和， 一维差分数组和二维差分数组\n如果要计算差分数组和前缀和数组最好是将坐标转为 1-n，更好计算；不然sum i j对应的grid为i-1,j-1\n\n\n一维差分数组中，如果数组中一段数据加上或者减去某一个元素，在差分数组中只有两头的元素进行了修改，中间的元素都没有修改\n二维差分数组中，如果包含左上角（x1, y1）, 右下角（x2, y2）这一部分都+C, 那么对应的差分数组d[x1][y1]+c d[x2+1][y2+1]+c d[x1][y1+1]-c d[x2+1][y1]-c\n(上升的对角线两端元素-c, 下降的对角线元素+c)\n\n二维差分数组公式:\nnums[i][j]-nums[i-1][j]-nums[i][j-1]+nums[i-1][j-1]=d[i][j]\n从差分数组还原原来的数组\nnums[i][j]=nums[i-1][j]+nums[i][j-1]-nums[i-1][j-1]+d[i][j]\n\n\n\n例题：\n1. 5931. 用邮票贴满网格图 (hard-周赛题目)\n\n方法一: 使用二维前缀和，对原来矩阵中每个左上角为0，且邮票区域都为0的位置（二维区域前缀和为0），贴上邮票，为了减少贴这个过程的时间开销，使用二元差分数组\n贴完后，对二元差分数组进行还原，如果仍然遇到为0的位置，那么返回false\n注意这道题没必要求差分数组，差分数组可以全部直接初始化为0， 那么还原回来的也是填充数组\n方法二: 不使用二维差分数组，使用另外一个数组，标记贴邮票的左上角，然后针对每个grid中为0的位置，计算邮票部分区域（注意是贴了邮票的矩阵，是另一个矩阵）的前缀和，如果为0，表示这个区域没有被贴上邮票，返回false\n\n2. 航班预订统计 (middle)\n一维差分数组的题目\n如果原来数组的下标就是1-n的话，那么修改n-m部分的数据， 就会修改等差数列的d[n]和d[m+1]两个端点的数据\n\n\n3. 拼车\n这道题类似于天际线问题，使用hash, 左断点加入m个人，右端点减去m个人\n然后遍历hash的每个key,如果有个时刻是大于capacity, 那么返回false\n\n4. lc995. K 连续位的最小翻转次数（hard）\n- 从左到右遍历，遇到0就进行翻转，使用差分数组进行假意翻转，通过presum累加来求得当前翻转的次数\n\n### 前缀异或值\n在求前缀异或的时候，结果数组可以从1开始取，这样的话就不用对边缘单独进行赋值操作\n```C++\nfor (int i = 1; i <= m; ++i) {\n    for (int j = 1; j <= n; ++j) {\n        pre[i][j] = pre[i - 1][j] ^ pre[i][j - 1] ^ pre[i - 1][j - 1] ^ matrix[i - 1][j - 1];\n        results.push_back(pre[i][j]);\n    }\n}\n```\n\n\n### 分类讨论题\n1.  K 次串联后最大子数组之和\n分类分析\nk=1;\nk=2;\nk>2 如果array之和小于0，那么结果就是k=2情况，否则k=2+(k-2)*sum(one array)\n\n\n#### 摩尔投票算法\n1.求众数\n```C++\nint k=0;\nint target_num=0;\nfor(int i=0;i<size;i++){\n    if(k==0){\n        target_num=nums[i];\n        k=1;\n    }else{\n        if(nums[i]==target_num){\n            k++;\n        }else{\n            k--;\n        }\n    }\n}\n\n//判断target_num的数是否大于n/2;\nint cnt=0;\nfor(int i=0;i<size;i++){\n    if(nums[i]==target_num){\n        cnt++;\n    }\n}\nif(cnt>n/2){\n    return target_num;\n}\n```\n\n2.求大于n/3 的数\n这样的数最多只有两个\n```C++\nint k1=0;//投票的数量\nint k2=0;\nint target_num1;//具体的数\nint target_num2;\nfor(int i=0;i<size;i++){\n    if(k1>0&&target_num1==nums[i]){\n        k1++;\n    }else if(k2>0&&target_num2==nums[i]){\n        k2++;\n    }else if(k1==0){\n        target_num1=nums[i];\n        k1=1;\n    }else if(k2==0){\n        target_num2=nums[i];\n        k2=1;\n    }else{\n        k1--;\n        k2--;\n    }\n}\n\nint cnt1=0;\nint cnt2=0;\nfor(int i=0;i<size;i++){\n    if(k1>0&&nums[i]==target_num1){\n        cnt1++;\n    }else if(k2>0&&nums[i]==target_num2){\n        cnt2++;\n    }\n}\nif(cnt1>n/3){\n    res.push_back(target_num1);\n}\nif(cnt2>n/3){\n    res.push_back(target_num2);\n}\n\n```\n\n\n\n\n### 分治算法专题\n1.IP地址验证合理性\n1. 对于 IPv4 地址，通过界定符 . 将地址分为四块->a；对于 IPv6 地址，通过界定符 : 将地址分为八块->b。（count(.)==4/count(:)==6/neither）\n    a. 对于 IPv4 地址的每一块，检查它们是否在 0 - 255 内，且没有前置零。\n    b. 对于 IPv6 地址的每一块，检查其长度是否为 1 - 4 位的十六进制数。\n\n2. 删除注释\n    分情况判断+用一个状态表明现在是否在注释内，主要是用于/* */情况\n    （1）题目中没有考虑/* 不属于注释的这种情况，因此每次遇到/* &&block= False 表示开始块注释，每次遇到*/&&block=True,表示结束块注释\n    （2）遇到//直接结束，因为//后面都是注释，而且不改变状态\n\n\n#### corner case的例子\nlc1363: 形成3的最大倍数\n思路： 判断sum之和\n1. %3==0， 那么返回res\n2. %3==1, 如果数组中有%3==1的数字那么直接删除； 否则删除两个%3==2的数字\n3. %3==2, 如果数组中有%3==2的数字那么直接删除； 否则删除两个%3==1的数字\n4. 易错点：结果可能包含前缀0，因此需要将前缀0去掉（000001/000000）；结果也可能只是“”， 那么直接返回“”， 而不是0\n\n\nlc旋转链表\n1.求size\n2. k=k%size; k=k-size,表示第k个节点是现在的头结点（k-1是新链表尾节点）\n3. 将头节点前面一个节点（k-1）的next置为null, 同时将当前链表的最后一个节点next指向头节点（利用在第二步变成环，可以减少找尾结点这一步）\n<font color=red>链表类似题一定要判断head是否为null, size是否为0或者1这种情况 </font>\n快慢指针删除链表的重复元素的时候，一定要记得将慢指针的next设置为null\n\nlc,加1\n在vector数组上+1\n- 一定要注意最后carry不为0的情况，需要在最开头插入一个数 digits.insert(digits.begin(),carry);\n- 应该使用tmp记录当前位的和。int tmp=digits[i]+carry;\n\nlc68. 文本左右对齐\n字符串相关的模拟题，主要是分情况讨论\n一个单词/最后一行/其他情况（spacecount, extraspace）\n\n其他corner case: \n- 1. 乘法可能会超出范围，可能需要使用long long型 （数据范围一定要注意是用long long还是int）\n- 2. 在进行寻找mid的时候left+(right-left)/2\n- 3. 一定要注意< <=，以及边界情况的例子，在微软（矩阵旋转）和字节（和滑动窗口的最大值）最开始取[0,k-1]以及压入一个元素 已经跌过两次坑了\n- lc220. 存在重复元素 III，一定要注意nums[i]-t可能超出整数的范围，因此需要使用long 或者longlong对nums进行强制转换\n\n\n#### 模拟题目\n1. 矩阵旋转90\n2. 螺旋矩阵 （使用分成4段（后面两段需要判断 left< right&& upper< down才可以），或者坐标移动+vis数组）\n3. 倒酒杯\n\n\n#### 总结\nok \n\n1. 二维差分数组常用在对数组中的某一个块的区域进行操作， 比如这道题的贴邮票， 对整块数组+1; 比如对0-k这段距离的数据都进行翻转\n\n2. 一个数比较大，但是它取模之后的结果不一定大,两种解决方案\n    1) 保存long long的结果\n    2) sum为定值的时候，一个数越接近sum的一半，乘积之后的结果越大\n\n    ```C++\n    if (abs(cur*2 - sum) < abs(best*2 - sum)) {\n        best = cur;\n    }\n    ```\n3. 负数和正数的向上向下取整不同\nMath.floor(2.6);    //2.0   floor地板 水平数轴向右取整\nMath.floor(-2.6);   //-3.0   floor地板 水平数轴向右取整\n\n\n","source":"_posts/leetcode/其他.md","raw":"---\ntitle: 其他问题\ncatogory:\n  - leetcode 题目汇总\ntags: 其他\ncategories:\n  - leetcode\ndate: 2021-11-13 17:22:38\n---\n\n#### 数组相关问题\n要将数字放在对应的位置上，使用原地交换的方式\n1. 旋转矩阵  这个好像不行，需要记录交换过来的值的同时，记录交换过来的下标\n2. 自然数数组的排序\n3. 奇数下标是奇数，偶数下标是偶数\n\n- 第一种方法，使用一个环来进行数据的交换\n- 第二种方法，每个数据与当前的数据进行交换，然后判断当前交换过来的数据应该放到的位置，重复这样的过程，知道当前交换过来的数是应该放置的数\n\n举个例子：\n//如果下标i应该放的数据是 i+1 index和value之间存在映射\n```C++\ntmp=a[i];\nwhile(a[i]!=i+1){\n    int next=a[tmp-1];\n    a[tmp-1]=tmp;\n    tmp=next;\n}\n\nwhile(a[i]!=i+1){\n    swap(a[i], a[a[i]-1]);\n}\n```\n\n4. 最大子矩阵的和转为最大子数组的和，枚举每一行开始  i从0 ~ n-1,每次换开始的时候重新初始化数组s; j从i ~ n-1\n二维转为一维\n```C++\nfor(int i=0;i<matrix.size();i++){ //枚举row1\n    int s[matrix[0].size()];\n    for(int j=i;j<matrix.size();j++){ //枚举row2\n        int cur=0;//从头开始\n        for(int k=0;k<matrix[0].size();k++){ //转为最大子数组和\n            s[k]+=matrix[j][k];\n            cur+=s[k]; //利用之前加的值，加上现在的值\n            res=max(res, cur);\n            if(cur<0){\n                cur=0;\n            }\n        }\n    }\n}\n```\n\n5. 边界都是1的最大正方形：\n这种问题先想个暴力算法，然后考虑如何用空间换时间，加速判断的过程\n- 1.先循环，找到每个点的right down数组，注意边界要单独赋值，从右往左，从下网上计算\n- 2.遍历size（最开始初始化为m.size()和m[0].size()的最小值）, 每个size下遍历每个点，看左右边长以及右上角和左下角的right down是否都大于size,\n如果是返回true,否则返回false\n\n\n6. 数组partition的调整\n使用双指针，一个指针指向排序好的末尾，一个指针指向待排序序列的头结点\n```C++\nint left=0;\nint right=1;\nwhile(right<length){\n    if(arr[left]!=arr[right]){\n        left++;\n        swap(arr[left], arr[right]);\n        right++;\n        \n    }\n}\n```\n\n此类型的拓展问题，红蓝白球的排序，以及 0 1 2的排序\n解决方案：记录一个左节点（初始化-1）右节点（length）中间节点：\n```C++\nint left=-1;\nint right=length;//排好序的头\nint index=0;\nwhile(index<right){\n    if(arr[index]==0){\n        swap(arr[++left], arr[index]);\n        index++;\n    }else if(arr[index]==2){\n        swap(arr[--right], arr[index]);//注意这种情况index还要继续判断，因此不能index++\n    }else{\n        index++;\n    }\n}\n\n```\n\n7. 网格中的最短路径和最短通路问题：\n- 1.一定要分清楚是用dp还是bfs\n- 2.如果是只能从左上往右下走，那么是dp,否则应该用bfs,同时因为是路径，因此需要一个额外的二维数组判断到当前节点需要的步数，或者另外申明一个node,\n这个node里面记录到这个节点的步数\n\n\n<font color=red>8. 缺失的第一个正数： /引申缺失的最大负数（原位hash或者置换）</font>\n- 方法一：如何在原数组上进行hash,但是保留那个位置的数不变使用- 符号；(负数 0全部变为size)\n  同时如果原来有符号，那么为了避免混淆，将原来为符号的数变为我们不关心的正数\n- 方法二：使用置换的方式，这种方式一定要注意进入死循环的方式因此在交换的时候判断。nums[nums[i]-1]!=nums[i]\n\n\n\n##### random类似题目总结：\n\nrand5 to rand7\nrand01p to rand6\nrand1toM to rand1toN\n\n```C++\n1）  二维的方式，使得两个调用rand5在二维矩阵上是大于rand7，然后就可以选取7的倍数的一段距离对rand7取模\n    do{\n        row=rand5()-1;\n        col=rand5()-1;\n        num=row*5+col //0-24之间\n    }while(num>=21)\n\n    return num%7+1;\n\n```\n2)\n首先等概率产生0-1  01 10是等概率残生的\n```C++\nint rand01(){\n    do{\n        num=rand01p();\n    }while(num==rand01p());\n    return num;\n}\n\n那么rand03=rand01()*2+rand01();\nrand0-15=rand03()*4+rand03(); //倍数+插空  用进制的方法可以产生rand07()=rand03()+rand01()*4\n那么rand6可由如下产生:\ndo{\n    num=rand0-15;\n}while(num>=12)\nreturn num%6+1;\n```\n\n3）k维的方式\nrand1toM()转为rand1toN()其实就是调用k次（用N的M进制可以求得）的rand1toM, 使得这a* M^(k-1)+b* M^(k-2)+……  +c 比n要小， 然后返回就可以了\n其实就是用M进制的数来表示N-1，如果随机生成的数是大于N，那么从头进行生成（注意是从头，而不是从当前数重新生成），否则返回这个数\n步骤：\n   1、将n-1转换成m进制数，假设结果转换成数组为 k = [a,b,c,d,e]\n　　2、使用rand1ToM(m)函数产生结果数组 res = [A,B,C,D,E]，如果res所表示的数值大于k所表示的数值，将res丢掉重新随机，直到产生的结果小于或等于k，这时产生的res的范围就在0～n-1之间，但是此时res所表示的数还是m进制的。 //随机生成M进制的每一位数\n　　3、将res数组转换成10进制整数。\n　　4、将步骤3的结果加1就是最终的结果。\n\n\n##### 数学相关问题\n1. 求num阶层中最后的包含0的个数，因为包含因子2的个数一定比5多，因此可以直接求包含因子5的个数\n每5个数有一个5，每25个数中有一个数包含两个5\n同样下面的模板可以用于求任何因子的个数\n```C++\nint func(int num){\n    int res=0;\n    while(num){\n        res+=num/5;\n        num=num/5;\n    }\n    return res;\n}\n```\n<font color=blue>2. 判断一个点是否在矩形中：叉乘+点乘</font>\n对角向量叉积的点积>=0,（对角向量的叉积方向相同），使用叉积的原因是：一个点在线外还是在线内，叉积的正负不同\n使用叉积可以判断方向，A = <a1, a2>，B = <b1, b2>\nAXB=a1* b2-a2 *b1, 叉积向量的方向为法线的方向，上下为第一个向量指向第二个向量，大手指的方向\n叉乘加内积\n\n(p1 p2 X p1 p ) * (p3 p4 X p3 p1)  >= 0  （四个边分成两组，每两个对边一组， 看两边的叉积是否同方向）\n\n<font color=blue>3. 相同的题型：判断点是否在三角形中 叉乘</font>\n1）先判断三个点的顺序是否是逆时针方向:逆时针方向叉积小于0；顺时针方向叉积大于等于（注意顺序可能导致结果不同！！！）；如果是顺时针正方向，那么调整点位置\n2）然后判断这个点x是否都是在三角形每条边的左边，判断过程：三角形每个顶点和边的叉积小于0\n\n（逆时针，点左侧；判断逆时针，仍然使用点左侧）\n\n求三个三角形不推荐，因为double类型可能出现误差\n\n\n<font color=red>4. 路径数组转为统计数组的题目：原地hash, 注意以负数作为标记的话，全部的数都需要转为正数</font>\n要求额外的空间复杂度为O(1)\n如果要实现空间复杂度为O(1),那么需要在原来的数据上进行运算，那么每个位置存储跳过来的位置（最开始节点存储为-1），直到当前的数为一个负数（表示已经求过距离），然后跳回去的时候就知道来的位置，同时更新当前的距离，\n为了区分已经判断过的值和未判断过的值，使用负数；求到距离矩阵之后再计算每个距离出现的次数，仍然是使用跳的方式，开始节点记得赋值为0，表示已经访问计算过\n\n这种方式也出现在”第一个未出现的正数“这道题解决方案中（值与下标相互映射）\n\n\n5. 正数数组的最小不可组成和：\ndp[0][0]=1\n使用动态规划\nfor j=0; j=arr.size(); j++:\n    for i = sum to min: //注意反着,因为一个数只能取一次0-1背包\n        if(i>=arr[j]):\n            dp[i]=dp[i-arr[j]]?True:dp[i]//注意是dp[i]而不是false,也不是dp[i]=dp[i-arr[i]]//因为可能一个数一种方式可以组成，但是另一种不行\n\nPS:没有思路就想暴力算法，然后递归考虑是否能转为动态规划，类似背包问题\n```C++\ndp[i][j]=dp[i-1][j-arr[i]]||dp[i-1][j];\n\nfor i in min to sum:\n    if dp[n][i] == false:\n        return i\n```\n\n6. 累加出整个范围最少还需要的数:\n使用当前可以累加得到的范围，如果范围超过了当前遍历到的arr的第一个数，那么下一个可以累加得到的范围是当前的范围+arr[i];否则下一个差的数应该是touch+1,可以累加得到的数是touch+1+touch\n\n可以累加得到的数是touch,下一个差的数是touch+1\n```C++\ntouch=0;\ncnt=0;\nfor(int i=0;i<arr.size();i++){\n    if(touch+1<arr[i]){\n        while(touch<arr[i]+1){//注意这是循环\n            touch+=touch+1;\n            cnt++;\n            if(touch>=range){\n                return cnt;\n            }\n        }\n    }else{\n        touch+=arr[i];\n        if(touch>=range){\n            return cnt;\n        }\n    }\n}\nwhile(touch<range){\n        touch+=touch+1;\n        cnt++;    \n}\n\n    return cnt;\n```\n\n7. 一种字符串和数字对应的关系 （lc168. Excel表列名称）\nA -> 1\nB -> 2\nC -> 3\n...\nZ -> 26\nAA -> 27\nAB -> 28 \n从 1开始的的 2626 进制转换题。（每一位至少都有1）\n- 方法1：\n```C++\nstring res=\"\";\nwhile(columnNumber>0){\n    columnNumber--;\n    res+=(columnNumber%26+'A');\n    columnNumber/=26;\n}\nreverse(res.begin(), res.end());\nreturn res;\n```\n\n- 方法2：注意是K伪进制数，也就是每一个伪至少为1不能为0，因此需要先从右往左计算位数（同时每一位分得1, 因为这个规则每一位至少都有1），然后从左往右分剩下的数字 \n\n```C++\n//先从右往左，减掉一轮，再从左往右看补在哪为 进制如果为3：base=1 3 9\nvoid int2str(){\n    cur=1;//代表进制的基数\n    k=0//代表位数\n    base=3//代表进制数，多少个字符就是多少进制\n    while(n>=cur){\n        k++;\n        n-=cur;\n        cur*=base;\n    }\n\n    int index=0;\n    while(k){\n        cur/=base;\n        res[index++]=getchar(n/cur);  //当前base的数量应该为n/cur+1,对应的下标就是n/cur\n        n=n%cur; //剩下的数可以分多少到下一个进制位中\n        k--;\n    }\n}\n```\n\n\nstr2int类似于K进制\n\n从N个数中等概率打印M个数,空间复杂度为O(1)：将每次打印的数每次交换到整个数组的末尾，然后下次在生成随机数的时候，减少生成范围（1，n-count）\n\n\n\n\n8. 数字的中文表达和英文表达：\n- 1.中文表达：对于零特殊处理\n- 2.英文表达：每三个一组进行处理；使用递归或者迭代。递归方式就是分别求出billion million和thousand三个部分的数字，然后加起来，\n在求每个部分的时候，先判断百位，如果百位有数字的话，那么加上”hundred“,否则分为数字<=10 <20; <=20 <100 and <10 三种情况进行处理\n\n\n9. 实现sqrt函数\n- 方法一：使用二分算法（一个数的平方根不会大于 n/2+1），标准二分，返回right\n\n- 方法二：牛顿迭代算法： y=f(x0)+k(x-x0)\n令y=0, 得到 x_i+1=(x_i+ C/x_i)  其中C为要求的目标\n```C++\nclass Solution {\npublic:\n    int mySqrt(int x) {\n        if (x == 0) {\n            return 0;\n        }\n\n        double C = x, x0 = x;\n        while (true) {\n            double xi = 0.5 * (x0 + C / x0);\n            if (fabs(x0 - xi) < 1e-7) {\n                break;\n            }\n            x0 = xi;\n        }\n        return int(x0);\n    }\n};\n```\n\n10. 小数的十进制转为二进制是*2 取整数部分，如果整数>=1, 那么num-=1,否则当前位为0， 直到num=0; 也可以1连除2，num如果num>base,那么减去base\n十进制整数转换为二进制整数采用\"除2取余，逆序排列\"法\n十进制小数转换成二进制小数采用\"乘2取整，顺序排列\"法\n\n\n11. 全排列问题，使用交换或者vis+回溯，一定要注意是否有重复的字符，如果有重复的字符，那么下一个交换或者选择的数，一定是当前没有选择的 （可以和当前自己位置进行交换）\n\n\n<font color=red>12. 树状数组例题：数字流的秩 线段树（平衡树+二叉搜索树，需要初始化4*n区间） 使用频繁更新数组的某一位（后面的位数也需要相应修改），以及求前缀和</font>\n线段树和树状数组的基本功能都是在某一满足结合律的操作(比如加法，乘法，最大值，最小值)下，O(logn)的时间复杂度内修改单个元素并且维护区间信息。不同的是，树状数组只能维护前缀“操作和”(前缀和，前缀积，前缀最大最小)，而线段树可以维护区间操作和。线段数组是真正的数，而树状数组只是一个数组\n\n树状数组主要是用于求前缀和，（改变原始然后求前缀和；差分数组适用于，某一段的元素被整体加上或者减去一个元素）\n- 区间查询：求index的前缀和其实就是不断将index的二进制数的最后一个一个1逐渐变为0 的数据对应的值相加；（x-(x&-x)）//不断地去掉二进制数最右边的一个1 （从x到=n）\n- 单点修改：更新一个index需要更新的其他下标的值相当于 不断加上最后一个1所代表的数字下标对应的值（x+(x&-x)）//从右边起一系列连续的1变为0，再把这一系列1的前一位0变为1,相当与最后一个1+1，导致连续进位\n其中存储值的下标从1开始，0下标主要是判断循环的终点，不被用来存储值 （从x到0）\n\n而且树状数组的下标从1开始，常用语频繁更新和频繁求前缀和\n```C++\n建立树状数组：\nint n;\nint a[1005],c[1005]; //对应原数组和树状数组\n//范围是[1,n]\nint lowbit(int x){\n    return x&(-x);\n}\n\nvoid updata(int i,int k){    //在i位置加上k\n    while(i <= n){\n        c[i] += k;\n        i += lowbit(i);\n    }\n}\n\nint getsum(int i){        //求A[1 - i]的和\n    int res = 0;\n    while(i > 0){\n        res += c[i];\n        i -= lowbit(i);\n    }\n    return res;\n}\n```\n树状数组如果输入有0， 那么所有的输入都应该向右边偏移以为（输入x，实际上对应x+1）\n\n例题：lc5999. 统计数组中好三元组数目\n这道题是求在一个数的左边，同时小于这个数的数量（数量题）\nlc307. 区域和检索 - 数组可修改\n- 这道题是，频繁的修改某个下标的元素值+同时求某个范围元素之间的元素和（值题目）\n- 数组的大小为arr的范围n， 下标对于树状数组的二进制下标\n- 需要先将num的值插入树状数组中， 然后更新的时候使用newvalue-ori[index]来更新当前节点后面的值，同时一定要记得更新ori[index]=newvalue !!!!\n- 一定要记得树状数组的下标是从1开始，但是num的下标从0开始；而且区间范围是两边闭合，所以求区间差的时候，left_index应该减1\n\n<font color=red>lc315. 计算右侧小于当前元素的个数（hard）</font>\n- 注意这道题数据可能为负数，因此需要对数据+10000+1 使数据shift到[1, +无穷]\n- 使用归并排序，每个i, j 那么num[i]+=j-i-1 (就是在i后面而且比nums[i]小的数的数量)\n归并排序易错点：需要使用索引数组,同时在进行归并的时候会修改索引数组，一定要记得复制一个新的数组出来，不能使用原来的数组；其次就是注意数组的范围，左右都闭合；归并排序还长用于计算逆序对\n\nlc493. 翻转对(hard)\n- 归并排序\n- 范围映射的树状数组（具体代码可见模板代码）\n\n\n13. 最佳直线，使用暴力枚举的方式， 三重循环\n    枚举直线两个起始端点(i, j)，后面遍历k是否在直线(i, j)上，在的话计算过得点个数进行更新， 最后判断这条直线上最多有多少个同点\n    时间复杂度：O(n^3)\n    空间复杂度：O(1)O(1)\n\n\n14. 枚举题：模式匹配问题，暂时未做，主要是通过a和b的数量来枚举a匹配的字符的长度和b字符的长度，主要是注意边界情况应该先于长度的枚举进行判断\n    example： pattern = \"abba\", value = \"dogcatcatdog\"\n    注意：pattern只包含字母\"a\"和\"b\"两种字符， 而且a或者b可以为空串， 而且a 与b映射的字符串不应该相等\n    lena lenb都为0; lena为0; lenb为0;lena lenb都不为0时， 他们映射的字符串不应该相等\n\n\n15. 大数相乘的题目\n- 使用第二个数的每一位数和第一个数相乘<< i 位，然后将求得的结果相加\n- 使用第一个数的每一位和第二个数相乘，更新结果的 arr[i+k]位\n\n16. 矩形覆盖面积： 公式为area1+area2-inter_area\ninter_area = max((最小 右上横坐标 - 最大左下横坐标), 0)* max(（最小右上纵坐标 -  最大左下纵坐标, 0)\n\n注意一定要和0进行比较\n\n\n16. 找众数II:\n- 使用hash算法\n- 使用摩尔投票算法\n\n找到超过 (n/3) 向下取整的数：数学证明这样的数最多2个，选两个数，如果当前的数都不等于前两个数，那么两个投票数都--\n这种投票算法同样适用于找到超过 n/2\n\n```C++\nclass Solution {\npublic:\n    vector<int> majorityElement(vector<int>& nums) {\n        vector<int> ans;\n        int element1 = 0;\n        int element2 = 0;\n        int vote1 = 0;\n        int vote2 = 0;\n\n        for (auto & num : nums) {\n            if (vote1 > 0 && num == element1) { //如果该元素为第一个元素，则计数加1\n                vote1++;\n            } else if (vote2 > 0 && num == element2) { //如果该元素为第二个元素，则计数加1\n                vote2++;\n            } else if (vote1 == 0) { // 选择第一个元素\n                element1 = num;\n                vote1++;\n            } else if (vote2 == 0) { // 选择第二个元素\n                element2 = num;\n                vote2++;\n            } else { //如果三个元素均不相同，则相互抵消1次\n                vote1--;\n                vote2--;\n            }\n        }\n\n        int cnt1 = 0;\n        int cnt2 = 0;\n        for (auto & num : nums) {\n            if (vote1 > 0 && num == element1) {\n                cnt1++;\n            }\n            if (vote2 > 0 && num == element2) {\n                cnt2++;\n            }\n        }\n        // 检测元素出现的次数是否满足要求\n        if (vote1 > 0 && cnt1 > nums.size() / 3) {\n            ans.push_back(element1);\n        }\n        if (vote2 > 0 && cnt2 > nums.size() / 3) {\n            ans.push_back(element2);\n        }\n\n        return ans;\n    }\n};\n\n```\n\n\n17. 为运算表达式计算优先级\n使用分治算法, 遍历表达式，找到运算符，将结果分成两个部分， 递归查找。类似二叉树的组成方式查找\n如果求具体的结果，那么需要使用vector将结果进行push_back,否则可以直接使用动态规划，计算总数\n\n\n18. 摆动序列 如果是需要相邻两个数不能等于的话，只能两个字符串都进行翻转，如果可以相邻等于的话，可以后面的字符串进行翻转就行了 \n\n\n19. 中文变为阿拉伯数字和阿拉伯数字变为中文\n    1.中文变为阿拉伯数字\n    使用栈，将文字划分为数字和量纲，遇到量纲，那么从栈中弹出与当前量纲小的数字与当前量纲相乘，然后不断累加，知道栈为空或者栈顶量纲比当前量纲大，然后将当前累加到的数压入栈中；最后的结果就是栈中的数求和\n\n    2.阿拉伯数字变为中文\n    注意：亿，万节之后如果只有0那么不需要输出0，如果千位为0的话那么需要输出0\n    10500，一万零五百， 15000一万五千\n    \n    将数组划分为节，然后每节使用一个函数判断\n    如果不是第一节，而且当前的数是大于0，而且小于1000的话那么需要加零\n\n\n20. 面试题 16.14. 最佳直线/149. 直线上最多的点数\n- 暴力方法：使用三重循环，前两个点固定一条直线，后一个点判断是否在直线上，是cnt++,最后找最大的cnt\n- hash方法，使用二重循环，遍历两个点，两个点得到一个斜率，然后hash_map中存储该斜率的cnt, 最后取最大值的时候res=max(res, cnt+1)//一定记得+1\n    因为gcd(5, 0)=5=cd(0, 5) 所以不存在除0情况\n```C++\nint a = x1 - x2, b = y1 - y2;\nint k = gcd(a, b);\nString key = (a / k) + \"_\" + (b / k); //斜率用string存储\n\nint gcd(int a, int b) {\n    return b == 0 ? a : gcd(b, a % b);\n}\n```\n\n21. 阶层之后的零\n-  方法1， 直接计算，n是5的倍数的个数+25倍数个数+...\n```C++\nint pow=5;\nwhile(n>=pow){\n    cnt+=n/pow;\n    pow=pow*5;\n}\nreturn cnt;\n```\n- 方法2， 对1-n中的每一个数计算，能够拆分为多少个5的因子\n```C++\nfor(int i=1;i<=n;i++){\nint tmp=i;\nwhile(tmp%5==0){\n    tmp=tmp/5;\n    cnt++;\n}\n```\n\n22. lc277. find-the-celebrity\n- 所有的人都认识名人，名人谁都不认识，找出名人\n- 假设法，O(n), 假设0是名人，如果遇到knows(0, i)==true, 说明0不是名人，同时说明[0~i-1]都不是名人，因为他们都不被0知道\n- 之后再判断一次，如果出现know(ans, i)==true||know(i, ans)==false, 返回-1\n\n\n\n\n #####  19.交换数据的位置\n（1）打标记方法： 这种方式理解起来更轻松, 注意这种方式，如果元数据中包含0或者小于0，但是目标数据中是大于0的([1, size])， 那可以将0，负数转为size+1; 否则如果元数据有0， 目标数据也有0的话，打标记是无法解决的\n\n1. 缺失的第一个正数 （用负号在原地打标记代替hash方法，或者用置换方法，一定要将负数和>size都转为size+1；同时对于target_index和当前index数据相同时，退出循环）\n2. 丢失的数字\n3. 数组中重复的数据\n\n将当前的数在对应的下标中打上标记，同时为了找到被覆盖数据的元数据，可以使用+n（这种可以找到重复3次， 4次都可以）,或者变为负数的这种做法\n但是变负数的这种方式，不能适用于含有0的这种情况，因为-0和0是一样的，无法判断是否出现过这个数字\n\n找到的条件是 nums[i]>=0 退出\n``` C++\n   int firstMissingPositive(vector<int>& nums) {\n        int n = nums.size();\n        for (int& num: nums) {\n            if (num <= 0) {\n                num = n + 1;\n            }\n        }\n        for (int i = 0; i < n; ++i) {\n            int num = abs(nums[i]);\n            if (num <= n) {\n                nums[num - 1] = -abs(nums[num - 1]);\n            }\n        }\n        for (int i = 0; i < n; ++i) {\n            if (nums[i] > 0) {\n                return i + 1;\n            }\n        }\n        return n + 1;\n    }\n\n```\n\n（2）置换\n1. 缺失的第一个正数 把数据放在对应的位置\n\n将当前的数放在当前数据对应的下标中\n\n找到的条件是 nums[i]！=i+1 退出\n```C++\n    int firstMissingPositive(vector<int>& nums) {\n        int n = nums.size();\n        for (int i = 0; i < n; ++i) {\n            while (nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i]) {\n                swap(nums[nums[i] - 1], nums[i]); //要和它交换的数不能等于它本身\n            }\n        }\n        for (int i = 0; i < n; ++i) {\n            if (nums[i] != i + 1) {\n                return i + 1;\n            }\n        }\n        return n + 1;\n    }\n```\n（3） 二分算法，查找小于mid的数据量，如果是大于mid的话说明重复的数小于等于mid,因此r=mid-1 and ans=mid(或者r=mid), 否则l=mid+1\n (4) 数组版快慢指针，index->nums[index] 那么有一个数会被指向两次，那么存在环\n - 映射找环法， 找冗余的数据，其实就是找环路的起点\n - https://segmentfault.com/a/1190000003817671\n ```C++\n class Solution {\n    public:\n        int findDuplicate(vector<int>& nums) {\n            int slow = 0, fast = 0;\n            do {\n                slow = nums[slow];\n                fast = nums[nums[fast]];\n            } while (slow != fast);\n            slow = 0;\n            while (slow != fast) {\n                slow = nums[slow];\n                fast = nums[fast];\n            }\n            return slow;\n        }\n    };\n ```\n\n4. lc 440和lc386 按照字典序排序，和按照字典序排序的第k个数字\n我们输入两个值n和k，n表示我们有从1到n个整数，然后将这些整数都字符串化之后按字典排序，找出其中第K大的。例如:n=15,k=5.那么1-15字符串化之后排序如下:1,10,11,12,13,14,15,2,3,4,5,6,7,8,9。其中第5大的就为13。\n实际上多叉树从到右进行计数\n\n每次求解二叉树相邻两个节点之间(base 和base+1)包含的数据，如果k>num那么直接更新k 然后当前数+1(base=base+1), 否则递归求里面的数据(base=base*10)\n\n\n<font color=red>20. 字符串相乘</font>\n- 模板代码：\n    ```C++ 关键代码\n    vector<int> res(size1+size2+1, 0);\n    reverse(num1.begin(), num1.end());\n    reverse(num2.begin(), num2.end());\n    for(int i=0;i<size1;i++){\n        for(int j=0;j<size2;j++){\n            res[i+j]=res[i+j]+(num1[i]-'0')*(num2[j]-'0');\n\n        }\n    }\n    ```\n- 知识点：字符ASCII码和数字的相互转换\n    char a='0'+81;\n    char b=a-81;\n    int c=a-'0';\n    cout<<a<< \" \"<<b<<\" \"<<c<<endl;\n    注意c最终打印的结果为-175, 而不是81！！！！ 所以在初始化字符串相乘的数组只能用int类型不能用string类型\n    char m='A'+1;//打印输出'B'\n\n- 初始化一个m+n的数组（注意一定要为int类型，不能为string类型），然后循环计算每一位应该的值，最后从低位到高位进行进位更新\n- 易错点：str1和str2需要翻转，之后的结果需要去前缀零以及翻转回来\n如果不翻转，那么nums1[i]和nums2[j]对应nums[i+j+1]的数组\n\n\n21. 分数到小数，模拟除法\n\n使用hash记录余数到下标的隐射，如果出现重复余数，说明出现了重复的小数循环体\n注意易错点：\n- 1.可能存在负数，但是不能直接对负数取反（因为可能为INT_MIN），需要转为long型\n    判断结果为负数使用异或\n    if (numeratorLong < 0 ^ denominatorLong < 0) {//异号为负数\n        sb.append('-');\n    }\n\n\n22. lc670. 最大交换\n- 一个数字交换一次，如何使得交换后的数最大 输入: 2736 输出: 7236\n- 先遍历字符串求得每个数最靠后的下标（因为小于当前的数，应该换到越靠后面越好）\n- 然后从左遍历每个数的时候，遍历 '9'到s[i]-'0'看是否有比当前数大的数，而且在这个数后面，如果有，那么交换，然后退出\n- 因为第二重循环只是从9到s[i]-'0'， 因此总的时间复杂度还是O(N)\n\n\n\n#### 分而治之专题\n\n1. 超级次方， 也类似观察规律的题目，就是在定义一种新的运算的时候，将它化简为熟知的运算。同时运用规律“对乘法的结果求模，等价于先对每个因子都求模，然后对因子相乘的结果再求模”\n不能直接使用系统自带的pow,只能自己实现pow因为，在求乘方过程随时会出现溢出，所以要为每一个中间结果取模\n\n2. 第K个语法符号\n找第n个的数的第k个字符是什么，转为找第n-1个数的对应f(k)位上面的数据（左半边不取反，右半边取反）\n易错点在：一个数的时候会add两次如何解决, 那么就在返回的时候，只有一个数的时候，说明出现了[[num, []]]的这种情况，那么直接return result.getInterger, 否则直接返回result\n\n#### 递归相关，表达式相关专题\n\n1. 迷你语法分析器： \n注意在进行递归的时候， 递归进去直接初始化一个NestInterger res, 来加入[]里面的数字， 遇到循环递归调用，然后返回时直接res.add\n另外一个易错点是，注意负数的处理\n\n\n#### 蓄水池抽样算法\n\n模板\n```C++\nclass Solution {\npublic:\n    Solution(ListNode* head) {\n        this->head=head;\n    }\n    \n    int getRandom() {\n        ListNode*cur=this->head;\n        int pool=-1;\n        int i=1;\n        while(cur){\n            if(rand()%i==0)pool=cur->val; //只选取一个数的情况\n            i++;\n            cur=cur->next;\n        }\n        return pool;\n    }\n\nprivate:\n    ListNode*head;\n};\n\n```\n\n例题：\n1. 链表随机节点\n2. 随机索引数 ，找到target数的随机一个index\n\n\n\n#### 并查集专题\n相关例题：\n\n除法求值：并查集的变形，除了要判断各个数字是否连通，还需添加一个数组记录节点之间的权重 weight(当前节点到其父节点的权重); 而且注意如何a/b那么应该是a的父亲节点是b, a指向b的权重为a/b, 反过来的话不对 **一定要注意这个权重的更新，应该为当前的权重 * 他原来父亲的现在的权重**\n\n易错点：\n- 在进行节点merge的时候一定要注意权重的更新，weight代表的是两个节点之间的权重，而不是一个节点到根节点的权重\n- find的时候返回的是father[a]而不是a !!!!!!\n- fa!=fb的时候应该是father[fa]=fb, 与两个孩子节点a b无关\n- 递归寻找father的时候，应该使用father[index]作为函数的参数而不是index(会陷入无限死循环中)\n- 在并查集的时候，可以直接使用string作为头节点，不一定要转为int类型  unordered_map<string, string> father; unordered_map<string, int>num\n例题：面试题 17.07. 婴儿名字\n- 可以使用string的find函数来对字符串进行分割（带括号或者，形式的分割）\n\n并查集模板：具体可见vscode里面的代码，两个模板 带size和不带size的情况\n\n\n例题2：lc947. 移除最多的同行或同列石头\n- 这个是二维坐标的，横坐标或者纵坐标相同都在一个并查集，因此需要将横纵坐标放在两个范围中，防止重叠；因为x, y在[0,1000]之间，一次你可以将横坐标放在+10001, 使得x y范围错开\n\n剑指 Offer II 111. 计算除法\n- 使用并查集或者BFS/DFS\n- 并查集注意分母为儿子（大），分子为父亲\n- BFS的时候正向，反向都要连接\n\n\n\n\n\n\n#### 图相关\n\n竞赛第四题 hard lc2097. 合法重新排列数对 //暂时没有看\n```C++\nclass Solution {\n    map<int, vector<int>> mp;\n    map<int, int> deg;\n    vector<vector<int>> ans;\n\n    void dfs(int sn) {\n        vector<int> &e = mp[sn]; // 注意这个是引用\n        while (!e.empty()) {\n            int fn = e.back();\n            e.pop_back();\n            dfs(fn);\n            ans.push_back(vector<int>{sn, fn});\n        }\n    }\n    //为什么要先dfs再push_back没看明白\n\npublic:\n    vector<vector<int>> validArrangement(vector<vector<int>>& pairs) {\n        for (auto &pair : pairs) {\n            mp[pair[0]].push_back(pair[1]);\n            deg[pair[0]]--; deg[pair[1]]++;\n        }\n        for (auto it = deg.begin(); it != deg.end(); it++) if (it->second == -1) dfs(it->first);\n        if (ans.empty()) dfs(deg.begin()->first);\n        reverse(ans.begin(), ans.end());\n        return ans;\n    }\n};\n\n```\n\n\n##### 有关于有向图和无向图的最短路径，以及有负边和无负边的最短路径\n\n1. Dijstra算法，适用于单源，有向或者无向的最短路径，不能适用于有负边（注意不是负环，负环情况下，无最短路径）的情况：例子：-1， -5， 2\n时间复杂度O(n^2))\n```C++\n#define INF 0x3f3f3f3f\n\nint e[Max][Max];//e[i][j]代表从i->j的距离，不通设为无穷大\nint dis[Max];//dis[i]代表从起点到i的最短距离\nbool book[Max];//book[i]代表点i是否在S中\nint n;//n个顶点\nint s;//起点\n\nvoid Dijkstra()\n{\n    for(int i=1;i<=n;i++)//初始化dis数组\n        dis[i]=e[s][i];\n\n    for(int i=1;i<=n;i++)//初始化book数组\n        book[i]=0;\n    dis[s]=0;\n    book[s]=1;\n\n    for(int i=1;i<=n-1;i++)//Dijkstra算法核心语句  注意也是n-1次\n    {\n        int minDis=INF;\n        int k;//找到与s最近的顶点k\n        for(int j=1;j<=n;j++)\n        {\n            if(book[j]==0 && dis[j]<minDis)\n            {\n                minDis=dis[j];\n                k=j;\n            }\n        }\n        book[k]=1;\n\n        for(int j=1;j<=n;j++)//“松弛”过程\n        {\n            if(e[k][j]<INF)\n            {\n                if(dis[j]>dis[k]+e[k][j])\n                    dis[j]=dis[k]+e[k][j];\n            }\n        }\n    }\n}\n```\n\n2. Bellman-ford算法：适用于单源，可有负权，有向或者无向的最短路径 记住只松弛n-1次\n能够检测出有负环情况\ndp[i][dst]=min(dp[i][dst], dp[i-1][src]+dist[src][dst]) i==1的时候表示经过的中转站为0\n\n时间复杂度O(n*m)/O(VE)\n\n```C++\n#define INF 0x3f3f3f3f\n\nstruct Edge{\n    int u;//起\n    int v;//终\n    int weight;//长度\n};\n\nEdge edge[maxm];//用来存储所有的边\nint dis[maxn];//dis[i]表示源点到i的最短距离\nint n,m;//n个点，m条边\nint s;//源点\n\nbool Bellmen_ford()\n{\n    for(int i=1;i<=n;i++)//初始化\n        dis[i]=INF;\n\n    dis[s]=0;//源节点到自己的距离为0\n\n    for(int i=1;i<n;i++)//松弛过程，计算最短路径 \n    {\n        for(int j=1;j<=m;j++) //m条边\n        {\n            if(dis[edge[j].v]>dis[edge[j].u]+edge[j].weight)//比较s->v与s->u->v大小\n                dis[edge[j].v]=dis[edge[j].u]+edge[j].weight;\n        }\n    }\n\n    for(int j=1;j<=m;j++)//判断是否有负边权的边\n    {\n        if(dis[edge[j].v]>dis[edge[j].u]+edge[j].weight)\n            return false;\n    }\n\n    return true;\n}\n```\n\n\n3. SPFA算法：是Bellman-ford算法的队列优化，适用于单源，可有负权，有向或者无向的最短路径 （自身其实无法处理负权）  \n设立一个队列用来保存待优化的点，优化时每次取出队首结点u，并且用u点当前的最短路径估计值对u点所指向的结点v进行松弛操作，如果v点的最短路径估计值有所调整，且v点不在当前的队列中，就将v点放入队尾。这样不断从队列中取出结点来进行松弛操作，直至队列空为止。\n\n注意，一旦从队列中弹出来，vis就设置为false，感觉负权的情况就会一直循环下去，不会跳出；遍历点，与边无关\n```C++\n#define INF 0x3f3f3f3f\n\nint dis[MAX];//dis[i]表示起点到i的最短距离\nbool vis[MAX];//是否访问过点i\nint e[MAX][MAX];//矩阵\n\nint n,m;//点和边的数量\nint s;//源点\n\nvoid SPFA()\n{\n    for(int i=1;i<=n;i++)//初始化\n    {\n        dis[i]=INF;\n        vis[i]=false;\n    }\n    queue<int> q;\n    q.push(s);\n    dis[s]=0;\n    vis[s]=true;\n\n    while(!q.empty())\n    {\n        int cur=q.front();\n        q.pop();\n        vis[cur]=false;\n        for(int i=1;i<=n;i++) //遍历每一个节点\n        {\n            if(e[cur][i]!=INF&&dis[i]>=dis[cur]+e[cur][i])\n            {\n                dis[i]=dis[cur]+e[cur][i];\n                if(!vis[i])\n                {\n                    vis[i]=true;\n                    q.push(i);  ///之后将start缩小的边才拿出来\n                }\n            }\n        }\n    }\n}\n```\n\n4. Floyd算法： Floyd算法是一种利用动态规划思想的计算加权图中多源点之间最短路径的算法。可以正确处理有向图或负权的最短路径问题。\n\n时间复杂度：O(N^3）\n\n空间复杂度：O(N^2）\n\n处理问题：多源、可有负权、有向图、无向图最短路径 \n```C++\nint e[Max][Max];//e[i][j]代表从i->j的距离，不通设为无穷大\nint n;//n个顶点\n//Floyd算法\nvoid Floyd()\n{\n    for(int k=1;k<=n;k++)//遍历所有的中间点\n    {\n        for(int i=1;i<=n;i++)//遍历所有的起点\n        {\n            for(int j=1;j<=n;j++)//遍历所有的终点\n            {\n                if (e[i][j]>e[i][k]+e[k][j])//如果当前i->j的距离大于i->k->j的距离之和\n                    e[i][j]=e[i][k]+e[k][j];//更新从i->j的最短路径\n            }\n        }\n    }\n}\n```\n\n最短路衍生拓展的一类题目：\n1. 最长路径问题：\n图不为非负权图：当存在正环时无解。\n如果不存在正环，边权取负后使用Bellman-Ford算法求最短路。\n2. 最长路径，但是路径的计算是权重之间的乘积，而且权重都是0-1之间的值，使用Dijstra算法 （e.g概率最大的路径）\nSolution: \n    单独使用Dijstra会导致超时，因此需要结合Dijstra+优先队列\n    1.现将src点push 到堆进行\n    2.然后遍历堆中的每个节点，如果当前节点能够松弛它的邻接节点，那么就放入堆中，否则不放入类似于SPFA,但是不同的是，\n    - 这个使用的优先队列，而SPFA是用的是一般的堆\n    - 这个不仅仅push了节点，也push了当前节点的最大概率，因此没有vis数组来标记当前节点是否在堆中，因为即使在堆中， 概率也可能是不一样的。\n    总的来说这道题使用bellman-ford算法更简单，只要当前没有任何松弛的边，那么直接退出循环\n\n颜色交替的最短路径：使用bellman-ford算法（本质是动态规划）， 只是在距离的转换是需要讨论两种情况\ndstEndWithRed[end]=min(dstEndWithRed[end], dstEndWithBlue[start]+1);\ndstEndWithBlue[end]=min(dstEndWithBlue[end], dstEndWithRed[start]+1);\n```C++\nfor(int i=0;i<n-1;i++){\n    for(auto edge: redEdges){\n        int start=edge[0];\n        int end=edge[1];\n        dstEndWithRed[end]=min(dstEndWithRed[end], dstEndWithBlue[start]+1);\n    }\n    for(auto edge: blueEdges){\n        int start=edge[0];\n        int end=edge[1];\n        dstEndWithBlue[end]=min(dstEndWithBlue[end], dstEndWithRed[start]+1);\n    }\n}\n```\n3. 成语接龙的最长，使用bfs，同时对连接好的成语，再来一次bfs (微软三面)\n\n<font color=red>4. lc787. K 站中转内最便宜的航班</font>\n- 只能最多经过k个中转站的最短路径\n- 使用bellman-ford算法，k个中转站就是松弛每条边 k+1次(1~k+1)，然后使用dp[i][dst]记录 中转i次的最短路径\n最后的结果就是在dp[1][dst] 到dp[k+1][dst]中取最小的一个\n\nlc6134. 找到离给定两个节点最近的节点\n- 内向基环树\n- 求出node1 到每个点的距离， 和node2 到每个点的距离，然后取最小 (两次求距离，然后取最小，最后注意返回的是最近的下标，而不是最近的距离)\n\nPS, 最开始理解的时候，感觉应该用两个节点的最近公共祖先来解决，但是因为图中可能有环，所以不能使用最近公共祖先的栈或者dfs方法解决\n\n### 前缀和和差分数组相关\n一般是有关于矩阵的一维前缀和， 二维前缀和， 一维差分数组和二维差分数组\n如果要计算差分数组和前缀和数组最好是将坐标转为 1-n，更好计算；不然sum i j对应的grid为i-1,j-1\n\n\n一维差分数组中，如果数组中一段数据加上或者减去某一个元素，在差分数组中只有两头的元素进行了修改，中间的元素都没有修改\n二维差分数组中，如果包含左上角（x1, y1）, 右下角（x2, y2）这一部分都+C, 那么对应的差分数组d[x1][y1]+c d[x2+1][y2+1]+c d[x1][y1+1]-c d[x2+1][y1]-c\n(上升的对角线两端元素-c, 下降的对角线元素+c)\n\n二维差分数组公式:\nnums[i][j]-nums[i-1][j]-nums[i][j-1]+nums[i-1][j-1]=d[i][j]\n从差分数组还原原来的数组\nnums[i][j]=nums[i-1][j]+nums[i][j-1]-nums[i-1][j-1]+d[i][j]\n\n\n\n例题：\n1. 5931. 用邮票贴满网格图 (hard-周赛题目)\n\n方法一: 使用二维前缀和，对原来矩阵中每个左上角为0，且邮票区域都为0的位置（二维区域前缀和为0），贴上邮票，为了减少贴这个过程的时间开销，使用二元差分数组\n贴完后，对二元差分数组进行还原，如果仍然遇到为0的位置，那么返回false\n注意这道题没必要求差分数组，差分数组可以全部直接初始化为0， 那么还原回来的也是填充数组\n方法二: 不使用二维差分数组，使用另外一个数组，标记贴邮票的左上角，然后针对每个grid中为0的位置，计算邮票部分区域（注意是贴了邮票的矩阵，是另一个矩阵）的前缀和，如果为0，表示这个区域没有被贴上邮票，返回false\n\n2. 航班预订统计 (middle)\n一维差分数组的题目\n如果原来数组的下标就是1-n的话，那么修改n-m部分的数据， 就会修改等差数列的d[n]和d[m+1]两个端点的数据\n\n\n3. 拼车\n这道题类似于天际线问题，使用hash, 左断点加入m个人，右端点减去m个人\n然后遍历hash的每个key,如果有个时刻是大于capacity, 那么返回false\n\n4. lc995. K 连续位的最小翻转次数（hard）\n- 从左到右遍历，遇到0就进行翻转，使用差分数组进行假意翻转，通过presum累加来求得当前翻转的次数\n\n### 前缀异或值\n在求前缀异或的时候，结果数组可以从1开始取，这样的话就不用对边缘单独进行赋值操作\n```C++\nfor (int i = 1; i <= m; ++i) {\n    for (int j = 1; j <= n; ++j) {\n        pre[i][j] = pre[i - 1][j] ^ pre[i][j - 1] ^ pre[i - 1][j - 1] ^ matrix[i - 1][j - 1];\n        results.push_back(pre[i][j]);\n    }\n}\n```\n\n\n### 分类讨论题\n1.  K 次串联后最大子数组之和\n分类分析\nk=1;\nk=2;\nk>2 如果array之和小于0，那么结果就是k=2情况，否则k=2+(k-2)*sum(one array)\n\n\n#### 摩尔投票算法\n1.求众数\n```C++\nint k=0;\nint target_num=0;\nfor(int i=0;i<size;i++){\n    if(k==0){\n        target_num=nums[i];\n        k=1;\n    }else{\n        if(nums[i]==target_num){\n            k++;\n        }else{\n            k--;\n        }\n    }\n}\n\n//判断target_num的数是否大于n/2;\nint cnt=0;\nfor(int i=0;i<size;i++){\n    if(nums[i]==target_num){\n        cnt++;\n    }\n}\nif(cnt>n/2){\n    return target_num;\n}\n```\n\n2.求大于n/3 的数\n这样的数最多只有两个\n```C++\nint k1=0;//投票的数量\nint k2=0;\nint target_num1;//具体的数\nint target_num2;\nfor(int i=0;i<size;i++){\n    if(k1>0&&target_num1==nums[i]){\n        k1++;\n    }else if(k2>0&&target_num2==nums[i]){\n        k2++;\n    }else if(k1==0){\n        target_num1=nums[i];\n        k1=1;\n    }else if(k2==0){\n        target_num2=nums[i];\n        k2=1;\n    }else{\n        k1--;\n        k2--;\n    }\n}\n\nint cnt1=0;\nint cnt2=0;\nfor(int i=0;i<size;i++){\n    if(k1>0&&nums[i]==target_num1){\n        cnt1++;\n    }else if(k2>0&&nums[i]==target_num2){\n        cnt2++;\n    }\n}\nif(cnt1>n/3){\n    res.push_back(target_num1);\n}\nif(cnt2>n/3){\n    res.push_back(target_num2);\n}\n\n```\n\n\n\n\n### 分治算法专题\n1.IP地址验证合理性\n1. 对于 IPv4 地址，通过界定符 . 将地址分为四块->a；对于 IPv6 地址，通过界定符 : 将地址分为八块->b。（count(.)==4/count(:)==6/neither）\n    a. 对于 IPv4 地址的每一块，检查它们是否在 0 - 255 内，且没有前置零。\n    b. 对于 IPv6 地址的每一块，检查其长度是否为 1 - 4 位的十六进制数。\n\n2. 删除注释\n    分情况判断+用一个状态表明现在是否在注释内，主要是用于/* */情况\n    （1）题目中没有考虑/* 不属于注释的这种情况，因此每次遇到/* &&block= False 表示开始块注释，每次遇到*/&&block=True,表示结束块注释\n    （2）遇到//直接结束，因为//后面都是注释，而且不改变状态\n\n\n#### corner case的例子\nlc1363: 形成3的最大倍数\n思路： 判断sum之和\n1. %3==0， 那么返回res\n2. %3==1, 如果数组中有%3==1的数字那么直接删除； 否则删除两个%3==2的数字\n3. %3==2, 如果数组中有%3==2的数字那么直接删除； 否则删除两个%3==1的数字\n4. 易错点：结果可能包含前缀0，因此需要将前缀0去掉（000001/000000）；结果也可能只是“”， 那么直接返回“”， 而不是0\n\n\nlc旋转链表\n1.求size\n2. k=k%size; k=k-size,表示第k个节点是现在的头结点（k-1是新链表尾节点）\n3. 将头节点前面一个节点（k-1）的next置为null, 同时将当前链表的最后一个节点next指向头节点（利用在第二步变成环，可以减少找尾结点这一步）\n<font color=red>链表类似题一定要判断head是否为null, size是否为0或者1这种情况 </font>\n快慢指针删除链表的重复元素的时候，一定要记得将慢指针的next设置为null\n\nlc,加1\n在vector数组上+1\n- 一定要注意最后carry不为0的情况，需要在最开头插入一个数 digits.insert(digits.begin(),carry);\n- 应该使用tmp记录当前位的和。int tmp=digits[i]+carry;\n\nlc68. 文本左右对齐\n字符串相关的模拟题，主要是分情况讨论\n一个单词/最后一行/其他情况（spacecount, extraspace）\n\n其他corner case: \n- 1. 乘法可能会超出范围，可能需要使用long long型 （数据范围一定要注意是用long long还是int）\n- 2. 在进行寻找mid的时候left+(right-left)/2\n- 3. 一定要注意< <=，以及边界情况的例子，在微软（矩阵旋转）和字节（和滑动窗口的最大值）最开始取[0,k-1]以及压入一个元素 已经跌过两次坑了\n- lc220. 存在重复元素 III，一定要注意nums[i]-t可能超出整数的范围，因此需要使用long 或者longlong对nums进行强制转换\n\n\n#### 模拟题目\n1. 矩阵旋转90\n2. 螺旋矩阵 （使用分成4段（后面两段需要判断 left< right&& upper< down才可以），或者坐标移动+vis数组）\n3. 倒酒杯\n\n\n#### 总结\nok \n\n1. 二维差分数组常用在对数组中的某一个块的区域进行操作， 比如这道题的贴邮票， 对整块数组+1; 比如对0-k这段距离的数据都进行翻转\n\n2. 一个数比较大，但是它取模之后的结果不一定大,两种解决方案\n    1) 保存long long的结果\n    2) sum为定值的时候，一个数越接近sum的一半，乘积之后的结果越大\n\n    ```C++\n    if (abs(cur*2 - sum) < abs(best*2 - sum)) {\n        best = cur;\n    }\n    ```\n3. 负数和正数的向上向下取整不同\nMath.floor(2.6);    //2.0   floor地板 水平数轴向右取整\nMath.floor(-2.6);   //-3.0   floor地板 水平数轴向右取整\n\n\n","slug":"leetcode/其他","published":1,"updated":"2023-07-10T10:36:19.535Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clk5ceinf000ajpjb97cs8fcx","content":"<h4 id=\"数组相关问题\"><a href=\"#数组相关问题\" class=\"headerlink\" title=\"数组相关问题\"></a>数组相关问题</h4><p>要将数字放在对应的位置上，使用原地交换的方式</p>\n<ol>\n<li>旋转矩阵  这个好像不行，需要记录交换过来的值的同时，记录交换过来的下标</li>\n<li>自然数数组的排序</li>\n<li>奇数下标是奇数，偶数下标是偶数</li>\n</ol>\n<ul>\n<li>第一种方法，使用一个环来进行数据的交换</li>\n<li>第二种方法，每个数据与当前的数据进行交换，然后判断当前交换过来的数据应该放到的位置，重复这样的过程，知道当前交换过来的数是应该放置的数</li>\n</ul>\n<p>举个例子：<br>//如果下标i应该放的数据是 i+1 index和value之间存在映射</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">tmp=a[i];<br><span class=\"hljs-keyword\">while</span>(a[i]!=i+<span class=\"hljs-number\">1</span>)&#123;<br>    <span class=\"hljs-keyword\">int</span> next=a[tmp<span class=\"hljs-number\">-1</span>];<br>    a[tmp<span class=\"hljs-number\">-1</span>]=tmp;<br>    tmp=next;<br>&#125;<br><br><span class=\"hljs-keyword\">while</span>(a[i]!=i+<span class=\"hljs-number\">1</span>)&#123;<br>    <span class=\"hljs-built_in\">swap</span>(a[i], a[a[i]<span class=\"hljs-number\">-1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li><p>最大子矩阵的和转为最大子数组的和，枚举每一行开始  i从0 ~ n-1,每次换开始的时候重新初始化数组s; j从i ~ n-1<br>二维转为一维</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;matrix.<span class=\"hljs-built_in\">size</span>();i++)&#123; <span class=\"hljs-comment\">//枚举row1</span><br>    <span class=\"hljs-keyword\">int</span> s[matrix[<span class=\"hljs-number\">0</span>].<span class=\"hljs-built_in\">size</span>()];<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j=i;j&lt;matrix.<span class=\"hljs-built_in\">size</span>();j++)&#123; <span class=\"hljs-comment\">//枚举row2</span><br>        <span class=\"hljs-keyword\">int</span> cur=<span class=\"hljs-number\">0</span>;<span class=\"hljs-comment\">//从头开始</span><br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> k=<span class=\"hljs-number\">0</span>;k&lt;matrix[<span class=\"hljs-number\">0</span>].<span class=\"hljs-built_in\">size</span>();k++)&#123; <span class=\"hljs-comment\">//转为最大子数组和</span><br>            s[k]+=matrix[j][k];<br>            cur+=s[k]; <span class=\"hljs-comment\">//利用之前加的值，加上现在的值</span><br>            res=<span class=\"hljs-built_in\">max</span>(res, cur);<br>            <span class=\"hljs-keyword\">if</span>(cur&lt;<span class=\"hljs-number\">0</span>)&#123;<br>                cur=<span class=\"hljs-number\">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li><p>边界都是1的最大正方形：<br>这种问题先想个暴力算法，然后考虑如何用空间换时间，加速判断的过程</p>\n</li>\n</ol>\n<ul>\n<li>1.先循环，找到每个点的right down数组，注意边界要单独赋值，从右往左，从下网上计算</li>\n<li>2.遍历size（最开始初始化为m.size()和m[0].size()的最小值）, 每个size下遍历每个点，看左右边长以及右上角和左下角的right down是否都大于size,<br>如果是返回true,否则返回false</li>\n</ul>\n<ol start=\"6\">\n<li>数组partition的调整<br>使用双指针，一个指针指向排序好的末尾，一个指针指向待排序序列的头结点<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">int</span> left=<span class=\"hljs-number\">0</span>;<br><span class=\"hljs-keyword\">int</span> right=<span class=\"hljs-number\">1</span>;<br><span class=\"hljs-keyword\">while</span>(right&lt;length)&#123;<br>    <span class=\"hljs-keyword\">if</span>(arr[left]!=arr[right])&#123;<br>        left++;<br>        <span class=\"hljs-built_in\">swap</span>(arr[left], arr[right]);<br>        right++;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n</ol>\n<p>此类型的拓展问题，红蓝白球的排序，以及 0 1 2的排序<br>解决方案：记录一个左节点（初始化-1）右节点（length）中间节点：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">int</span> left=<span class=\"hljs-number\">-1</span>;<br><span class=\"hljs-keyword\">int</span> right=length;<span class=\"hljs-comment\">//排好序的头</span><br><span class=\"hljs-keyword\">int</span> index=<span class=\"hljs-number\">0</span>;<br><span class=\"hljs-keyword\">while</span>(index&lt;right)&#123;<br>    <span class=\"hljs-keyword\">if</span>(arr[index]==<span class=\"hljs-number\">0</span>)&#123;<br>        <span class=\"hljs-built_in\">swap</span>(arr[++left], arr[index]);<br>        index++;<br>    &#125;<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(arr[index]==<span class=\"hljs-number\">2</span>)&#123;<br>        <span class=\"hljs-built_in\">swap</span>(arr[--right], arr[index]);<span class=\"hljs-comment\">//注意这种情况index还要继续判断，因此不能index++</span><br>    &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>        index++;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<ol start=\"7\">\n<li>网格中的最短路径和最短通路问题：</li>\n</ol>\n<ul>\n<li>1.一定要分清楚是用dp还是bfs</li>\n<li>2.如果是只能从左上往右下走，那么是dp,否则应该用bfs,同时因为是路径，因此需要一个额外的二维数组判断到当前节点需要的步数，或者另外申明一个node,<br>这个node里面记录到这个节点的步数</li>\n</ul>\n<p><font color=\"red\">8. 缺失的第一个正数： /引申缺失的最大负数（原位hash或者置换）</font></p>\n<ul>\n<li>方法一：如何在原数组上进行hash,但是保留那个位置的数不变使用- 符号；(负数 0全部变为size)<br>同时如果原来有符号，那么为了避免混淆，将原来为符号的数变为我们不关心的正数</li>\n<li>方法二：使用置换的方式，这种方式一定要注意进入死循环的方式因此在交换的时候判断。nums[nums[i]-1]!=nums[i]</li>\n</ul>\n<h5 id=\"random类似题目总结：\"><a href=\"#random类似题目总结：\" class=\"headerlink\" title=\"random类似题目总结：\"></a>random类似题目总结：</h5><p>rand5 to rand7<br>rand01p to rand6<br>rand1toM to rand1toN</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-number\">1</span>）  二维的方式，使得两个调用rand5在二维矩阵上是大于rand7，然后就可以选取<span class=\"hljs-number\">7</span>的倍数的一段距离对rand7取模<br>    <span class=\"hljs-keyword\">do</span>&#123;<br>        row=<span class=\"hljs-built_in\">rand5</span>()<span class=\"hljs-number\">-1</span>;<br>        col=<span class=\"hljs-built_in\">rand5</span>()<span class=\"hljs-number\">-1</span>;<br>        num=row*<span class=\"hljs-number\">5</span>+col <span class=\"hljs-comment\">//0-24之间</span><br>    &#125;<span class=\"hljs-keyword\">while</span>(num&gt;=<span class=\"hljs-number\">21</span>)<br><br>    <span class=\"hljs-keyword\">return</span> num%<span class=\"hljs-number\">7</span>+<span class=\"hljs-number\">1</span>;<br><br></code></pre></td></tr></table></figure>\n<p>2)<br>首先等概率产生0-1  01 10是等概率残生的</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">rand01</span><span class=\"hljs-params\">()</span></span>&#123;<br>    <span class=\"hljs-keyword\">do</span>&#123;<br>        num=<span class=\"hljs-built_in\">rand01p</span>();<br>    &#125;<span class=\"hljs-keyword\">while</span>(num==<span class=\"hljs-built_in\">rand01p</span>());<br>    <span class=\"hljs-keyword\">return</span> num;<br>&#125;<br><br>那么rand03=<span class=\"hljs-built_in\">rand01</span>()*<span class=\"hljs-number\">2</span>+<span class=\"hljs-built_in\">rand01</span>();<br>rand0<span class=\"hljs-number\">-15</span>=<span class=\"hljs-built_in\">rand03</span>()*<span class=\"hljs-number\">4</span>+<span class=\"hljs-built_in\">rand03</span>(); <span class=\"hljs-comment\">//倍数+插空  用进制的方法可以产生rand07()=rand03()+rand01()*4</span><br>那么rand6可由如下产生:<br><span class=\"hljs-keyword\">do</span>&#123;<br>    num=rand0<span class=\"hljs-number\">-15</span>;<br>&#125;<span class=\"hljs-keyword\">while</span>(num&gt;=<span class=\"hljs-number\">12</span>)<br><span class=\"hljs-keyword\">return</span> num%<span class=\"hljs-number\">6</span>+<span class=\"hljs-number\">1</span>;<br></code></pre></td></tr></table></figure>\n\n<p>3）k维的方式<br>rand1toM()转为rand1toN()其实就是调用k次（用N的M进制可以求得）的rand1toM, 使得这a* M^(k-1)+b* M^(k-2)+……  +c 比n要小， 然后返回就可以了<br>其实就是用M进制的数来表示N-1，如果随机生成的数是大于N，那么从头进行生成（注意是从头，而不是从当前数重新生成），否则返回这个数<br>步骤：<br>   1、将n-1转换成m进制数，假设结果转换成数组为 k = [a,b,c,d,e]<br>　　2、使用rand1ToM(m)函数产生结果数组 res = [A,B,C,D,E]，如果res所表示的数值大于k所表示的数值，将res丢掉重新随机，直到产生的结果小于或等于k，这时产生的res的范围就在0～n-1之间，但是此时res所表示的数还是m进制的。 //随机生成M进制的每一位数<br>　　3、将res数组转换成10进制整数。<br>　　4、将步骤3的结果加1就是最终的结果。</p>\n<h5 id=\"数学相关问题\"><a href=\"#数学相关问题\" class=\"headerlink\" title=\"数学相关问题\"></a>数学相关问题</h5><ol>\n<li>求num阶层中最后的包含0的个数，因为包含因子2的个数一定比5多，因此可以直接求包含因子5的个数<br>每5个数有一个5，每25个数中有一个数包含两个5<br>同样下面的模板可以用于求任何因子的个数<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">func</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> num)</span></span>&#123;<br>    <span class=\"hljs-keyword\">int</span> res=<span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">while</span>(num)&#123;<br>        res+=num/<span class=\"hljs-number\">5</span>;<br>        num=num/<span class=\"hljs-number\">5</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>\n<font color=\"blue\">2. 判断一个点是否在矩形中：叉乘+点乘</font><br>对角向量叉积的点积&gt;=0,（对角向量的叉积方向相同），使用叉积的原因是：一个点在线外还是在线内，叉积的正负不同<br>使用叉积可以判断方向，A = &lt;a1, a2&gt;，B = &lt;b1, b2&gt;<br>AXB=a1* b2-a2 *b1, 叉积向量的方向为法线的方向，上下为第一个向量指向第二个向量，大手指的方向<br>叉乘加内积</li>\n</ol>\n<p>(p1 p2 X p1 p ) * (p3 p4 X p3 p1)  &gt;= 0  （四个边分成两组，每两个对边一组， 看两边的叉积是否同方向）</p>\n<p><font color=\"blue\">3. 相同的题型：判断点是否在三角形中 叉乘</font><br>1）先判断三个点的顺序是否是逆时针方向:逆时针方向叉积小于0；顺时针方向叉积大于等于（注意顺序可能导致结果不同！！！）；如果是顺时针正方向，那么调整点位置<br>2）然后判断这个点x是否都是在三角形每条边的左边，判断过程：三角形每个顶点和边的叉积小于0</p>\n<p>（逆时针，点左侧；判断逆时针，仍然使用点左侧）</p>\n<p>求三个三角形不推荐，因为double类型可能出现误差</p>\n<p><font color=\"red\">4. 路径数组转为统计数组的题目：原地hash, 注意以负数作为标记的话，全部的数都需要转为正数</font><br>要求额外的空间复杂度为O(1)<br>如果要实现空间复杂度为O(1),那么需要在原来的数据上进行运算，那么每个位置存储跳过来的位置（最开始节点存储为-1），直到当前的数为一个负数（表示已经求过距离），然后跳回去的时候就知道来的位置，同时更新当前的距离，<br>为了区分已经判断过的值和未判断过的值，使用负数；求到距离矩阵之后再计算每个距离出现的次数，仍然是使用跳的方式，开始节点记得赋值为0，表示已经访问计算过</p>\n<p>这种方式也出现在”第一个未出现的正数“这道题解决方案中（值与下标相互映射）</p>\n<ol start=\"5\">\n<li>正数数组的最小不可组成和：<br>dp[0][0]=1<br>使用动态规划<br>for j=0; j=arr.size(); j++:<br> for i = sum to min: //注意反着,因为一个数只能取一次0-1背包<pre><code> if(i&gt;=arr[j]):\n     dp[i]=dp[i-arr[j]]?True:dp[i]//注意是dp[i]而不是false,也不是dp[i]=dp[i-arr[i]]//因为可能一个数一种方式可以组成，但是另一种不行\n</code></pre>\n</li>\n</ol>\n<p>PS:没有思路就想暴力算法，然后递归考虑是否能转为动态规划，类似背包问题</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">dp[i][j]=dp[i<span class=\"hljs-number\">-1</span>][j-arr[i]]||dp[i<span class=\"hljs-number\">-1</span>][j];<br><br><span class=\"hljs-keyword\">for</span> i in min to sum:<br>    <span class=\"hljs-keyword\">if</span> dp[n][i] == <span class=\"hljs-literal\">false</span>:<br>        <span class=\"hljs-keyword\">return</span> i<br></code></pre></td></tr></table></figure>\n\n<ol start=\"6\">\n<li>累加出整个范围最少还需要的数:<br>使用当前可以累加得到的范围，如果范围超过了当前遍历到的arr的第一个数，那么下一个可以累加得到的范围是当前的范围+arr[i];否则下一个差的数应该是touch+1,可以累加得到的数是touch+1+touch</li>\n</ol>\n<p>可以累加得到的数是touch,下一个差的数是touch+1</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">touch=<span class=\"hljs-number\">0</span>;<br>cnt=<span class=\"hljs-number\">0</span>;<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;arr.<span class=\"hljs-built_in\">size</span>();i++)&#123;<br>    <span class=\"hljs-keyword\">if</span>(touch+<span class=\"hljs-number\">1</span>&lt;arr[i])&#123;<br>        <span class=\"hljs-keyword\">while</span>(touch&lt;arr[i]+<span class=\"hljs-number\">1</span>)&#123;<span class=\"hljs-comment\">//注意这是循环</span><br>            touch+=touch+<span class=\"hljs-number\">1</span>;<br>            cnt++;<br>            <span class=\"hljs-keyword\">if</span>(touch&gt;=range)&#123;<br>                <span class=\"hljs-keyword\">return</span> cnt;<br>            &#125;<br>        &#125;<br>    &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>        touch+=arr[i];<br>        <span class=\"hljs-keyword\">if</span>(touch&gt;=range)&#123;<br>            <span class=\"hljs-keyword\">return</span> cnt;<br>        &#125;<br>    &#125;<br>&#125;<br><span class=\"hljs-keyword\">while</span>(touch&lt;range)&#123;<br>        touch+=touch+<span class=\"hljs-number\">1</span>;<br>        cnt++;    <br>&#125;<br><br>    <span class=\"hljs-keyword\">return</span> cnt;<br></code></pre></td></tr></table></figure>\n\n<ol start=\"7\">\n<li>一种字符串和数字对应的关系 （lc168. Excel表列名称）<br>A -&gt; 1<br>B -&gt; 2<br>C -&gt; 3<br>…<br>Z -&gt; 26<br>AA -&gt; 27<br>AB -&gt; 28<br>从 1开始的的 2626 进制转换题。（每一位至少都有1）</li>\n</ol>\n<ul>\n<li><p>方法1：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">string res=<span class=\"hljs-string\">&quot;&quot;</span>;<br><span class=\"hljs-keyword\">while</span>(columnNumber&gt;<span class=\"hljs-number\">0</span>)&#123;<br>    columnNumber--;<br>    res+=(columnNumber%<span class=\"hljs-number\">26</span>+<span class=\"hljs-string\">&#x27;A&#x27;</span>);<br>    columnNumber/=<span class=\"hljs-number\">26</span>;<br>&#125;<br><span class=\"hljs-built_in\">reverse</span>(res.<span class=\"hljs-built_in\">begin</span>(), res.<span class=\"hljs-built_in\">end</span>());<br><span class=\"hljs-keyword\">return</span> res;<br></code></pre></td></tr></table></figure></li>\n<li><p>方法2：注意是K伪进制数，也就是每一个伪至少为1不能为0，因此需要先从右往左计算位数（同时每一位分得1, 因为这个规则每一位至少都有1），然后从左往右分剩下的数字 </p>\n</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-comment\">//先从右往左，减掉一轮，再从左往右看补在哪为 进制如果为3：base=1 3 9</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">int2str</span><span class=\"hljs-params\">()</span></span>&#123;<br>    cur=<span class=\"hljs-number\">1</span>;<span class=\"hljs-comment\">//代表进制的基数</span><br>    k=<span class=\"hljs-number\">0</span><span class=\"hljs-comment\">//代表位数</span><br>    base=<span class=\"hljs-number\">3</span><span class=\"hljs-comment\">//代表进制数，多少个字符就是多少进制</span><br>    <span class=\"hljs-keyword\">while</span>(n&gt;=cur)&#123;<br>        k++;<br>        n-=cur;<br>        cur*=base;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">int</span> index=<span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">while</span>(k)&#123;<br>        cur/=base;<br>        res[index++]=<span class=\"hljs-built_in\">getchar</span>(n/cur);  <span class=\"hljs-comment\">//当前base的数量应该为n/cur+1,对应的下标就是n/cur</span><br>        n=n%cur; <span class=\"hljs-comment\">//剩下的数可以分多少到下一个进制位中</span><br>        k--;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n<p>str2int类似于K进制</p>\n<p>从N个数中等概率打印M个数,空间复杂度为O(1)：将每次打印的数每次交换到整个数组的末尾，然后下次在生成随机数的时候，减少生成范围（1，n-count）</p>\n<ol start=\"8\">\n<li>数字的中文表达和英文表达：</li>\n</ol>\n<ul>\n<li>1.中文表达：对于零特殊处理</li>\n<li>2.英文表达：每三个一组进行处理；使用递归或者迭代。递归方式就是分别求出billion million和thousand三个部分的数字，然后加起来，<br>在求每个部分的时候，先判断百位，如果百位有数字的话，那么加上”hundred“,否则分为数字&lt;=10 &lt;20; &lt;=20 &lt;100 and &lt;10 三种情况进行处理</li>\n</ul>\n<ol start=\"9\">\n<li>实现sqrt函数</li>\n</ol>\n<ul>\n<li><p>方法一：使用二分算法（一个数的平方根不会大于 n/2+1），标准二分，返回right</p>\n</li>\n<li><p>方法二：牛顿迭代算法： y=f(x0)+k(x-x0)<br>令y=0, 得到 x_i+1=(x_i+ C/x_i)  其中C为要求的目标</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> &#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">mySqrt</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> x)</span> </span>&#123;<br>        <span class=\"hljs-keyword\">if</span> (x == <span class=\"hljs-number\">0</span>) &#123;<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>        &#125;<br><br>        <span class=\"hljs-keyword\">double</span> C = x, x0 = x;<br>        <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>) &#123;<br>            <span class=\"hljs-keyword\">double</span> xi = <span class=\"hljs-number\">0.5</span> * (x0 + C / x0);<br>            <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">fabs</span>(x0 - xi) &lt; <span class=\"hljs-number\">1e-7</span>) &#123;<br>                <span class=\"hljs-keyword\">break</span>;<br>            &#125;<br>            x0 = xi;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\"><span class=\"hljs-keyword\">int</span></span>(x0);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li>\n</ul>\n<ol start=\"10\">\n<li>小数的十进制转为二进制是*2 取整数部分，如果整数&gt;=1, 那么num-=1,否则当前位为0， 直到num=0; 也可以1连除2，num如果num&gt;base,那么减去base<br>十进制整数转换为二进制整数采用”除2取余，逆序排列”法<br>十进制小数转换成二进制小数采用”乘2取整，顺序排列”法</li>\n</ol>\n<ol start=\"11\">\n<li>全排列问题，使用交换或者vis+回溯，一定要注意是否有重复的字符，如果有重复的字符，那么下一个交换或者选择的数，一定是当前没有选择的 （可以和当前自己位置进行交换）</li>\n</ol>\n<p><font color=\"red\">12. 树状数组例题：数字流的秩 线段树（平衡树+二叉搜索树，需要初始化4*n区间） 使用频繁更新数组的某一位（后面的位数也需要相应修改），以及求前缀和</font><br>线段树和树状数组的基本功能都是在某一满足结合律的操作(比如加法，乘法，最大值，最小值)下，O(logn)的时间复杂度内修改单个元素并且维护区间信息。不同的是，树状数组只能维护前缀“操作和”(前缀和，前缀积，前缀最大最小)，而线段树可以维护区间操作和。线段数组是真正的数，而树状数组只是一个数组</p>\n<p>树状数组主要是用于求前缀和，（改变原始然后求前缀和；差分数组适用于，某一段的元素被整体加上或者减去一个元素）</p>\n<ul>\n<li>区间查询：求index的前缀和其实就是不断将index的二进制数的最后一个一个1逐渐变为0 的数据对应的值相加；（x-(x&amp;-x)）//不断地去掉二进制数最右边的一个1 （从x到=n）</li>\n<li>单点修改：更新一个index需要更新的其他下标的值相当于 不断加上最后一个1所代表的数字下标对应的值（x+(x&amp;-x)）//从右边起一系列连续的1变为0，再把这一系列1的前一位0变为1,相当与最后一个1+1，导致连续进位<br>其中存储值的下标从1开始，0下标主要是判断循环的终点，不被用来存储值 （从x到0）</li>\n</ul>\n<p>而且树状数组的下标从1开始，常用语频繁更新和频繁求前缀和</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">建立树状数组：<br><span class=\"hljs-keyword\">int</span> n;<br><span class=\"hljs-keyword\">int</span> a[<span class=\"hljs-number\">1005</span>],c[<span class=\"hljs-number\">1005</span>]; <span class=\"hljs-comment\">//对应原数组和树状数组</span><br><span class=\"hljs-comment\">//范围是[1,n]</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">lowbit</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> x)</span></span>&#123;<br>    <span class=\"hljs-keyword\">return</span> x&amp;(-x);<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">updata</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> i,<span class=\"hljs-keyword\">int</span> k)</span></span>&#123;    <span class=\"hljs-comment\">//在i位置加上k</span><br>    <span class=\"hljs-keyword\">while</span>(i &lt;= n)&#123;<br>        c[i] += k;<br>        i += <span class=\"hljs-built_in\">lowbit</span>(i);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">getsum</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> i)</span></span>&#123;        <span class=\"hljs-comment\">//求A[1 - i]的和</span><br>    <span class=\"hljs-keyword\">int</span> res = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">while</span>(i &gt; <span class=\"hljs-number\">0</span>)&#123;<br>        res += c[i];<br>        i -= <span class=\"hljs-built_in\">lowbit</span>(i);<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>树状数组如果输入有0， 那么所有的输入都应该向右边偏移以为（输入x，实际上对应x+1）</p>\n<p>例题：lc5999. 统计数组中好三元组数目<br>这道题是求在一个数的左边，同时小于这个数的数量（数量题）<br>lc307. 区域和检索 - 数组可修改</p>\n<ul>\n<li>这道题是，频繁的修改某个下标的元素值+同时求某个范围元素之间的元素和（值题目）</li>\n<li>数组的大小为arr的范围n， 下标对于树状数组的二进制下标</li>\n<li>需要先将num的值插入树状数组中， 然后更新的时候使用newvalue-ori[index]来更新当前节点后面的值，同时一定要记得更新ori[index]=newvalue !!!!</li>\n<li>一定要记得树状数组的下标是从1开始，但是num的下标从0开始；而且区间范围是两边闭合，所以求区间差的时候，left_index应该减1</li>\n</ul>\n<p><font color=\"red\">lc315. 计算右侧小于当前元素的个数（hard）</font></p>\n<ul>\n<li>注意这道题数据可能为负数，因此需要对数据+10000+1 使数据shift到[1, +无穷]</li>\n<li>使用归并排序，每个i, j 那么num[i]+=j-i-1 (就是在i后面而且比nums[i]小的数的数量)<br>归并排序易错点：需要使用索引数组,同时在进行归并的时候会修改索引数组，一定要记得复制一个新的数组出来，不能使用原来的数组；其次就是注意数组的范围，左右都闭合；归并排序还长用于计算逆序对</li>\n</ul>\n<p>lc493. 翻转对(hard)</p>\n<ul>\n<li>归并排序</li>\n<li>范围映射的树状数组（具体代码可见模板代码）</li>\n</ul>\n<ol start=\"13\">\n<li>最佳直线，使用暴力枚举的方式， 三重循环<br>枚举直线两个起始端点(i, j)，后面遍历k是否在直线(i, j)上，在的话计算过得点个数进行更新， 最后判断这条直线上最多有多少个同点<br>时间复杂度：O(n^3)<br>空间复杂度：O(1)O(1)</li>\n</ol>\n<ol start=\"14\">\n<li>枚举题：模式匹配问题，暂时未做，主要是通过a和b的数量来枚举a匹配的字符的长度和b字符的长度，主要是注意边界情况应该先于长度的枚举进行判断<br>example： pattern = “abba”, value = “dogcatcatdog”<br>注意：pattern只包含字母”a”和”b”两种字符， 而且a或者b可以为空串， 而且a 与b映射的字符串不应该相等<br>lena lenb都为0; lena为0; lenb为0;lena lenb都不为0时， 他们映射的字符串不应该相等</li>\n</ol>\n<ol start=\"15\">\n<li>大数相乘的题目</li>\n</ol>\n<ul>\n<li>使用第二个数的每一位数和第一个数相乘&lt;&lt; i 位，然后将求得的结果相加</li>\n<li>使用第一个数的每一位和第二个数相乘，更新结果的 arr[i+k]位</li>\n</ul>\n<ol start=\"16\">\n<li>矩形覆盖面积： 公式为area1+area2-inter_area<br>inter_area = max((最小 右上横坐标 - 最大左下横坐标), 0)* max(（最小右上纵坐标 -  最大左下纵坐标, 0)</li>\n</ol>\n<p>注意一定要和0进行比较</p>\n<ol start=\"16\">\n<li>找众数II:</li>\n</ol>\n<ul>\n<li>使用hash算法</li>\n<li>使用摩尔投票算法</li>\n</ul>\n<p>找到超过 (n/3) 向下取整的数：数学证明这样的数最多2个，选两个数，如果当前的数都不等于前两个数，那么两个投票数都–<br>这种投票算法同样适用于找到超过 n/2</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> &#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\">vector&lt;<span class=\"hljs-keyword\">int</span>&gt; <span class=\"hljs-title\">majorityElement</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        vector&lt;<span class=\"hljs-keyword\">int</span>&gt; ans;<br>        <span class=\"hljs-keyword\">int</span> element1 = <span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-keyword\">int</span> element2 = <span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-keyword\">int</span> vote1 = <span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-keyword\">int</span> vote2 = <span class=\"hljs-number\">0</span>;<br><br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> &amp; num : nums) &#123;<br>            <span class=\"hljs-keyword\">if</span> (vote1 &gt; <span class=\"hljs-number\">0</span> &amp;&amp; num == element1) &#123; <span class=\"hljs-comment\">//如果该元素为第一个元素，则计数加1</span><br>                vote1++;<br>            &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (vote2 &gt; <span class=\"hljs-number\">0</span> &amp;&amp; num == element2) &#123; <span class=\"hljs-comment\">//如果该元素为第二个元素，则计数加1</span><br>                vote2++;<br>            &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (vote1 == <span class=\"hljs-number\">0</span>) &#123; <span class=\"hljs-comment\">// 选择第一个元素</span><br>                element1 = num;<br>                vote1++;<br>            &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (vote2 == <span class=\"hljs-number\">0</span>) &#123; <span class=\"hljs-comment\">// 选择第二个元素</span><br>                element2 = num;<br>                vote2++;<br>            &#125; <span class=\"hljs-keyword\">else</span> &#123; <span class=\"hljs-comment\">//如果三个元素均不相同，则相互抵消1次</span><br>                vote1--;<br>                vote2--;<br>            &#125;<br>        &#125;<br><br>        <span class=\"hljs-keyword\">int</span> cnt1 = <span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-keyword\">int</span> cnt2 = <span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> &amp; num : nums) &#123;<br>            <span class=\"hljs-keyword\">if</span> (vote1 &gt; <span class=\"hljs-number\">0</span> &amp;&amp; num == element1) &#123;<br>                cnt1++;<br>            &#125;<br>            <span class=\"hljs-keyword\">if</span> (vote2 &gt; <span class=\"hljs-number\">0</span> &amp;&amp; num == element2) &#123;<br>                cnt2++;<br>            &#125;<br>        &#125;<br>        <span class=\"hljs-comment\">// 检测元素出现的次数是否满足要求</span><br>        <span class=\"hljs-keyword\">if</span> (vote1 &gt; <span class=\"hljs-number\">0</span> &amp;&amp; cnt1 &gt; nums.<span class=\"hljs-built_in\">size</span>() / <span class=\"hljs-number\">3</span>) &#123;<br>            ans.<span class=\"hljs-built_in\">push_back</span>(element1);<br>        &#125;<br>        <span class=\"hljs-keyword\">if</span> (vote2 &gt; <span class=\"hljs-number\">0</span> &amp;&amp; cnt2 &gt; nums.<span class=\"hljs-built_in\">size</span>() / <span class=\"hljs-number\">3</span>) &#123;<br>            ans.<span class=\"hljs-built_in\">push_back</span>(element2);<br>        &#125;<br><br>        <span class=\"hljs-keyword\">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>\n\n\n<ol start=\"17\">\n<li>为运算表达式计算优先级<br>使用分治算法, 遍历表达式，找到运算符，将结果分成两个部分， 递归查找。类似二叉树的组成方式查找<br>如果求具体的结果，那么需要使用vector将结果进行push_back,否则可以直接使用动态规划，计算总数</li>\n</ol>\n<ol start=\"18\">\n<li>摆动序列 如果是需要相邻两个数不能等于的话，只能两个字符串都进行翻转，如果可以相邻等于的话，可以后面的字符串进行翻转就行了 </li>\n</ol>\n<ol start=\"19\">\n<li><p>中文变为阿拉伯数字和阿拉伯数字变为中文<br>1.中文变为阿拉伯数字<br>使用栈，将文字划分为数字和量纲，遇到量纲，那么从栈中弹出与当前量纲小的数字与当前量纲相乘，然后不断累加，知道栈为空或者栈顶量纲比当前量纲大，然后将当前累加到的数压入栈中；最后的结果就是栈中的数求和</p>\n<p>2.阿拉伯数字变为中文<br>注意：亿，万节之后如果只有0那么不需要输出0，如果千位为0的话那么需要输出0<br>10500，一万零五百， 15000一万五千</p>\n<p>将数组划分为节，然后每节使用一个函数判断<br>如果不是第一节，而且当前的数是大于0，而且小于1000的话那么需要加零</p>\n</li>\n</ol>\n<ol start=\"20\">\n<li>面试题 16.14. 最佳直线/149. 直线上最多的点数</li>\n</ol>\n<ul>\n<li>暴力方法：使用三重循环，前两个点固定一条直线，后一个点判断是否在直线上，是cnt++,最后找最大的cnt</li>\n<li>hash方法，使用二重循环，遍历两个点，两个点得到一个斜率，然后hash_map中存储该斜率的cnt, 最后取最大值的时候res=max(res, cnt+1)//一定记得+1<br>  因为gcd(5, 0)=5=cd(0, 5) 所以不存在除0情况<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">int</span> a = x1 - x2, b = y1 - y2;<br><span class=\"hljs-keyword\">int</span> k = <span class=\"hljs-built_in\">gcd</span>(a, b);<br>String key = (a / k) + <span class=\"hljs-string\">&quot;_&quot;</span> + (b / k); <span class=\"hljs-comment\">//斜率用string存储</span><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">gcd</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> a, <span class=\"hljs-keyword\">int</span> b)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">return</span> b == <span class=\"hljs-number\">0</span> ? a : <span class=\"hljs-built_in\">gcd</span>(b, a % b);<br>&#125;<br></code></pre></td></tr></table></figure></li>\n</ul>\n<ol start=\"21\">\n<li>阶层之后的零</li>\n</ol>\n<ul>\n<li> 方法1， 直接计算，n是5的倍数的个数+25倍数个数+…<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">int</span> pow=<span class=\"hljs-number\">5</span>;<br><span class=\"hljs-keyword\">while</span>(n&gt;=pow)&#123;<br>    cnt+=n/pow;<br>    pow=pow*<span class=\"hljs-number\">5</span>;<br>&#125;<br><span class=\"hljs-keyword\">return</span> cnt;<br></code></pre></td></tr></table></figure></li>\n<li>方法2， 对1-n中的每一个数计算，能够拆分为多少个5的因子<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;=n;i++)&#123;<br><span class=\"hljs-keyword\">int</span> tmp=i;<br><span class=\"hljs-keyword\">while</span>(tmp%<span class=\"hljs-number\">5</span>==<span class=\"hljs-number\">0</span>)&#123;<br>    tmp=tmp/<span class=\"hljs-number\">5</span>;<br>    cnt++;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n</ul>\n<ol start=\"22\">\n<li>lc277. find-the-celebrity</li>\n</ol>\n<ul>\n<li>所有的人都认识名人，名人谁都不认识，找出名人</li>\n<li>假设法，O(n), 假设0是名人，如果遇到knows(0, i)==true, 说明0不是名人，同时说明[0~i-1]都不是名人，因为他们都不被0知道</li>\n<li>之后再判断一次，如果出现know(ans, i)==true||know(i, ans)==false, 返回-1</li>\n</ul>\n<h5 id=\"19-交换数据的位置\"><a href=\"#19-交换数据的位置\" class=\"headerlink\" title=\"19.交换数据的位置\"></a>19.交换数据的位置</h5><p>（1）打标记方法： 这种方式理解起来更轻松, 注意这种方式，如果元数据中包含0或者小于0，但是目标数据中是大于0的([1, size])， 那可以将0，负数转为size+1; 否则如果元数据有0， 目标数据也有0的话，打标记是无法解决的</p>\n<ol>\n<li>缺失的第一个正数 （用负号在原地打标记代替hash方法，或者用置换方法，一定要将负数和&gt;size都转为size+1；同时对于target_index和当前index数据相同时，退出循环）</li>\n<li>丢失的数字</li>\n<li>数组中重复的数据</li>\n</ol>\n<p>将当前的数在对应的下标中打上标记，同时为了找到被覆盖数据的元数据，可以使用+n（这种可以找到重复3次， 4次都可以）,或者变为负数的这种做法<br>但是变负数的这种方式，不能适用于含有0的这种情况，因为-0和0是一样的，无法判断是否出现过这个数字</p>\n<p>找到的条件是 nums[i]&gt;=0 退出</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">firstMissingPositive</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;<br>     <span class=\"hljs-keyword\">int</span> n = nums.<span class=\"hljs-built_in\">size</span>();<br>     <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span>&amp; num: nums) &#123;<br>         <span class=\"hljs-keyword\">if</span> (num &lt;= <span class=\"hljs-number\">0</span>) &#123;<br>             num = n + <span class=\"hljs-number\">1</span>;<br>         &#125;<br>     &#125;<br>     <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; n; ++i) &#123;<br>         <span class=\"hljs-keyword\">int</span> num = <span class=\"hljs-built_in\">abs</span>(nums[i]);<br>         <span class=\"hljs-keyword\">if</span> (num &lt;= n) &#123;<br>             nums[num - <span class=\"hljs-number\">1</span>] = -<span class=\"hljs-built_in\">abs</span>(nums[num - <span class=\"hljs-number\">1</span>]);<br>         &#125;<br>     &#125;<br>     <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; n; ++i) &#123;<br>         <span class=\"hljs-keyword\">if</span> (nums[i] &gt; <span class=\"hljs-number\">0</span>) &#123;<br>             <span class=\"hljs-keyword\">return</span> i + <span class=\"hljs-number\">1</span>;<br>         &#125;<br>     &#125;<br>     <span class=\"hljs-keyword\">return</span> n + <span class=\"hljs-number\">1</span>;<br> &#125;<br><br></code></pre></td></tr></table></figure>\n\n<p>（2）置换</p>\n<ol>\n<li>缺失的第一个正数 把数据放在对应的位置</li>\n</ol>\n<p>将当前的数放在当前数据对应的下标中</p>\n<p>找到的条件是 nums[i]！=i+1 退出</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">firstMissingPositive</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">int</span> n = nums.<span class=\"hljs-built_in\">size</span>();<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; n; ++i) &#123;<br>        <span class=\"hljs-keyword\">while</span> (nums[i] &gt; <span class=\"hljs-number\">0</span> &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[nums[i] - <span class=\"hljs-number\">1</span>] != nums[i]) &#123;<br>            <span class=\"hljs-built_in\">swap</span>(nums[nums[i] - <span class=\"hljs-number\">1</span>], nums[i]); <span class=\"hljs-comment\">//要和它交换的数不能等于它本身</span><br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; n; ++i) &#123;<br>        <span class=\"hljs-keyword\">if</span> (nums[i] != i + <span class=\"hljs-number\">1</span>) &#123;<br>            <span class=\"hljs-keyword\">return</span> i + <span class=\"hljs-number\">1</span>;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> n + <span class=\"hljs-number\">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>（3） 二分算法，查找小于mid的数据量，如果是大于mid的话说明重复的数小于等于mid,因此r=mid-1 and ans=mid(或者r=mid), 否则l=mid+1<br> (4) 数组版快慢指针，index-&gt;nums[index] 那么有一个数会被指向两次，那么存在环</p>\n<ul>\n<li>映射找环法， 找冗余的数据，其实就是找环路的起点</li>\n<li><a href=\"https://segmentfault.com/a/1190000003817671\">https://segmentfault.com/a/1190000003817671</a><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> &#123;</span><br>   <span class=\"hljs-keyword\">public</span>:<br>       <span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">findDuplicate</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;<br>           <span class=\"hljs-keyword\">int</span> slow = <span class=\"hljs-number\">0</span>, fast = <span class=\"hljs-number\">0</span>;<br>           <span class=\"hljs-keyword\">do</span> &#123;<br>               slow = nums[slow];<br>               fast = nums[nums[fast]];<br>           &#125; <span class=\"hljs-keyword\">while</span> (slow != fast);<br>           slow = <span class=\"hljs-number\">0</span>;<br>           <span class=\"hljs-keyword\">while</span> (slow != fast) &#123;<br>               slow = nums[slow];<br>               fast = nums[fast];<br>           &#125;<br>           <span class=\"hljs-keyword\">return</span> slow;<br>       &#125;<br>   &#125;;<br></code></pre></td></tr></table></figure></li>\n</ul>\n<ol start=\"4\">\n<li>lc 440和lc386 按照字典序排序，和按照字典序排序的第k个数字<br>我们输入两个值n和k，n表示我们有从1到n个整数，然后将这些整数都字符串化之后按字典排序，找出其中第K大的。例如:n=15,k=5.那么1-15字符串化之后排序如下:1,10,11,12,13,14,15,2,3,4,5,6,7,8,9。其中第5大的就为13。<br>实际上多叉树从到右进行计数</li>\n</ol>\n<p>每次求解二叉树相邻两个节点之间(base 和base+1)包含的数据，如果k&gt;num那么直接更新k 然后当前数+1(base=base+1), 否则递归求里面的数据(base=base*10)</p>\n<p><font color=\"red\">20. 字符串相乘</font></p>\n<ul>\n<li><p>模板代码：</p>\n  <figure class=\"highlight c++\"><figcaption><span>关键代码</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\">vector&lt;<span class=\"hljs-keyword\">int</span>&gt; <span class=\"hljs-title\">res</span><span class=\"hljs-params\">(size1+size2+<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>)</span></span>;<br><span class=\"hljs-built_in\">reverse</span>(num1.<span class=\"hljs-built_in\">begin</span>(), num1.<span class=\"hljs-built_in\">end</span>());<br><span class=\"hljs-built_in\">reverse</span>(num2.<span class=\"hljs-built_in\">begin</span>(), num2.<span class=\"hljs-built_in\">end</span>());<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;size1;i++)&#123;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">0</span>;j&lt;size2;j++)&#123;<br>        res[i+j]=res[i+j]+(num1[i]-<span class=\"hljs-string\">&#x27;0&#x27;</span>)*(num2[j]-<span class=\"hljs-string\">&#x27;0&#x27;</span>);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li><p>知识点：字符ASCII码和数字的相互转换<br>  char a=’0’+81;<br>  char b=a-81;<br>  int c=a-‘0’;<br>  cout&lt;&lt;a&lt;&lt; “ “&lt;&lt;b&lt;&lt;” “&lt;&lt;c&lt;&lt;endl;<br>  注意c最终打印的结果为-175, 而不是81！！！！ 所以在初始化字符串相乘的数组只能用int类型不能用string类型<br>  char m=’A’+1;//打印输出’B’</p>\n</li>\n<li><p>初始化一个m+n的数组（注意一定要为int类型，不能为string类型），然后循环计算每一位应该的值，最后从低位到高位进行进位更新</p>\n</li>\n<li><p>易错点：str1和str2需要翻转，之后的结果需要去前缀零以及翻转回来<br>如果不翻转，那么nums1[i]和nums2[j]对应nums[i+j+1]的数组</p>\n</li>\n</ul>\n<ol start=\"21\">\n<li>分数到小数，模拟除法</li>\n</ol>\n<p>使用hash记录余数到下标的隐射，如果出现重复余数，说明出现了重复的小数循环体<br>注意易错点：</p>\n<ul>\n<li>1.可能存在负数，但是不能直接对负数取反（因为可能为INT_MIN），需要转为long型<br>  判断结果为负数使用异或<br>  if (numeratorLong &lt; 0 ^ denominatorLong &lt; 0) {//异号为负数<pre><code>  sb.append(&#39;-&#39;);\n</code></pre>\n  }</li>\n</ul>\n<ol start=\"22\">\n<li>lc670. 最大交换</li>\n</ol>\n<ul>\n<li>一个数字交换一次，如何使得交换后的数最大 输入: 2736 输出: 7236</li>\n<li>先遍历字符串求得每个数最靠后的下标（因为小于当前的数，应该换到越靠后面越好）</li>\n<li>然后从左遍历每个数的时候，遍历 ‘9’到s[i]-‘0’看是否有比当前数大的数，而且在这个数后面，如果有，那么交换，然后退出</li>\n<li>因为第二重循环只是从9到s[i]-‘0’， 因此总的时间复杂度还是O(N)</li>\n</ul>\n<h4 id=\"分而治之专题\"><a href=\"#分而治之专题\" class=\"headerlink\" title=\"分而治之专题\"></a>分而治之专题</h4><ol>\n<li><p>超级次方， 也类似观察规律的题目，就是在定义一种新的运算的时候，将它化简为熟知的运算。同时运用规律“对乘法的结果求模，等价于先对每个因子都求模，然后对因子相乘的结果再求模”<br>不能直接使用系统自带的pow,只能自己实现pow因为，在求乘方过程随时会出现溢出，所以要为每一个中间结果取模</p>\n</li>\n<li><p>第K个语法符号<br>找第n个的数的第k个字符是什么，转为找第n-1个数的对应f(k)位上面的数据（左半边不取反，右半边取反）<br>易错点在：一个数的时候会add两次如何解决, 那么就在返回的时候，只有一个数的时候，说明出现了[[num, []]]的这种情况，那么直接return result.getInterger, 否则直接返回result</p>\n</li>\n</ol>\n<h4 id=\"递归相关，表达式相关专题\"><a href=\"#递归相关，表达式相关专题\" class=\"headerlink\" title=\"递归相关，表达式相关专题\"></a>递归相关，表达式相关专题</h4><ol>\n<li>迷你语法分析器：<br>注意在进行递归的时候， 递归进去直接初始化一个NestInterger res, 来加入[]里面的数字， 遇到循环递归调用，然后返回时直接res.add<br>另外一个易错点是，注意负数的处理</li>\n</ol>\n<h4 id=\"蓄水池抽样算法\"><a href=\"#蓄水池抽样算法\" class=\"headerlink\" title=\"蓄水池抽样算法\"></a>蓄水池抽样算法</h4><p>模板</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> &#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">Solution</span>(ListNode* head) &#123;<br>        <span class=\"hljs-keyword\">this</span>-&gt;head=head;<br>    &#125;<br>    <br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">getRandom</span><span class=\"hljs-params\">()</span> </span>&#123;<br>        ListNode*cur=<span class=\"hljs-keyword\">this</span>-&gt;head;<br>        <span class=\"hljs-keyword\">int</span> pool=<span class=\"hljs-number\">-1</span>;<br>        <span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">1</span>;<br>        <span class=\"hljs-keyword\">while</span>(cur)&#123;<br>            <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">rand</span>()%i==<span class=\"hljs-number\">0</span>)pool=cur-&gt;val; <span class=\"hljs-comment\">//只选取一个数的情况</span><br>            i++;<br>            cur=cur-&gt;next;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> pool;<br>    &#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>    ListNode*head;<br>&#125;;<br><br></code></pre></td></tr></table></figure>\n\n<p>例题：</p>\n<ol>\n<li>链表随机节点</li>\n<li>随机索引数 ，找到target数的随机一个index</li>\n</ol>\n<h4 id=\"并查集专题\"><a href=\"#并查集专题\" class=\"headerlink\" title=\"并查集专题\"></a>并查集专题</h4><p>相关例题：</p>\n<p>除法求值：并查集的变形，除了要判断各个数字是否连通，还需添加一个数组记录节点之间的权重 weight(当前节点到其父节点的权重); 而且注意如何a/b那么应该是a的父亲节点是b, a指向b的权重为a/b, 反过来的话不对 <strong>一定要注意这个权重的更新，应该为当前的权重 * 他原来父亲的现在的权重</strong></p>\n<p>易错点：</p>\n<ul>\n<li>在进行节点merge的时候一定要注意权重的更新，weight代表的是两个节点之间的权重，而不是一个节点到根节点的权重</li>\n<li>find的时候返回的是father[a]而不是a !!!!!!</li>\n<li>fa!=fb的时候应该是father[fa]=fb, 与两个孩子节点a b无关</li>\n<li>递归寻找father的时候，应该使用father[index]作为函数的参数而不是index(会陷入无限死循环中)</li>\n<li>在并查集的时候，可以直接使用string作为头节点，不一定要转为int类型  unordered_map&lt;string, string&gt; father; unordered_map&lt;string, int&gt;num<br>例题：面试题 17.07. 婴儿名字</li>\n<li>可以使用string的find函数来对字符串进行分割（带括号或者，形式的分割）</li>\n</ul>\n<p>并查集模板：具体可见vscode里面的代码，两个模板 带size和不带size的情况</p>\n<p>例题2：lc947. 移除最多的同行或同列石头</p>\n<ul>\n<li>这个是二维坐标的，横坐标或者纵坐标相同都在一个并查集，因此需要将横纵坐标放在两个范围中，防止重叠；因为x, y在[0,1000]之间，一次你可以将横坐标放在+10001, 使得x y范围错开</li>\n</ul>\n<p>剑指 Offer II 111. 计算除法</p>\n<ul>\n<li>使用并查集或者BFS/DFS</li>\n<li>并查集注意分母为儿子（大），分子为父亲</li>\n<li>BFS的时候正向，反向都要连接</li>\n</ul>\n<h4 id=\"图相关\"><a href=\"#图相关\" class=\"headerlink\" title=\"图相关\"></a>图相关</h4><p>竞赛第四题 hard lc2097. 合法重新排列数对 //暂时没有看</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> &#123;</span><br>    map&lt;<span class=\"hljs-keyword\">int</span>, vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&gt; mp;<br>    map&lt;<span class=\"hljs-keyword\">int</span>, <span class=\"hljs-keyword\">int</span>&gt; deg;<br>    vector&lt;vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&gt; ans;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">dfs</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> sn)</span> </span>&#123;<br>        vector&lt;<span class=\"hljs-keyword\">int</span>&gt; &amp;e = mp[sn]; <span class=\"hljs-comment\">// 注意这个是引用</span><br>        <span class=\"hljs-keyword\">while</span> (!e.<span class=\"hljs-built_in\">empty</span>()) &#123;<br>            <span class=\"hljs-keyword\">int</span> fn = e.<span class=\"hljs-built_in\">back</span>();<br>            e.<span class=\"hljs-built_in\">pop_back</span>();<br>            <span class=\"hljs-built_in\">dfs</span>(fn);<br>            ans.<span class=\"hljs-built_in\">push_back</span>(vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&#123;sn, fn&#125;);<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-comment\">//为什么要先dfs再push_back没看明白</span><br><br><span class=\"hljs-keyword\">public</span>:<br>    vector&lt;vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&gt; <span class=\"hljs-built_in\">validArrangement</span>(vector&lt;vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&gt;&amp; pairs) &#123;<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> &amp;pair : pairs) &#123;<br>            mp[pair[<span class=\"hljs-number\">0</span>]].<span class=\"hljs-built_in\">push_back</span>(pair[<span class=\"hljs-number\">1</span>]);<br>            deg[pair[<span class=\"hljs-number\">0</span>]]--; deg[pair[<span class=\"hljs-number\">1</span>]]++;<br>        &#125;<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> it = deg.<span class=\"hljs-built_in\">begin</span>(); it != deg.<span class=\"hljs-built_in\">end</span>(); it++) <span class=\"hljs-keyword\">if</span> (it-&gt;second == <span class=\"hljs-number\">-1</span>) <span class=\"hljs-built_in\">dfs</span>(it-&gt;first);<br>        <span class=\"hljs-keyword\">if</span> (ans.<span class=\"hljs-built_in\">empty</span>()) <span class=\"hljs-built_in\">dfs</span>(deg.<span class=\"hljs-built_in\">begin</span>()-&gt;first);<br>        <span class=\"hljs-built_in\">reverse</span>(ans.<span class=\"hljs-built_in\">begin</span>(), ans.<span class=\"hljs-built_in\">end</span>());<br>        <span class=\"hljs-keyword\">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>\n\n\n<h5 id=\"有关于有向图和无向图的最短路径，以及有负边和无负边的最短路径\"><a href=\"#有关于有向图和无向图的最短路径，以及有负边和无负边的最短路径\" class=\"headerlink\" title=\"有关于有向图和无向图的最短路径，以及有负边和无负边的最短路径\"></a>有关于有向图和无向图的最短路径，以及有负边和无负边的最短路径</h5><ol>\n<li><p>Dijstra算法，适用于单源，有向或者无向的最短路径，不能适用于有负边（注意不是负环，负环情况下，无最短路径）的情况：例子：-1， -5， 2<br>时间复杂度O(n^2))</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">define</span> INF 0x3f3f3f3f</span><br><br><span class=\"hljs-keyword\">int</span> e[Max][Max];<span class=\"hljs-comment\">//e[i][j]代表从i-&gt;j的距离，不通设为无穷大</span><br><span class=\"hljs-keyword\">int</span> dis[Max];<span class=\"hljs-comment\">//dis[i]代表从起点到i的最短距离</span><br><span class=\"hljs-keyword\">bool</span> book[Max];<span class=\"hljs-comment\">//book[i]代表点i是否在S中</span><br><span class=\"hljs-keyword\">int</span> n;<span class=\"hljs-comment\">//n个顶点</span><br><span class=\"hljs-keyword\">int</span> s;<span class=\"hljs-comment\">//起点</span><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Dijkstra</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;=n;i++)<span class=\"hljs-comment\">//初始化dis数组</span><br>        dis[i]=e[s][i];<br><br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;=n;i++)<span class=\"hljs-comment\">//初始化book数组</span><br>        book[i]=<span class=\"hljs-number\">0</span>;<br>    dis[s]=<span class=\"hljs-number\">0</span>;<br>    book[s]=<span class=\"hljs-number\">1</span>;<br><br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;=n<span class=\"hljs-number\">-1</span>;i++)<span class=\"hljs-comment\">//Dijkstra算法核心语句  注意也是n-1次</span><br>    &#123;<br>        <span class=\"hljs-keyword\">int</span> minDis=INF;<br>        <span class=\"hljs-keyword\">int</span> k;<span class=\"hljs-comment\">//找到与s最近的顶点k</span><br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">1</span>;j&lt;=n;j++)<br>        &#123;<br>            <span class=\"hljs-keyword\">if</span>(book[j]==<span class=\"hljs-number\">0</span> &amp;&amp; dis[j]&lt;minDis)<br>            &#123;<br>                minDis=dis[j];<br>                k=j;<br>            &#125;<br>        &#125;<br>        book[k]=<span class=\"hljs-number\">1</span>;<br><br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">1</span>;j&lt;=n;j++)<span class=\"hljs-comment\">//“松弛”过程</span><br>        &#123;<br>            <span class=\"hljs-keyword\">if</span>(e[k][j]&lt;INF)<br>            &#123;<br>                <span class=\"hljs-keyword\">if</span>(dis[j]&gt;dis[k]+e[k][j])<br>                    dis[j]=dis[k]+e[k][j];<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li><p>Bellman-ford算法：适用于单源，可有负权，有向或者无向的最短路径 记住只松弛n-1次<br>能够检测出有负环情况<br>dp[i][dst]=min(dp[i][dst], dp[i-1][src]+dist[src][dst]) i==1的时候表示经过的中转站为0</p>\n</li>\n</ol>\n<p>时间复杂度O(n*m)/O(VE)</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">define</span> INF 0x3f3f3f3f</span><br><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Edge</span>&#123;</span><br>    <span class=\"hljs-keyword\">int</span> u;<span class=\"hljs-comment\">//起</span><br>    <span class=\"hljs-keyword\">int</span> v;<span class=\"hljs-comment\">//终</span><br>    <span class=\"hljs-keyword\">int</span> weight;<span class=\"hljs-comment\">//长度</span><br>&#125;;<br><br>Edge edge[maxm];<span class=\"hljs-comment\">//用来存储所有的边</span><br><span class=\"hljs-keyword\">int</span> dis[maxn];<span class=\"hljs-comment\">//dis[i]表示源点到i的最短距离</span><br><span class=\"hljs-keyword\">int</span> n,m;<span class=\"hljs-comment\">//n个点，m条边</span><br><span class=\"hljs-keyword\">int</span> s;<span class=\"hljs-comment\">//源点</span><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">bool</span> <span class=\"hljs-title\">Bellmen_ford</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;=n;i++)<span class=\"hljs-comment\">//初始化</span><br>        dis[i]=INF;<br><br>    dis[s]=<span class=\"hljs-number\">0</span>;<span class=\"hljs-comment\">//源节点到自己的距离为0</span><br><br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;n;i++)<span class=\"hljs-comment\">//松弛过程，计算最短路径 </span><br>    &#123;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">1</span>;j&lt;=m;j++) <span class=\"hljs-comment\">//m条边</span><br>        &#123;<br>            <span class=\"hljs-keyword\">if</span>(dis[edge[j].v]&gt;dis[edge[j].u]+edge[j].weight)<span class=\"hljs-comment\">//比较s-&gt;v与s-&gt;u-&gt;v大小</span><br>                dis[edge[j].v]=dis[edge[j].u]+edge[j].weight;<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">1</span>;j&lt;=m;j++)<span class=\"hljs-comment\">//判断是否有负边权的边</span><br>    &#123;<br>        <span class=\"hljs-keyword\">if</span>(dis[edge[j].v]&gt;dis[edge[j].u]+edge[j].weight)<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n<ol start=\"3\">\n<li>SPFA算法：是Bellman-ford算法的队列优化，适用于单源，可有负权，有向或者无向的最短路径 （自身其实无法处理负权）<br>设立一个队列用来保存待优化的点，优化时每次取出队首结点u，并且用u点当前的最短路径估计值对u点所指向的结点v进行松弛操作，如果v点的最短路径估计值有所调整，且v点不在当前的队列中，就将v点放入队尾。这样不断从队列中取出结点来进行松弛操作，直至队列空为止。</li>\n</ol>\n<p>注意，一旦从队列中弹出来，vis就设置为false，感觉负权的情况就会一直循环下去，不会跳出；遍历点，与边无关</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">define</span> INF 0x3f3f3f3f</span><br><br><span class=\"hljs-keyword\">int</span> dis[MAX];<span class=\"hljs-comment\">//dis[i]表示起点到i的最短距离</span><br><span class=\"hljs-keyword\">bool</span> vis[MAX];<span class=\"hljs-comment\">//是否访问过点i</span><br><span class=\"hljs-keyword\">int</span> e[MAX][MAX];<span class=\"hljs-comment\">//矩阵</span><br><br><span class=\"hljs-keyword\">int</span> n,m;<span class=\"hljs-comment\">//点和边的数量</span><br><span class=\"hljs-keyword\">int</span> s;<span class=\"hljs-comment\">//源点</span><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">SPFA</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;=n;i++)<span class=\"hljs-comment\">//初始化</span><br>    &#123;<br>        dis[i]=INF;<br>        vis[i]=<span class=\"hljs-literal\">false</span>;<br>    &#125;<br>    queue&lt;<span class=\"hljs-keyword\">int</span>&gt; q;<br>    q.<span class=\"hljs-built_in\">push</span>(s);<br>    dis[s]=<span class=\"hljs-number\">0</span>;<br>    vis[s]=<span class=\"hljs-literal\">true</span>;<br><br>    <span class=\"hljs-keyword\">while</span>(!q.<span class=\"hljs-built_in\">empty</span>())<br>    &#123;<br>        <span class=\"hljs-keyword\">int</span> cur=q.<span class=\"hljs-built_in\">front</span>();<br>        q.<span class=\"hljs-built_in\">pop</span>();<br>        vis[cur]=<span class=\"hljs-literal\">false</span>;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;=n;i++) <span class=\"hljs-comment\">//遍历每一个节点</span><br>        &#123;<br>            <span class=\"hljs-keyword\">if</span>(e[cur][i]!=INF&amp;&amp;dis[i]&gt;=dis[cur]+e[cur][i])<br>            &#123;<br>                dis[i]=dis[cur]+e[cur][i];<br>                <span class=\"hljs-keyword\">if</span>(!vis[i])<br>                &#123;<br>                    vis[i]=<span class=\"hljs-literal\">true</span>;<br>                    q.<span class=\"hljs-built_in\">push</span>(i);  <span class=\"hljs-comment\">///之后将start缩小的边才拿出来</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>Floyd算法： Floyd算法是一种利用动态规划思想的计算加权图中多源点之间最短路径的算法。可以正确处理有向图或负权的最短路径问题。</li>\n</ol>\n<p>时间复杂度：O(N^3）</p>\n<p>空间复杂度：O(N^2）</p>\n<p>处理问题：多源、可有负权、有向图、无向图最短路径 </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">int</span> e[Max][Max];<span class=\"hljs-comment\">//e[i][j]代表从i-&gt;j的距离，不通设为无穷大</span><br><span class=\"hljs-keyword\">int</span> n;<span class=\"hljs-comment\">//n个顶点</span><br><span class=\"hljs-comment\">//Floyd算法</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Floyd</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> k=<span class=\"hljs-number\">1</span>;k&lt;=n;k++)<span class=\"hljs-comment\">//遍历所有的中间点</span><br>    &#123;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;=n;i++)<span class=\"hljs-comment\">//遍历所有的起点</span><br>        &#123;<br>            <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">1</span>;j&lt;=n;j++)<span class=\"hljs-comment\">//遍历所有的终点</span><br>            &#123;<br>                <span class=\"hljs-keyword\">if</span> (e[i][j]&gt;e[i][k]+e[k][j])<span class=\"hljs-comment\">//如果当前i-&gt;j的距离大于i-&gt;k-&gt;j的距离之和</span><br>                    e[i][j]=e[i][k]+e[k][j];<span class=\"hljs-comment\">//更新从i-&gt;j的最短路径</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>最短路衍生拓展的一类题目：</p>\n<ol>\n<li>最长路径问题：<br>图不为非负权图：当存在正环时无解。<br>如果不存在正环，边权取负后使用Bellman-Ford算法求最短路。</li>\n<li>最长路径，但是路径的计算是权重之间的乘积，而且权重都是0-1之间的值，使用Dijstra算法 （e.g概率最大的路径）<br>Solution:<br> 单独使用Dijstra会导致超时，因此需要结合Dijstra+优先队列<br> 1.现将src点push 到堆进行<br> 2.然后遍历堆中的每个节点，如果当前节点能够松弛它的邻接节点，那么就放入堆中，否则不放入类似于SPFA,但是不同的是，<ul>\n<li>这个使用的优先队列，而SPFA是用的是一般的堆</li>\n<li>这个不仅仅push了节点，也push了当前节点的最大概率，因此没有vis数组来标记当前节点是否在堆中，因为即使在堆中， 概率也可能是不一样的。<br>总的来说这道题使用bellman-ford算法更简单，只要当前没有任何松弛的边，那么直接退出循环</li>\n</ul>\n</li>\n</ol>\n<p>颜色交替的最短路径：使用bellman-ford算法（本质是动态规划）， 只是在距离的转换是需要讨论两种情况<br>dstEndWithRed[end]=min(dstEndWithRed[end], dstEndWithBlue[start]+1);<br>dstEndWithBlue[end]=min(dstEndWithBlue[end], dstEndWithRed[start]+1);</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;n<span class=\"hljs-number\">-1</span>;i++)&#123;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">auto</span> edge: redEdges)&#123;<br>        <span class=\"hljs-keyword\">int</span> start=edge[<span class=\"hljs-number\">0</span>];<br>        <span class=\"hljs-keyword\">int</span> end=edge[<span class=\"hljs-number\">1</span>];<br>        dstEndWithRed[end]=<span class=\"hljs-built_in\">min</span>(dstEndWithRed[end], dstEndWithBlue[start]+<span class=\"hljs-number\">1</span>);<br>    &#125;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">auto</span> edge: blueEdges)&#123;<br>        <span class=\"hljs-keyword\">int</span> start=edge[<span class=\"hljs-number\">0</span>];<br>        <span class=\"hljs-keyword\">int</span> end=edge[<span class=\"hljs-number\">1</span>];<br>        dstEndWithBlue[end]=<span class=\"hljs-built_in\">min</span>(dstEndWithBlue[end], dstEndWithRed[start]+<span class=\"hljs-number\">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>成语接龙的最长，使用bfs，同时对连接好的成语，再来一次bfs (微软三面)</li>\n</ol>\n<p><font color=\"red\">4. lc787. K 站中转内最便宜的航班</font></p>\n<ul>\n<li>只能最多经过k个中转站的最短路径</li>\n<li>使用bellman-ford算法，k个中转站就是松弛每条边 k+1次(1~k+1)，然后使用dp[i][dst]记录 中转i次的最短路径<br>最后的结果就是在dp[1][dst] 到dp[k+1][dst]中取最小的一个</li>\n</ul>\n<p>lc6134. 找到离给定两个节点最近的节点</p>\n<ul>\n<li>内向基环树</li>\n<li>求出node1 到每个点的距离， 和node2 到每个点的距离，然后取最小 (两次求距离，然后取最小，最后注意返回的是最近的下标，而不是最近的距离)</li>\n</ul>\n<p>PS, 最开始理解的时候，感觉应该用两个节点的最近公共祖先来解决，但是因为图中可能有环，所以不能使用最近公共祖先的栈或者dfs方法解决</p>\n<h3 id=\"前缀和和差分数组相关\"><a href=\"#前缀和和差分数组相关\" class=\"headerlink\" title=\"前缀和和差分数组相关\"></a>前缀和和差分数组相关</h3><p>一般是有关于矩阵的一维前缀和， 二维前缀和， 一维差分数组和二维差分数组<br>如果要计算差分数组和前缀和数组最好是将坐标转为 1-n，更好计算；不然sum i j对应的grid为i-1,j-1</p>\n<p>一维差分数组中，如果数组中一段数据加上或者减去某一个元素，在差分数组中只有两头的元素进行了修改，中间的元素都没有修改<br>二维差分数组中，如果包含左上角（x1, y1）, 右下角（x2, y2）这一部分都+C, 那么对应的差分数组d[x1][y1]+c d[x2+1][y2+1]+c d[x1][y1+1]-c d[x2+1][y1]-c<br>(上升的对角线两端元素-c, 下降的对角线元素+c)</p>\n<p>二维差分数组公式:<br>nums[i][j]-nums[i-1][j]-nums[i][j-1]+nums[i-1][j-1]=d[i][j]<br>从差分数组还原原来的数组<br>nums[i][j]=nums[i-1][j]+nums[i][j-1]-nums[i-1][j-1]+d[i][j]</p>\n<p>例题：</p>\n<ol>\n<li><ol start=\"5931\">\n<li>用邮票贴满网格图 (hard-周赛题目)</li>\n</ol>\n</li>\n</ol>\n<p>方法一: 使用二维前缀和，对原来矩阵中每个左上角为0，且邮票区域都为0的位置（二维区域前缀和为0），贴上邮票，为了减少贴这个过程的时间开销，使用二元差分数组<br>贴完后，对二元差分数组进行还原，如果仍然遇到为0的位置，那么返回false<br>注意这道题没必要求差分数组，差分数组可以全部直接初始化为0， 那么还原回来的也是填充数组<br>方法二: 不使用二维差分数组，使用另外一个数组，标记贴邮票的左上角，然后针对每个grid中为0的位置，计算邮票部分区域（注意是贴了邮票的矩阵，是另一个矩阵）的前缀和，如果为0，表示这个区域没有被贴上邮票，返回false</p>\n<ol start=\"2\">\n<li>航班预订统计 (middle)<br>一维差分数组的题目<br>如果原来数组的下标就是1-n的话，那么修改n-m部分的数据， 就会修改等差数列的d[n]和d[m+1]两个端点的数据</li>\n</ol>\n<ol start=\"3\">\n<li><p>拼车<br>这道题类似于天际线问题，使用hash, 左断点加入m个人，右端点减去m个人<br>然后遍历hash的每个key,如果有个时刻是大于capacity, 那么返回false</p>\n</li>\n<li><p>lc995. K 连续位的最小翻转次数（hard）</p>\n</li>\n</ol>\n<ul>\n<li>从左到右遍历，遇到0就进行翻转，使用差分数组进行假意翻转，通过presum累加来求得当前翻转的次数</li>\n</ul>\n<h3 id=\"前缀异或值\"><a href=\"#前缀异或值\" class=\"headerlink\" title=\"前缀异或值\"></a>前缀异或值</h3><p>在求前缀异或的时候，结果数组可以从1开始取，这样的话就不用对边缘单独进行赋值操作</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt;= m; ++i) &#123;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">1</span>; j &lt;= n; ++j) &#123;<br>        pre[i][j] = pre[i - <span class=\"hljs-number\">1</span>][j] ^ pre[i][j - <span class=\"hljs-number\">1</span>] ^ pre[i - <span class=\"hljs-number\">1</span>][j - <span class=\"hljs-number\">1</span>] ^ matrix[i - <span class=\"hljs-number\">1</span>][j - <span class=\"hljs-number\">1</span>];<br>        results.<span class=\"hljs-built_in\">push_back</span>(pre[i][j]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n<h3 id=\"分类讨论题\"><a href=\"#分类讨论题\" class=\"headerlink\" title=\"分类讨论题\"></a>分类讨论题</h3><ol>\n<li> K 次串联后最大子数组之和<br>分类分析<br>k=1;<br>k=2;<br>k&gt;2 如果array之和小于0，那么结果就是k=2情况，否则k=2+(k-2)*sum(one array)</li>\n</ol>\n<h4 id=\"摩尔投票算法\"><a href=\"#摩尔投票算法\" class=\"headerlink\" title=\"摩尔投票算法\"></a>摩尔投票算法</h4><p>1.求众数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">int</span> k=<span class=\"hljs-number\">0</span>;<br><span class=\"hljs-keyword\">int</span> target_num=<span class=\"hljs-number\">0</span>;<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;size;i++)&#123;<br>    <span class=\"hljs-keyword\">if</span>(k==<span class=\"hljs-number\">0</span>)&#123;<br>        target_num=nums[i];<br>        k=<span class=\"hljs-number\">1</span>;<br>    &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>        <span class=\"hljs-keyword\">if</span>(nums[i]==target_num)&#123;<br>            k++;<br>        &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>            k--;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">//判断target_num的数是否大于n/2;</span><br><span class=\"hljs-keyword\">int</span> cnt=<span class=\"hljs-number\">0</span>;<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;size;i++)&#123;<br>    <span class=\"hljs-keyword\">if</span>(nums[i]==target_num)&#123;<br>        cnt++;<br>    &#125;<br>&#125;<br><span class=\"hljs-keyword\">if</span>(cnt&gt;n/<span class=\"hljs-number\">2</span>)&#123;<br>    <span class=\"hljs-keyword\">return</span> target_num;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>2.求大于n/3 的数<br>这样的数最多只有两个</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">int</span> k1=<span class=\"hljs-number\">0</span>;<span class=\"hljs-comment\">//投票的数量</span><br><span class=\"hljs-keyword\">int</span> k2=<span class=\"hljs-number\">0</span>;<br><span class=\"hljs-keyword\">int</span> target_num1;<span class=\"hljs-comment\">//具体的数</span><br><span class=\"hljs-keyword\">int</span> target_num2;<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;size;i++)&#123;<br>    <span class=\"hljs-keyword\">if</span>(k1&gt;<span class=\"hljs-number\">0</span>&amp;&amp;target_num1==nums[i])&#123;<br>        k1++;<br>    &#125;<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(k2&gt;<span class=\"hljs-number\">0</span>&amp;&amp;target_num2==nums[i])&#123;<br>        k2++;<br>    &#125;<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(k1==<span class=\"hljs-number\">0</span>)&#123;<br>        target_num1=nums[i];<br>        k1=<span class=\"hljs-number\">1</span>;<br>    &#125;<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(k2==<span class=\"hljs-number\">0</span>)&#123;<br>        target_num2=nums[i];<br>        k2=<span class=\"hljs-number\">1</span>;<br>    &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>        k1--;<br>        k2--;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">int</span> cnt1=<span class=\"hljs-number\">0</span>;<br><span class=\"hljs-keyword\">int</span> cnt2=<span class=\"hljs-number\">0</span>;<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;size;i++)&#123;<br>    <span class=\"hljs-keyword\">if</span>(k1&gt;<span class=\"hljs-number\">0</span>&amp;&amp;nums[i]==target_num1)&#123;<br>        cnt1++;<br>    &#125;<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(k2&gt;<span class=\"hljs-number\">0</span>&amp;&amp;nums[i]==target_num2)&#123;<br>        cnt2++;<br>    &#125;<br>&#125;<br><span class=\"hljs-keyword\">if</span>(cnt1&gt;n/<span class=\"hljs-number\">3</span>)&#123;<br>    res.<span class=\"hljs-built_in\">push_back</span>(target_num1);<br>&#125;<br><span class=\"hljs-keyword\">if</span>(cnt2&gt;n/<span class=\"hljs-number\">3</span>)&#123;<br>    res.<span class=\"hljs-built_in\">push_back</span>(target_num2);<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n\n\n\n<h3 id=\"分治算法专题\"><a href=\"#分治算法专题\" class=\"headerlink\" title=\"分治算法专题\"></a>分治算法专题</h3><p>1.IP地址验证合理性</p>\n<ol>\n<li><p>对于 IPv4 地址，通过界定符 . 将地址分为四块-&gt;a；对于 IPv6 地址，通过界定符 : 将地址分为八块-&gt;b。（count(.)==4/count(:)==6/neither）<br> a. 对于 IPv4 地址的每一块，检查它们是否在 0 - 255 内，且没有前置零。<br> b. 对于 IPv6 地址的每一块，检查其长度是否为 1 - 4 位的十六进制数。</p>\n</li>\n<li><p>删除注释<br> 分情况判断+用一个状态表明现在是否在注释内，主要是用于/* <em>/情况<br> （1）题目中没有考虑/</em> 不属于注释的这种情况，因此每次遇到/* &amp;&amp;block= False 表示开始块注释，每次遇到*/&amp;&amp;block=True,表示结束块注释<br> （2）遇到//直接结束，因为//后面都是注释，而且不改变状态</p>\n</li>\n</ol>\n<h4 id=\"corner-case的例子\"><a href=\"#corner-case的例子\" class=\"headerlink\" title=\"corner case的例子\"></a>corner case的例子</h4><p>lc1363: 形成3的最大倍数<br>思路： 判断sum之和</p>\n<ol>\n<li>%3==0， 那么返回res</li>\n<li>%3==1, 如果数组中有%3==1的数字那么直接删除； 否则删除两个%3==2的数字</li>\n<li>%3==2, 如果数组中有%3==2的数字那么直接删除； 否则删除两个%3==1的数字</li>\n<li>易错点：结果可能包含前缀0，因此需要将前缀0去掉（000001/000000）；结果也可能只是“”， 那么直接返回“”， 而不是0</li>\n</ol>\n<p>lc旋转链表<br>1.求size<br>2. k=k%size; k=k-size,表示第k个节点是现在的头结点（k-1是新链表尾节点）<br>3. 将头节点前面一个节点（k-1）的next置为null, 同时将当前链表的最后一个节点next指向头节点（利用在第二步变成环，可以减少找尾结点这一步）<br><font color=\"red\">链表类似题一定要判断head是否为null, size是否为0或者1这种情况 </font><br>快慢指针删除链表的重复元素的时候，一定要记得将慢指针的next设置为null</p>\n<p>lc,加1<br>在vector数组上+1</p>\n<ul>\n<li>一定要注意最后carry不为0的情况，需要在最开头插入一个数 digits.insert(digits.begin(),carry);</li>\n<li>应该使用tmp记录当前位的和。int tmp=digits[i]+carry;</li>\n</ul>\n<p>lc68. 文本左右对齐<br>字符串相关的模拟题，主要是分情况讨论<br>一个单词/最后一行/其他情况（spacecount, extraspace）</p>\n<p>其他corner case: </p>\n<ul>\n<li><ol>\n<li>乘法可能会超出范围，可能需要使用long long型 （数据范围一定要注意是用long long还是int）</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>在进行寻找mid的时候left+(right-left)/2</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>一定要注意&lt; &lt;=，以及边界情况的例子，在微软（矩阵旋转）和字节（和滑动窗口的最大值）最开始取[0,k-1]以及压入一个元素 已经跌过两次坑了</li>\n</ol>\n</li>\n<li>lc220. 存在重复元素 III，一定要注意nums[i]-t可能超出整数的范围，因此需要使用long 或者longlong对nums进行强制转换</li>\n</ul>\n<h4 id=\"模拟题目\"><a href=\"#模拟题目\" class=\"headerlink\" title=\"模拟题目\"></a>模拟题目</h4><ol>\n<li>矩阵旋转90</li>\n<li>螺旋矩阵 （使用分成4段（后面两段需要判断 left&lt; right&amp;&amp; upper&lt; down才可以），或者坐标移动+vis数组）</li>\n<li>倒酒杯</li>\n</ol>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>ok </p>\n<ol>\n<li><p>二维差分数组常用在对数组中的某一个块的区域进行操作， 比如这道题的贴邮票， 对整块数组+1; 比如对0-k这段距离的数据都进行翻转</p>\n</li>\n<li><p>一个数比较大，但是它取模之后的结果不一定大,两种解决方案</p>\n<ol>\n<li>保存long long的结果</li>\n<li>sum为定值的时候，一个数越接近sum的一半，乘积之后的结果越大</li>\n</ol>\n <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">abs</span>(cur*<span class=\"hljs-number\">2</span> - sum) &lt; <span class=\"hljs-built_in\">abs</span>(best*<span class=\"hljs-number\">2</span> - sum)) &#123;<br>    best = cur;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li><p>负数和正数的向上向下取整不同<br>Math.floor(2.6);    //2.0   floor地板 水平数轴向右取整<br>Math.floor(-2.6);   //-3.0   floor地板 水平数轴向右取整</p>\n</li>\n</ol>\n","site":{"data":{}},"wordcount":23287,"excerpt":"","more":"<h4 id=\"数组相关问题\"><a href=\"#数组相关问题\" class=\"headerlink\" title=\"数组相关问题\"></a>数组相关问题</h4><p>要将数字放在对应的位置上，使用原地交换的方式</p>\n<ol>\n<li>旋转矩阵  这个好像不行，需要记录交换过来的值的同时，记录交换过来的下标</li>\n<li>自然数数组的排序</li>\n<li>奇数下标是奇数，偶数下标是偶数</li>\n</ol>\n<ul>\n<li>第一种方法，使用一个环来进行数据的交换</li>\n<li>第二种方法，每个数据与当前的数据进行交换，然后判断当前交换过来的数据应该放到的位置，重复这样的过程，知道当前交换过来的数是应该放置的数</li>\n</ul>\n<p>举个例子：<br>//如果下标i应该放的数据是 i+1 index和value之间存在映射</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">tmp=a[i];<br><span class=\"hljs-keyword\">while</span>(a[i]!=i+<span class=\"hljs-number\">1</span>)&#123;<br>    <span class=\"hljs-keyword\">int</span> next=a[tmp<span class=\"hljs-number\">-1</span>];<br>    a[tmp<span class=\"hljs-number\">-1</span>]=tmp;<br>    tmp=next;<br>&#125;<br><br><span class=\"hljs-keyword\">while</span>(a[i]!=i+<span class=\"hljs-number\">1</span>)&#123;<br>    <span class=\"hljs-built_in\">swap</span>(a[i], a[a[i]<span class=\"hljs-number\">-1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li><p>最大子矩阵的和转为最大子数组的和，枚举每一行开始  i从0 ~ n-1,每次换开始的时候重新初始化数组s; j从i ~ n-1<br>二维转为一维</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;matrix.<span class=\"hljs-built_in\">size</span>();i++)&#123; <span class=\"hljs-comment\">//枚举row1</span><br>    <span class=\"hljs-keyword\">int</span> s[matrix[<span class=\"hljs-number\">0</span>].<span class=\"hljs-built_in\">size</span>()];<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j=i;j&lt;matrix.<span class=\"hljs-built_in\">size</span>();j++)&#123; <span class=\"hljs-comment\">//枚举row2</span><br>        <span class=\"hljs-keyword\">int</span> cur=<span class=\"hljs-number\">0</span>;<span class=\"hljs-comment\">//从头开始</span><br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> k=<span class=\"hljs-number\">0</span>;k&lt;matrix[<span class=\"hljs-number\">0</span>].<span class=\"hljs-built_in\">size</span>();k++)&#123; <span class=\"hljs-comment\">//转为最大子数组和</span><br>            s[k]+=matrix[j][k];<br>            cur+=s[k]; <span class=\"hljs-comment\">//利用之前加的值，加上现在的值</span><br>            res=<span class=\"hljs-built_in\">max</span>(res, cur);<br>            <span class=\"hljs-keyword\">if</span>(cur&lt;<span class=\"hljs-number\">0</span>)&#123;<br>                cur=<span class=\"hljs-number\">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li><p>边界都是1的最大正方形：<br>这种问题先想个暴力算法，然后考虑如何用空间换时间，加速判断的过程</p>\n</li>\n</ol>\n<ul>\n<li>1.先循环，找到每个点的right down数组，注意边界要单独赋值，从右往左，从下网上计算</li>\n<li>2.遍历size（最开始初始化为m.size()和m[0].size()的最小值）, 每个size下遍历每个点，看左右边长以及右上角和左下角的right down是否都大于size,<br>如果是返回true,否则返回false</li>\n</ul>\n<ol start=\"6\">\n<li>数组partition的调整<br>使用双指针，一个指针指向排序好的末尾，一个指针指向待排序序列的头结点<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">int</span> left=<span class=\"hljs-number\">0</span>;<br><span class=\"hljs-keyword\">int</span> right=<span class=\"hljs-number\">1</span>;<br><span class=\"hljs-keyword\">while</span>(right&lt;length)&#123;<br>    <span class=\"hljs-keyword\">if</span>(arr[left]!=arr[right])&#123;<br>        left++;<br>        <span class=\"hljs-built_in\">swap</span>(arr[left], arr[right]);<br>        right++;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n</ol>\n<p>此类型的拓展问题，红蓝白球的排序，以及 0 1 2的排序<br>解决方案：记录一个左节点（初始化-1）右节点（length）中间节点：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">int</span> left=<span class=\"hljs-number\">-1</span>;<br><span class=\"hljs-keyword\">int</span> right=length;<span class=\"hljs-comment\">//排好序的头</span><br><span class=\"hljs-keyword\">int</span> index=<span class=\"hljs-number\">0</span>;<br><span class=\"hljs-keyword\">while</span>(index&lt;right)&#123;<br>    <span class=\"hljs-keyword\">if</span>(arr[index]==<span class=\"hljs-number\">0</span>)&#123;<br>        <span class=\"hljs-built_in\">swap</span>(arr[++left], arr[index]);<br>        index++;<br>    &#125;<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(arr[index]==<span class=\"hljs-number\">2</span>)&#123;<br>        <span class=\"hljs-built_in\">swap</span>(arr[--right], arr[index]);<span class=\"hljs-comment\">//注意这种情况index还要继续判断，因此不能index++</span><br>    &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>        index++;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<ol start=\"7\">\n<li>网格中的最短路径和最短通路问题：</li>\n</ol>\n<ul>\n<li>1.一定要分清楚是用dp还是bfs</li>\n<li>2.如果是只能从左上往右下走，那么是dp,否则应该用bfs,同时因为是路径，因此需要一个额外的二维数组判断到当前节点需要的步数，或者另外申明一个node,<br>这个node里面记录到这个节点的步数</li>\n</ul>\n<p><font color=\"red\">8. 缺失的第一个正数： /引申缺失的最大负数（原位hash或者置换）</font></p>\n<ul>\n<li>方法一：如何在原数组上进行hash,但是保留那个位置的数不变使用- 符号；(负数 0全部变为size)<br>同时如果原来有符号，那么为了避免混淆，将原来为符号的数变为我们不关心的正数</li>\n<li>方法二：使用置换的方式，这种方式一定要注意进入死循环的方式因此在交换的时候判断。nums[nums[i]-1]!=nums[i]</li>\n</ul>\n<h5 id=\"random类似题目总结：\"><a href=\"#random类似题目总结：\" class=\"headerlink\" title=\"random类似题目总结：\"></a>random类似题目总结：</h5><p>rand5 to rand7<br>rand01p to rand6<br>rand1toM to rand1toN</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-number\">1</span>）  二维的方式，使得两个调用rand5在二维矩阵上是大于rand7，然后就可以选取<span class=\"hljs-number\">7</span>的倍数的一段距离对rand7取模<br>    <span class=\"hljs-keyword\">do</span>&#123;<br>        row=<span class=\"hljs-built_in\">rand5</span>()<span class=\"hljs-number\">-1</span>;<br>        col=<span class=\"hljs-built_in\">rand5</span>()<span class=\"hljs-number\">-1</span>;<br>        num=row*<span class=\"hljs-number\">5</span>+col <span class=\"hljs-comment\">//0-24之间</span><br>    &#125;<span class=\"hljs-keyword\">while</span>(num&gt;=<span class=\"hljs-number\">21</span>)<br><br>    <span class=\"hljs-keyword\">return</span> num%<span class=\"hljs-number\">7</span>+<span class=\"hljs-number\">1</span>;<br><br></code></pre></td></tr></table></figure>\n<p>2)<br>首先等概率产生0-1  01 10是等概率残生的</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">rand01</span><span class=\"hljs-params\">()</span></span>&#123;<br>    <span class=\"hljs-keyword\">do</span>&#123;<br>        num=<span class=\"hljs-built_in\">rand01p</span>();<br>    &#125;<span class=\"hljs-keyword\">while</span>(num==<span class=\"hljs-built_in\">rand01p</span>());<br>    <span class=\"hljs-keyword\">return</span> num;<br>&#125;<br><br>那么rand03=<span class=\"hljs-built_in\">rand01</span>()*<span class=\"hljs-number\">2</span>+<span class=\"hljs-built_in\">rand01</span>();<br>rand0<span class=\"hljs-number\">-15</span>=<span class=\"hljs-built_in\">rand03</span>()*<span class=\"hljs-number\">4</span>+<span class=\"hljs-built_in\">rand03</span>(); <span class=\"hljs-comment\">//倍数+插空  用进制的方法可以产生rand07()=rand03()+rand01()*4</span><br>那么rand6可由如下产生:<br><span class=\"hljs-keyword\">do</span>&#123;<br>    num=rand0<span class=\"hljs-number\">-15</span>;<br>&#125;<span class=\"hljs-keyword\">while</span>(num&gt;=<span class=\"hljs-number\">12</span>)<br><span class=\"hljs-keyword\">return</span> num%<span class=\"hljs-number\">6</span>+<span class=\"hljs-number\">1</span>;<br></code></pre></td></tr></table></figure>\n\n<p>3）k维的方式<br>rand1toM()转为rand1toN()其实就是调用k次（用N的M进制可以求得）的rand1toM, 使得这a* M^(k-1)+b* M^(k-2)+……  +c 比n要小， 然后返回就可以了<br>其实就是用M进制的数来表示N-1，如果随机生成的数是大于N，那么从头进行生成（注意是从头，而不是从当前数重新生成），否则返回这个数<br>步骤：<br>   1、将n-1转换成m进制数，假设结果转换成数组为 k = [a,b,c,d,e]<br>　　2、使用rand1ToM(m)函数产生结果数组 res = [A,B,C,D,E]，如果res所表示的数值大于k所表示的数值，将res丢掉重新随机，直到产生的结果小于或等于k，这时产生的res的范围就在0～n-1之间，但是此时res所表示的数还是m进制的。 //随机生成M进制的每一位数<br>　　3、将res数组转换成10进制整数。<br>　　4、将步骤3的结果加1就是最终的结果。</p>\n<h5 id=\"数学相关问题\"><a href=\"#数学相关问题\" class=\"headerlink\" title=\"数学相关问题\"></a>数学相关问题</h5><ol>\n<li>求num阶层中最后的包含0的个数，因为包含因子2的个数一定比5多，因此可以直接求包含因子5的个数<br>每5个数有一个5，每25个数中有一个数包含两个5<br>同样下面的模板可以用于求任何因子的个数<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">func</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> num)</span></span>&#123;<br>    <span class=\"hljs-keyword\">int</span> res=<span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">while</span>(num)&#123;<br>        res+=num/<span class=\"hljs-number\">5</span>;<br>        num=num/<span class=\"hljs-number\">5</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>\n<font color=\"blue\">2. 判断一个点是否在矩形中：叉乘+点乘</font><br>对角向量叉积的点积&gt;=0,（对角向量的叉积方向相同），使用叉积的原因是：一个点在线外还是在线内，叉积的正负不同<br>使用叉积可以判断方向，A = &lt;a1, a2&gt;，B = &lt;b1, b2&gt;<br>AXB=a1* b2-a2 *b1, 叉积向量的方向为法线的方向，上下为第一个向量指向第二个向量，大手指的方向<br>叉乘加内积</li>\n</ol>\n<p>(p1 p2 X p1 p ) * (p3 p4 X p3 p1)  &gt;= 0  （四个边分成两组，每两个对边一组， 看两边的叉积是否同方向）</p>\n<p><font color=\"blue\">3. 相同的题型：判断点是否在三角形中 叉乘</font><br>1）先判断三个点的顺序是否是逆时针方向:逆时针方向叉积小于0；顺时针方向叉积大于等于（注意顺序可能导致结果不同！！！）；如果是顺时针正方向，那么调整点位置<br>2）然后判断这个点x是否都是在三角形每条边的左边，判断过程：三角形每个顶点和边的叉积小于0</p>\n<p>（逆时针，点左侧；判断逆时针，仍然使用点左侧）</p>\n<p>求三个三角形不推荐，因为double类型可能出现误差</p>\n<p><font color=\"red\">4. 路径数组转为统计数组的题目：原地hash, 注意以负数作为标记的话，全部的数都需要转为正数</font><br>要求额外的空间复杂度为O(1)<br>如果要实现空间复杂度为O(1),那么需要在原来的数据上进行运算，那么每个位置存储跳过来的位置（最开始节点存储为-1），直到当前的数为一个负数（表示已经求过距离），然后跳回去的时候就知道来的位置，同时更新当前的距离，<br>为了区分已经判断过的值和未判断过的值，使用负数；求到距离矩阵之后再计算每个距离出现的次数，仍然是使用跳的方式，开始节点记得赋值为0，表示已经访问计算过</p>\n<p>这种方式也出现在”第一个未出现的正数“这道题解决方案中（值与下标相互映射）</p>\n<ol start=\"5\">\n<li>正数数组的最小不可组成和：<br>dp[0][0]=1<br>使用动态规划<br>for j=0; j=arr.size(); j++:<br> for i = sum to min: //注意反着,因为一个数只能取一次0-1背包<pre><code> if(i&gt;=arr[j]):\n     dp[i]=dp[i-arr[j]]?True:dp[i]//注意是dp[i]而不是false,也不是dp[i]=dp[i-arr[i]]//因为可能一个数一种方式可以组成，但是另一种不行\n</code></pre>\n</li>\n</ol>\n<p>PS:没有思路就想暴力算法，然后递归考虑是否能转为动态规划，类似背包问题</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">dp[i][j]=dp[i<span class=\"hljs-number\">-1</span>][j-arr[i]]||dp[i<span class=\"hljs-number\">-1</span>][j];<br><br><span class=\"hljs-keyword\">for</span> i in min to sum:<br>    <span class=\"hljs-keyword\">if</span> dp[n][i] == <span class=\"hljs-literal\">false</span>:<br>        <span class=\"hljs-keyword\">return</span> i<br></code></pre></td></tr></table></figure>\n\n<ol start=\"6\">\n<li>累加出整个范围最少还需要的数:<br>使用当前可以累加得到的范围，如果范围超过了当前遍历到的arr的第一个数，那么下一个可以累加得到的范围是当前的范围+arr[i];否则下一个差的数应该是touch+1,可以累加得到的数是touch+1+touch</li>\n</ol>\n<p>可以累加得到的数是touch,下一个差的数是touch+1</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">touch=<span class=\"hljs-number\">0</span>;<br>cnt=<span class=\"hljs-number\">0</span>;<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;arr.<span class=\"hljs-built_in\">size</span>();i++)&#123;<br>    <span class=\"hljs-keyword\">if</span>(touch+<span class=\"hljs-number\">1</span>&lt;arr[i])&#123;<br>        <span class=\"hljs-keyword\">while</span>(touch&lt;arr[i]+<span class=\"hljs-number\">1</span>)&#123;<span class=\"hljs-comment\">//注意这是循环</span><br>            touch+=touch+<span class=\"hljs-number\">1</span>;<br>            cnt++;<br>            <span class=\"hljs-keyword\">if</span>(touch&gt;=range)&#123;<br>                <span class=\"hljs-keyword\">return</span> cnt;<br>            &#125;<br>        &#125;<br>    &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>        touch+=arr[i];<br>        <span class=\"hljs-keyword\">if</span>(touch&gt;=range)&#123;<br>            <span class=\"hljs-keyword\">return</span> cnt;<br>        &#125;<br>    &#125;<br>&#125;<br><span class=\"hljs-keyword\">while</span>(touch&lt;range)&#123;<br>        touch+=touch+<span class=\"hljs-number\">1</span>;<br>        cnt++;    <br>&#125;<br><br>    <span class=\"hljs-keyword\">return</span> cnt;<br></code></pre></td></tr></table></figure>\n\n<ol start=\"7\">\n<li>一种字符串和数字对应的关系 （lc168. Excel表列名称）<br>A -&gt; 1<br>B -&gt; 2<br>C -&gt; 3<br>…<br>Z -&gt; 26<br>AA -&gt; 27<br>AB -&gt; 28<br>从 1开始的的 2626 进制转换题。（每一位至少都有1）</li>\n</ol>\n<ul>\n<li><p>方法1：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">string res=<span class=\"hljs-string\">&quot;&quot;</span>;<br><span class=\"hljs-keyword\">while</span>(columnNumber&gt;<span class=\"hljs-number\">0</span>)&#123;<br>    columnNumber--;<br>    res+=(columnNumber%<span class=\"hljs-number\">26</span>+<span class=\"hljs-string\">&#x27;A&#x27;</span>);<br>    columnNumber/=<span class=\"hljs-number\">26</span>;<br>&#125;<br><span class=\"hljs-built_in\">reverse</span>(res.<span class=\"hljs-built_in\">begin</span>(), res.<span class=\"hljs-built_in\">end</span>());<br><span class=\"hljs-keyword\">return</span> res;<br></code></pre></td></tr></table></figure></li>\n<li><p>方法2：注意是K伪进制数，也就是每一个伪至少为1不能为0，因此需要先从右往左计算位数（同时每一位分得1, 因为这个规则每一位至少都有1），然后从左往右分剩下的数字 </p>\n</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-comment\">//先从右往左，减掉一轮，再从左往右看补在哪为 进制如果为3：base=1 3 9</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">int2str</span><span class=\"hljs-params\">()</span></span>&#123;<br>    cur=<span class=\"hljs-number\">1</span>;<span class=\"hljs-comment\">//代表进制的基数</span><br>    k=<span class=\"hljs-number\">0</span><span class=\"hljs-comment\">//代表位数</span><br>    base=<span class=\"hljs-number\">3</span><span class=\"hljs-comment\">//代表进制数，多少个字符就是多少进制</span><br>    <span class=\"hljs-keyword\">while</span>(n&gt;=cur)&#123;<br>        k++;<br>        n-=cur;<br>        cur*=base;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">int</span> index=<span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">while</span>(k)&#123;<br>        cur/=base;<br>        res[index++]=<span class=\"hljs-built_in\">getchar</span>(n/cur);  <span class=\"hljs-comment\">//当前base的数量应该为n/cur+1,对应的下标就是n/cur</span><br>        n=n%cur; <span class=\"hljs-comment\">//剩下的数可以分多少到下一个进制位中</span><br>        k--;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n<p>str2int类似于K进制</p>\n<p>从N个数中等概率打印M个数,空间复杂度为O(1)：将每次打印的数每次交换到整个数组的末尾，然后下次在生成随机数的时候，减少生成范围（1，n-count）</p>\n<ol start=\"8\">\n<li>数字的中文表达和英文表达：</li>\n</ol>\n<ul>\n<li>1.中文表达：对于零特殊处理</li>\n<li>2.英文表达：每三个一组进行处理；使用递归或者迭代。递归方式就是分别求出billion million和thousand三个部分的数字，然后加起来，<br>在求每个部分的时候，先判断百位，如果百位有数字的话，那么加上”hundred“,否则分为数字&lt;=10 &lt;20; &lt;=20 &lt;100 and &lt;10 三种情况进行处理</li>\n</ul>\n<ol start=\"9\">\n<li>实现sqrt函数</li>\n</ol>\n<ul>\n<li><p>方法一：使用二分算法（一个数的平方根不会大于 n/2+1），标准二分，返回right</p>\n</li>\n<li><p>方法二：牛顿迭代算法： y=f(x0)+k(x-x0)<br>令y=0, 得到 x_i+1=(x_i+ C/x_i)  其中C为要求的目标</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> &#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">mySqrt</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> x)</span> </span>&#123;<br>        <span class=\"hljs-keyword\">if</span> (x == <span class=\"hljs-number\">0</span>) &#123;<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>        &#125;<br><br>        <span class=\"hljs-keyword\">double</span> C = x, x0 = x;<br>        <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>) &#123;<br>            <span class=\"hljs-keyword\">double</span> xi = <span class=\"hljs-number\">0.5</span> * (x0 + C / x0);<br>            <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">fabs</span>(x0 - xi) &lt; <span class=\"hljs-number\">1e-7</span>) &#123;<br>                <span class=\"hljs-keyword\">break</span>;<br>            &#125;<br>            x0 = xi;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\"><span class=\"hljs-keyword\">int</span></span>(x0);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li>\n</ul>\n<ol start=\"10\">\n<li>小数的十进制转为二进制是*2 取整数部分，如果整数&gt;=1, 那么num-=1,否则当前位为0， 直到num=0; 也可以1连除2，num如果num&gt;base,那么减去base<br>十进制整数转换为二进制整数采用”除2取余，逆序排列”法<br>十进制小数转换成二进制小数采用”乘2取整，顺序排列”法</li>\n</ol>\n<ol start=\"11\">\n<li>全排列问题，使用交换或者vis+回溯，一定要注意是否有重复的字符，如果有重复的字符，那么下一个交换或者选择的数，一定是当前没有选择的 （可以和当前自己位置进行交换）</li>\n</ol>\n<p><font color=\"red\">12. 树状数组例题：数字流的秩 线段树（平衡树+二叉搜索树，需要初始化4*n区间） 使用频繁更新数组的某一位（后面的位数也需要相应修改），以及求前缀和</font><br>线段树和树状数组的基本功能都是在某一满足结合律的操作(比如加法，乘法，最大值，最小值)下，O(logn)的时间复杂度内修改单个元素并且维护区间信息。不同的是，树状数组只能维护前缀“操作和”(前缀和，前缀积，前缀最大最小)，而线段树可以维护区间操作和。线段数组是真正的数，而树状数组只是一个数组</p>\n<p>树状数组主要是用于求前缀和，（改变原始然后求前缀和；差分数组适用于，某一段的元素被整体加上或者减去一个元素）</p>\n<ul>\n<li>区间查询：求index的前缀和其实就是不断将index的二进制数的最后一个一个1逐渐变为0 的数据对应的值相加；（x-(x&amp;-x)）//不断地去掉二进制数最右边的一个1 （从x到=n）</li>\n<li>单点修改：更新一个index需要更新的其他下标的值相当于 不断加上最后一个1所代表的数字下标对应的值（x+(x&amp;-x)）//从右边起一系列连续的1变为0，再把这一系列1的前一位0变为1,相当与最后一个1+1，导致连续进位<br>其中存储值的下标从1开始，0下标主要是判断循环的终点，不被用来存储值 （从x到0）</li>\n</ul>\n<p>而且树状数组的下标从1开始，常用语频繁更新和频繁求前缀和</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">建立树状数组：<br><span class=\"hljs-keyword\">int</span> n;<br><span class=\"hljs-keyword\">int</span> a[<span class=\"hljs-number\">1005</span>],c[<span class=\"hljs-number\">1005</span>]; <span class=\"hljs-comment\">//对应原数组和树状数组</span><br><span class=\"hljs-comment\">//范围是[1,n]</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">lowbit</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> x)</span></span>&#123;<br>    <span class=\"hljs-keyword\">return</span> x&amp;(-x);<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">updata</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> i,<span class=\"hljs-keyword\">int</span> k)</span></span>&#123;    <span class=\"hljs-comment\">//在i位置加上k</span><br>    <span class=\"hljs-keyword\">while</span>(i &lt;= n)&#123;<br>        c[i] += k;<br>        i += <span class=\"hljs-built_in\">lowbit</span>(i);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">getsum</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> i)</span></span>&#123;        <span class=\"hljs-comment\">//求A[1 - i]的和</span><br>    <span class=\"hljs-keyword\">int</span> res = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">while</span>(i &gt; <span class=\"hljs-number\">0</span>)&#123;<br>        res += c[i];<br>        i -= <span class=\"hljs-built_in\">lowbit</span>(i);<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>树状数组如果输入有0， 那么所有的输入都应该向右边偏移以为（输入x，实际上对应x+1）</p>\n<p>例题：lc5999. 统计数组中好三元组数目<br>这道题是求在一个数的左边，同时小于这个数的数量（数量题）<br>lc307. 区域和检索 - 数组可修改</p>\n<ul>\n<li>这道题是，频繁的修改某个下标的元素值+同时求某个范围元素之间的元素和（值题目）</li>\n<li>数组的大小为arr的范围n， 下标对于树状数组的二进制下标</li>\n<li>需要先将num的值插入树状数组中， 然后更新的时候使用newvalue-ori[index]来更新当前节点后面的值，同时一定要记得更新ori[index]=newvalue !!!!</li>\n<li>一定要记得树状数组的下标是从1开始，但是num的下标从0开始；而且区间范围是两边闭合，所以求区间差的时候，left_index应该减1</li>\n</ul>\n<p><font color=\"red\">lc315. 计算右侧小于当前元素的个数（hard）</font></p>\n<ul>\n<li>注意这道题数据可能为负数，因此需要对数据+10000+1 使数据shift到[1, +无穷]</li>\n<li>使用归并排序，每个i, j 那么num[i]+=j-i-1 (就是在i后面而且比nums[i]小的数的数量)<br>归并排序易错点：需要使用索引数组,同时在进行归并的时候会修改索引数组，一定要记得复制一个新的数组出来，不能使用原来的数组；其次就是注意数组的范围，左右都闭合；归并排序还长用于计算逆序对</li>\n</ul>\n<p>lc493. 翻转对(hard)</p>\n<ul>\n<li>归并排序</li>\n<li>范围映射的树状数组（具体代码可见模板代码）</li>\n</ul>\n<ol start=\"13\">\n<li>最佳直线，使用暴力枚举的方式， 三重循环<br>枚举直线两个起始端点(i, j)，后面遍历k是否在直线(i, j)上，在的话计算过得点个数进行更新， 最后判断这条直线上最多有多少个同点<br>时间复杂度：O(n^3)<br>空间复杂度：O(1)O(1)</li>\n</ol>\n<ol start=\"14\">\n<li>枚举题：模式匹配问题，暂时未做，主要是通过a和b的数量来枚举a匹配的字符的长度和b字符的长度，主要是注意边界情况应该先于长度的枚举进行判断<br>example： pattern = “abba”, value = “dogcatcatdog”<br>注意：pattern只包含字母”a”和”b”两种字符， 而且a或者b可以为空串， 而且a 与b映射的字符串不应该相等<br>lena lenb都为0; lena为0; lenb为0;lena lenb都不为0时， 他们映射的字符串不应该相等</li>\n</ol>\n<ol start=\"15\">\n<li>大数相乘的题目</li>\n</ol>\n<ul>\n<li>使用第二个数的每一位数和第一个数相乘&lt;&lt; i 位，然后将求得的结果相加</li>\n<li>使用第一个数的每一位和第二个数相乘，更新结果的 arr[i+k]位</li>\n</ul>\n<ol start=\"16\">\n<li>矩形覆盖面积： 公式为area1+area2-inter_area<br>inter_area = max((最小 右上横坐标 - 最大左下横坐标), 0)* max(（最小右上纵坐标 -  最大左下纵坐标, 0)</li>\n</ol>\n<p>注意一定要和0进行比较</p>\n<ol start=\"16\">\n<li>找众数II:</li>\n</ol>\n<ul>\n<li>使用hash算法</li>\n<li>使用摩尔投票算法</li>\n</ul>\n<p>找到超过 (n/3) 向下取整的数：数学证明这样的数最多2个，选两个数，如果当前的数都不等于前两个数，那么两个投票数都–<br>这种投票算法同样适用于找到超过 n/2</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> &#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\">vector&lt;<span class=\"hljs-keyword\">int</span>&gt; <span class=\"hljs-title\">majorityElement</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        vector&lt;<span class=\"hljs-keyword\">int</span>&gt; ans;<br>        <span class=\"hljs-keyword\">int</span> element1 = <span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-keyword\">int</span> element2 = <span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-keyword\">int</span> vote1 = <span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-keyword\">int</span> vote2 = <span class=\"hljs-number\">0</span>;<br><br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> &amp; num : nums) &#123;<br>            <span class=\"hljs-keyword\">if</span> (vote1 &gt; <span class=\"hljs-number\">0</span> &amp;&amp; num == element1) &#123; <span class=\"hljs-comment\">//如果该元素为第一个元素，则计数加1</span><br>                vote1++;<br>            &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (vote2 &gt; <span class=\"hljs-number\">0</span> &amp;&amp; num == element2) &#123; <span class=\"hljs-comment\">//如果该元素为第二个元素，则计数加1</span><br>                vote2++;<br>            &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (vote1 == <span class=\"hljs-number\">0</span>) &#123; <span class=\"hljs-comment\">// 选择第一个元素</span><br>                element1 = num;<br>                vote1++;<br>            &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (vote2 == <span class=\"hljs-number\">0</span>) &#123; <span class=\"hljs-comment\">// 选择第二个元素</span><br>                element2 = num;<br>                vote2++;<br>            &#125; <span class=\"hljs-keyword\">else</span> &#123; <span class=\"hljs-comment\">//如果三个元素均不相同，则相互抵消1次</span><br>                vote1--;<br>                vote2--;<br>            &#125;<br>        &#125;<br><br>        <span class=\"hljs-keyword\">int</span> cnt1 = <span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-keyword\">int</span> cnt2 = <span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> &amp; num : nums) &#123;<br>            <span class=\"hljs-keyword\">if</span> (vote1 &gt; <span class=\"hljs-number\">0</span> &amp;&amp; num == element1) &#123;<br>                cnt1++;<br>            &#125;<br>            <span class=\"hljs-keyword\">if</span> (vote2 &gt; <span class=\"hljs-number\">0</span> &amp;&amp; num == element2) &#123;<br>                cnt2++;<br>            &#125;<br>        &#125;<br>        <span class=\"hljs-comment\">// 检测元素出现的次数是否满足要求</span><br>        <span class=\"hljs-keyword\">if</span> (vote1 &gt; <span class=\"hljs-number\">0</span> &amp;&amp; cnt1 &gt; nums.<span class=\"hljs-built_in\">size</span>() / <span class=\"hljs-number\">3</span>) &#123;<br>            ans.<span class=\"hljs-built_in\">push_back</span>(element1);<br>        &#125;<br>        <span class=\"hljs-keyword\">if</span> (vote2 &gt; <span class=\"hljs-number\">0</span> &amp;&amp; cnt2 &gt; nums.<span class=\"hljs-built_in\">size</span>() / <span class=\"hljs-number\">3</span>) &#123;<br>            ans.<span class=\"hljs-built_in\">push_back</span>(element2);<br>        &#125;<br><br>        <span class=\"hljs-keyword\">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>\n\n\n<ol start=\"17\">\n<li>为运算表达式计算优先级<br>使用分治算法, 遍历表达式，找到运算符，将结果分成两个部分， 递归查找。类似二叉树的组成方式查找<br>如果求具体的结果，那么需要使用vector将结果进行push_back,否则可以直接使用动态规划，计算总数</li>\n</ol>\n<ol start=\"18\">\n<li>摆动序列 如果是需要相邻两个数不能等于的话，只能两个字符串都进行翻转，如果可以相邻等于的话，可以后面的字符串进行翻转就行了 </li>\n</ol>\n<ol start=\"19\">\n<li><p>中文变为阿拉伯数字和阿拉伯数字变为中文<br>1.中文变为阿拉伯数字<br>使用栈，将文字划分为数字和量纲，遇到量纲，那么从栈中弹出与当前量纲小的数字与当前量纲相乘，然后不断累加，知道栈为空或者栈顶量纲比当前量纲大，然后将当前累加到的数压入栈中；最后的结果就是栈中的数求和</p>\n<p>2.阿拉伯数字变为中文<br>注意：亿，万节之后如果只有0那么不需要输出0，如果千位为0的话那么需要输出0<br>10500，一万零五百， 15000一万五千</p>\n<p>将数组划分为节，然后每节使用一个函数判断<br>如果不是第一节，而且当前的数是大于0，而且小于1000的话那么需要加零</p>\n</li>\n</ol>\n<ol start=\"20\">\n<li>面试题 16.14. 最佳直线/149. 直线上最多的点数</li>\n</ol>\n<ul>\n<li>暴力方法：使用三重循环，前两个点固定一条直线，后一个点判断是否在直线上，是cnt++,最后找最大的cnt</li>\n<li>hash方法，使用二重循环，遍历两个点，两个点得到一个斜率，然后hash_map中存储该斜率的cnt, 最后取最大值的时候res=max(res, cnt+1)//一定记得+1<br>  因为gcd(5, 0)=5=cd(0, 5) 所以不存在除0情况<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">int</span> a = x1 - x2, b = y1 - y2;<br><span class=\"hljs-keyword\">int</span> k = <span class=\"hljs-built_in\">gcd</span>(a, b);<br>String key = (a / k) + <span class=\"hljs-string\">&quot;_&quot;</span> + (b / k); <span class=\"hljs-comment\">//斜率用string存储</span><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">gcd</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> a, <span class=\"hljs-keyword\">int</span> b)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">return</span> b == <span class=\"hljs-number\">0</span> ? a : <span class=\"hljs-built_in\">gcd</span>(b, a % b);<br>&#125;<br></code></pre></td></tr></table></figure></li>\n</ul>\n<ol start=\"21\">\n<li>阶层之后的零</li>\n</ol>\n<ul>\n<li> 方法1， 直接计算，n是5的倍数的个数+25倍数个数+…<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">int</span> pow=<span class=\"hljs-number\">5</span>;<br><span class=\"hljs-keyword\">while</span>(n&gt;=pow)&#123;<br>    cnt+=n/pow;<br>    pow=pow*<span class=\"hljs-number\">5</span>;<br>&#125;<br><span class=\"hljs-keyword\">return</span> cnt;<br></code></pre></td></tr></table></figure></li>\n<li>方法2， 对1-n中的每一个数计算，能够拆分为多少个5的因子<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;=n;i++)&#123;<br><span class=\"hljs-keyword\">int</span> tmp=i;<br><span class=\"hljs-keyword\">while</span>(tmp%<span class=\"hljs-number\">5</span>==<span class=\"hljs-number\">0</span>)&#123;<br>    tmp=tmp/<span class=\"hljs-number\">5</span>;<br>    cnt++;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n</ul>\n<ol start=\"22\">\n<li>lc277. find-the-celebrity</li>\n</ol>\n<ul>\n<li>所有的人都认识名人，名人谁都不认识，找出名人</li>\n<li>假设法，O(n), 假设0是名人，如果遇到knows(0, i)==true, 说明0不是名人，同时说明[0~i-1]都不是名人，因为他们都不被0知道</li>\n<li>之后再判断一次，如果出现know(ans, i)==true||know(i, ans)==false, 返回-1</li>\n</ul>\n<h5 id=\"19-交换数据的位置\"><a href=\"#19-交换数据的位置\" class=\"headerlink\" title=\"19.交换数据的位置\"></a>19.交换数据的位置</h5><p>（1）打标记方法： 这种方式理解起来更轻松, 注意这种方式，如果元数据中包含0或者小于0，但是目标数据中是大于0的([1, size])， 那可以将0，负数转为size+1; 否则如果元数据有0， 目标数据也有0的话，打标记是无法解决的</p>\n<ol>\n<li>缺失的第一个正数 （用负号在原地打标记代替hash方法，或者用置换方法，一定要将负数和&gt;size都转为size+1；同时对于target_index和当前index数据相同时，退出循环）</li>\n<li>丢失的数字</li>\n<li>数组中重复的数据</li>\n</ol>\n<p>将当前的数在对应的下标中打上标记，同时为了找到被覆盖数据的元数据，可以使用+n（这种可以找到重复3次， 4次都可以）,或者变为负数的这种做法<br>但是变负数的这种方式，不能适用于含有0的这种情况，因为-0和0是一样的，无法判断是否出现过这个数字</p>\n<p>找到的条件是 nums[i]&gt;=0 退出</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">firstMissingPositive</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;<br>     <span class=\"hljs-keyword\">int</span> n = nums.<span class=\"hljs-built_in\">size</span>();<br>     <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span>&amp; num: nums) &#123;<br>         <span class=\"hljs-keyword\">if</span> (num &lt;= <span class=\"hljs-number\">0</span>) &#123;<br>             num = n + <span class=\"hljs-number\">1</span>;<br>         &#125;<br>     &#125;<br>     <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; n; ++i) &#123;<br>         <span class=\"hljs-keyword\">int</span> num = <span class=\"hljs-built_in\">abs</span>(nums[i]);<br>         <span class=\"hljs-keyword\">if</span> (num &lt;= n) &#123;<br>             nums[num - <span class=\"hljs-number\">1</span>] = -<span class=\"hljs-built_in\">abs</span>(nums[num - <span class=\"hljs-number\">1</span>]);<br>         &#125;<br>     &#125;<br>     <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; n; ++i) &#123;<br>         <span class=\"hljs-keyword\">if</span> (nums[i] &gt; <span class=\"hljs-number\">0</span>) &#123;<br>             <span class=\"hljs-keyword\">return</span> i + <span class=\"hljs-number\">1</span>;<br>         &#125;<br>     &#125;<br>     <span class=\"hljs-keyword\">return</span> n + <span class=\"hljs-number\">1</span>;<br> &#125;<br><br></code></pre></td></tr></table></figure>\n\n<p>（2）置换</p>\n<ol>\n<li>缺失的第一个正数 把数据放在对应的位置</li>\n</ol>\n<p>将当前的数放在当前数据对应的下标中</p>\n<p>找到的条件是 nums[i]！=i+1 退出</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">firstMissingPositive</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">int</span> n = nums.<span class=\"hljs-built_in\">size</span>();<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; n; ++i) &#123;<br>        <span class=\"hljs-keyword\">while</span> (nums[i] &gt; <span class=\"hljs-number\">0</span> &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[nums[i] - <span class=\"hljs-number\">1</span>] != nums[i]) &#123;<br>            <span class=\"hljs-built_in\">swap</span>(nums[nums[i] - <span class=\"hljs-number\">1</span>], nums[i]); <span class=\"hljs-comment\">//要和它交换的数不能等于它本身</span><br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; n; ++i) &#123;<br>        <span class=\"hljs-keyword\">if</span> (nums[i] != i + <span class=\"hljs-number\">1</span>) &#123;<br>            <span class=\"hljs-keyword\">return</span> i + <span class=\"hljs-number\">1</span>;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> n + <span class=\"hljs-number\">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>（3） 二分算法，查找小于mid的数据量，如果是大于mid的话说明重复的数小于等于mid,因此r=mid-1 and ans=mid(或者r=mid), 否则l=mid+1<br> (4) 数组版快慢指针，index-&gt;nums[index] 那么有一个数会被指向两次，那么存在环</p>\n<ul>\n<li>映射找环法， 找冗余的数据，其实就是找环路的起点</li>\n<li><a href=\"https://segmentfault.com/a/1190000003817671\">https://segmentfault.com/a/1190000003817671</a><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> &#123;</span><br>   <span class=\"hljs-keyword\">public</span>:<br>       <span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">findDuplicate</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;<br>           <span class=\"hljs-keyword\">int</span> slow = <span class=\"hljs-number\">0</span>, fast = <span class=\"hljs-number\">0</span>;<br>           <span class=\"hljs-keyword\">do</span> &#123;<br>               slow = nums[slow];<br>               fast = nums[nums[fast]];<br>           &#125; <span class=\"hljs-keyword\">while</span> (slow != fast);<br>           slow = <span class=\"hljs-number\">0</span>;<br>           <span class=\"hljs-keyword\">while</span> (slow != fast) &#123;<br>               slow = nums[slow];<br>               fast = nums[fast];<br>           &#125;<br>           <span class=\"hljs-keyword\">return</span> slow;<br>       &#125;<br>   &#125;;<br></code></pre></td></tr></table></figure></li>\n</ul>\n<ol start=\"4\">\n<li>lc 440和lc386 按照字典序排序，和按照字典序排序的第k个数字<br>我们输入两个值n和k，n表示我们有从1到n个整数，然后将这些整数都字符串化之后按字典排序，找出其中第K大的。例如:n=15,k=5.那么1-15字符串化之后排序如下:1,10,11,12,13,14,15,2,3,4,5,6,7,8,9。其中第5大的就为13。<br>实际上多叉树从到右进行计数</li>\n</ol>\n<p>每次求解二叉树相邻两个节点之间(base 和base+1)包含的数据，如果k&gt;num那么直接更新k 然后当前数+1(base=base+1), 否则递归求里面的数据(base=base*10)</p>\n<p><font color=\"red\">20. 字符串相乘</font></p>\n<ul>\n<li><p>模板代码：</p>\n  <figure class=\"highlight c++\"><figcaption><span>关键代码</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\">vector&lt;<span class=\"hljs-keyword\">int</span>&gt; <span class=\"hljs-title\">res</span><span class=\"hljs-params\">(size1+size2+<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>)</span></span>;<br><span class=\"hljs-built_in\">reverse</span>(num1.<span class=\"hljs-built_in\">begin</span>(), num1.<span class=\"hljs-built_in\">end</span>());<br><span class=\"hljs-built_in\">reverse</span>(num2.<span class=\"hljs-built_in\">begin</span>(), num2.<span class=\"hljs-built_in\">end</span>());<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;size1;i++)&#123;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">0</span>;j&lt;size2;j++)&#123;<br>        res[i+j]=res[i+j]+(num1[i]-<span class=\"hljs-string\">&#x27;0&#x27;</span>)*(num2[j]-<span class=\"hljs-string\">&#x27;0&#x27;</span>);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li><p>知识点：字符ASCII码和数字的相互转换<br>  char a=’0’+81;<br>  char b=a-81;<br>  int c=a-‘0’;<br>  cout&lt;&lt;a&lt;&lt; “ “&lt;&lt;b&lt;&lt;” “&lt;&lt;c&lt;&lt;endl;<br>  注意c最终打印的结果为-175, 而不是81！！！！ 所以在初始化字符串相乘的数组只能用int类型不能用string类型<br>  char m=’A’+1;//打印输出’B’</p>\n</li>\n<li><p>初始化一个m+n的数组（注意一定要为int类型，不能为string类型），然后循环计算每一位应该的值，最后从低位到高位进行进位更新</p>\n</li>\n<li><p>易错点：str1和str2需要翻转，之后的结果需要去前缀零以及翻转回来<br>如果不翻转，那么nums1[i]和nums2[j]对应nums[i+j+1]的数组</p>\n</li>\n</ul>\n<ol start=\"21\">\n<li>分数到小数，模拟除法</li>\n</ol>\n<p>使用hash记录余数到下标的隐射，如果出现重复余数，说明出现了重复的小数循环体<br>注意易错点：</p>\n<ul>\n<li>1.可能存在负数，但是不能直接对负数取反（因为可能为INT_MIN），需要转为long型<br>  判断结果为负数使用异或<br>  if (numeratorLong &lt; 0 ^ denominatorLong &lt; 0) {//异号为负数<pre><code>  sb.append(&#39;-&#39;);\n</code></pre>\n  }</li>\n</ul>\n<ol start=\"22\">\n<li>lc670. 最大交换</li>\n</ol>\n<ul>\n<li>一个数字交换一次，如何使得交换后的数最大 输入: 2736 输出: 7236</li>\n<li>先遍历字符串求得每个数最靠后的下标（因为小于当前的数，应该换到越靠后面越好）</li>\n<li>然后从左遍历每个数的时候，遍历 ‘9’到s[i]-‘0’看是否有比当前数大的数，而且在这个数后面，如果有，那么交换，然后退出</li>\n<li>因为第二重循环只是从9到s[i]-‘0’， 因此总的时间复杂度还是O(N)</li>\n</ul>\n<h4 id=\"分而治之专题\"><a href=\"#分而治之专题\" class=\"headerlink\" title=\"分而治之专题\"></a>分而治之专题</h4><ol>\n<li><p>超级次方， 也类似观察规律的题目，就是在定义一种新的运算的时候，将它化简为熟知的运算。同时运用规律“对乘法的结果求模，等价于先对每个因子都求模，然后对因子相乘的结果再求模”<br>不能直接使用系统自带的pow,只能自己实现pow因为，在求乘方过程随时会出现溢出，所以要为每一个中间结果取模</p>\n</li>\n<li><p>第K个语法符号<br>找第n个的数的第k个字符是什么，转为找第n-1个数的对应f(k)位上面的数据（左半边不取反，右半边取反）<br>易错点在：一个数的时候会add两次如何解决, 那么就在返回的时候，只有一个数的时候，说明出现了[[num, []]]的这种情况，那么直接return result.getInterger, 否则直接返回result</p>\n</li>\n</ol>\n<h4 id=\"递归相关，表达式相关专题\"><a href=\"#递归相关，表达式相关专题\" class=\"headerlink\" title=\"递归相关，表达式相关专题\"></a>递归相关，表达式相关专题</h4><ol>\n<li>迷你语法分析器：<br>注意在进行递归的时候， 递归进去直接初始化一个NestInterger res, 来加入[]里面的数字， 遇到循环递归调用，然后返回时直接res.add<br>另外一个易错点是，注意负数的处理</li>\n</ol>\n<h4 id=\"蓄水池抽样算法\"><a href=\"#蓄水池抽样算法\" class=\"headerlink\" title=\"蓄水池抽样算法\"></a>蓄水池抽样算法</h4><p>模板</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> &#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">Solution</span>(ListNode* head) &#123;<br>        <span class=\"hljs-keyword\">this</span>-&gt;head=head;<br>    &#125;<br>    <br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">getRandom</span><span class=\"hljs-params\">()</span> </span>&#123;<br>        ListNode*cur=<span class=\"hljs-keyword\">this</span>-&gt;head;<br>        <span class=\"hljs-keyword\">int</span> pool=<span class=\"hljs-number\">-1</span>;<br>        <span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">1</span>;<br>        <span class=\"hljs-keyword\">while</span>(cur)&#123;<br>            <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">rand</span>()%i==<span class=\"hljs-number\">0</span>)pool=cur-&gt;val; <span class=\"hljs-comment\">//只选取一个数的情况</span><br>            i++;<br>            cur=cur-&gt;next;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> pool;<br>    &#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>    ListNode*head;<br>&#125;;<br><br></code></pre></td></tr></table></figure>\n\n<p>例题：</p>\n<ol>\n<li>链表随机节点</li>\n<li>随机索引数 ，找到target数的随机一个index</li>\n</ol>\n<h4 id=\"并查集专题\"><a href=\"#并查集专题\" class=\"headerlink\" title=\"并查集专题\"></a>并查集专题</h4><p>相关例题：</p>\n<p>除法求值：并查集的变形，除了要判断各个数字是否连通，还需添加一个数组记录节点之间的权重 weight(当前节点到其父节点的权重); 而且注意如何a/b那么应该是a的父亲节点是b, a指向b的权重为a/b, 反过来的话不对 <strong>一定要注意这个权重的更新，应该为当前的权重 * 他原来父亲的现在的权重</strong></p>\n<p>易错点：</p>\n<ul>\n<li>在进行节点merge的时候一定要注意权重的更新，weight代表的是两个节点之间的权重，而不是一个节点到根节点的权重</li>\n<li>find的时候返回的是father[a]而不是a !!!!!!</li>\n<li>fa!=fb的时候应该是father[fa]=fb, 与两个孩子节点a b无关</li>\n<li>递归寻找father的时候，应该使用father[index]作为函数的参数而不是index(会陷入无限死循环中)</li>\n<li>在并查集的时候，可以直接使用string作为头节点，不一定要转为int类型  unordered_map&lt;string, string&gt; father; unordered_map&lt;string, int&gt;num<br>例题：面试题 17.07. 婴儿名字</li>\n<li>可以使用string的find函数来对字符串进行分割（带括号或者，形式的分割）</li>\n</ul>\n<p>并查集模板：具体可见vscode里面的代码，两个模板 带size和不带size的情况</p>\n<p>例题2：lc947. 移除最多的同行或同列石头</p>\n<ul>\n<li>这个是二维坐标的，横坐标或者纵坐标相同都在一个并查集，因此需要将横纵坐标放在两个范围中，防止重叠；因为x, y在[0,1000]之间，一次你可以将横坐标放在+10001, 使得x y范围错开</li>\n</ul>\n<p>剑指 Offer II 111. 计算除法</p>\n<ul>\n<li>使用并查集或者BFS/DFS</li>\n<li>并查集注意分母为儿子（大），分子为父亲</li>\n<li>BFS的时候正向，反向都要连接</li>\n</ul>\n<h4 id=\"图相关\"><a href=\"#图相关\" class=\"headerlink\" title=\"图相关\"></a>图相关</h4><p>竞赛第四题 hard lc2097. 合法重新排列数对 //暂时没有看</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> &#123;</span><br>    map&lt;<span class=\"hljs-keyword\">int</span>, vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&gt; mp;<br>    map&lt;<span class=\"hljs-keyword\">int</span>, <span class=\"hljs-keyword\">int</span>&gt; deg;<br>    vector&lt;vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&gt; ans;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">dfs</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> sn)</span> </span>&#123;<br>        vector&lt;<span class=\"hljs-keyword\">int</span>&gt; &amp;e = mp[sn]; <span class=\"hljs-comment\">// 注意这个是引用</span><br>        <span class=\"hljs-keyword\">while</span> (!e.<span class=\"hljs-built_in\">empty</span>()) &#123;<br>            <span class=\"hljs-keyword\">int</span> fn = e.<span class=\"hljs-built_in\">back</span>();<br>            e.<span class=\"hljs-built_in\">pop_back</span>();<br>            <span class=\"hljs-built_in\">dfs</span>(fn);<br>            ans.<span class=\"hljs-built_in\">push_back</span>(vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&#123;sn, fn&#125;);<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-comment\">//为什么要先dfs再push_back没看明白</span><br><br><span class=\"hljs-keyword\">public</span>:<br>    vector&lt;vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&gt; <span class=\"hljs-built_in\">validArrangement</span>(vector&lt;vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&gt;&amp; pairs) &#123;<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> &amp;pair : pairs) &#123;<br>            mp[pair[<span class=\"hljs-number\">0</span>]].<span class=\"hljs-built_in\">push_back</span>(pair[<span class=\"hljs-number\">1</span>]);<br>            deg[pair[<span class=\"hljs-number\">0</span>]]--; deg[pair[<span class=\"hljs-number\">1</span>]]++;<br>        &#125;<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> it = deg.<span class=\"hljs-built_in\">begin</span>(); it != deg.<span class=\"hljs-built_in\">end</span>(); it++) <span class=\"hljs-keyword\">if</span> (it-&gt;second == <span class=\"hljs-number\">-1</span>) <span class=\"hljs-built_in\">dfs</span>(it-&gt;first);<br>        <span class=\"hljs-keyword\">if</span> (ans.<span class=\"hljs-built_in\">empty</span>()) <span class=\"hljs-built_in\">dfs</span>(deg.<span class=\"hljs-built_in\">begin</span>()-&gt;first);<br>        <span class=\"hljs-built_in\">reverse</span>(ans.<span class=\"hljs-built_in\">begin</span>(), ans.<span class=\"hljs-built_in\">end</span>());<br>        <span class=\"hljs-keyword\">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>\n\n\n<h5 id=\"有关于有向图和无向图的最短路径，以及有负边和无负边的最短路径\"><a href=\"#有关于有向图和无向图的最短路径，以及有负边和无负边的最短路径\" class=\"headerlink\" title=\"有关于有向图和无向图的最短路径，以及有负边和无负边的最短路径\"></a>有关于有向图和无向图的最短路径，以及有负边和无负边的最短路径</h5><ol>\n<li><p>Dijstra算法，适用于单源，有向或者无向的最短路径，不能适用于有负边（注意不是负环，负环情况下，无最短路径）的情况：例子：-1， -5， 2<br>时间复杂度O(n^2))</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">define</span> INF 0x3f3f3f3f</span><br><br><span class=\"hljs-keyword\">int</span> e[Max][Max];<span class=\"hljs-comment\">//e[i][j]代表从i-&gt;j的距离，不通设为无穷大</span><br><span class=\"hljs-keyword\">int</span> dis[Max];<span class=\"hljs-comment\">//dis[i]代表从起点到i的最短距离</span><br><span class=\"hljs-keyword\">bool</span> book[Max];<span class=\"hljs-comment\">//book[i]代表点i是否在S中</span><br><span class=\"hljs-keyword\">int</span> n;<span class=\"hljs-comment\">//n个顶点</span><br><span class=\"hljs-keyword\">int</span> s;<span class=\"hljs-comment\">//起点</span><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Dijkstra</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;=n;i++)<span class=\"hljs-comment\">//初始化dis数组</span><br>        dis[i]=e[s][i];<br><br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;=n;i++)<span class=\"hljs-comment\">//初始化book数组</span><br>        book[i]=<span class=\"hljs-number\">0</span>;<br>    dis[s]=<span class=\"hljs-number\">0</span>;<br>    book[s]=<span class=\"hljs-number\">1</span>;<br><br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;=n<span class=\"hljs-number\">-1</span>;i++)<span class=\"hljs-comment\">//Dijkstra算法核心语句  注意也是n-1次</span><br>    &#123;<br>        <span class=\"hljs-keyword\">int</span> minDis=INF;<br>        <span class=\"hljs-keyword\">int</span> k;<span class=\"hljs-comment\">//找到与s最近的顶点k</span><br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">1</span>;j&lt;=n;j++)<br>        &#123;<br>            <span class=\"hljs-keyword\">if</span>(book[j]==<span class=\"hljs-number\">0</span> &amp;&amp; dis[j]&lt;minDis)<br>            &#123;<br>                minDis=dis[j];<br>                k=j;<br>            &#125;<br>        &#125;<br>        book[k]=<span class=\"hljs-number\">1</span>;<br><br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">1</span>;j&lt;=n;j++)<span class=\"hljs-comment\">//“松弛”过程</span><br>        &#123;<br>            <span class=\"hljs-keyword\">if</span>(e[k][j]&lt;INF)<br>            &#123;<br>                <span class=\"hljs-keyword\">if</span>(dis[j]&gt;dis[k]+e[k][j])<br>                    dis[j]=dis[k]+e[k][j];<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li><p>Bellman-ford算法：适用于单源，可有负权，有向或者无向的最短路径 记住只松弛n-1次<br>能够检测出有负环情况<br>dp[i][dst]=min(dp[i][dst], dp[i-1][src]+dist[src][dst]) i==1的时候表示经过的中转站为0</p>\n</li>\n</ol>\n<p>时间复杂度O(n*m)/O(VE)</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">define</span> INF 0x3f3f3f3f</span><br><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Edge</span>&#123;</span><br>    <span class=\"hljs-keyword\">int</span> u;<span class=\"hljs-comment\">//起</span><br>    <span class=\"hljs-keyword\">int</span> v;<span class=\"hljs-comment\">//终</span><br>    <span class=\"hljs-keyword\">int</span> weight;<span class=\"hljs-comment\">//长度</span><br>&#125;;<br><br>Edge edge[maxm];<span class=\"hljs-comment\">//用来存储所有的边</span><br><span class=\"hljs-keyword\">int</span> dis[maxn];<span class=\"hljs-comment\">//dis[i]表示源点到i的最短距离</span><br><span class=\"hljs-keyword\">int</span> n,m;<span class=\"hljs-comment\">//n个点，m条边</span><br><span class=\"hljs-keyword\">int</span> s;<span class=\"hljs-comment\">//源点</span><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">bool</span> <span class=\"hljs-title\">Bellmen_ford</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;=n;i++)<span class=\"hljs-comment\">//初始化</span><br>        dis[i]=INF;<br><br>    dis[s]=<span class=\"hljs-number\">0</span>;<span class=\"hljs-comment\">//源节点到自己的距离为0</span><br><br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;n;i++)<span class=\"hljs-comment\">//松弛过程，计算最短路径 </span><br>    &#123;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">1</span>;j&lt;=m;j++) <span class=\"hljs-comment\">//m条边</span><br>        &#123;<br>            <span class=\"hljs-keyword\">if</span>(dis[edge[j].v]&gt;dis[edge[j].u]+edge[j].weight)<span class=\"hljs-comment\">//比较s-&gt;v与s-&gt;u-&gt;v大小</span><br>                dis[edge[j].v]=dis[edge[j].u]+edge[j].weight;<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">1</span>;j&lt;=m;j++)<span class=\"hljs-comment\">//判断是否有负边权的边</span><br>    &#123;<br>        <span class=\"hljs-keyword\">if</span>(dis[edge[j].v]&gt;dis[edge[j].u]+edge[j].weight)<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n<ol start=\"3\">\n<li>SPFA算法：是Bellman-ford算法的队列优化，适用于单源，可有负权，有向或者无向的最短路径 （自身其实无法处理负权）<br>设立一个队列用来保存待优化的点，优化时每次取出队首结点u，并且用u点当前的最短路径估计值对u点所指向的结点v进行松弛操作，如果v点的最短路径估计值有所调整，且v点不在当前的队列中，就将v点放入队尾。这样不断从队列中取出结点来进行松弛操作，直至队列空为止。</li>\n</ol>\n<p>注意，一旦从队列中弹出来，vis就设置为false，感觉负权的情况就会一直循环下去，不会跳出；遍历点，与边无关</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">define</span> INF 0x3f3f3f3f</span><br><br><span class=\"hljs-keyword\">int</span> dis[MAX];<span class=\"hljs-comment\">//dis[i]表示起点到i的最短距离</span><br><span class=\"hljs-keyword\">bool</span> vis[MAX];<span class=\"hljs-comment\">//是否访问过点i</span><br><span class=\"hljs-keyword\">int</span> e[MAX][MAX];<span class=\"hljs-comment\">//矩阵</span><br><br><span class=\"hljs-keyword\">int</span> n,m;<span class=\"hljs-comment\">//点和边的数量</span><br><span class=\"hljs-keyword\">int</span> s;<span class=\"hljs-comment\">//源点</span><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">SPFA</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;=n;i++)<span class=\"hljs-comment\">//初始化</span><br>    &#123;<br>        dis[i]=INF;<br>        vis[i]=<span class=\"hljs-literal\">false</span>;<br>    &#125;<br>    queue&lt;<span class=\"hljs-keyword\">int</span>&gt; q;<br>    q.<span class=\"hljs-built_in\">push</span>(s);<br>    dis[s]=<span class=\"hljs-number\">0</span>;<br>    vis[s]=<span class=\"hljs-literal\">true</span>;<br><br>    <span class=\"hljs-keyword\">while</span>(!q.<span class=\"hljs-built_in\">empty</span>())<br>    &#123;<br>        <span class=\"hljs-keyword\">int</span> cur=q.<span class=\"hljs-built_in\">front</span>();<br>        q.<span class=\"hljs-built_in\">pop</span>();<br>        vis[cur]=<span class=\"hljs-literal\">false</span>;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;=n;i++) <span class=\"hljs-comment\">//遍历每一个节点</span><br>        &#123;<br>            <span class=\"hljs-keyword\">if</span>(e[cur][i]!=INF&amp;&amp;dis[i]&gt;=dis[cur]+e[cur][i])<br>            &#123;<br>                dis[i]=dis[cur]+e[cur][i];<br>                <span class=\"hljs-keyword\">if</span>(!vis[i])<br>                &#123;<br>                    vis[i]=<span class=\"hljs-literal\">true</span>;<br>                    q.<span class=\"hljs-built_in\">push</span>(i);  <span class=\"hljs-comment\">///之后将start缩小的边才拿出来</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>Floyd算法： Floyd算法是一种利用动态规划思想的计算加权图中多源点之间最短路径的算法。可以正确处理有向图或负权的最短路径问题。</li>\n</ol>\n<p>时间复杂度：O(N^3）</p>\n<p>空间复杂度：O(N^2）</p>\n<p>处理问题：多源、可有负权、有向图、无向图最短路径 </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">int</span> e[Max][Max];<span class=\"hljs-comment\">//e[i][j]代表从i-&gt;j的距离，不通设为无穷大</span><br><span class=\"hljs-keyword\">int</span> n;<span class=\"hljs-comment\">//n个顶点</span><br><span class=\"hljs-comment\">//Floyd算法</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Floyd</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> k=<span class=\"hljs-number\">1</span>;k&lt;=n;k++)<span class=\"hljs-comment\">//遍历所有的中间点</span><br>    &#123;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;=n;i++)<span class=\"hljs-comment\">//遍历所有的起点</span><br>        &#123;<br>            <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">1</span>;j&lt;=n;j++)<span class=\"hljs-comment\">//遍历所有的终点</span><br>            &#123;<br>                <span class=\"hljs-keyword\">if</span> (e[i][j]&gt;e[i][k]+e[k][j])<span class=\"hljs-comment\">//如果当前i-&gt;j的距离大于i-&gt;k-&gt;j的距离之和</span><br>                    e[i][j]=e[i][k]+e[k][j];<span class=\"hljs-comment\">//更新从i-&gt;j的最短路径</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>最短路衍生拓展的一类题目：</p>\n<ol>\n<li>最长路径问题：<br>图不为非负权图：当存在正环时无解。<br>如果不存在正环，边权取负后使用Bellman-Ford算法求最短路。</li>\n<li>最长路径，但是路径的计算是权重之间的乘积，而且权重都是0-1之间的值，使用Dijstra算法 （e.g概率最大的路径）<br>Solution:<br> 单独使用Dijstra会导致超时，因此需要结合Dijstra+优先队列<br> 1.现将src点push 到堆进行<br> 2.然后遍历堆中的每个节点，如果当前节点能够松弛它的邻接节点，那么就放入堆中，否则不放入类似于SPFA,但是不同的是，<ul>\n<li>这个使用的优先队列，而SPFA是用的是一般的堆</li>\n<li>这个不仅仅push了节点，也push了当前节点的最大概率，因此没有vis数组来标记当前节点是否在堆中，因为即使在堆中， 概率也可能是不一样的。<br>总的来说这道题使用bellman-ford算法更简单，只要当前没有任何松弛的边，那么直接退出循环</li>\n</ul>\n</li>\n</ol>\n<p>颜色交替的最短路径：使用bellman-ford算法（本质是动态规划）， 只是在距离的转换是需要讨论两种情况<br>dstEndWithRed[end]=min(dstEndWithRed[end], dstEndWithBlue[start]+1);<br>dstEndWithBlue[end]=min(dstEndWithBlue[end], dstEndWithRed[start]+1);</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;n<span class=\"hljs-number\">-1</span>;i++)&#123;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">auto</span> edge: redEdges)&#123;<br>        <span class=\"hljs-keyword\">int</span> start=edge[<span class=\"hljs-number\">0</span>];<br>        <span class=\"hljs-keyword\">int</span> end=edge[<span class=\"hljs-number\">1</span>];<br>        dstEndWithRed[end]=<span class=\"hljs-built_in\">min</span>(dstEndWithRed[end], dstEndWithBlue[start]+<span class=\"hljs-number\">1</span>);<br>    &#125;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">auto</span> edge: blueEdges)&#123;<br>        <span class=\"hljs-keyword\">int</span> start=edge[<span class=\"hljs-number\">0</span>];<br>        <span class=\"hljs-keyword\">int</span> end=edge[<span class=\"hljs-number\">1</span>];<br>        dstEndWithBlue[end]=<span class=\"hljs-built_in\">min</span>(dstEndWithBlue[end], dstEndWithRed[start]+<span class=\"hljs-number\">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>成语接龙的最长，使用bfs，同时对连接好的成语，再来一次bfs (微软三面)</li>\n</ol>\n<p><font color=\"red\">4. lc787. K 站中转内最便宜的航班</font></p>\n<ul>\n<li>只能最多经过k个中转站的最短路径</li>\n<li>使用bellman-ford算法，k个中转站就是松弛每条边 k+1次(1~k+1)，然后使用dp[i][dst]记录 中转i次的最短路径<br>最后的结果就是在dp[1][dst] 到dp[k+1][dst]中取最小的一个</li>\n</ul>\n<p>lc6134. 找到离给定两个节点最近的节点</p>\n<ul>\n<li>内向基环树</li>\n<li>求出node1 到每个点的距离， 和node2 到每个点的距离，然后取最小 (两次求距离，然后取最小，最后注意返回的是最近的下标，而不是最近的距离)</li>\n</ul>\n<p>PS, 最开始理解的时候，感觉应该用两个节点的最近公共祖先来解决，但是因为图中可能有环，所以不能使用最近公共祖先的栈或者dfs方法解决</p>\n<h3 id=\"前缀和和差分数组相关\"><a href=\"#前缀和和差分数组相关\" class=\"headerlink\" title=\"前缀和和差分数组相关\"></a>前缀和和差分数组相关</h3><p>一般是有关于矩阵的一维前缀和， 二维前缀和， 一维差分数组和二维差分数组<br>如果要计算差分数组和前缀和数组最好是将坐标转为 1-n，更好计算；不然sum i j对应的grid为i-1,j-1</p>\n<p>一维差分数组中，如果数组中一段数据加上或者减去某一个元素，在差分数组中只有两头的元素进行了修改，中间的元素都没有修改<br>二维差分数组中，如果包含左上角（x1, y1）, 右下角（x2, y2）这一部分都+C, 那么对应的差分数组d[x1][y1]+c d[x2+1][y2+1]+c d[x1][y1+1]-c d[x2+1][y1]-c<br>(上升的对角线两端元素-c, 下降的对角线元素+c)</p>\n<p>二维差分数组公式:<br>nums[i][j]-nums[i-1][j]-nums[i][j-1]+nums[i-1][j-1]=d[i][j]<br>从差分数组还原原来的数组<br>nums[i][j]=nums[i-1][j]+nums[i][j-1]-nums[i-1][j-1]+d[i][j]</p>\n<p>例题：</p>\n<ol>\n<li><ol start=\"5931\">\n<li>用邮票贴满网格图 (hard-周赛题目)</li>\n</ol>\n</li>\n</ol>\n<p>方法一: 使用二维前缀和，对原来矩阵中每个左上角为0，且邮票区域都为0的位置（二维区域前缀和为0），贴上邮票，为了减少贴这个过程的时间开销，使用二元差分数组<br>贴完后，对二元差分数组进行还原，如果仍然遇到为0的位置，那么返回false<br>注意这道题没必要求差分数组，差分数组可以全部直接初始化为0， 那么还原回来的也是填充数组<br>方法二: 不使用二维差分数组，使用另外一个数组，标记贴邮票的左上角，然后针对每个grid中为0的位置，计算邮票部分区域（注意是贴了邮票的矩阵，是另一个矩阵）的前缀和，如果为0，表示这个区域没有被贴上邮票，返回false</p>\n<ol start=\"2\">\n<li>航班预订统计 (middle)<br>一维差分数组的题目<br>如果原来数组的下标就是1-n的话，那么修改n-m部分的数据， 就会修改等差数列的d[n]和d[m+1]两个端点的数据</li>\n</ol>\n<ol start=\"3\">\n<li><p>拼车<br>这道题类似于天际线问题，使用hash, 左断点加入m个人，右端点减去m个人<br>然后遍历hash的每个key,如果有个时刻是大于capacity, 那么返回false</p>\n</li>\n<li><p>lc995. K 连续位的最小翻转次数（hard）</p>\n</li>\n</ol>\n<ul>\n<li>从左到右遍历，遇到0就进行翻转，使用差分数组进行假意翻转，通过presum累加来求得当前翻转的次数</li>\n</ul>\n<h3 id=\"前缀异或值\"><a href=\"#前缀异或值\" class=\"headerlink\" title=\"前缀异或值\"></a>前缀异或值</h3><p>在求前缀异或的时候，结果数组可以从1开始取，这样的话就不用对边缘单独进行赋值操作</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt;= m; ++i) &#123;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">1</span>; j &lt;= n; ++j) &#123;<br>        pre[i][j] = pre[i - <span class=\"hljs-number\">1</span>][j] ^ pre[i][j - <span class=\"hljs-number\">1</span>] ^ pre[i - <span class=\"hljs-number\">1</span>][j - <span class=\"hljs-number\">1</span>] ^ matrix[i - <span class=\"hljs-number\">1</span>][j - <span class=\"hljs-number\">1</span>];<br>        results.<span class=\"hljs-built_in\">push_back</span>(pre[i][j]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n<h3 id=\"分类讨论题\"><a href=\"#分类讨论题\" class=\"headerlink\" title=\"分类讨论题\"></a>分类讨论题</h3><ol>\n<li> K 次串联后最大子数组之和<br>分类分析<br>k=1;<br>k=2;<br>k&gt;2 如果array之和小于0，那么结果就是k=2情况，否则k=2+(k-2)*sum(one array)</li>\n</ol>\n<h4 id=\"摩尔投票算法\"><a href=\"#摩尔投票算法\" class=\"headerlink\" title=\"摩尔投票算法\"></a>摩尔投票算法</h4><p>1.求众数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">int</span> k=<span class=\"hljs-number\">0</span>;<br><span class=\"hljs-keyword\">int</span> target_num=<span class=\"hljs-number\">0</span>;<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;size;i++)&#123;<br>    <span class=\"hljs-keyword\">if</span>(k==<span class=\"hljs-number\">0</span>)&#123;<br>        target_num=nums[i];<br>        k=<span class=\"hljs-number\">1</span>;<br>    &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>        <span class=\"hljs-keyword\">if</span>(nums[i]==target_num)&#123;<br>            k++;<br>        &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>            k--;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">//判断target_num的数是否大于n/2;</span><br><span class=\"hljs-keyword\">int</span> cnt=<span class=\"hljs-number\">0</span>;<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;size;i++)&#123;<br>    <span class=\"hljs-keyword\">if</span>(nums[i]==target_num)&#123;<br>        cnt++;<br>    &#125;<br>&#125;<br><span class=\"hljs-keyword\">if</span>(cnt&gt;n/<span class=\"hljs-number\">2</span>)&#123;<br>    <span class=\"hljs-keyword\">return</span> target_num;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>2.求大于n/3 的数<br>这样的数最多只有两个</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">int</span> k1=<span class=\"hljs-number\">0</span>;<span class=\"hljs-comment\">//投票的数量</span><br><span class=\"hljs-keyword\">int</span> k2=<span class=\"hljs-number\">0</span>;<br><span class=\"hljs-keyword\">int</span> target_num1;<span class=\"hljs-comment\">//具体的数</span><br><span class=\"hljs-keyword\">int</span> target_num2;<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;size;i++)&#123;<br>    <span class=\"hljs-keyword\">if</span>(k1&gt;<span class=\"hljs-number\">0</span>&amp;&amp;target_num1==nums[i])&#123;<br>        k1++;<br>    &#125;<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(k2&gt;<span class=\"hljs-number\">0</span>&amp;&amp;target_num2==nums[i])&#123;<br>        k2++;<br>    &#125;<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(k1==<span class=\"hljs-number\">0</span>)&#123;<br>        target_num1=nums[i];<br>        k1=<span class=\"hljs-number\">1</span>;<br>    &#125;<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(k2==<span class=\"hljs-number\">0</span>)&#123;<br>        target_num2=nums[i];<br>        k2=<span class=\"hljs-number\">1</span>;<br>    &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>        k1--;<br>        k2--;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">int</span> cnt1=<span class=\"hljs-number\">0</span>;<br><span class=\"hljs-keyword\">int</span> cnt2=<span class=\"hljs-number\">0</span>;<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;size;i++)&#123;<br>    <span class=\"hljs-keyword\">if</span>(k1&gt;<span class=\"hljs-number\">0</span>&amp;&amp;nums[i]==target_num1)&#123;<br>        cnt1++;<br>    &#125;<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(k2&gt;<span class=\"hljs-number\">0</span>&amp;&amp;nums[i]==target_num2)&#123;<br>        cnt2++;<br>    &#125;<br>&#125;<br><span class=\"hljs-keyword\">if</span>(cnt1&gt;n/<span class=\"hljs-number\">3</span>)&#123;<br>    res.<span class=\"hljs-built_in\">push_back</span>(target_num1);<br>&#125;<br><span class=\"hljs-keyword\">if</span>(cnt2&gt;n/<span class=\"hljs-number\">3</span>)&#123;<br>    res.<span class=\"hljs-built_in\">push_back</span>(target_num2);<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n\n\n\n<h3 id=\"分治算法专题\"><a href=\"#分治算法专题\" class=\"headerlink\" title=\"分治算法专题\"></a>分治算法专题</h3><p>1.IP地址验证合理性</p>\n<ol>\n<li><p>对于 IPv4 地址，通过界定符 . 将地址分为四块-&gt;a；对于 IPv6 地址，通过界定符 : 将地址分为八块-&gt;b。（count(.)==4/count(:)==6/neither）<br> a. 对于 IPv4 地址的每一块，检查它们是否在 0 - 255 内，且没有前置零。<br> b. 对于 IPv6 地址的每一块，检查其长度是否为 1 - 4 位的十六进制数。</p>\n</li>\n<li><p>删除注释<br> 分情况判断+用一个状态表明现在是否在注释内，主要是用于/* <em>/情况<br> （1）题目中没有考虑/</em> 不属于注释的这种情况，因此每次遇到/* &amp;&amp;block= False 表示开始块注释，每次遇到*/&amp;&amp;block=True,表示结束块注释<br> （2）遇到//直接结束，因为//后面都是注释，而且不改变状态</p>\n</li>\n</ol>\n<h4 id=\"corner-case的例子\"><a href=\"#corner-case的例子\" class=\"headerlink\" title=\"corner case的例子\"></a>corner case的例子</h4><p>lc1363: 形成3的最大倍数<br>思路： 判断sum之和</p>\n<ol>\n<li>%3==0， 那么返回res</li>\n<li>%3==1, 如果数组中有%3==1的数字那么直接删除； 否则删除两个%3==2的数字</li>\n<li>%3==2, 如果数组中有%3==2的数字那么直接删除； 否则删除两个%3==1的数字</li>\n<li>易错点：结果可能包含前缀0，因此需要将前缀0去掉（000001/000000）；结果也可能只是“”， 那么直接返回“”， 而不是0</li>\n</ol>\n<p>lc旋转链表<br>1.求size<br>2. k=k%size; k=k-size,表示第k个节点是现在的头结点（k-1是新链表尾节点）<br>3. 将头节点前面一个节点（k-1）的next置为null, 同时将当前链表的最后一个节点next指向头节点（利用在第二步变成环，可以减少找尾结点这一步）<br><font color=\"red\">链表类似题一定要判断head是否为null, size是否为0或者1这种情况 </font><br>快慢指针删除链表的重复元素的时候，一定要记得将慢指针的next设置为null</p>\n<p>lc,加1<br>在vector数组上+1</p>\n<ul>\n<li>一定要注意最后carry不为0的情况，需要在最开头插入一个数 digits.insert(digits.begin(),carry);</li>\n<li>应该使用tmp记录当前位的和。int tmp=digits[i]+carry;</li>\n</ul>\n<p>lc68. 文本左右对齐<br>字符串相关的模拟题，主要是分情况讨论<br>一个单词/最后一行/其他情况（spacecount, extraspace）</p>\n<p>其他corner case: </p>\n<ul>\n<li><ol>\n<li>乘法可能会超出范围，可能需要使用long long型 （数据范围一定要注意是用long long还是int）</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>在进行寻找mid的时候left+(right-left)/2</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>一定要注意&lt; &lt;=，以及边界情况的例子，在微软（矩阵旋转）和字节（和滑动窗口的最大值）最开始取[0,k-1]以及压入一个元素 已经跌过两次坑了</li>\n</ol>\n</li>\n<li>lc220. 存在重复元素 III，一定要注意nums[i]-t可能超出整数的范围，因此需要使用long 或者longlong对nums进行强制转换</li>\n</ul>\n<h4 id=\"模拟题目\"><a href=\"#模拟题目\" class=\"headerlink\" title=\"模拟题目\"></a>模拟题目</h4><ol>\n<li>矩阵旋转90</li>\n<li>螺旋矩阵 （使用分成4段（后面两段需要判断 left&lt; right&amp;&amp; upper&lt; down才可以），或者坐标移动+vis数组）</li>\n<li>倒酒杯</li>\n</ol>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>ok </p>\n<ol>\n<li><p>二维差分数组常用在对数组中的某一个块的区域进行操作， 比如这道题的贴邮票， 对整块数组+1; 比如对0-k这段距离的数据都进行翻转</p>\n</li>\n<li><p>一个数比较大，但是它取模之后的结果不一定大,两种解决方案</p>\n<ol>\n<li>保存long long的结果</li>\n<li>sum为定值的时候，一个数越接近sum的一半，乘积之后的结果越大</li>\n</ol>\n <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">abs</span>(cur*<span class=\"hljs-number\">2</span> - sum) &lt; <span class=\"hljs-built_in\">abs</span>(best*<span class=\"hljs-number\">2</span> - sum)) &#123;<br>    best = cur;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li><p>负数和正数的向上向下取整不同<br>Math.floor(2.6);    //2.0   floor地板 水平数轴向右取整<br>Math.floor(-2.6);   //-3.0   floor地板 水平数轴向右取整</p>\n</li>\n</ol>\n"},{"title":"动态规划","catogory":["leetcode 题目汇总"],"date":"2021-11-13T09:00:51.000Z","_content":"\n### 求总数问题\n1. 回文字符串的个数\n2. 表达式为期望结果的总数\n    - 也是区间dp, dp[i][j][0]或者dp[i][j][1])\n    - 因为不是表达式的个数，而是达到期望值的个数，因此要记录一个表达式的值，用三维数组\n3. 能够组成的二叉树的个数\n4. 打气球的最大分数(区间dp)\n   - 虽然不是求个数，而是求最大，但是也是与当前状态的左右边界有关。因为最终结果和左右两边有关，因此都是枚举的长度+右边界，计算左边界，进行动态规划\n   转移方程：考虑这个区间上最后一个气球的打破方式，即最后一个气球的打破位置。在左边右边和中间\n   ```C++\n   f[i][j] = max( f[i][j], f[i][k - 1] + f[k + 1][j] + a[k] * a[i - 1] * a[j + 1]); //闭区间的更新方式\n   ```\n\n   在leetcode上面的一道原题，只是描述改变了\n   lc312. 戳气球\n   - 这道题如果将dp[i][j]定义为开区间或得的最大值就更容易理解\n   ```C++\n   状态转移： dp[i][j]=max(dp[i][j], dp[i][k]+dp[k][j]+val[i]*val[k]*val[j]);//开区间的更新方式\n   ```\n   - 注意为了减少情况的分类讨论，需要在左右两边都加上1，这样的话枚举一个区间留下的最后一个数，也是可以求得值的\n\n5. 旋变字符串问题 (区间dp) lc87. 扰乱字符串\n    -  四重循环，三维dp（两个字符串两个端点+一个长度）\n    - 这道题不是求个数，而是求是否，但是仍然是需要枚举长度的问题，因为是两个字符串，所以应该有4个边，但是运用长度相等的信息，将思维坐标转为左边坐标+size, 成为三维问题\n   dp[start1][start2][len] 而且这道题有两个长度：一个是总字符串长度，一个是总字符串化为为两个旋变字符串的长度\n    ```C++\n    for(int size = 2; size <= n; size++){\n            for(int l1 = 0; l1 <= n - size; l1++){\n                for(int l2 = 0; l2 <= n - size; l2++){\n                    for(int leftPart = 1; leftPart < size; leftPart++){\n                        if((dp[l1][l2][leftPart] && dp[l1 + leftPart][l2 + leftPart][size - leftPart]) || \n                            (dp[l1][l2 + size - leftPart][leftPart] && dp[l1 + leftPart][l2][size - leftPart])){\n                            dp[l1][l2][size] = true;      // 只要有一个leftPart满足旋变串条件就可以break出去\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n    ```\n6. 数字字符串转为字母组合的总数\n    - 因为只是与之前的结果或者后面的结果有关，因此只需要从左到右枚举下标就可以了\n    ```C++\n    递推式\n    // 第 i 个字符只能单独转换为一个 字母\n    // dp[i-1] ：第 i 个字符单独转换的方案数\n    dp[i]=dp[i-1];\n    // 第 i 个字符 可以和 第 i-1 个字符 共同转换为一个 字母\n    // dp[i-1] ：第 i 个字符单独转换的方案数\n    // dp[i-2] ：第 i 个字符，结合第 i-1 个字符组合转换为一个字母的方案数\n    dp[i]=dp[i-1]+dp[i-2];\n    //如果第i个字符不能单独存在那么\n    dp[i]=0\n    ```\n7. 组合总数IV， \n    - 总结：如果排序不同算不同的排列组合的话那么 target循环在外侧， nums总数循环在内侧\n    ```C++\n        for(int i=1;i<=target;i++){\n                for(int j=0;j<size;j++){\n                    if(i>=nums[j]&&dp[i - nums[j]] < INT_MAX - dp[i]){\n                        dp[i]+=dp[i-nums[j]];\n                    }\n                }\n            }\n    ```\n    - 如果排序不同算相同的排列祝贺的话那么， target循环在内侧，nums总数循环在外侧, 完全背包问题\n    ```C++\n    for(int i=1;i<=size;i++){\n        for(int j=1;j<=target;j++){\n            dp[i][j]+=dp[i-1][j];\n            if(j>=nums[i-1]){\n                dp[i][j]+=dp[i][j-nums[i-1]];\n            }\n        }\n    }\n    ```\n8. 删除回文子数组\n    - 区间dp/枚举长度的dp\n    - 数组，每次可以删除一个数字，或者删除掉一个回文串，求删除需要的最少次数\n    ```\n    dp[i][j]=min(dp[i+1][j-1], dp[i][j]) if a[i]==a[j]\n    dp[i][j]=min(dp[i][k]+dp[k+1][j], dp[i][j])\n    dp长度从3开始，dp长度为1， 2的时候使用初始化\n    ```\n    - 答案见：https://cloud.tencent.com/developer/article/1659691 可以作为区间dp模板，但是枚举长度和转移方程那里可以修改一下\n\n9. lc115. 不同的子序列 (具体分析见字符串匹配问题)\n\n10. 446. 等差数列划分 II - 子序列（hard）\n- 题意：等差子序列个数，可不连续，每个序列至少包含3个数\n- 我的困难地方在于，这个序列长度要等于3，那么将序列==2的如何处理，如果出现重复如何处理 比如2  1 2 3\n- 官方解题方案是，计算弱等差子序列的个数（序列==2），然后再计算结果的时候遍历三个数，同时因为差为负数，所以使用hash_map数组vector<unordered_map<long long, int>> d(size)\n- 将记录以某一下标结尾的序列中包含的数个数，转为差为d的对数（个数->对数）\n\n11. 1000. 合并石头的最低成本(hard)\n- 区间dp的经典题目，四重区间dp\n- 将i，j之间的num堆转为 区间划分前面1堆后面num-1堆，然后因为连续k堆可以转为一堆，所以单独对于dp[i][j][k]单独进行转换为dp[i][j][1]\ndp[i][j][num]=min(dp[i][j][num], dp[i][q][1]+dp[q+1][j][num-1]); //num表示num堆， 注意没有必要枚举dp[i][q][2]+dp[q+1][j][num-2]//这种情况，因为下标划分已经达到枚举的作用\n\n\n### 求最大最小问题\nPS: 子串都是要求连续的，而子序列是不要求连续的\n1. 扔鸡蛋 lc887 \n    https://zhuanlan.zhihu.com/p/92288604\n    两种状态转移：\n    a. dp[k][n], k个鸡蛋n层楼， 需要最少扔多少次\n        dp[1][N] = N\n        dp[..][0] = 0\n        for i=1到n:\n         dp[k][n]=min(dp[k][n], max(dp[k][i-1]+dp[k-1][n-i])+1);//不需要在第i层再扔，因此删除i\n    b. dp[k][m], k个鸡蛋扔m次，可以验证的最大楼层数\n        dp[0][..] = 0\n        dp[..][0] = 0\n        whle(dp[K][m]<N){\n            m++;\n            for (int k = 1; k <= K; k++){\n                dp[k][m] = dp[k][m - 1] + dp[k - 1][m - 1] + 1;\n            }\n        }\n    ```C++\n        int ans=-1;\n        vector<vector<int>> dp(n+1,vector<int>(k+1));\n        if(n==1&k>=1){\n            return 1;\n        }\n        for(int i=0;i<=n;i++){\n            dp[i][1]=i; //一个鸡蛋\n        }\n        \n        for(int j=1;j<=k;j++){\n            dp[1][j]=1; //一次操作\n        }\n\n        for(int i=2;i<=n;i++){ //n次操作\n            for(int j=1;j<=k;j++){ //k个鸡蛋\n                dp[i][j]=dp[i-1][j]+dp[i-1][j-1]+1;\n            }\n            if(dp[i][k]>=n){\n                    ans=i;\n                    break;\n            }\n        }\n        return ans;\n    ```\n\n2. 最长递增子串\n3. 最长递增子序列  \n    两种方法：\n    - 两重循环\n    - 单调栈+二分查找\n    扩展 最长递增子序列的个数，时间复杂度仍然是O(n^2)，只是多了一个cnt, 每次出现最大就更新，否则进行cnt的累加\n     \n    另外类似的题目: 1027. 最长等差数列\n    dp[i][j]表示以i结尾而且差为j的最长数列\n    ```C++\n        for(int i=0;i<size;i++){\n            for(int j=0;j<i;j++){\n                int tmp=nums[i]-nums[j];//因为差可能是负数\n                dp[i][tmp+1000]=dp[j][tmp+1000]+1;\n                res=max(res, dp[i][tmp+1000]);   \n            }\n        }\n    ```\n    lc1218. 最长定差子序列： 这道题diff是定了，因此只需要一维hash就可以了\n    ```C++\n    for(int i=0;i<size;i++){\n        hash[arr[i]]=max(hash[arr[i]-difference]+1, hash[arr[i]]);\n        res=max(res, hash[arr[i]]);\n    }\n    ```\n\n4. 最长公共子串（要求连续）\n     - 注意和子序列的区别：动态规划转移方程是 dp[i][j]=dp[i-1][j-1]+1 or dp[i][j]=0表示以i或者j结尾的子串， 最后遍历二维数组求最大值\n    求具体的最长公共子串，只需要动态规划的时候，记录最长的公共子串的下标，然后s.substr(start_pos = index-maxlen+1, len = maxlen)就可以了\n\n5. 最长公共子序列 （最长长度/最长具体序列/最短包含序列）\n    - 题意改变，但是代码不变的题目--不相交的线\n    - 相似的题目：\n    1. 编辑距离\n    2. 两个字符串的删除操作， 可以直接动态规划求最少的删除字符数量，也可以用最长公共子序列，然后用m+n-2*lcs\n    - 如果要求具体删除的是哪些字符串，两种方法应该都是可以的\n    - 动态规划转移方程是 \n    ```\n    dp[i][j]=dp[i][j]+1 or dp[i][j]=max(dp[i][j-1], dp[i-1][j])\n    ``` \n    dp[i-1][j] 表示以i或者j结尾的子串中包括的最长公共子序列（不一定是以i j结尾）， 所以最后只用直接返回dp[m][n]\n    - 在求最长的公共子序列的时候，需要使用dp转换等式 i--,j-- 或者j--, 或者i--来进行查找最长的公共子序列， 同时也可以求最短的删除的字符具体是哪些\n    ```C++\n    int i = m-1, j = n-1;\n    while(i >= 0 && j >= 0){\n        if(s1.charAt(i) == s2.charAt(j)){\n            res.append(s1.charAt(i));\n            i--;\n            j--;\n        }\n        if(i>0 && j>0 && s1.charAt(i) != s2.charAt(j)){\n            if(dp[i-1][j] > dp[i][j-1])\n                i--;\n            else\n                j--;\n            //dp[i-1][j] < dp[i][j-1]时,j--;\n            //dp[i-1][j] = dp[i][j-1]时,i--或j--,这里统一为j--;\n        }\n        \n        //行或列到达边界\n        if(i==0)j--;\n        if(j==0)i--;\n    }\n    ```\n    PS: lc1092. 最短公共超序列\n    - 求包含两个字符的最短序列， 其实就是m+n-k(k为公共序列的长度)\n    相比于公共序列， 会在i--, j-- 都push_back字符; 求具体的公共序列的时候，只有相等的时候才push相等的字符\n    ```C++\n        int i=size1-1;\n        int j=size2-1;\n        string res;\n        while(i>0&&j>0){\n            if(str1[i]==str2[j]){\n                res.push_back(str1[i]);\n                i--;j--;\n            }else{\n                if(dp[i-1][j]>dp[i][j-1]){\n                    res.push_back(str1[i]);\n                    i--;\n                }else{\n                    res.push_back(str2[j]);\n                    j--;\n                }\n            }\n        }\n        while(i>0){\n            res.push_back(str1[i--]);\n        }\n         while(j>0){\n            res.push_back(str2[j--]);\n        }\n        reverse(res.begin(), res.end());\n    ```\n\n    \n\n6. 最长回文子序列\n    - 不要求连续，枚举长度\n    - 初始化长度为1和2的情况，然后\n    ```C++\n     for(int len=3;len<=s_len;len++){\n            for(int left=0;left<s_len;left++){\n                int right=left+len-1;\n                if(right<s_len){\n                    dp[left][right]=max(dp[left+1][right], dp[left][right-1]);\n                    if(s[left]==s[right]){\n                        dp[left][right]=max(dp[left][right],dp[left+1][right-1]+2);\n                    } \n                }\n            }\n        }\n    ```\n\n7. 最长回文子串的问题 （判断true/false的dp系列）\n    - 可以用动态规划也可以用从中间向两边扩展的方法\n    动态规划dp[left][right]不是表示长度，而是表示是否为回文子串，在求长度使用一个公共变量max_len,每求出dp 如果dp为1那么更新max_len\n\n8. 最长有效括号子串\n    - 方法一：动态规划\n    - 转移方程 dp[i]:以i结尾的最长有效括号子串 转移方程如下\n    ```C++\n        for(int i=1;i<s_len;i++){\n            if(s[i]==')'){\n                int j=i-dp[i-1]-1;\n                if(j>=0&&s[j]=='('){\n                    dp[i]=dp[i-1]+2;\n                    if(j-1>=0){\n                        dp[i]+=dp[j-1];\n                    }\n                }\n                result=max(result, dp[i]);\n            }\n        }\n    ```\n    - 方法二：下标栈，栈低维护的是最后一个没有被匹配的右括号下标，如果s[i]=='('入栈下标; 如果s[i]==')', 栈中弹出一个元素，如果栈为空，直接push(i) continue，否则更新ans=max(ans, i-s.peek())\n\n9. 分割回文串系列题目\n    1. 分割回文串1\n    - 动态规划+回溯dfs，求所有i， j之间的子字符串p[i][j]是否是回文（类似最长回文子串的题目）\n\n    2. 分割回文串2\n    - 求最少分割次数\n        - 这道题不能使用枚举长度和左边界+枚举分割点的方式，时间复杂度太高（O(N^3)）\n        - 正确的解决方案是，求dp[i] 从0到i需要分割的最少次数，同时事先需要使用动态规划求出任意i j之间是否是回文串；如果0-i是回文串，直接结果为0，否则依次遍历i之后的字符串，找到回文串j+1-i，同时更新dp[i]=min(dp[i], dp[j]+1)\n        - 这道题可以和“子数组异或值为0的最多划分”进行类比（动态规划+map映射上一个位置）；不同之处这道题通过回文串映射到上一个位置，异或和是通过异或值为和当前值相同隐射到上一个位置\n    ```C++\n        for(int i=0;i<s_len;i++){\n            dp[i]=INT_MAX;\n        }\n        dp[0]=1;\n        for(int i=0;i<s_len;i++){\n            if(p[0][i]){\n                dp[i]=0;\n            }else{\n                for(int j=0;j<i;j++){ //类似最长递增序列 需要预处理，i, j之间是否为回文， 预处理代码i为逆序，j为顺序\n                    if(p[j+1][i]){\n                        dp[i]=min(dp[i], dp[j]+1);//每一个被分割的子字符串都必须要为回文\n                    }\n                }\n            }\n            \n        }\n        return dp[s_len-1];\n    ```\n\n\n10. 背包问题\n    - 比较难的例题：货物转移（lintcode-困难） 反向dp（求背包数最少）+滚动数组+额外条件\n        - 相当于转为两个题：\n        1. 从n个背包里面选择最少的背包使得背包容量大于等于sum（与选最大价值使得，重量小于sum相反）\n        2. 假设1求出来的结果为m, 从n个背包里面选择m个背包使得转移最少-->选出的n个背包里面包含货物最多（weight最大）\n        相当于在状态转移方程再加上了一个weight数组的更新，具体代码如下：\n        dp[i]表示使得容量达到i（大于等于i），选择的最少的背包；\n        weight[i]表示使得背包容量达到i（大于等于i），在选择的背包最少的前提下，背包里原本包含的货物最多。\n        ```C++\n            for(int i=0;i<n;i++){\n                    for(int j=sum;j>=1;j--){ //0-1背包问题\n                        int tmp=max(j-b[i], 0);\n                        // dp[j]=min(dp[tmp]+1, dp[j]); 实际上的状态转移\n                        if(dp[j]<dp[tmp]+1){  //拆分后的状态转移\n                            // weight[j]=weight[tmp];\n                            continue;\n                        }else if(dp[j]==dp[tmp]+1){\n                            weight[j]=max(weight[j], weight[tmp]+a[i]); //背包数量一样，选择权重加起来更大的背包\n                        }else if(dp[j]>dp[tmp]+1){\n                            dp[j]=dp[tmp]+1;\n                            weight[j]=weight[tmp]+a[i];\n                        }\n                    }\n                }\n        ```\n     \n    - 扩展的有关于 分组背包的问题（），每个组k的数量还不一样\n    分组背包：每组物品有若干个，同一组内的物品最多只能选一个。（每组中物品不同，个数和体积都可能不一样）\n    多重背包: 有N种物品和一个容量为V 的背包。第i种物品最多有Mi件可用，每件耗费的空间是Ci ，价值是Wi (每组物品相同，且个数相等)\n    ```C++ 分组背包伪代码 和多重背包有点类似也是三重循环\n    //注意这里是三层循环\n        for 所有的组k\n            for v=V to 0\n                for 所有属于组k的i \n                f[v]=max{f[v],f[v-c[i]]+w[i]}\n                end\n            end\n        end\n    ```\n    例题：lc2218. 从栈中取出 K 个硬币的最大面值和（hard）\n    - 使用前缀和+动态规划\n    ```C++\n     for(int i=1;i<=n;i++){ //注意1-n, 之后piles在进行下标访问的时候需要i-1\n        int size=piles[i-1].size();\n        vector<int> presum(piles[i-1].size(), 0);\n        presum[0]=piles[i-1][0];\n        \n        for(int k=1;k<size;k++){\n            presum[k]=presum[k-1]+piles[i-1][k]; //用前缀和表示选择前面z个\n        }\n        for(int j=1;j<=k;j++){\n            dp[i][j]=dp[i-1][j];\n            for(int z=1;z<=size;z++){ //每组的size可能都不相同\n                if(j>=z){\n                    dp[i][j]=max(dp[i-1][j-z]+presum[z-1], dp[i][j]);\n                }\n            }\n        }\n    }\n    return dp[n][k];\n    ```\n\n    - 背包问题求具体的转移方案：我们可以用g_{i,v}表示第 i件物品占用空间为 v的时候是否选择了此物品。\n    ```C++ (感觉应该是0-1背包的)\n        int v = V;  // 记录当前的存储空间\n        // 因为最后一件物品存储的是最终状态，所以从最后一件物品进行循环\n        for (从最后一件循环至第一件) {\n        if (g[i][v]) {\n            选了第 i 项物品;\n            v -= 第 i 项物品的价值;\n        } else\n            未选第 i 项物品;\n        }\n    ```\n      \n\n11. 换钱问题\n    零钱兑换II：一定要注意虽然每个硬币都有无数个，但是不能出现重复，也就是 121  112这种情况，所以硬币的循环一定要放在最外层\n    ```C++\n     for(int i=0;i<coins.size();i++){//硬币放在最内层会发生错误\n        for(int j=0;j<=amount;j++){\n            if(j>=coins[i]){\n                    dp[j]=dp[j]+dp[j-coins[i]];\n            }\n        }\n    }\n    ```\n12. 通配符匹配问题（hard） 类似最短单词距离的动态转移\n    - 一定要注意动态规划的状态转移方程式是i j 从 i-k j-k转移过来，不能出现i+k j+k(如果出现，一定是枚举的长度，例如回文串和打气球问题)\n    - 易错点：\n    字符串的匹配问题，通常会在字符前面加上” “ dp[0][0]=1\n    同时如果i j从1开始取的话，需要初始化赋值dp[0][i] 和dp[i][0]\n    <font color=blue>\n    corner case:\n    s = \"\"\n    p = \"******\" </font>\n    ```C++\n    dp[0][0]=1\n    //下面这个循环是非常重要的\n    for(int i=2;i<p_len;i++){\n        if(p[i]=='*'){\n            dp[0][i]=dp[0][i-1]; // or dp[0][i]=dp[0][i-1];\n        }\n    }\n    \n    for(int i=1;i<s_len;i++){\n        for(int j=1;j<p_len;j++){\n            if(p[j]=='*'){\n                dp[i][j]=dp[i-1][j]||dp[i][j-1];\n            }else{\n                if(s[i]==p[j]||p[j]=='?'){\n                    dp[i][j]=dp[i-1][j-1]; \n                }else{\n                    dp[i][j]=0;\n                }\n            }\n        }\n    }\n    ```\n    - 如果不好赋值dp[i][0] or dp[0][i] 可以让i j 从0开始取，但是在状态转移的时候注意进行j 或者i的判断 if j>=1  dp[j-1]\n        1. 问题1：*可以匹配任意字符 \n        2. 问题2：*只能匹配前面字符的0个1个或多个(正则表达式匹配) 需要判断s[i] p[j-1]是否相等\n\n13. 打家劫舍\n    - 求能够得到金额的最大值。\n    - 环形可以转为dp[0][size-2]和dp[1][size-1]两者之中求最大值\n    - 类似的一道题：删除并获得点数（题意：选了nums[i]， 就不能选择nums[i-1] 和nums[i+1]， 打家劫舍这里的i, i+1是下标的， 这道题是实际数字上的。两个问题都是使用dp \n\n14. 整数拆分 \n    - 可以使用动态规划 二层循环 dp[i]= max(j*(i-j), j* dp[i-j])， 因为存在i-j > dp[i-j]的情况\n    - 或者使用数据规划，将余数为2（2*） 1（4*） 0(3*)情况区别对待\n\n15. 最大整除子集 \n    - 和最长递增序列有相似之处）\n    - 注意：在进行倒推序列的时候，需要记录当前的maxval 以及target_dpval, 这两者都需要在压入每个元素的时候更新\n    - 相邻两个数的商不一定相等\n\n16.  摆动序列 （序列最长问题）\n\n17. 无重叠区间 \n    - 可以使用动态规划，找到以每个区间结尾的最长子序列（O(N^2)） 或者贪心，对区间右边进行排序然后选择 O(nlogn)\n\n18. 最后一块石头的重量 II\n    - 需要理解题意之后转为背包问题，也就是最大最小问题\n    - 求两个子集相差的最小值 -> 转为背包问题，背包容量是sum/2，求能够放入背包的最大数\n    ```\n    dp[i][j]=max(dp[i-1][j], dp[i-1][j-stone[i]]+stone[i])\n    ```\n\n    - 0-1的最大背包问题，逆向枚举\n    - 多重背包问题也是，只能逆向枚举\n    - 完全背包（无限个）才是正向枚举！！！\n\n19. 乘积为正数的最长子数组长度 (最长子数组系列题目)\n    - 注意这道题是求最长的长度，不是最大的乘积，但是这两个问题都可以使用动态规划完成\n    1. 最长的长度，positive[i]表示以i结尾的为正数的子数组，negtive[i] i结尾的为负数的子数组，\n    ```C++\n            if (nums[0] > 0) {\n                positive[0] = 1;\n            } else if (nums[0] < 0) {\n                negative[0] = 1;\n            }\n            int maxLength = positive[0];\n            for (int i = 1; i < length; i++) {\n                if (nums[i] > 0) {\n                    positive[i] = positive[i - 1] + 1;\n                    negative[i] = negative[i - 1] > 0 ? negative[i - 1] + 1 : 0; //注意一定要和0判断\n                } else if (nums[i] < 0) {\n                    positive[i] = negative[i - 1] > 0 ? negative[i - 1] + 1 : 0;\n                    negative[i] = positive[i - 1] + 1;\n                } else {\n                    positive[i] = 0;\n                    negative[i] = 0;\n                }\n                maxLength = Math.max(maxLength, positive[i]);\n            }\n    ```\n    - 我的思路：转为前缀和+hash\n        题意转为：负数为1，正数为0， 0单独处理，相加和为偶数的最长子数组\n        如果<0, 那么sum+=1；\n        如果>0, 那么sum不变；\n        如果=0, 那么sum=0，  hash.clear(), hash[0]=i；\n        如果sum为偶数：\n        res=max(res, i-hash[0])\n        如果sum为奇数：\n        如果hash[1]存在\n        res=max(res, i-hash[1]) \n        否则hash[1]=i;\n\n    2. 最大乘积（可能为负数），dp1[i]表示以i结尾乘积最大子数组，dp2[i]的乘积最小(注意不一定为负数)的子数组\n    ```C++\n            for(int i=1;i<=size;i++){\n                if(nums[i-1]>0){\n                    dp1[i]=max(dp1[i-1]*nums[i-1], nums[i-1]);\n                    dp2[i]=min(dp2[i-1]*nums[i-1], nums[i-1]);\n                }else if(nums[i-1]<0){\n                    dp1[i]=max(dp2[i-1]*nums[i-1], nums[i-1]);\n                    dp2[i]=min(dp1[i-1]*nums[i-1], nums[i-1]);\n                }else{\n                    dp1[i]=0;\n                    dp2[i]=0;\n                }\n                res=max(res, dp1[i]);\n    ```\n\n\n20. 最低票价\n    - 找到能够让days天都观光的最低票价，类似完全背包问题， 最少兑换钞票\n    - dp[i]定义为至少让index==i天观光所需要的最低票价， 分别遍历决策1，决策2， 决策3需要的最低票价\n\n    - solution 1：每天进行dp + 从后往前\n    ```C++ \n    int len = days.length, maxDay = days[len - 1], minDay = days[0];\n    int[] dp = new int[maxDay + 31]; // 多扩几天，省得判断 365 的限制\n    // 只需看 maxDay -> minDay，此区间外都不需要出门，不会增加费用\n    for (int d = maxDay, i = len - 1; d >= minDay; d--) {\n        // i 表示 days 的索引\n        // 也可提前将所有 days 放入 Set，再通过 set.contains() 判断\n        if (d == days[i]) {\n            dp[d] = Math.min(dp[d + 1] + costs[0], dp[d + 7] + costs[1]); //三种情况\n            dp[d] = Math.min(dp[d], dp[d + 30] + costs[2]);\n            i--; // 别忘了递减一天\n        } else dp[d] = dp[d + 1]; // 不需要出门\n    }\n    return dp[minDay]; // 从后向前遍历，返回最前的 minDay\n    ```\n    - solution 2：只从days包含的天数进行dp + 从前往后\n    ```C++\n    int valid[3]={1, 7, 30};\n    for(int i=0;i<size;i++){\n        dp[i]=INT_MAX;\n        for(int j=0;j<n;j++){\n            if(days[i]-valid[j]<days[0]){\n                dp[i]=min(dp[i], costs[j]); \n            }else{\n                int index=upper_bound(days.begin(), days.end(), days[i]-valid[j])-days.begin();\n                //找到对应的前面天数对应的下标\n                // cout<<index<<endl;\n                dp[i]=min(dp[index-1]+costs[j], dp[i]);\n            }\n        }\n    }\n    ```\n\n\n\n\n### 数学相关问题（找规律）\n1. 计算各个位数不同的数字个数 \n    - 其实就是9* 9 * 8* 7这种情况）但是要注意是n位数以内的n位数都需要计算，开始各位数有10种情况，后面在当前数插入数据的时候，最开头有9种情况，后面数据有（10-1）种情况，因为后面的数据是可以为0的（固定前面，枚举后面）\n\n2. 消除游戏 和约瑟夫环问题\n    - 解决方案一：使用之后的下标和之前下标的映射 来解决（删除后，末尾从1开始编号）\n    2 ~ 2k映射为k ~ 1那么还原的规律f(2k)=2*(k+1-f(k))\n    - 解决方案二：每次记录剩下链表的头结点，如果当前剩下的个数==1那么直接返回这个数\n\n    - 约瑟夫环递推问题的公式\n𝑓(𝑛)=(𝑓(𝑛−1)+𝑚)%𝑛  （一共n个人，数到m的人被杀）\ndef lastRemaining(n, m):\n    if n == 1: return 0\n    return (lastRemaining(n-1, m) + m) % n\n\n3. 第 N 位数字（一位）\n    - 题意： 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,顺序排列后的第n位数字\n    - 找到不同位数包含的数字number= base*10-base,如果n>这个数那么更新n-=number * weishu,否则就在这个位数里面查找\n    - 如果当前的数%位数==0，那么当前的数字是cur_num=base+n/weishu-1, 否则当前的数字为cur_num=base+n/weishu，然后计算在当前数字里面对应具体哪个数字， 为(cur_num/pow(10, weishu-n%weishu))%10\n\n    - 扩展：还有一个排序后的第n个数 （一个数）二叉树，求两个节点直接夹的数组，类似于上面这道题base* 10的操作，如果小于，那么就往二叉树的下一层节点走（a=a*10, b=b*10, 知道a大于n, 退出向下搜索的循环）\n\n4. 灯泡开关/灯泡开关II\n    - 主要是找到规律前6个灯泡可以推导出其他灯泡的状态，更进一步是，前三个灯可以推导后面所有的状态，因此有状态16种\n    - 只需要枚举每个灯泡的每种状态(为0或者为1)就可以了因此是16种情况，用4位表示； 1的数量num num< m， 而且num%2 == m%2\n    - 同时要注意可能灯泡小于6， 因此需要shift=max(6-n, 0)\n    - 然后再将每个状态异或起来就可以了\n（找规律，但不是动态规划问题）\n\n\n5. 到达终点数字\n    - 左右走，步数为1， 2， 3，...。也是属于找规律，但是不是动态规划的问题 \n    - 找到连加中大于target的最小sum(cur=k),然后求delta=sum-target,如果为奇数那么k++, 直到为delta偶数 (那么就可以减去delta/2)，然后返回当前k值\n\n6. 子矩阵问题(lintcode)\n    1. 第一种题型，要求矩阵内部的元素全部为1，那么以i， j为右下角的最长矩阵边长为\n    ```C++\n    if(matrix[i][j]==1){\n        dp[i][j]=min(dp[i][j-1], dp[i-1][j], dp[i-1][j-1])+1\n    }\n    ```\n    那么以 i， j为右下角的子矩阵的个数为dp[i][j]个\n\n    2. 要求矩形框最长, 那么每个点需要为何它上面最长 up，和左边最长 left， 两个数组\n    ```C++\n    int tmp = min(left[i][j-1], up[i-1][j])+1;\n    for(int len=tmp-1;len>=1;len--){ //枚举长度，使得4个边长都是在len之内，说明能围成一个框\n        if(min(up[i][j-len], left[i-len][j])>=len){\n            return len+1;//返回枚举得到的最长边框\n        }\n    }\n    ```\n\n<font color=red>7. 捡苹果(lintcode) </font>\n    - 前后缀问题(找两个区间，一个区间连续k个数，一个区间连续l个数，两个区间不相交且和最大)\n    - solution: 枚举中间的划分点i,使得\n    ```C++\n    res=max(res, presumK[i]+postsumL[i+1])\n    res=max(res, presumL[i]+postsumK[i+1])\n    ```\n    - 思路没问题：主要是没有找打0~i之前连续窗口最大值与i~len-1 连续窗口的最大值怎么求\n    - 计算前缀和后缀数组，注意如果index转为1~size，那么后缀数组需要开size+2 !!!!\n    ```C++\n            for(int i=K;i<=size;i++){\n                presumK[i]=max(presum[i]-presum[i-K], presumK[i-1]);\n            }\n            for(int i=L;i<=size;i++){\n                presumL[i]=max(presum[i]-presum[i-L], presumL[i-1]);\n            }\n            for(int i=size-K+1;i>=1;i--){\n                postsumK[i]=max(presum[i+K-1]-presum[i-1], postsumK[i+1]);\n            }\n            for(int i=size-L+1;i>=1;i--){\n                postsumL[i]=max(presum[i+L-1]-presum[i-1], postsumL[i+1]);\n            }\n    ```\n\n8. 钢笔和\n    - 题意：找到两个不相交的区间，每个区间和都为target, 使得这两个区间len之和最小，其实也可以向上一题一样，分为pre post,然后枚举划分点，使用分治算法进行计算\n\n9. 可被三整除的最大和 这道题和lc1363 形成3的最大倍数是一样的思路\n    - 不要求是连续\n    - 使用余数的递归公式 dp[i][j]表示以i结尾的余数为j的最大和\n    - 那么就要根据nums[i]%3的余数分类别更新dp[i][0], dp[i][1], dp[i][2]\n    - 一个更简单的方法是 \n    ```C++\n    a=remainder[0]+nums[i]; \n    b=remainder[1]+nums[i];\n    c=remainder[2]+nums[i];//因为可以不连续\n    remainder[a%3]=max(remainder[a%3], a);//a对余数就是a%3,所以分在一组\n    remainder[b%3]=max(remainder[b%3], b);\n    remainder[c%3]=max(remainder[c%3], c);\n    ```\n\n    - PS: 类似的一个题：将字符串翻转到单调递增  \n    dp[i][0]表示前i个数以0结尾，dp[i][0]表示前i个数以1结尾\n    易错点：dp[i][1]=min(dp[i-1][0], dp[i-1][1]) //以1结尾的时候，前面以0结尾是不需要+1的\n\n\n### 博弈论相关问题\n1. 石子问题\n2. 预测家，当前只能从石子序列的头或者尾部进行取，那么使用枚举长度的动态规划+前缀和 （区dp） 注意这道题和lc1423. 可获得的最大点数 不一样因为这个是一定要拿完，而且有两个人拿，而lc1423是一个人拿，所以使用滑动窗口解决 n-k的窗口内数据最小就行\n3. 能赢吗， 因为是从1-n中随机取，而且取了之后就不能取了，所以使用带记忆的dfs, 使用位图来记录当前状态是否遍历过 dp[state]\n\n\n\n### 其他\n1. 斐波拉切数列问题\n2. 成熟的牛不断生小牛的问题\n3. 汉罗塔问题\n4. 走地图问题（最短/最长价值/龙与地下城游戏）\n5. 扔鸡蛋问题\n```C++\ndp[i][j]=1+dp[i-1][j-1]+dp[i-1][j] //dp[i][j]表示用i次操作j个鸡蛋能够验证的最高高度\n```\n6. 画匠问题\n    - 动态规划或者二分算法\n    - 动态规划：类似于鸡蛋问题，可以使用滑动数组，将二维转为一维，但是在转的时候注意i j的顺序 dp[i-1][0~j]可以转 dp[0~i][j]不太好转\n\n    - 二分解法如下\n    二分法，限制所有画作完成的时长，然后检查在这个时长限制下画家的数量够不够。够的话说明时间还可以压缩，不够的话就要放宽时长限制，多给一些时间。\n    ```C++\n    int getNumber(int limit){\n        int cnt=0;\n        int tmpsum=0;\n        for(int i=0;i<arr.size();i++){\n            tmpsum+=arr[i];\n            if(tmpsum>limit){\n                cnt++;\n                tmpsum=arr[i];\n            }\n        }\n        return cnt+1;\n    }\n    int left=INT_MIN, right=0; //表示一个画家画的时长\n    for(int i=0;i<arr.size();i++){\n        left=max(arr[i], left);\n        right+=arr[i];\n    }\n\n    if(K>=arr.size()){//如果画家数量比画多\n        return left;//返回时长最大的画\n    }\n\n    while(left<right){\n        int mid=left+(right-left)/2;\n        int tmp=getNumber(mid);\n        if(tmp==K){\n            right=mid;\n        }else if(tmp<K){\n            right=mid-1;//应该也可以和tmp==K合并为right=mid\n        }else{\n            left=mid+1;\n        }\n    }\n\n    return right;//最小的时长\n    ```\n\n<font color=red>7. 邮局选址的问题</font>\n    - 转移状态的枚举类似于画匠问题\n    - 因为两个邮局的情况，不清楚那个邮局负责哪些居民区，那么就枚举，然后求最小。\n    - 这道题前提是要知道：建立一个邮局的时候，建在中间是最优的情况！\n        1. 提前求i ~ j这段距离建立一个邮局的最小距离\n        2. dp[i][j]表示0 ~ i这段居民区，有j+1个邮局的最小距离   也可以改成j对应j个邮局，这样初始化dp[i][1],循环j从 2 ~ num\n        3. 初始化边界dp[i][0]=w[0][i];\n        4. 建立转移方程： dp[i][j]=min(dp[k][j-1]+w[k+1][i], dp[i][j]) k从0到i，（官方题解：两端值都取!!!!!），表示建邮局的位置\n        注意j<=i，当j>i dp=0; 每次进入k循环的时候，在初始化dp[i][j]=INT_MAX\n        5. 返回结果 dp[n-1][K-1];\n        ```C++\n        int w[size+1][size+1];\n        //求任意两个居民点之间建立一个邮局的最短距离\n        for(int i=0;i<size;i++){\n            for(int j=i+1;j<size;j++){\n                w[i][j]=w[i][j-1]+a[j]-a[(i+j)/2];\n            }\n        }\n        dp[i][0]=w[0][i];\n        for(int i=0;i<=size-1;i++){\n            for(int j=1;j<=num-1;j++){  \n                if(j>=i){//邮局数量>=居民区数量  如果不进行判断就需要 k<=i，否则就会因为进不去 k 的循环，导致dp[i][j]=INT_MAX\n                    dp[i][j]=0;\n                }else{\n                    dp[i][j]=INT_MAX;\n                    for(int k=0;k<i;k++){\n                        dp[i][j]=min(dp[k][j-1]+ w[k+1][i], dp[i][j]); //注意k+1可能==size，因此需要w需要size+1空间\n                    }\n                }\n            }\n        }\n        ```\n        总结，从左到右开始建立，而不是使用二进制记录状态，随机建立\n        状态转移类似最长递增子序列的思路， 需要提前计算i， j之间建立一个邮局的最短距离\n\n<font color=red>8. 数组的最大价值 (区间dp)</font>\n    - 题意，就是找任意不相交区间且每个区间首位值相等，使得这些区间加起来价值最大\n    - 转移方程：\n  `  dp[i]=max(dp[i-1], dp[j-1]+presum[i]-presum[j-1]); （a[i]==a[j]）`\n    因为需要a[j]==a[i]，如果使用二重循环会超时\n    解决方案：\n    （1）使用hash存储不同a[i]对应的下标\n    （2）记录另外一个hash 使得hash[a[i]]=max(hash[a[i]], dp[i-1]-presum[i-1]) \n    - 之后再进行更新就不用循环找与i相同的下标j,可以直接更新dp[i]=max(dp[i-1], presum[i]+hash[a[i]]); \n（注意要对hash[a[i]]是否存在进行分类讨论）\n\n<font color=red>9. 盒子放置（谷歌）/现在无权限查看</font>\n    - 使用动态规划的思想；\n    - dp[i][j] 表示当前第i个box，第j个position能放置的最多的box数量。\n    如果 box[i - 1] <= position[j - 1]，则dp[i][j] = dp[i - 1][ j - 1] + 1 贪心，放在最后一个位置最好\n    反之，dp[i][j] = max(dp[i-1][j], dp[i][j - 1]) 其中di[i-1][j]表示不放第i个box, dp[i][j - 1] 第i个box不放在j个位置\n    **重要！！！！！**\n    - 注意下标i从0 ~ n-1，但是这个因为有w，所以最好和w对应，不转为1 ~ n。\n    从i从0开始取的话，每次k循环，划分两个部分相加， 后半部分都不会包含第一个数，因此j要从2开始取，否则就会造成dp[0][0]//第一个0代表有地址，第二个0代表无邮局，就会返回INT_MAX,造成结果错误\n    背包问题，i下标是1~n 因为i可能从i-1推导，需要i>=1\n\n\n8. “马”在棋盘上的概率\n    - 类似的==地图问题==，虽然当前位置可以由它四面八方的位置推出来，但是因为步数，所以对应的三维数组还是由之前的状态推导出来，因此仍然可以使用动态规划\n    ```C++\n        for(int K=1;K<=k;K++){\n            for(int i=0;i<n;i++){\n                for(int j=0;j<n;j++){\n                    for(int q=0;q<8;q++){\n                        int nextx=i+dx[q];\n                        int nexty=j+dy[q];\n                        if(nextx>=0&&nextx<n&&nexty>=0&&nexty<n){\n                            dp[i][j][K]+=dp[nextx][nexty][K-1]/8.0; //下一个和当前反过来感觉也行\n                        }\n                    }\n                }\n            }\n        }\n        double sum=0.0;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                sum+=dp[i][j][k]; //k步走到每个棋盘的概率加起来\n            }\n        }\n    ```\n\n### 字符串与动态规划  \n也可以划分到Trie树问题:一般是对单词建立Trie树\n1. 单词拆分问题（\n    - dp代表的是True or False\n    - dp+第二层循环枚举字典里面的每一个单词，看是否恰好是当前遍历序列0~i的最后几个字符\n    为了进一步减少时间，内层训练从i枚举到0，同时为true的时候直接退出\n    ```C++\n    for(int i=1;i<size;i++){ //遍历字符串的每一个字符\n        for(int j=i;j>=0;j--){\n            string tmp=s.substr(j, i-j+1);\n            if(wordSet.find(tmp)!=wordSet.end()){\n                dp[i]=dp[i]|dp[j-1];\n            }\n            if(dp[i]){\n                break;\n            }\n        }\n    }\n    方法二：\n    以当前判断后面的字符串\n    for(int i=0;i<=s.size();i++){\n        for(int j=0;j<wordDict.size();j++){\n            if(!dp[i]){\n                continue;\n            }\n            string tmp=s.substr(i,wordDict[j].size());\n            if(tmp==wordDict[j]){\n                dp[i+wordDict[j].size()]=true;\n            \n                path[i].push_back(i+wordDict[j].size());\n            }\n        }\n    }\n    ```\n    <font color =red>单词拆分II需要求出所有可行的解</font>\n    为了避免重复的计算和对比，字符串的前缀是否包含单词表里面的单词，需要使用单词拆分1的方法将i后面对应的true的下标放在hash<int, vector>里面记录起来，这样之后再进行遍历的时候就不需要重复判断；\n    另外一个去处回溯的重复方案是， 将一个下标后面的字符串对应的可以拆分方案提前记录起来（hash<int, vector<vector<int>>），这样的话，就不用对同一下标进行多次重复求值（类似于二叉树的组成类似的）\n\n<font color=red>2. 恢复空格问题(代表的无效字符的个数)- 使用Trie树的经典案例 </font>\n    - 都可以转为Trie树+dp类型的题目 \n    - 这个不能暴力erase,因为可能出现一个单词是另外一个单词的前缀，可能导致erase顺序不同，结果不同；这个只能使用字典序；\n    - 另外一个减少暴力深搜索带来的超时问题，可以使用第二层循环每次枚举dict的每个元素，看是否与当前遍历序列的最后几个字符相同，而不是每个不同长度的单词一个一个的进行比较。\n    - 多次搜索：使用暴力的string find或者使用将small单词列表建立Trie树，然后big以每个字符为开头，查找字符串是否出现在Trie树中，在查找的路径中如果遇到isend=True说明找到了一个字符\n    然后继续找下去\n    \n\n3. 环绕字符串中唯一的子字符串\n    - 题意为：找到子串字符必须是连续的，这样的子串的个数，但是这样可以会出现重复比如abcbc，所以要使用dp (其实就是hash，记录以某个字符结尾的最长的子串)\n    - 计算出26个英文字母中每一个英文字母的结尾的最长的连续的环绕字符串，然后求和\n    - PS：注意字符串去重，如果不考虑去重的话，可以直接使用滑动窗口记录子串个数；因为这个滑动窗口是直接出现不连续，窗口长度直接退化为1，所以可以只记录窗口长度，不记录窗口左右两端\n\n4. lc97. 交错字符串\n- 求第三个字符串是否能由第一个和第二个字符串组合得到，是否问题\n- 易错点：不能使用双指针，因为针对一个两个字符串相同的情况可能造成错误\n- 使用动态规划，dp[i][j]表示字符串1的前i个字符和字符串1的前j个字符能否组成第三个字符串的i+j个字符\n\n\n\n### 状态压缩\n1. 划分为k个相同子集，也可以看做dfs+回溯+贪心\n    - 状态压缩的话就是dp[i]中i的每一个数由二进制位的状态组成，然后遍历二进制的每一个状态，当前的状态可以由当前状态中任意取消一个1的状态转移过来，或者用当前的状态更新下一个状态（将状态中为0的转为1），只有只有dp[i]=true, 而且当前状态的和%target+nums[i]<=target下一个状态才为true,否则为false\n    ```C++\n    bool canPartitionKSubsets(vector<int>& nums, int k) {\n            int size=nums.size();\n            int total_sum=0;\n            for(int i=0;i<size;i++){\n                total_sum+=nums[i];\n            }\n            if(total_sum%k!=0){\n                return false;\n            }\n            int target=total_sum/k;\n            sort(nums.begin(), nums.end());\n            int total_state=1<<size;\n            vector<bool> dp(total_state, false);\n            vector<int> sum(total_state, 0);\n            dp[0]=true;\n            for(int i=0;i<total_state;i++){\n                if(!dp[i]){\n                    continue;\n                }\n                // cout<<i<<endl;\n                for(int j=0;j<size;j++){\n                    // cout<<j<<endl;\n                    if((i&(1<<j))==0){   //注意：位运算一定要记得打上括号之后再判断是否相等，否则会出错！！！！！\n                        int next=i|(1<<j);\n                        // cout<<next<<endl;\n                        if(sum[i]%target+nums[j]<=target){\n                            sum[next]=sum[i]+nums[j];\n                            dp[next]=true;\n                            cout<<next<<endl;\n                        }else{\n                            break;\n                        }\n                    }\n                }\n            }\n            return dp[total_state-1];\n    ```\n\n2. 优美的排列\n    - 也是状态压缩 或者回溯，相比第2题需要枚举当前位置放的数是哪个，所以多一层循环。上面那道题因为数的位置是固定的，所以只需要判断这个数放没放。\n    - 其实还是顺序放，当前放了m个，那么下一个要放的数就是m+1， 所以也可以不同像下面的题解一样多一层循环（3月8日修改）\n    ```python\n    class Solution {\n    public:\n        int count(int number){\n            int res=0;\n            while(number!=0){\n                if(number&1){\n                    res++;\n                }\n                number=number>>1;\n            }\n            return res;\n        }\n        int countArrangement(int n) {\n            int state=1<<n;\n            \n            vector<int> dp(state, 0);\n            dp[0]=1;\n            for(int num=1;num<=n;num++){ //类似背包的，当前放第num数， 标准答案是将状态放在外层， 然后通过1个个数判断当前的num\n                for(int i=0;i<state;i++){\n                    // if(!dp[i]){\n                    //     continue;\n                    // }\n                    if(count(i)!=num-1){\n                        continue;\n                    }\n                    for(int j=0;j<n;j++){\n                        if((i&(1<<j))==0){\n                            if(num%(j+1)==0||(j+1)%num==0){\n                                int next=i^(1<<j);\n                                dp[next]+=dp[i];\n                            }\n                        }\n                    }\n                }\n            }\n            return dp[state-1];\n            \n        }\n    };\n    ```\n\n3. 华为的一个机试题目\n    - 需要在规定燃油内（规定长度内）得到的资源最大化（有点像0-1背包问题）， 但是这个不同之处在于：从不同点到相同的i，消耗的燃油是不一样的， 而且这个最后还需要回到原点，所以dist需要走过的位置mask 以及最后的位置i\n    - 其实就是先求每个mask的最小dist, 得到d[mask][i]:也就是以i结尾的最小燃油，然后遍历这个数组，如果d[mask][i]+fuel[i][0]<=maxdist 那么更新ans\n    ans=max(ans, g[mask])\n\n    - 为什么不直接求d[fuel][i]的最大化，这样也会重复vis统一节点\n    https://leetcode-cn.com/circle/discuss/a4pRYY/\n\n4. 访问所有节点的最短路径(hard)\n    - 题意：一笔走完所有的节点，注意可能重复访问同一个节点\n    - 主要思路：\n    先求出任意两个节点间的距离，使用floyd，同时记得出事dist[i][i]=0\n    然后使用d[mask][i]:表示最后状态为mask,并且以i结尾的最短路径\n    最后遍历d[mask][i] 求最小值\n    - 易错点，mask的循环一定要在节点i的循环的外面， 否则就会出错\n```C++\n  for(int mask=1;mask<(1<<n);mask++){\n            for(int i=0;i<n;i++){\n                if (mask & (1 << i)) { //如果i这个点已经被选过\n                    for(int k=0;k<n;k++){\n                        if((mask&(1<<k))==0){\n                            d[mask|(1<<k)][k]=min(d[mask|(1<<k)][k],d[mask][i]+dist[i][k]); //需要先使用floy求出任意两点之间的最短距离\n                        }\n                    }\n                }\n            }\n        }\n```\n\n5. 基于陈述统计最多好人数\n    - 这个是枚举状态（二进制），与dp无关，但是和状态压缩dp有点类似\n\n6. 两个数组最小的异或值之和  / <font color=red>lc2172： 数组的最大与和 </font>\n    - 这两道题都是位运算相关的状态压缩\n    第一题枚举nums2每个数应该放的位置\n    第二题需要先装为状态压缩的样子，因为每个index有两个slot,所以需要先转为2*n个slot，那么slot和index对应关系为j/2+1\n    然后枚举每个数应该放在哪个slot,同时注意这道题不是每个状态都有值，对于one_num of state i>=num数量, 直接continue\n    - 一个位可以放两个数的情况，需要展开分别讨论\n    ```C++\n    int ans = 0;\n    vector<int> f(1 << (numSlots * 2));\n    for (int i = 0; i < f.size(); ++i) {\n        int c = __builtin_popcount(i); //当前已经放了几个数，下一个放的数就是nums[c]\n        if (c >= nums.size()) continue; //直接跳过\n        for (int j = 0; j < numSlots * 2; ++j) {\n            if ((i & (1 << j)) == 0) { // 枚举空篮子 j\n                int s = i | (1 << j);\n                f[s] = max(f[s], f[i] + ((j / 2 + 1) & nums[c]));\n                ans = max(ans, f[s]); //有效的状态求结果\n            }\n        }\n    }\n    return ans;\n    ``` \n\n### 动态规划 + 拓扑排序\n1. 并行课程III\n题意：可能具有拓扑结构+每节课程都有上课时间， 任意两节不依赖课程可以同时上，求最短上完所有课程的时间\n转化：拓扑排序的最长路径\n两种解决方案：\n- 转为dfs，建立依赖关系的时候反向建立，然后将度为0的点放入队列之中（root）,dfs求深度，然后多棵树取最长深度\n- 使用拓扑排序，将度为0的点放入队列，同时每次在取出队列中的点的时候，用当前点的结果f[v]更新v后面所有后修课程的结果\nf[w]=max(f[w], f[v]+time[v])\n\n\n### 反向dp\n1. <font color=red>lc174. 地下城游戏</font>\n- 正序的含义为“从起点出发，到达位置（i，j）所需要的最少血量”；正向dp有两个因素影响，可能每条路各有一个因素好，因此不知道选择哪条；（当前需要的血量，和整条路径中至少需要的血量）\n- 倒序的含义是“从（i，j）出发，到达终点需要最少的血量”。初始血量本来就是要求的，所以只能倒序dp\n- 转移方程：\n```C++\nif(i==m-1&&j==n-1){\n    dp[i][j]=max(1-dungeon[i][j], 1);\n}else if(i==m-1){\n    dp[i][j]=max(dp[i][j+1]-dungeon[i][j], 1); //每个点的初始健康点都必须为正整数\n}else if(j==n-1){\n        dp[i][j]=max(dp[i+1][j]-dungeon[i][j], 1);                \n}else{\n        dp[i][j]=max(min(dp[i+1][j], dp[i][j+1])-dungeon[i][j], 1); \n}   \n```\n\n### 总结\nok  ok\n1. 图与动态规划，一定要注意vis的问题，bellman-ford以及floyd算法都是图的动态规划的例子\n但是注意因为bellman-ford是求距离最小，所以不会出现重复vis同一个节点的情况\n但是如果求max的情况，使用动态规划+图就可能造成一个节点vis多次，因此最好考虑记忆化dfs或者状态压缩\n\n2. 状态压缩问题，将状态放在外层比较保险；如果是list数组，那么可以将num放在外面，如果是图，那么只能将状态放在外面。 通常状态压缩使用的题目是将数据放在哪个位置，得到最大/最小、/满足什么样的条件的XXX类似题型\n<font color=red>图类型的状态压缩：求遍历这个图中所有节点的最小代价（代价指的是走过路径长度的总和， 应该是顺序走完）。状态压缩dp，注意不要理解成最小生成树</font>\n\n\n3. 动态规划的关键是处理 i 取值范围 j取值范围，转移方程以及边界情况求动态规划\n也就是找到dp[i]-> dp[j] (j< i) 的递推公式,这个递推可能由i，j之间回文，括号，或者异或和组成；特别的，如果是回文可以提前得到任何i，j之间是否为回文字符串，模板代码如下：\n```C++\n   for(int i=s_len-1;i>=0;i--){\n        for(int j=i+1;j<s_len;j++){\n            p[i][j]=(s[i]==s[j]&&p[i+1][j-1]);\n        }\n    }\n```\n\n4.区间dp问题，外围长度的字符状态，可以由内围的长度的字符推导出来 dp[i][size]\n\n5. 如果进行了状态压缩：\n0-1的最大背包问题，逆向枚举\n多重背包问题也是，只能逆向枚举\n完全背包（无限个）才是正向枚举！！！\n\n6. 有的时候动态规划不好解决，考虑使用带记忆的dfs，（比如要求所有的路径，或者所有路径中花费最小等等） 而且dp 的index可以为一个vector（类似与状态压缩）\n\n7. 最短时间类似题，除了考虑动态规划，也可以向二分算法中思考，比如画匠问题\n\n8. 动态规划可以解决true/false（是否能化为k个相同区间，单词拆分问题）, 最小最大最长问题，总数问题\n\n9. 当动态规划的状态比较多的情况下\n注意 res+=dp[i][m]%MOD(wrong answer) \nres=(res+dp[m][i])%MOD(right answer);\n\n10. 划分性dp有两种情况：以i为结尾，和0-i之间，区分这两种情况就是判断在进行dp递推的时候，如果dp[i] 依赖于多个之前的dp[j]那么应该使用以i为结尾，如果dp[i]只依赖之前的一个dp[j]那么使用0-i之内的元素\n（最长子序列和最长子串问题）\n\n11. 使用状态枚举（状态压缩）的方法，要求k<32 !!!!如果n<100那么就不能这么枚举\n\n12. 背包问题可能也会加一个额外的条件，类似于最短路径问题（Dijstra/bellman-ford/floyd）中再加一个额外条件,具体例题见“货物转移”(lintcode)模板： dp数量最小+weight最大类似题目\n```C++\n    if(d[j]+1<d[i]){ //找到更优解\n        d[i]=d[j]+1;\n        weight[i]=weight[j]; // update weight and d\n    }else if(d[i]==d[j]+1){\n        weight[i]=max/min(weight[j], weight[i]); //only update weight\n    }else{\n        continue; //do not update anything\n    }\n```\n\n13. 动态规划一定要注意状态的初始化，在i 和 j都从1开始取的时候，一定要记得赋值dp[0][1到n] 以及dp[1到n][0]\n\n14. 如果出现反复将一个字符串的子串和字典中的每个字符比对的题目，可以使用Trie树，或者使用动态规划（True/False类型），提前判断某一个子字符串是否在字典中\n\n15. 刷一刷leetcode以面试题开始的题目\n\n16. 每个物品选择或者不选择，使得总体的方案是n, 同时花费最少的这种类似题可以使用动态规划\n例题： lc1029. 两地调度\n- 第一想法是使用二进制的暴力枚举\n- 因为整体的方案一定要是n, 所以一定要初始化dp[0][j] (j>=2为一个比较大的值)； 同时dp[i][0] 为dp[i-1][0]+cost[i][1]\n```C++\n    dp[0][0]=costs[0][1];\n    dp[0][1]=costs[0][0];\n   for(int j=2;j<=n/2;j++){\n        dp[0][j]=1000000; //注意这个是非常重要的！！！！\n    }\n    for(int i=1;i<n;i++){\n        dp[i][0]=dp[i-1][0]+costs[i][1];\n        for(int j=1;j<=n/2;j++){ //j代表剩余的0类的数量\n            dp[i][j]=min(dp[i-1][j]+costs[i][1], dp[i-1][j-1]+costs[i][0]);\n        }\n    }\n```\n- 第二种方法是贪心：\n    a[i] - b[i]代表将i员工派往a地比派往b地的费钱程度，数值越高表示派往a地越不划算；\n    将所有花费按a[i] - b[i]从小到大排序，则前n个为派往a地更划算的员工，后n个为派往b地更划算的员工。\n\nlc474. 一和零 （类似于0-1背包问题）\n- 选不选择每个字符串，满足0， 1不超过m, n同时使得最后的字符串个数最多; 或者选了这个不能选择左右两边， 类似问题都使用dp\n- 这种第一种想到的思路是回溯，更进一步的方法是动态规划\n- 回溯思路如果不求具体序列，只求总数的话，可以考虑动态规划解决\n```C++\nif(j>=zero_num&&k>=one_num){\n    dp[i][j][k]=max(dp[i-1][j-zero_num][k-one_num]+1, dp[i-1][j][k]);\n}else{\n    dp[i][j][k]=dp[i-1][j][k]; //一定注意else别忘了\n}\n```\n\n\n17. 非常重要的资源：https://oi-wiki.org/dp/knapsack/ \nOI-wiki  《背包九讲》\n\n18. 连续数组进行划分，是的划分个数满足条件，使用动态规划或者二分查找\n例题：lc410. 分割数组的最大值(hard), 画匠问题\n\n19. 一定要注意数组越界可能不会报错，比如403. 青蛙过河，申请dp[size][size] size=18， 但是访问dp[18][29]范围为true\n所以这道题关键在于一定要加上判断if(k<=j+1) 才能进行dp的更新，否则就会发生访问到越界的数据\n","source":"_posts/leetcode/动态规划题型.md","raw":"---\ntitle: 动态规划\ncatogory:\n  - leetcode 题目汇总\ntags: dp\ncategories:\n  - leetcode\ndate: 2021-11-13 17:00:51\n---\n\n### 求总数问题\n1. 回文字符串的个数\n2. 表达式为期望结果的总数\n    - 也是区间dp, dp[i][j][0]或者dp[i][j][1])\n    - 因为不是表达式的个数，而是达到期望值的个数，因此要记录一个表达式的值，用三维数组\n3. 能够组成的二叉树的个数\n4. 打气球的最大分数(区间dp)\n   - 虽然不是求个数，而是求最大，但是也是与当前状态的左右边界有关。因为最终结果和左右两边有关，因此都是枚举的长度+右边界，计算左边界，进行动态规划\n   转移方程：考虑这个区间上最后一个气球的打破方式，即最后一个气球的打破位置。在左边右边和中间\n   ```C++\n   f[i][j] = max( f[i][j], f[i][k - 1] + f[k + 1][j] + a[k] * a[i - 1] * a[j + 1]); //闭区间的更新方式\n   ```\n\n   在leetcode上面的一道原题，只是描述改变了\n   lc312. 戳气球\n   - 这道题如果将dp[i][j]定义为开区间或得的最大值就更容易理解\n   ```C++\n   状态转移： dp[i][j]=max(dp[i][j], dp[i][k]+dp[k][j]+val[i]*val[k]*val[j]);//开区间的更新方式\n   ```\n   - 注意为了减少情况的分类讨论，需要在左右两边都加上1，这样的话枚举一个区间留下的最后一个数，也是可以求得值的\n\n5. 旋变字符串问题 (区间dp) lc87. 扰乱字符串\n    -  四重循环，三维dp（两个字符串两个端点+一个长度）\n    - 这道题不是求个数，而是求是否，但是仍然是需要枚举长度的问题，因为是两个字符串，所以应该有4个边，但是运用长度相等的信息，将思维坐标转为左边坐标+size, 成为三维问题\n   dp[start1][start2][len] 而且这道题有两个长度：一个是总字符串长度，一个是总字符串化为为两个旋变字符串的长度\n    ```C++\n    for(int size = 2; size <= n; size++){\n            for(int l1 = 0; l1 <= n - size; l1++){\n                for(int l2 = 0; l2 <= n - size; l2++){\n                    for(int leftPart = 1; leftPart < size; leftPart++){\n                        if((dp[l1][l2][leftPart] && dp[l1 + leftPart][l2 + leftPart][size - leftPart]) || \n                            (dp[l1][l2 + size - leftPart][leftPart] && dp[l1 + leftPart][l2][size - leftPart])){\n                            dp[l1][l2][size] = true;      // 只要有一个leftPart满足旋变串条件就可以break出去\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n    ```\n6. 数字字符串转为字母组合的总数\n    - 因为只是与之前的结果或者后面的结果有关，因此只需要从左到右枚举下标就可以了\n    ```C++\n    递推式\n    // 第 i 个字符只能单独转换为一个 字母\n    // dp[i-1] ：第 i 个字符单独转换的方案数\n    dp[i]=dp[i-1];\n    // 第 i 个字符 可以和 第 i-1 个字符 共同转换为一个 字母\n    // dp[i-1] ：第 i 个字符单独转换的方案数\n    // dp[i-2] ：第 i 个字符，结合第 i-1 个字符组合转换为一个字母的方案数\n    dp[i]=dp[i-1]+dp[i-2];\n    //如果第i个字符不能单独存在那么\n    dp[i]=0\n    ```\n7. 组合总数IV， \n    - 总结：如果排序不同算不同的排列组合的话那么 target循环在外侧， nums总数循环在内侧\n    ```C++\n        for(int i=1;i<=target;i++){\n                for(int j=0;j<size;j++){\n                    if(i>=nums[j]&&dp[i - nums[j]] < INT_MAX - dp[i]){\n                        dp[i]+=dp[i-nums[j]];\n                    }\n                }\n            }\n    ```\n    - 如果排序不同算相同的排列祝贺的话那么， target循环在内侧，nums总数循环在外侧, 完全背包问题\n    ```C++\n    for(int i=1;i<=size;i++){\n        for(int j=1;j<=target;j++){\n            dp[i][j]+=dp[i-1][j];\n            if(j>=nums[i-1]){\n                dp[i][j]+=dp[i][j-nums[i-1]];\n            }\n        }\n    }\n    ```\n8. 删除回文子数组\n    - 区间dp/枚举长度的dp\n    - 数组，每次可以删除一个数字，或者删除掉一个回文串，求删除需要的最少次数\n    ```\n    dp[i][j]=min(dp[i+1][j-1], dp[i][j]) if a[i]==a[j]\n    dp[i][j]=min(dp[i][k]+dp[k+1][j], dp[i][j])\n    dp长度从3开始，dp长度为1， 2的时候使用初始化\n    ```\n    - 答案见：https://cloud.tencent.com/developer/article/1659691 可以作为区间dp模板，但是枚举长度和转移方程那里可以修改一下\n\n9. lc115. 不同的子序列 (具体分析见字符串匹配问题)\n\n10. 446. 等差数列划分 II - 子序列（hard）\n- 题意：等差子序列个数，可不连续，每个序列至少包含3个数\n- 我的困难地方在于，这个序列长度要等于3，那么将序列==2的如何处理，如果出现重复如何处理 比如2  1 2 3\n- 官方解题方案是，计算弱等差子序列的个数（序列==2），然后再计算结果的时候遍历三个数，同时因为差为负数，所以使用hash_map数组vector<unordered_map<long long, int>> d(size)\n- 将记录以某一下标结尾的序列中包含的数个数，转为差为d的对数（个数->对数）\n\n11. 1000. 合并石头的最低成本(hard)\n- 区间dp的经典题目，四重区间dp\n- 将i，j之间的num堆转为 区间划分前面1堆后面num-1堆，然后因为连续k堆可以转为一堆，所以单独对于dp[i][j][k]单独进行转换为dp[i][j][1]\ndp[i][j][num]=min(dp[i][j][num], dp[i][q][1]+dp[q+1][j][num-1]); //num表示num堆， 注意没有必要枚举dp[i][q][2]+dp[q+1][j][num-2]//这种情况，因为下标划分已经达到枚举的作用\n\n\n### 求最大最小问题\nPS: 子串都是要求连续的，而子序列是不要求连续的\n1. 扔鸡蛋 lc887 \n    https://zhuanlan.zhihu.com/p/92288604\n    两种状态转移：\n    a. dp[k][n], k个鸡蛋n层楼， 需要最少扔多少次\n        dp[1][N] = N\n        dp[..][0] = 0\n        for i=1到n:\n         dp[k][n]=min(dp[k][n], max(dp[k][i-1]+dp[k-1][n-i])+1);//不需要在第i层再扔，因此删除i\n    b. dp[k][m], k个鸡蛋扔m次，可以验证的最大楼层数\n        dp[0][..] = 0\n        dp[..][0] = 0\n        whle(dp[K][m]<N){\n            m++;\n            for (int k = 1; k <= K; k++){\n                dp[k][m] = dp[k][m - 1] + dp[k - 1][m - 1] + 1;\n            }\n        }\n    ```C++\n        int ans=-1;\n        vector<vector<int>> dp(n+1,vector<int>(k+1));\n        if(n==1&k>=1){\n            return 1;\n        }\n        for(int i=0;i<=n;i++){\n            dp[i][1]=i; //一个鸡蛋\n        }\n        \n        for(int j=1;j<=k;j++){\n            dp[1][j]=1; //一次操作\n        }\n\n        for(int i=2;i<=n;i++){ //n次操作\n            for(int j=1;j<=k;j++){ //k个鸡蛋\n                dp[i][j]=dp[i-1][j]+dp[i-1][j-1]+1;\n            }\n            if(dp[i][k]>=n){\n                    ans=i;\n                    break;\n            }\n        }\n        return ans;\n    ```\n\n2. 最长递增子串\n3. 最长递增子序列  \n    两种方法：\n    - 两重循环\n    - 单调栈+二分查找\n    扩展 最长递增子序列的个数，时间复杂度仍然是O(n^2)，只是多了一个cnt, 每次出现最大就更新，否则进行cnt的累加\n     \n    另外类似的题目: 1027. 最长等差数列\n    dp[i][j]表示以i结尾而且差为j的最长数列\n    ```C++\n        for(int i=0;i<size;i++){\n            for(int j=0;j<i;j++){\n                int tmp=nums[i]-nums[j];//因为差可能是负数\n                dp[i][tmp+1000]=dp[j][tmp+1000]+1;\n                res=max(res, dp[i][tmp+1000]);   \n            }\n        }\n    ```\n    lc1218. 最长定差子序列： 这道题diff是定了，因此只需要一维hash就可以了\n    ```C++\n    for(int i=0;i<size;i++){\n        hash[arr[i]]=max(hash[arr[i]-difference]+1, hash[arr[i]]);\n        res=max(res, hash[arr[i]]);\n    }\n    ```\n\n4. 最长公共子串（要求连续）\n     - 注意和子序列的区别：动态规划转移方程是 dp[i][j]=dp[i-1][j-1]+1 or dp[i][j]=0表示以i或者j结尾的子串， 最后遍历二维数组求最大值\n    求具体的最长公共子串，只需要动态规划的时候，记录最长的公共子串的下标，然后s.substr(start_pos = index-maxlen+1, len = maxlen)就可以了\n\n5. 最长公共子序列 （最长长度/最长具体序列/最短包含序列）\n    - 题意改变，但是代码不变的题目--不相交的线\n    - 相似的题目：\n    1. 编辑距离\n    2. 两个字符串的删除操作， 可以直接动态规划求最少的删除字符数量，也可以用最长公共子序列，然后用m+n-2*lcs\n    - 如果要求具体删除的是哪些字符串，两种方法应该都是可以的\n    - 动态规划转移方程是 \n    ```\n    dp[i][j]=dp[i][j]+1 or dp[i][j]=max(dp[i][j-1], dp[i-1][j])\n    ``` \n    dp[i-1][j] 表示以i或者j结尾的子串中包括的最长公共子序列（不一定是以i j结尾）， 所以最后只用直接返回dp[m][n]\n    - 在求最长的公共子序列的时候，需要使用dp转换等式 i--,j-- 或者j--, 或者i--来进行查找最长的公共子序列， 同时也可以求最短的删除的字符具体是哪些\n    ```C++\n    int i = m-1, j = n-1;\n    while(i >= 0 && j >= 0){\n        if(s1.charAt(i) == s2.charAt(j)){\n            res.append(s1.charAt(i));\n            i--;\n            j--;\n        }\n        if(i>0 && j>0 && s1.charAt(i) != s2.charAt(j)){\n            if(dp[i-1][j] > dp[i][j-1])\n                i--;\n            else\n                j--;\n            //dp[i-1][j] < dp[i][j-1]时,j--;\n            //dp[i-1][j] = dp[i][j-1]时,i--或j--,这里统一为j--;\n        }\n        \n        //行或列到达边界\n        if(i==0)j--;\n        if(j==0)i--;\n    }\n    ```\n    PS: lc1092. 最短公共超序列\n    - 求包含两个字符的最短序列， 其实就是m+n-k(k为公共序列的长度)\n    相比于公共序列， 会在i--, j-- 都push_back字符; 求具体的公共序列的时候，只有相等的时候才push相等的字符\n    ```C++\n        int i=size1-1;\n        int j=size2-1;\n        string res;\n        while(i>0&&j>0){\n            if(str1[i]==str2[j]){\n                res.push_back(str1[i]);\n                i--;j--;\n            }else{\n                if(dp[i-1][j]>dp[i][j-1]){\n                    res.push_back(str1[i]);\n                    i--;\n                }else{\n                    res.push_back(str2[j]);\n                    j--;\n                }\n            }\n        }\n        while(i>0){\n            res.push_back(str1[i--]);\n        }\n         while(j>0){\n            res.push_back(str2[j--]);\n        }\n        reverse(res.begin(), res.end());\n    ```\n\n    \n\n6. 最长回文子序列\n    - 不要求连续，枚举长度\n    - 初始化长度为1和2的情况，然后\n    ```C++\n     for(int len=3;len<=s_len;len++){\n            for(int left=0;left<s_len;left++){\n                int right=left+len-1;\n                if(right<s_len){\n                    dp[left][right]=max(dp[left+1][right], dp[left][right-1]);\n                    if(s[left]==s[right]){\n                        dp[left][right]=max(dp[left][right],dp[left+1][right-1]+2);\n                    } \n                }\n            }\n        }\n    ```\n\n7. 最长回文子串的问题 （判断true/false的dp系列）\n    - 可以用动态规划也可以用从中间向两边扩展的方法\n    动态规划dp[left][right]不是表示长度，而是表示是否为回文子串，在求长度使用一个公共变量max_len,每求出dp 如果dp为1那么更新max_len\n\n8. 最长有效括号子串\n    - 方法一：动态规划\n    - 转移方程 dp[i]:以i结尾的最长有效括号子串 转移方程如下\n    ```C++\n        for(int i=1;i<s_len;i++){\n            if(s[i]==')'){\n                int j=i-dp[i-1]-1;\n                if(j>=0&&s[j]=='('){\n                    dp[i]=dp[i-1]+2;\n                    if(j-1>=0){\n                        dp[i]+=dp[j-1];\n                    }\n                }\n                result=max(result, dp[i]);\n            }\n        }\n    ```\n    - 方法二：下标栈，栈低维护的是最后一个没有被匹配的右括号下标，如果s[i]=='('入栈下标; 如果s[i]==')', 栈中弹出一个元素，如果栈为空，直接push(i) continue，否则更新ans=max(ans, i-s.peek())\n\n9. 分割回文串系列题目\n    1. 分割回文串1\n    - 动态规划+回溯dfs，求所有i， j之间的子字符串p[i][j]是否是回文（类似最长回文子串的题目）\n\n    2. 分割回文串2\n    - 求最少分割次数\n        - 这道题不能使用枚举长度和左边界+枚举分割点的方式，时间复杂度太高（O(N^3)）\n        - 正确的解决方案是，求dp[i] 从0到i需要分割的最少次数，同时事先需要使用动态规划求出任意i j之间是否是回文串；如果0-i是回文串，直接结果为0，否则依次遍历i之后的字符串，找到回文串j+1-i，同时更新dp[i]=min(dp[i], dp[j]+1)\n        - 这道题可以和“子数组异或值为0的最多划分”进行类比（动态规划+map映射上一个位置）；不同之处这道题通过回文串映射到上一个位置，异或和是通过异或值为和当前值相同隐射到上一个位置\n    ```C++\n        for(int i=0;i<s_len;i++){\n            dp[i]=INT_MAX;\n        }\n        dp[0]=1;\n        for(int i=0;i<s_len;i++){\n            if(p[0][i]){\n                dp[i]=0;\n            }else{\n                for(int j=0;j<i;j++){ //类似最长递增序列 需要预处理，i, j之间是否为回文， 预处理代码i为逆序，j为顺序\n                    if(p[j+1][i]){\n                        dp[i]=min(dp[i], dp[j]+1);//每一个被分割的子字符串都必须要为回文\n                    }\n                }\n            }\n            \n        }\n        return dp[s_len-1];\n    ```\n\n\n10. 背包问题\n    - 比较难的例题：货物转移（lintcode-困难） 反向dp（求背包数最少）+滚动数组+额外条件\n        - 相当于转为两个题：\n        1. 从n个背包里面选择最少的背包使得背包容量大于等于sum（与选最大价值使得，重量小于sum相反）\n        2. 假设1求出来的结果为m, 从n个背包里面选择m个背包使得转移最少-->选出的n个背包里面包含货物最多（weight最大）\n        相当于在状态转移方程再加上了一个weight数组的更新，具体代码如下：\n        dp[i]表示使得容量达到i（大于等于i），选择的最少的背包；\n        weight[i]表示使得背包容量达到i（大于等于i），在选择的背包最少的前提下，背包里原本包含的货物最多。\n        ```C++\n            for(int i=0;i<n;i++){\n                    for(int j=sum;j>=1;j--){ //0-1背包问题\n                        int tmp=max(j-b[i], 0);\n                        // dp[j]=min(dp[tmp]+1, dp[j]); 实际上的状态转移\n                        if(dp[j]<dp[tmp]+1){  //拆分后的状态转移\n                            // weight[j]=weight[tmp];\n                            continue;\n                        }else if(dp[j]==dp[tmp]+1){\n                            weight[j]=max(weight[j], weight[tmp]+a[i]); //背包数量一样，选择权重加起来更大的背包\n                        }else if(dp[j]>dp[tmp]+1){\n                            dp[j]=dp[tmp]+1;\n                            weight[j]=weight[tmp]+a[i];\n                        }\n                    }\n                }\n        ```\n     \n    - 扩展的有关于 分组背包的问题（），每个组k的数量还不一样\n    分组背包：每组物品有若干个，同一组内的物品最多只能选一个。（每组中物品不同，个数和体积都可能不一样）\n    多重背包: 有N种物品和一个容量为V 的背包。第i种物品最多有Mi件可用，每件耗费的空间是Ci ，价值是Wi (每组物品相同，且个数相等)\n    ```C++ 分组背包伪代码 和多重背包有点类似也是三重循环\n    //注意这里是三层循环\n        for 所有的组k\n            for v=V to 0\n                for 所有属于组k的i \n                f[v]=max{f[v],f[v-c[i]]+w[i]}\n                end\n            end\n        end\n    ```\n    例题：lc2218. 从栈中取出 K 个硬币的最大面值和（hard）\n    - 使用前缀和+动态规划\n    ```C++\n     for(int i=1;i<=n;i++){ //注意1-n, 之后piles在进行下标访问的时候需要i-1\n        int size=piles[i-1].size();\n        vector<int> presum(piles[i-1].size(), 0);\n        presum[0]=piles[i-1][0];\n        \n        for(int k=1;k<size;k++){\n            presum[k]=presum[k-1]+piles[i-1][k]; //用前缀和表示选择前面z个\n        }\n        for(int j=1;j<=k;j++){\n            dp[i][j]=dp[i-1][j];\n            for(int z=1;z<=size;z++){ //每组的size可能都不相同\n                if(j>=z){\n                    dp[i][j]=max(dp[i-1][j-z]+presum[z-1], dp[i][j]);\n                }\n            }\n        }\n    }\n    return dp[n][k];\n    ```\n\n    - 背包问题求具体的转移方案：我们可以用g_{i,v}表示第 i件物品占用空间为 v的时候是否选择了此物品。\n    ```C++ (感觉应该是0-1背包的)\n        int v = V;  // 记录当前的存储空间\n        // 因为最后一件物品存储的是最终状态，所以从最后一件物品进行循环\n        for (从最后一件循环至第一件) {\n        if (g[i][v]) {\n            选了第 i 项物品;\n            v -= 第 i 项物品的价值;\n        } else\n            未选第 i 项物品;\n        }\n    ```\n      \n\n11. 换钱问题\n    零钱兑换II：一定要注意虽然每个硬币都有无数个，但是不能出现重复，也就是 121  112这种情况，所以硬币的循环一定要放在最外层\n    ```C++\n     for(int i=0;i<coins.size();i++){//硬币放在最内层会发生错误\n        for(int j=0;j<=amount;j++){\n            if(j>=coins[i]){\n                    dp[j]=dp[j]+dp[j-coins[i]];\n            }\n        }\n    }\n    ```\n12. 通配符匹配问题（hard） 类似最短单词距离的动态转移\n    - 一定要注意动态规划的状态转移方程式是i j 从 i-k j-k转移过来，不能出现i+k j+k(如果出现，一定是枚举的长度，例如回文串和打气球问题)\n    - 易错点：\n    字符串的匹配问题，通常会在字符前面加上” “ dp[0][0]=1\n    同时如果i j从1开始取的话，需要初始化赋值dp[0][i] 和dp[i][0]\n    <font color=blue>\n    corner case:\n    s = \"\"\n    p = \"******\" </font>\n    ```C++\n    dp[0][0]=1\n    //下面这个循环是非常重要的\n    for(int i=2;i<p_len;i++){\n        if(p[i]=='*'){\n            dp[0][i]=dp[0][i-1]; // or dp[0][i]=dp[0][i-1];\n        }\n    }\n    \n    for(int i=1;i<s_len;i++){\n        for(int j=1;j<p_len;j++){\n            if(p[j]=='*'){\n                dp[i][j]=dp[i-1][j]||dp[i][j-1];\n            }else{\n                if(s[i]==p[j]||p[j]=='?'){\n                    dp[i][j]=dp[i-1][j-1]; \n                }else{\n                    dp[i][j]=0;\n                }\n            }\n        }\n    }\n    ```\n    - 如果不好赋值dp[i][0] or dp[0][i] 可以让i j 从0开始取，但是在状态转移的时候注意进行j 或者i的判断 if j>=1  dp[j-1]\n        1. 问题1：*可以匹配任意字符 \n        2. 问题2：*只能匹配前面字符的0个1个或多个(正则表达式匹配) 需要判断s[i] p[j-1]是否相等\n\n13. 打家劫舍\n    - 求能够得到金额的最大值。\n    - 环形可以转为dp[0][size-2]和dp[1][size-1]两者之中求最大值\n    - 类似的一道题：删除并获得点数（题意：选了nums[i]， 就不能选择nums[i-1] 和nums[i+1]， 打家劫舍这里的i, i+1是下标的， 这道题是实际数字上的。两个问题都是使用dp \n\n14. 整数拆分 \n    - 可以使用动态规划 二层循环 dp[i]= max(j*(i-j), j* dp[i-j])， 因为存在i-j > dp[i-j]的情况\n    - 或者使用数据规划，将余数为2（2*） 1（4*） 0(3*)情况区别对待\n\n15. 最大整除子集 \n    - 和最长递增序列有相似之处）\n    - 注意：在进行倒推序列的时候，需要记录当前的maxval 以及target_dpval, 这两者都需要在压入每个元素的时候更新\n    - 相邻两个数的商不一定相等\n\n16.  摆动序列 （序列最长问题）\n\n17. 无重叠区间 \n    - 可以使用动态规划，找到以每个区间结尾的最长子序列（O(N^2)） 或者贪心，对区间右边进行排序然后选择 O(nlogn)\n\n18. 最后一块石头的重量 II\n    - 需要理解题意之后转为背包问题，也就是最大最小问题\n    - 求两个子集相差的最小值 -> 转为背包问题，背包容量是sum/2，求能够放入背包的最大数\n    ```\n    dp[i][j]=max(dp[i-1][j], dp[i-1][j-stone[i]]+stone[i])\n    ```\n\n    - 0-1的最大背包问题，逆向枚举\n    - 多重背包问题也是，只能逆向枚举\n    - 完全背包（无限个）才是正向枚举！！！\n\n19. 乘积为正数的最长子数组长度 (最长子数组系列题目)\n    - 注意这道题是求最长的长度，不是最大的乘积，但是这两个问题都可以使用动态规划完成\n    1. 最长的长度，positive[i]表示以i结尾的为正数的子数组，negtive[i] i结尾的为负数的子数组，\n    ```C++\n            if (nums[0] > 0) {\n                positive[0] = 1;\n            } else if (nums[0] < 0) {\n                negative[0] = 1;\n            }\n            int maxLength = positive[0];\n            for (int i = 1; i < length; i++) {\n                if (nums[i] > 0) {\n                    positive[i] = positive[i - 1] + 1;\n                    negative[i] = negative[i - 1] > 0 ? negative[i - 1] + 1 : 0; //注意一定要和0判断\n                } else if (nums[i] < 0) {\n                    positive[i] = negative[i - 1] > 0 ? negative[i - 1] + 1 : 0;\n                    negative[i] = positive[i - 1] + 1;\n                } else {\n                    positive[i] = 0;\n                    negative[i] = 0;\n                }\n                maxLength = Math.max(maxLength, positive[i]);\n            }\n    ```\n    - 我的思路：转为前缀和+hash\n        题意转为：负数为1，正数为0， 0单独处理，相加和为偶数的最长子数组\n        如果<0, 那么sum+=1；\n        如果>0, 那么sum不变；\n        如果=0, 那么sum=0，  hash.clear(), hash[0]=i；\n        如果sum为偶数：\n        res=max(res, i-hash[0])\n        如果sum为奇数：\n        如果hash[1]存在\n        res=max(res, i-hash[1]) \n        否则hash[1]=i;\n\n    2. 最大乘积（可能为负数），dp1[i]表示以i结尾乘积最大子数组，dp2[i]的乘积最小(注意不一定为负数)的子数组\n    ```C++\n            for(int i=1;i<=size;i++){\n                if(nums[i-1]>0){\n                    dp1[i]=max(dp1[i-1]*nums[i-1], nums[i-1]);\n                    dp2[i]=min(dp2[i-1]*nums[i-1], nums[i-1]);\n                }else if(nums[i-1]<0){\n                    dp1[i]=max(dp2[i-1]*nums[i-1], nums[i-1]);\n                    dp2[i]=min(dp1[i-1]*nums[i-1], nums[i-1]);\n                }else{\n                    dp1[i]=0;\n                    dp2[i]=0;\n                }\n                res=max(res, dp1[i]);\n    ```\n\n\n20. 最低票价\n    - 找到能够让days天都观光的最低票价，类似完全背包问题， 最少兑换钞票\n    - dp[i]定义为至少让index==i天观光所需要的最低票价， 分别遍历决策1，决策2， 决策3需要的最低票价\n\n    - solution 1：每天进行dp + 从后往前\n    ```C++ \n    int len = days.length, maxDay = days[len - 1], minDay = days[0];\n    int[] dp = new int[maxDay + 31]; // 多扩几天，省得判断 365 的限制\n    // 只需看 maxDay -> minDay，此区间外都不需要出门，不会增加费用\n    for (int d = maxDay, i = len - 1; d >= minDay; d--) {\n        // i 表示 days 的索引\n        // 也可提前将所有 days 放入 Set，再通过 set.contains() 判断\n        if (d == days[i]) {\n            dp[d] = Math.min(dp[d + 1] + costs[0], dp[d + 7] + costs[1]); //三种情况\n            dp[d] = Math.min(dp[d], dp[d + 30] + costs[2]);\n            i--; // 别忘了递减一天\n        } else dp[d] = dp[d + 1]; // 不需要出门\n    }\n    return dp[minDay]; // 从后向前遍历，返回最前的 minDay\n    ```\n    - solution 2：只从days包含的天数进行dp + 从前往后\n    ```C++\n    int valid[3]={1, 7, 30};\n    for(int i=0;i<size;i++){\n        dp[i]=INT_MAX;\n        for(int j=0;j<n;j++){\n            if(days[i]-valid[j]<days[0]){\n                dp[i]=min(dp[i], costs[j]); \n            }else{\n                int index=upper_bound(days.begin(), days.end(), days[i]-valid[j])-days.begin();\n                //找到对应的前面天数对应的下标\n                // cout<<index<<endl;\n                dp[i]=min(dp[index-1]+costs[j], dp[i]);\n            }\n        }\n    }\n    ```\n\n\n\n\n### 数学相关问题（找规律）\n1. 计算各个位数不同的数字个数 \n    - 其实就是9* 9 * 8* 7这种情况）但是要注意是n位数以内的n位数都需要计算，开始各位数有10种情况，后面在当前数插入数据的时候，最开头有9种情况，后面数据有（10-1）种情况，因为后面的数据是可以为0的（固定前面，枚举后面）\n\n2. 消除游戏 和约瑟夫环问题\n    - 解决方案一：使用之后的下标和之前下标的映射 来解决（删除后，末尾从1开始编号）\n    2 ~ 2k映射为k ~ 1那么还原的规律f(2k)=2*(k+1-f(k))\n    - 解决方案二：每次记录剩下链表的头结点，如果当前剩下的个数==1那么直接返回这个数\n\n    - 约瑟夫环递推问题的公式\n𝑓(𝑛)=(𝑓(𝑛−1)+𝑚)%𝑛  （一共n个人，数到m的人被杀）\ndef lastRemaining(n, m):\n    if n == 1: return 0\n    return (lastRemaining(n-1, m) + m) % n\n\n3. 第 N 位数字（一位）\n    - 题意： 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,顺序排列后的第n位数字\n    - 找到不同位数包含的数字number= base*10-base,如果n>这个数那么更新n-=number * weishu,否则就在这个位数里面查找\n    - 如果当前的数%位数==0，那么当前的数字是cur_num=base+n/weishu-1, 否则当前的数字为cur_num=base+n/weishu，然后计算在当前数字里面对应具体哪个数字， 为(cur_num/pow(10, weishu-n%weishu))%10\n\n    - 扩展：还有一个排序后的第n个数 （一个数）二叉树，求两个节点直接夹的数组，类似于上面这道题base* 10的操作，如果小于，那么就往二叉树的下一层节点走（a=a*10, b=b*10, 知道a大于n, 退出向下搜索的循环）\n\n4. 灯泡开关/灯泡开关II\n    - 主要是找到规律前6个灯泡可以推导出其他灯泡的状态，更进一步是，前三个灯可以推导后面所有的状态，因此有状态16种\n    - 只需要枚举每个灯泡的每种状态(为0或者为1)就可以了因此是16种情况，用4位表示； 1的数量num num< m， 而且num%2 == m%2\n    - 同时要注意可能灯泡小于6， 因此需要shift=max(6-n, 0)\n    - 然后再将每个状态异或起来就可以了\n（找规律，但不是动态规划问题）\n\n\n5. 到达终点数字\n    - 左右走，步数为1， 2， 3，...。也是属于找规律，但是不是动态规划的问题 \n    - 找到连加中大于target的最小sum(cur=k),然后求delta=sum-target,如果为奇数那么k++, 直到为delta偶数 (那么就可以减去delta/2)，然后返回当前k值\n\n6. 子矩阵问题(lintcode)\n    1. 第一种题型，要求矩阵内部的元素全部为1，那么以i， j为右下角的最长矩阵边长为\n    ```C++\n    if(matrix[i][j]==1){\n        dp[i][j]=min(dp[i][j-1], dp[i-1][j], dp[i-1][j-1])+1\n    }\n    ```\n    那么以 i， j为右下角的子矩阵的个数为dp[i][j]个\n\n    2. 要求矩形框最长, 那么每个点需要为何它上面最长 up，和左边最长 left， 两个数组\n    ```C++\n    int tmp = min(left[i][j-1], up[i-1][j])+1;\n    for(int len=tmp-1;len>=1;len--){ //枚举长度，使得4个边长都是在len之内，说明能围成一个框\n        if(min(up[i][j-len], left[i-len][j])>=len){\n            return len+1;//返回枚举得到的最长边框\n        }\n    }\n    ```\n\n<font color=red>7. 捡苹果(lintcode) </font>\n    - 前后缀问题(找两个区间，一个区间连续k个数，一个区间连续l个数，两个区间不相交且和最大)\n    - solution: 枚举中间的划分点i,使得\n    ```C++\n    res=max(res, presumK[i]+postsumL[i+1])\n    res=max(res, presumL[i]+postsumK[i+1])\n    ```\n    - 思路没问题：主要是没有找打0~i之前连续窗口最大值与i~len-1 连续窗口的最大值怎么求\n    - 计算前缀和后缀数组，注意如果index转为1~size，那么后缀数组需要开size+2 !!!!\n    ```C++\n            for(int i=K;i<=size;i++){\n                presumK[i]=max(presum[i]-presum[i-K], presumK[i-1]);\n            }\n            for(int i=L;i<=size;i++){\n                presumL[i]=max(presum[i]-presum[i-L], presumL[i-1]);\n            }\n            for(int i=size-K+1;i>=1;i--){\n                postsumK[i]=max(presum[i+K-1]-presum[i-1], postsumK[i+1]);\n            }\n            for(int i=size-L+1;i>=1;i--){\n                postsumL[i]=max(presum[i+L-1]-presum[i-1], postsumL[i+1]);\n            }\n    ```\n\n8. 钢笔和\n    - 题意：找到两个不相交的区间，每个区间和都为target, 使得这两个区间len之和最小，其实也可以向上一题一样，分为pre post,然后枚举划分点，使用分治算法进行计算\n\n9. 可被三整除的最大和 这道题和lc1363 形成3的最大倍数是一样的思路\n    - 不要求是连续\n    - 使用余数的递归公式 dp[i][j]表示以i结尾的余数为j的最大和\n    - 那么就要根据nums[i]%3的余数分类别更新dp[i][0], dp[i][1], dp[i][2]\n    - 一个更简单的方法是 \n    ```C++\n    a=remainder[0]+nums[i]; \n    b=remainder[1]+nums[i];\n    c=remainder[2]+nums[i];//因为可以不连续\n    remainder[a%3]=max(remainder[a%3], a);//a对余数就是a%3,所以分在一组\n    remainder[b%3]=max(remainder[b%3], b);\n    remainder[c%3]=max(remainder[c%3], c);\n    ```\n\n    - PS: 类似的一个题：将字符串翻转到单调递增  \n    dp[i][0]表示前i个数以0结尾，dp[i][0]表示前i个数以1结尾\n    易错点：dp[i][1]=min(dp[i-1][0], dp[i-1][1]) //以1结尾的时候，前面以0结尾是不需要+1的\n\n\n### 博弈论相关问题\n1. 石子问题\n2. 预测家，当前只能从石子序列的头或者尾部进行取，那么使用枚举长度的动态规划+前缀和 （区dp） 注意这道题和lc1423. 可获得的最大点数 不一样因为这个是一定要拿完，而且有两个人拿，而lc1423是一个人拿，所以使用滑动窗口解决 n-k的窗口内数据最小就行\n3. 能赢吗， 因为是从1-n中随机取，而且取了之后就不能取了，所以使用带记忆的dfs, 使用位图来记录当前状态是否遍历过 dp[state]\n\n\n\n### 其他\n1. 斐波拉切数列问题\n2. 成熟的牛不断生小牛的问题\n3. 汉罗塔问题\n4. 走地图问题（最短/最长价值/龙与地下城游戏）\n5. 扔鸡蛋问题\n```C++\ndp[i][j]=1+dp[i-1][j-1]+dp[i-1][j] //dp[i][j]表示用i次操作j个鸡蛋能够验证的最高高度\n```\n6. 画匠问题\n    - 动态规划或者二分算法\n    - 动态规划：类似于鸡蛋问题，可以使用滑动数组，将二维转为一维，但是在转的时候注意i j的顺序 dp[i-1][0~j]可以转 dp[0~i][j]不太好转\n\n    - 二分解法如下\n    二分法，限制所有画作完成的时长，然后检查在这个时长限制下画家的数量够不够。够的话说明时间还可以压缩，不够的话就要放宽时长限制，多给一些时间。\n    ```C++\n    int getNumber(int limit){\n        int cnt=0;\n        int tmpsum=0;\n        for(int i=0;i<arr.size();i++){\n            tmpsum+=arr[i];\n            if(tmpsum>limit){\n                cnt++;\n                tmpsum=arr[i];\n            }\n        }\n        return cnt+1;\n    }\n    int left=INT_MIN, right=0; //表示一个画家画的时长\n    for(int i=0;i<arr.size();i++){\n        left=max(arr[i], left);\n        right+=arr[i];\n    }\n\n    if(K>=arr.size()){//如果画家数量比画多\n        return left;//返回时长最大的画\n    }\n\n    while(left<right){\n        int mid=left+(right-left)/2;\n        int tmp=getNumber(mid);\n        if(tmp==K){\n            right=mid;\n        }else if(tmp<K){\n            right=mid-1;//应该也可以和tmp==K合并为right=mid\n        }else{\n            left=mid+1;\n        }\n    }\n\n    return right;//最小的时长\n    ```\n\n<font color=red>7. 邮局选址的问题</font>\n    - 转移状态的枚举类似于画匠问题\n    - 因为两个邮局的情况，不清楚那个邮局负责哪些居民区，那么就枚举，然后求最小。\n    - 这道题前提是要知道：建立一个邮局的时候，建在中间是最优的情况！\n        1. 提前求i ~ j这段距离建立一个邮局的最小距离\n        2. dp[i][j]表示0 ~ i这段居民区，有j+1个邮局的最小距离   也可以改成j对应j个邮局，这样初始化dp[i][1],循环j从 2 ~ num\n        3. 初始化边界dp[i][0]=w[0][i];\n        4. 建立转移方程： dp[i][j]=min(dp[k][j-1]+w[k+1][i], dp[i][j]) k从0到i，（官方题解：两端值都取!!!!!），表示建邮局的位置\n        注意j<=i，当j>i dp=0; 每次进入k循环的时候，在初始化dp[i][j]=INT_MAX\n        5. 返回结果 dp[n-1][K-1];\n        ```C++\n        int w[size+1][size+1];\n        //求任意两个居民点之间建立一个邮局的最短距离\n        for(int i=0;i<size;i++){\n            for(int j=i+1;j<size;j++){\n                w[i][j]=w[i][j-1]+a[j]-a[(i+j)/2];\n            }\n        }\n        dp[i][0]=w[0][i];\n        for(int i=0;i<=size-1;i++){\n            for(int j=1;j<=num-1;j++){  \n                if(j>=i){//邮局数量>=居民区数量  如果不进行判断就需要 k<=i，否则就会因为进不去 k 的循环，导致dp[i][j]=INT_MAX\n                    dp[i][j]=0;\n                }else{\n                    dp[i][j]=INT_MAX;\n                    for(int k=0;k<i;k++){\n                        dp[i][j]=min(dp[k][j-1]+ w[k+1][i], dp[i][j]); //注意k+1可能==size，因此需要w需要size+1空间\n                    }\n                }\n            }\n        }\n        ```\n        总结，从左到右开始建立，而不是使用二进制记录状态，随机建立\n        状态转移类似最长递增子序列的思路， 需要提前计算i， j之间建立一个邮局的最短距离\n\n<font color=red>8. 数组的最大价值 (区间dp)</font>\n    - 题意，就是找任意不相交区间且每个区间首位值相等，使得这些区间加起来价值最大\n    - 转移方程：\n  `  dp[i]=max(dp[i-1], dp[j-1]+presum[i]-presum[j-1]); （a[i]==a[j]）`\n    因为需要a[j]==a[i]，如果使用二重循环会超时\n    解决方案：\n    （1）使用hash存储不同a[i]对应的下标\n    （2）记录另外一个hash 使得hash[a[i]]=max(hash[a[i]], dp[i-1]-presum[i-1]) \n    - 之后再进行更新就不用循环找与i相同的下标j,可以直接更新dp[i]=max(dp[i-1], presum[i]+hash[a[i]]); \n（注意要对hash[a[i]]是否存在进行分类讨论）\n\n<font color=red>9. 盒子放置（谷歌）/现在无权限查看</font>\n    - 使用动态规划的思想；\n    - dp[i][j] 表示当前第i个box，第j个position能放置的最多的box数量。\n    如果 box[i - 1] <= position[j - 1]，则dp[i][j] = dp[i - 1][ j - 1] + 1 贪心，放在最后一个位置最好\n    反之，dp[i][j] = max(dp[i-1][j], dp[i][j - 1]) 其中di[i-1][j]表示不放第i个box, dp[i][j - 1] 第i个box不放在j个位置\n    **重要！！！！！**\n    - 注意下标i从0 ~ n-1，但是这个因为有w，所以最好和w对应，不转为1 ~ n。\n    从i从0开始取的话，每次k循环，划分两个部分相加， 后半部分都不会包含第一个数，因此j要从2开始取，否则就会造成dp[0][0]//第一个0代表有地址，第二个0代表无邮局，就会返回INT_MAX,造成结果错误\n    背包问题，i下标是1~n 因为i可能从i-1推导，需要i>=1\n\n\n8. “马”在棋盘上的概率\n    - 类似的==地图问题==，虽然当前位置可以由它四面八方的位置推出来，但是因为步数，所以对应的三维数组还是由之前的状态推导出来，因此仍然可以使用动态规划\n    ```C++\n        for(int K=1;K<=k;K++){\n            for(int i=0;i<n;i++){\n                for(int j=0;j<n;j++){\n                    for(int q=0;q<8;q++){\n                        int nextx=i+dx[q];\n                        int nexty=j+dy[q];\n                        if(nextx>=0&&nextx<n&&nexty>=0&&nexty<n){\n                            dp[i][j][K]+=dp[nextx][nexty][K-1]/8.0; //下一个和当前反过来感觉也行\n                        }\n                    }\n                }\n            }\n        }\n        double sum=0.0;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                sum+=dp[i][j][k]; //k步走到每个棋盘的概率加起来\n            }\n        }\n    ```\n\n### 字符串与动态规划  \n也可以划分到Trie树问题:一般是对单词建立Trie树\n1. 单词拆分问题（\n    - dp代表的是True or False\n    - dp+第二层循环枚举字典里面的每一个单词，看是否恰好是当前遍历序列0~i的最后几个字符\n    为了进一步减少时间，内层训练从i枚举到0，同时为true的时候直接退出\n    ```C++\n    for(int i=1;i<size;i++){ //遍历字符串的每一个字符\n        for(int j=i;j>=0;j--){\n            string tmp=s.substr(j, i-j+1);\n            if(wordSet.find(tmp)!=wordSet.end()){\n                dp[i]=dp[i]|dp[j-1];\n            }\n            if(dp[i]){\n                break;\n            }\n        }\n    }\n    方法二：\n    以当前判断后面的字符串\n    for(int i=0;i<=s.size();i++){\n        for(int j=0;j<wordDict.size();j++){\n            if(!dp[i]){\n                continue;\n            }\n            string tmp=s.substr(i,wordDict[j].size());\n            if(tmp==wordDict[j]){\n                dp[i+wordDict[j].size()]=true;\n            \n                path[i].push_back(i+wordDict[j].size());\n            }\n        }\n    }\n    ```\n    <font color =red>单词拆分II需要求出所有可行的解</font>\n    为了避免重复的计算和对比，字符串的前缀是否包含单词表里面的单词，需要使用单词拆分1的方法将i后面对应的true的下标放在hash<int, vector>里面记录起来，这样之后再进行遍历的时候就不需要重复判断；\n    另外一个去处回溯的重复方案是， 将一个下标后面的字符串对应的可以拆分方案提前记录起来（hash<int, vector<vector<int>>），这样的话，就不用对同一下标进行多次重复求值（类似于二叉树的组成类似的）\n\n<font color=red>2. 恢复空格问题(代表的无效字符的个数)- 使用Trie树的经典案例 </font>\n    - 都可以转为Trie树+dp类型的题目 \n    - 这个不能暴力erase,因为可能出现一个单词是另外一个单词的前缀，可能导致erase顺序不同，结果不同；这个只能使用字典序；\n    - 另外一个减少暴力深搜索带来的超时问题，可以使用第二层循环每次枚举dict的每个元素，看是否与当前遍历序列的最后几个字符相同，而不是每个不同长度的单词一个一个的进行比较。\n    - 多次搜索：使用暴力的string find或者使用将small单词列表建立Trie树，然后big以每个字符为开头，查找字符串是否出现在Trie树中，在查找的路径中如果遇到isend=True说明找到了一个字符\n    然后继续找下去\n    \n\n3. 环绕字符串中唯一的子字符串\n    - 题意为：找到子串字符必须是连续的，这样的子串的个数，但是这样可以会出现重复比如abcbc，所以要使用dp (其实就是hash，记录以某个字符结尾的最长的子串)\n    - 计算出26个英文字母中每一个英文字母的结尾的最长的连续的环绕字符串，然后求和\n    - PS：注意字符串去重，如果不考虑去重的话，可以直接使用滑动窗口记录子串个数；因为这个滑动窗口是直接出现不连续，窗口长度直接退化为1，所以可以只记录窗口长度，不记录窗口左右两端\n\n4. lc97. 交错字符串\n- 求第三个字符串是否能由第一个和第二个字符串组合得到，是否问题\n- 易错点：不能使用双指针，因为针对一个两个字符串相同的情况可能造成错误\n- 使用动态规划，dp[i][j]表示字符串1的前i个字符和字符串1的前j个字符能否组成第三个字符串的i+j个字符\n\n\n\n### 状态压缩\n1. 划分为k个相同子集，也可以看做dfs+回溯+贪心\n    - 状态压缩的话就是dp[i]中i的每一个数由二进制位的状态组成，然后遍历二进制的每一个状态，当前的状态可以由当前状态中任意取消一个1的状态转移过来，或者用当前的状态更新下一个状态（将状态中为0的转为1），只有只有dp[i]=true, 而且当前状态的和%target+nums[i]<=target下一个状态才为true,否则为false\n    ```C++\n    bool canPartitionKSubsets(vector<int>& nums, int k) {\n            int size=nums.size();\n            int total_sum=0;\n            for(int i=0;i<size;i++){\n                total_sum+=nums[i];\n            }\n            if(total_sum%k!=0){\n                return false;\n            }\n            int target=total_sum/k;\n            sort(nums.begin(), nums.end());\n            int total_state=1<<size;\n            vector<bool> dp(total_state, false);\n            vector<int> sum(total_state, 0);\n            dp[0]=true;\n            for(int i=0;i<total_state;i++){\n                if(!dp[i]){\n                    continue;\n                }\n                // cout<<i<<endl;\n                for(int j=0;j<size;j++){\n                    // cout<<j<<endl;\n                    if((i&(1<<j))==0){   //注意：位运算一定要记得打上括号之后再判断是否相等，否则会出错！！！！！\n                        int next=i|(1<<j);\n                        // cout<<next<<endl;\n                        if(sum[i]%target+nums[j]<=target){\n                            sum[next]=sum[i]+nums[j];\n                            dp[next]=true;\n                            cout<<next<<endl;\n                        }else{\n                            break;\n                        }\n                    }\n                }\n            }\n            return dp[total_state-1];\n    ```\n\n2. 优美的排列\n    - 也是状态压缩 或者回溯，相比第2题需要枚举当前位置放的数是哪个，所以多一层循环。上面那道题因为数的位置是固定的，所以只需要判断这个数放没放。\n    - 其实还是顺序放，当前放了m个，那么下一个要放的数就是m+1， 所以也可以不同像下面的题解一样多一层循环（3月8日修改）\n    ```python\n    class Solution {\n    public:\n        int count(int number){\n            int res=0;\n            while(number!=0){\n                if(number&1){\n                    res++;\n                }\n                number=number>>1;\n            }\n            return res;\n        }\n        int countArrangement(int n) {\n            int state=1<<n;\n            \n            vector<int> dp(state, 0);\n            dp[0]=1;\n            for(int num=1;num<=n;num++){ //类似背包的，当前放第num数， 标准答案是将状态放在外层， 然后通过1个个数判断当前的num\n                for(int i=0;i<state;i++){\n                    // if(!dp[i]){\n                    //     continue;\n                    // }\n                    if(count(i)!=num-1){\n                        continue;\n                    }\n                    for(int j=0;j<n;j++){\n                        if((i&(1<<j))==0){\n                            if(num%(j+1)==0||(j+1)%num==0){\n                                int next=i^(1<<j);\n                                dp[next]+=dp[i];\n                            }\n                        }\n                    }\n                }\n            }\n            return dp[state-1];\n            \n        }\n    };\n    ```\n\n3. 华为的一个机试题目\n    - 需要在规定燃油内（规定长度内）得到的资源最大化（有点像0-1背包问题）， 但是这个不同之处在于：从不同点到相同的i，消耗的燃油是不一样的， 而且这个最后还需要回到原点，所以dist需要走过的位置mask 以及最后的位置i\n    - 其实就是先求每个mask的最小dist, 得到d[mask][i]:也就是以i结尾的最小燃油，然后遍历这个数组，如果d[mask][i]+fuel[i][0]<=maxdist 那么更新ans\n    ans=max(ans, g[mask])\n\n    - 为什么不直接求d[fuel][i]的最大化，这样也会重复vis统一节点\n    https://leetcode-cn.com/circle/discuss/a4pRYY/\n\n4. 访问所有节点的最短路径(hard)\n    - 题意：一笔走完所有的节点，注意可能重复访问同一个节点\n    - 主要思路：\n    先求出任意两个节点间的距离，使用floyd，同时记得出事dist[i][i]=0\n    然后使用d[mask][i]:表示最后状态为mask,并且以i结尾的最短路径\n    最后遍历d[mask][i] 求最小值\n    - 易错点，mask的循环一定要在节点i的循环的外面， 否则就会出错\n```C++\n  for(int mask=1;mask<(1<<n);mask++){\n            for(int i=0;i<n;i++){\n                if (mask & (1 << i)) { //如果i这个点已经被选过\n                    for(int k=0;k<n;k++){\n                        if((mask&(1<<k))==0){\n                            d[mask|(1<<k)][k]=min(d[mask|(1<<k)][k],d[mask][i]+dist[i][k]); //需要先使用floy求出任意两点之间的最短距离\n                        }\n                    }\n                }\n            }\n        }\n```\n\n5. 基于陈述统计最多好人数\n    - 这个是枚举状态（二进制），与dp无关，但是和状态压缩dp有点类似\n\n6. 两个数组最小的异或值之和  / <font color=red>lc2172： 数组的最大与和 </font>\n    - 这两道题都是位运算相关的状态压缩\n    第一题枚举nums2每个数应该放的位置\n    第二题需要先装为状态压缩的样子，因为每个index有两个slot,所以需要先转为2*n个slot，那么slot和index对应关系为j/2+1\n    然后枚举每个数应该放在哪个slot,同时注意这道题不是每个状态都有值，对于one_num of state i>=num数量, 直接continue\n    - 一个位可以放两个数的情况，需要展开分别讨论\n    ```C++\n    int ans = 0;\n    vector<int> f(1 << (numSlots * 2));\n    for (int i = 0; i < f.size(); ++i) {\n        int c = __builtin_popcount(i); //当前已经放了几个数，下一个放的数就是nums[c]\n        if (c >= nums.size()) continue; //直接跳过\n        for (int j = 0; j < numSlots * 2; ++j) {\n            if ((i & (1 << j)) == 0) { // 枚举空篮子 j\n                int s = i | (1 << j);\n                f[s] = max(f[s], f[i] + ((j / 2 + 1) & nums[c]));\n                ans = max(ans, f[s]); //有效的状态求结果\n            }\n        }\n    }\n    return ans;\n    ``` \n\n### 动态规划 + 拓扑排序\n1. 并行课程III\n题意：可能具有拓扑结构+每节课程都有上课时间， 任意两节不依赖课程可以同时上，求最短上完所有课程的时间\n转化：拓扑排序的最长路径\n两种解决方案：\n- 转为dfs，建立依赖关系的时候反向建立，然后将度为0的点放入队列之中（root）,dfs求深度，然后多棵树取最长深度\n- 使用拓扑排序，将度为0的点放入队列，同时每次在取出队列中的点的时候，用当前点的结果f[v]更新v后面所有后修课程的结果\nf[w]=max(f[w], f[v]+time[v])\n\n\n### 反向dp\n1. <font color=red>lc174. 地下城游戏</font>\n- 正序的含义为“从起点出发，到达位置（i，j）所需要的最少血量”；正向dp有两个因素影响，可能每条路各有一个因素好，因此不知道选择哪条；（当前需要的血量，和整条路径中至少需要的血量）\n- 倒序的含义是“从（i，j）出发，到达终点需要最少的血量”。初始血量本来就是要求的，所以只能倒序dp\n- 转移方程：\n```C++\nif(i==m-1&&j==n-1){\n    dp[i][j]=max(1-dungeon[i][j], 1);\n}else if(i==m-1){\n    dp[i][j]=max(dp[i][j+1]-dungeon[i][j], 1); //每个点的初始健康点都必须为正整数\n}else if(j==n-1){\n        dp[i][j]=max(dp[i+1][j]-dungeon[i][j], 1);                \n}else{\n        dp[i][j]=max(min(dp[i+1][j], dp[i][j+1])-dungeon[i][j], 1); \n}   \n```\n\n### 总结\nok  ok\n1. 图与动态规划，一定要注意vis的问题，bellman-ford以及floyd算法都是图的动态规划的例子\n但是注意因为bellman-ford是求距离最小，所以不会出现重复vis同一个节点的情况\n但是如果求max的情况，使用动态规划+图就可能造成一个节点vis多次，因此最好考虑记忆化dfs或者状态压缩\n\n2. 状态压缩问题，将状态放在外层比较保险；如果是list数组，那么可以将num放在外面，如果是图，那么只能将状态放在外面。 通常状态压缩使用的题目是将数据放在哪个位置，得到最大/最小、/满足什么样的条件的XXX类似题型\n<font color=red>图类型的状态压缩：求遍历这个图中所有节点的最小代价（代价指的是走过路径长度的总和， 应该是顺序走完）。状态压缩dp，注意不要理解成最小生成树</font>\n\n\n3. 动态规划的关键是处理 i 取值范围 j取值范围，转移方程以及边界情况求动态规划\n也就是找到dp[i]-> dp[j] (j< i) 的递推公式,这个递推可能由i，j之间回文，括号，或者异或和组成；特别的，如果是回文可以提前得到任何i，j之间是否为回文字符串，模板代码如下：\n```C++\n   for(int i=s_len-1;i>=0;i--){\n        for(int j=i+1;j<s_len;j++){\n            p[i][j]=(s[i]==s[j]&&p[i+1][j-1]);\n        }\n    }\n```\n\n4.区间dp问题，外围长度的字符状态，可以由内围的长度的字符推导出来 dp[i][size]\n\n5. 如果进行了状态压缩：\n0-1的最大背包问题，逆向枚举\n多重背包问题也是，只能逆向枚举\n完全背包（无限个）才是正向枚举！！！\n\n6. 有的时候动态规划不好解决，考虑使用带记忆的dfs，（比如要求所有的路径，或者所有路径中花费最小等等） 而且dp 的index可以为一个vector（类似与状态压缩）\n\n7. 最短时间类似题，除了考虑动态规划，也可以向二分算法中思考，比如画匠问题\n\n8. 动态规划可以解决true/false（是否能化为k个相同区间，单词拆分问题）, 最小最大最长问题，总数问题\n\n9. 当动态规划的状态比较多的情况下\n注意 res+=dp[i][m]%MOD(wrong answer) \nres=(res+dp[m][i])%MOD(right answer);\n\n10. 划分性dp有两种情况：以i为结尾，和0-i之间，区分这两种情况就是判断在进行dp递推的时候，如果dp[i] 依赖于多个之前的dp[j]那么应该使用以i为结尾，如果dp[i]只依赖之前的一个dp[j]那么使用0-i之内的元素\n（最长子序列和最长子串问题）\n\n11. 使用状态枚举（状态压缩）的方法，要求k<32 !!!!如果n<100那么就不能这么枚举\n\n12. 背包问题可能也会加一个额外的条件，类似于最短路径问题（Dijstra/bellman-ford/floyd）中再加一个额外条件,具体例题见“货物转移”(lintcode)模板： dp数量最小+weight最大类似题目\n```C++\n    if(d[j]+1<d[i]){ //找到更优解\n        d[i]=d[j]+1;\n        weight[i]=weight[j]; // update weight and d\n    }else if(d[i]==d[j]+1){\n        weight[i]=max/min(weight[j], weight[i]); //only update weight\n    }else{\n        continue; //do not update anything\n    }\n```\n\n13. 动态规划一定要注意状态的初始化，在i 和 j都从1开始取的时候，一定要记得赋值dp[0][1到n] 以及dp[1到n][0]\n\n14. 如果出现反复将一个字符串的子串和字典中的每个字符比对的题目，可以使用Trie树，或者使用动态规划（True/False类型），提前判断某一个子字符串是否在字典中\n\n15. 刷一刷leetcode以面试题开始的题目\n\n16. 每个物品选择或者不选择，使得总体的方案是n, 同时花费最少的这种类似题可以使用动态规划\n例题： lc1029. 两地调度\n- 第一想法是使用二进制的暴力枚举\n- 因为整体的方案一定要是n, 所以一定要初始化dp[0][j] (j>=2为一个比较大的值)； 同时dp[i][0] 为dp[i-1][0]+cost[i][1]\n```C++\n    dp[0][0]=costs[0][1];\n    dp[0][1]=costs[0][0];\n   for(int j=2;j<=n/2;j++){\n        dp[0][j]=1000000; //注意这个是非常重要的！！！！\n    }\n    for(int i=1;i<n;i++){\n        dp[i][0]=dp[i-1][0]+costs[i][1];\n        for(int j=1;j<=n/2;j++){ //j代表剩余的0类的数量\n            dp[i][j]=min(dp[i-1][j]+costs[i][1], dp[i-1][j-1]+costs[i][0]);\n        }\n    }\n```\n- 第二种方法是贪心：\n    a[i] - b[i]代表将i员工派往a地比派往b地的费钱程度，数值越高表示派往a地越不划算；\n    将所有花费按a[i] - b[i]从小到大排序，则前n个为派往a地更划算的员工，后n个为派往b地更划算的员工。\n\nlc474. 一和零 （类似于0-1背包问题）\n- 选不选择每个字符串，满足0， 1不超过m, n同时使得最后的字符串个数最多; 或者选了这个不能选择左右两边， 类似问题都使用dp\n- 这种第一种想到的思路是回溯，更进一步的方法是动态规划\n- 回溯思路如果不求具体序列，只求总数的话，可以考虑动态规划解决\n```C++\nif(j>=zero_num&&k>=one_num){\n    dp[i][j][k]=max(dp[i-1][j-zero_num][k-one_num]+1, dp[i-1][j][k]);\n}else{\n    dp[i][j][k]=dp[i-1][j][k]; //一定注意else别忘了\n}\n```\n\n\n17. 非常重要的资源：https://oi-wiki.org/dp/knapsack/ \nOI-wiki  《背包九讲》\n\n18. 连续数组进行划分，是的划分个数满足条件，使用动态规划或者二分查找\n例题：lc410. 分割数组的最大值(hard), 画匠问题\n\n19. 一定要注意数组越界可能不会报错，比如403. 青蛙过河，申请dp[size][size] size=18， 但是访问dp[18][29]范围为true\n所以这道题关键在于一定要加上判断if(k<=j+1) 才能进行dp的更新，否则就会发生访问到越界的数据\n","slug":"leetcode/动态规划题型","published":1,"updated":"2023-07-10T10:36:19.537Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clk5ceinh000cjpjb98vb9863","content":"<h3 id=\"求总数问题\"><a href=\"#求总数问题\" class=\"headerlink\" title=\"求总数问题\"></a>求总数问题</h3><ol>\n<li><p>回文字符串的个数</p>\n</li>\n<li><p>表达式为期望结果的总数</p>\n<ul>\n<li>也是区间dp, dp[i][j][0]或者dp[i][j][1])</li>\n<li>因为不是表达式的个数，而是达到期望值的个数，因此要记录一个表达式的值，用三维数组</li>\n</ul>\n</li>\n<li><p>能够组成的二叉树的个数</p>\n</li>\n<li><p>打气球的最大分数(区间dp)</p>\n<ul>\n<li>虽然不是求个数，而是求最大，但是也是与当前状态的左右边界有关。因为最终结果和左右两边有关，因此都是枚举的长度+右边界，计算左边界，进行动态规划<br>转移方程：考虑这个区间上最后一个气球的打破方式，即最后一个气球的打破位置。在左边右边和中间<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">f[i][j] = <span class=\"hljs-built_in\">max</span>( f[i][j], f[i][k - <span class=\"hljs-number\">1</span>] + f[k + <span class=\"hljs-number\">1</span>][j] + a[k] * a[i - <span class=\"hljs-number\">1</span>] * a[j + <span class=\"hljs-number\">1</span>]); <span class=\"hljs-comment\">//闭区间的更新方式</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n<p>在leetcode上面的一道原题，只是描述改变了<br>lc312. 戳气球</p>\n<ul>\n<li>这道题如果将dp[i][j]定义为开区间或得的最大值就更容易理解<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">状态转移： dp[i][j]=<span class=\"hljs-built_in\">max</span>(dp[i][j], dp[i][k]+dp[k][j]+val[i]*val[k]*val[j]);<span class=\"hljs-comment\">//开区间的更新方式</span><br></code></pre></td></tr></table></figure></li>\n<li>注意为了减少情况的分类讨论，需要在左右两边都加上1，这样的话枚举一个区间留下的最后一个数，也是可以求得值的</li>\n</ul>\n</li>\n<li><p>旋变字符串问题 (区间dp) lc87. 扰乱字符串</p>\n<ul>\n<li> 四重循环，三维dp（两个字符串两个端点+一个长度）</li>\n<li>这道题不是求个数，而是求是否，但是仍然是需要枚举长度的问题，因为是两个字符串，所以应该有4个边，但是运用长度相等的信息，将思维坐标转为左边坐标+size, 成为三维问题<br>dp[start1][start2][len] 而且这道题有两个长度：一个是总字符串长度，一个是总字符串化为为两个旋变字符串的长度<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> size = <span class=\"hljs-number\">2</span>; size &lt;= n; size++)&#123;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> l1 = <span class=\"hljs-number\">0</span>; l1 &lt;= n - size; l1++)&#123;<br>            <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> l2 = <span class=\"hljs-number\">0</span>; l2 &lt;= n - size; l2++)&#123;<br>                <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> leftPart = <span class=\"hljs-number\">1</span>; leftPart &lt; size; leftPart++)&#123;<br>                    <span class=\"hljs-keyword\">if</span>((dp[l1][l2][leftPart] &amp;&amp; dp[l1 + leftPart][l2 + leftPart][size - leftPart]) || <br>                        (dp[l1][l2 + size - leftPart][leftPart] &amp;&amp; dp[l1 + leftPart][l2][size - leftPart]))&#123;<br>                        dp[l1][l2][size] = <span class=\"hljs-literal\">true</span>;      <span class=\"hljs-comment\">// 只要有一个leftPart满足旋变串条件就可以break出去</span><br>                        <span class=\"hljs-keyword\">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>数字字符串转为字母组合的总数</p>\n<ul>\n<li>因为只是与之前的结果或者后面的结果有关，因此只需要从左到右枚举下标就可以了<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">递推式<br><span class=\"hljs-comment\">// 第 i 个字符只能单独转换为一个 字母</span><br><span class=\"hljs-comment\">// dp[i-1] ：第 i 个字符单独转换的方案数</span><br>dp[i]=dp[i<span class=\"hljs-number\">-1</span>];<br><span class=\"hljs-comment\">// 第 i 个字符 可以和 第 i-1 个字符 共同转换为一个 字母</span><br><span class=\"hljs-comment\">// dp[i-1] ：第 i 个字符单独转换的方案数</span><br><span class=\"hljs-comment\">// dp[i-2] ：第 i 个字符，结合第 i-1 个字符组合转换为一个字母的方案数</span><br>dp[i]=dp[i<span class=\"hljs-number\">-1</span>]+dp[i<span class=\"hljs-number\">-2</span>];<br><span class=\"hljs-comment\">//如果第i个字符不能单独存在那么</span><br>dp[i]=<span class=\"hljs-number\">0</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>组合总数IV， </p>\n<ul>\n<li>总结：如果排序不同算不同的排列组合的话那么 target循环在外侧， nums总数循环在内侧<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;=target;i++)&#123;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">0</span>;j&lt;size;j++)&#123;<br>            <span class=\"hljs-keyword\">if</span>(i&gt;=nums[j]&amp;&amp;dp[i - nums[j]] &lt; INT_MAX - dp[i])&#123;<br>                dp[i]+=dp[i-nums[j]];<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></li>\n<li>如果排序不同算相同的排列祝贺的话那么， target循环在内侧，nums总数循环在外侧, 完全背包问题<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;=size;i++)&#123;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">1</span>;j&lt;=target;j++)&#123;<br>        dp[i][j]+=dp[i<span class=\"hljs-number\">-1</span>][j];<br>        <span class=\"hljs-keyword\">if</span>(j&gt;=nums[i<span class=\"hljs-number\">-1</span>])&#123;<br>            dp[i][j]+=dp[i][j-nums[i<span class=\"hljs-number\">-1</span>]];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>删除回文子数组</p>\n<ul>\n<li>区间dp/枚举长度的dp</li>\n<li>数组，每次可以删除一个数字，或者删除掉一个回文串，求删除需要的最少次数<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">dp<span class=\"hljs-selector-attr\">[i]</span><span class=\"hljs-selector-attr\">[j]</span>=min(dp<span class=\"hljs-selector-attr\">[i+1]</span><span class=\"hljs-selector-attr\">[j-1]</span>, dp<span class=\"hljs-selector-attr\">[i]</span><span class=\"hljs-selector-attr\">[j]</span>) <span class=\"hljs-keyword\">if</span> <span class=\"hljs-selector-tag\">a</span><span class=\"hljs-selector-attr\">[i]</span>==<span class=\"hljs-selector-tag\">a</span><span class=\"hljs-selector-attr\">[j]</span><br>dp<span class=\"hljs-selector-attr\">[i]</span><span class=\"hljs-selector-attr\">[j]</span>=min(dp<span class=\"hljs-selector-attr\">[i]</span><span class=\"hljs-selector-attr\">[k]</span>+dp<span class=\"hljs-selector-attr\">[k+1]</span><span class=\"hljs-selector-attr\">[j]</span>, dp<span class=\"hljs-selector-attr\">[i]</span><span class=\"hljs-selector-attr\">[j]</span>)<br>dp长度从<span class=\"hljs-number\">3</span>开始，dp长度为<span class=\"hljs-number\">1</span>， <span class=\"hljs-number\">2</span>的时候使用初始化<br></code></pre></td></tr></table></figure></li>\n<li>答案见：<a href=\"https://cloud.tencent.com/developer/article/1659691\">https://cloud.tencent.com/developer/article/1659691</a> 可以作为区间dp模板，但是枚举长度和转移方程那里可以修改一下</li>\n</ul>\n</li>\n<li><p>lc115. 不同的子序列 (具体分析见字符串匹配问题)</p>\n</li>\n<li><ol start=\"446\">\n<li>等差数列划分 II - 子序列（hard）</li>\n</ol>\n</li>\n</ol>\n<ul>\n<li>题意：等差子序列个数，可不连续，每个序列至少包含3个数</li>\n<li>我的困难地方在于，这个序列长度要等于3，那么将序列==2的如何处理，如果出现重复如何处理 比如2  1 2 3</li>\n<li>官方解题方案是，计算弱等差子序列的个数（序列==2），然后再计算结果的时候遍历三个数，同时因为差为负数，所以使用hash_map数组vector&lt;unordered_map&lt;long long, int&gt;&gt; d(size)</li>\n<li>将记录以某一下标结尾的序列中包含的数个数，转为差为d的对数（个数-&gt;对数）</li>\n</ul>\n<ol start=\"11\">\n<li><ol start=\"1000\">\n<li>合并石头的最低成本(hard)</li>\n</ol>\n</li>\n</ol>\n<ul>\n<li>区间dp的经典题目，四重区间dp</li>\n<li>将i，j之间的num堆转为 区间划分前面1堆后面num-1堆，然后因为连续k堆可以转为一堆，所以单独对于dp[i][j][k]单独进行转换为dp[i][j][1]<br>dp[i][j][num]=min(dp[i][j][num], dp[i][q][1]+dp[q+1][j][num-1]); //num表示num堆， 注意没有必要枚举dp[i][q][2]+dp[q+1][j][num-2]//这种情况，因为下标划分已经达到枚举的作用</li>\n</ul>\n<h3 id=\"求最大最小问题\"><a href=\"#求最大最小问题\" class=\"headerlink\" title=\"求最大最小问题\"></a>求最大最小问题</h3><p>PS: 子串都是要求连续的，而子序列是不要求连续的</p>\n<ol>\n<li><p>扔鸡蛋 lc887<br> <a href=\"https://zhuanlan.zhihu.com/p/92288604\">https://zhuanlan.zhihu.com/p/92288604</a><br> 两种状态转移：<br> a. dp[k][n], k个鸡蛋n层楼， 需要最少扔多少次</p>\n<pre><code> dp[1][N] = N\n dp[..][0] = 0\n for i=1到n:\n  dp[k][n]=min(dp[k][n], max(dp[k][i-1]+dp[k-1][n-i])+1);//不需要在第i层再扔，因此删除i\n</code></pre>\n<p> b. dp[k][m], k个鸡蛋扔m次，可以验证的最大楼层数</p>\n<pre><code> dp[0][..] = 0\n dp[..][0] = 0\n whle(dp[K][m]&lt;N)&#123;\n     m++;\n     for (int k = 1; k &lt;= K; k++)&#123;\n         dp[k][m] = dp[k][m - 1] + dp[k - 1][m - 1] + 1;\n     &#125;\n &#125;\n</code></pre>\n <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">int</span> ans=<span class=\"hljs-number\">-1</span>;<br>vector&lt;vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&gt; <span class=\"hljs-built_in\">dp</span>(n+<span class=\"hljs-number\">1</span>,vector&lt;<span class=\"hljs-keyword\">int</span>&gt;(k+<span class=\"hljs-number\">1</span>));<br><span class=\"hljs-keyword\">if</span>(n==<span class=\"hljs-number\">1</span>&amp;k&gt;=<span class=\"hljs-number\">1</span>)&#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br>&#125;<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;=n;i++)&#123;<br>    dp[i][<span class=\"hljs-number\">1</span>]=i; <span class=\"hljs-comment\">//一个鸡蛋</span><br>&#125;<br><br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">1</span>;j&lt;=k;j++)&#123;<br>    dp[<span class=\"hljs-number\">1</span>][j]=<span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">//一次操作</span><br>&#125;<br><br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">2</span>;i&lt;=n;i++)&#123; <span class=\"hljs-comment\">//n次操作</span><br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">1</span>;j&lt;=k;j++)&#123; <span class=\"hljs-comment\">//k个鸡蛋</span><br>        dp[i][j]=dp[i<span class=\"hljs-number\">-1</span>][j]+dp[i<span class=\"hljs-number\">-1</span>][j<span class=\"hljs-number\">-1</span>]+<span class=\"hljs-number\">1</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span>(dp[i][k]&gt;=n)&#123;<br>            ans=i;<br>            <span class=\"hljs-keyword\">break</span>;<br>    &#125;<br>&#125;<br><span class=\"hljs-keyword\">return</span> ans;<br></code></pre></td></tr></table></figure></li>\n<li><p>最长递增子串</p>\n</li>\n<li><p>最长递增子序列<br> 两种方法：</p>\n<ul>\n<li>两重循环</li>\n<li>单调栈+二分查找<br>扩展 最长递增子序列的个数，时间复杂度仍然是O(n^2)，只是多了一个cnt, 每次出现最大就更新，否则进行cnt的累加</li>\n</ul>\n<p> 另外类似的题目: 1027. 最长等差数列<br> dp[i][j]表示以i结尾而且差为j的最长数列</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;size;i++)&#123;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">0</span>;j&lt;i;j++)&#123;<br>        <span class=\"hljs-keyword\">int</span> tmp=nums[i]-nums[j];<span class=\"hljs-comment\">//因为差可能是负数</span><br>        dp[i][tmp+<span class=\"hljs-number\">1000</span>]=dp[j][tmp+<span class=\"hljs-number\">1000</span>]+<span class=\"hljs-number\">1</span>;<br>        res=<span class=\"hljs-built_in\">max</span>(res, dp[i][tmp+<span class=\"hljs-number\">1000</span>]);   <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p> lc1218. 最长定差子序列： 这道题diff是定了，因此只需要一维hash就可以了</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;size;i++)&#123;<br>    hash[arr[i]]=<span class=\"hljs-built_in\">max</span>(hash[arr[i]-difference]+<span class=\"hljs-number\">1</span>, hash[arr[i]]);<br>    res=<span class=\"hljs-built_in\">max</span>(res, hash[arr[i]]);<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li><p>最长公共子串（要求连续）</p>\n<ul>\n<li>注意和子序列的区别：动态规划转移方程是 dp[i][j]=dp[i-1][j-1]+1 or dp[i][j]=0表示以i或者j结尾的子串， 最后遍历二维数组求最大值<br>求具体的最长公共子串，只需要动态规划的时候，记录最长的公共子串的下标，然后s.substr(start_pos = index-maxlen+1, len = maxlen)就可以了</li>\n</ul>\n</li>\n<li><p>最长公共子序列 （最长长度/最长具体序列/最短包含序列）</p>\n<ul>\n<li>题意改变，但是代码不变的题目–不相交的线</li>\n<li>相似的题目：</li>\n</ul>\n<ol>\n<li>编辑距离</li>\n<li>两个字符串的删除操作， 可以直接动态规划求最少的删除字符数量，也可以用最长公共子序列，然后用m+n-2*lcs</li>\n</ol>\n<ul>\n<li>如果要求具体删除的是哪些字符串，两种方法应该都是可以的</li>\n<li>动态规划转移方程是 <figure class=\"highlight inform7\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs inform7\">dp<span class=\"hljs-comment\">[i]</span><span class=\"hljs-comment\">[j]</span>=dp<span class=\"hljs-comment\">[i]</span><span class=\"hljs-comment\">[j]</span>+1 or dp<span class=\"hljs-comment\">[i]</span><span class=\"hljs-comment\">[j]</span>=max(dp<span class=\"hljs-comment\">[i]</span><span class=\"hljs-comment\">[j-1]</span>, dp<span class=\"hljs-comment\">[i-1]</span><span class=\"hljs-comment\">[j]</span>)<br></code></pre></td></tr></table></figure>\ndp[i-1][j] 表示以i或者j结尾的子串中包括的最长公共子序列（不一定是以i j结尾）， 所以最后只用直接返回dp[m][n]</li>\n<li>在求最长的公共子序列的时候，需要使用dp转换等式 i–,j– 或者j–, 或者i–来进行查找最长的公共子序列， 同时也可以求最短的删除的字符具体是哪些<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">int</span> i = m<span class=\"hljs-number\">-1</span>, j = n<span class=\"hljs-number\">-1</span>;<br><span class=\"hljs-keyword\">while</span>(i &gt;= <span class=\"hljs-number\">0</span> &amp;&amp; j &gt;= <span class=\"hljs-number\">0</span>)&#123;<br>    <span class=\"hljs-keyword\">if</span>(s1.<span class=\"hljs-built_in\">charAt</span>(i) == s2.<span class=\"hljs-built_in\">charAt</span>(j))&#123;<br>        res.<span class=\"hljs-built_in\">append</span>(s1.<span class=\"hljs-built_in\">charAt</span>(i));<br>        i--;<br>        j--;<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span>(i&gt;<span class=\"hljs-number\">0</span> &amp;&amp; j&gt;<span class=\"hljs-number\">0</span> &amp;&amp; s1.<span class=\"hljs-built_in\">charAt</span>(i) != s2.<span class=\"hljs-built_in\">charAt</span>(j))&#123;<br>        <span class=\"hljs-keyword\">if</span>(dp[i<span class=\"hljs-number\">-1</span>][j] &gt; dp[i][j<span class=\"hljs-number\">-1</span>])<br>            i--;<br>        <span class=\"hljs-keyword\">else</span><br>            j--;<br>        <span class=\"hljs-comment\">//dp[i-1][j] &lt; dp[i][j-1]时,j--;</span><br>        <span class=\"hljs-comment\">//dp[i-1][j] = dp[i][j-1]时,i--或j--,这里统一为j--;</span><br>    &#125;<br>    <br>    <span class=\"hljs-comment\">//行或列到达边界</span><br>    <span class=\"hljs-keyword\">if</span>(i==<span class=\"hljs-number\">0</span>)j--;<br>    <span class=\"hljs-keyword\">if</span>(j==<span class=\"hljs-number\">0</span>)i--;<br>&#125;<br></code></pre></td></tr></table></figure>\nPS: lc1092. 最短公共超序列</li>\n<li>求包含两个字符的最短序列， 其实就是m+n-k(k为公共序列的长度)<br>相比于公共序列， 会在i–, j– 都push_back字符; 求具体的公共序列的时候，只有相等的时候才push相等的字符<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">int</span> i=size1<span class=\"hljs-number\">-1</span>;<br><span class=\"hljs-keyword\">int</span> j=size2<span class=\"hljs-number\">-1</span>;<br>string res;<br><span class=\"hljs-keyword\">while</span>(i&gt;<span class=\"hljs-number\">0</span>&amp;&amp;j&gt;<span class=\"hljs-number\">0</span>)&#123;<br>    <span class=\"hljs-keyword\">if</span>(str1[i]==str2[j])&#123;<br>        res.<span class=\"hljs-built_in\">push_back</span>(str1[i]);<br>        i--;j--;<br>    &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>        <span class=\"hljs-keyword\">if</span>(dp[i<span class=\"hljs-number\">-1</span>][j]&gt;dp[i][j<span class=\"hljs-number\">-1</span>])&#123;<br>            res.<span class=\"hljs-built_in\">push_back</span>(str1[i]);<br>            i--;<br>        &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>            res.<span class=\"hljs-built_in\">push_back</span>(str2[j]);<br>            j--;<br>        &#125;<br>    &#125;<br>&#125;<br><span class=\"hljs-keyword\">while</span>(i&gt;<span class=\"hljs-number\">0</span>)&#123;<br>    res.<span class=\"hljs-built_in\">push_back</span>(str1[i--]);<br>&#125;<br> <span class=\"hljs-keyword\">while</span>(j&gt;<span class=\"hljs-number\">0</span>)&#123;<br>    res.<span class=\"hljs-built_in\">push_back</span>(str2[j--]);<br>&#125;<br><span class=\"hljs-built_in\">reverse</span>(res.<span class=\"hljs-built_in\">begin</span>(), res.<span class=\"hljs-built_in\">end</span>());<br></code></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>最长回文子序列</p>\n<ul>\n<li>不要求连续，枚举长度</li>\n<li>初始化长度为1和2的情况，然后<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> len=<span class=\"hljs-number\">3</span>;len&lt;=s_len;len++)&#123;<br>       <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> left=<span class=\"hljs-number\">0</span>;left&lt;s_len;left++)&#123;<br>           <span class=\"hljs-keyword\">int</span> right=left+len<span class=\"hljs-number\">-1</span>;<br>           <span class=\"hljs-keyword\">if</span>(right&lt;s_len)&#123;<br>               dp[left][right]=<span class=\"hljs-built_in\">max</span>(dp[left+<span class=\"hljs-number\">1</span>][right], dp[left][right<span class=\"hljs-number\">-1</span>]);<br>               <span class=\"hljs-keyword\">if</span>(s[left]==s[right])&#123;<br>                   dp[left][right]=<span class=\"hljs-built_in\">max</span>(dp[left][right],dp[left+<span class=\"hljs-number\">1</span>][right<span class=\"hljs-number\">-1</span>]+<span class=\"hljs-number\">2</span>);<br>               &#125; <br>           &#125;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>最长回文子串的问题 （判断true/false的dp系列）</p>\n<ul>\n<li>可以用动态规划也可以用从中间向两边扩展的方法<br>动态规划dp[left][right]不是表示长度，而是表示是否为回文子串，在求长度使用一个公共变量max_len,每求出dp 如果dp为1那么更新max_len</li>\n</ul>\n</li>\n<li><p>最长有效括号子串</p>\n<ul>\n<li>方法一：动态规划</li>\n<li>转移方程 dp[i]:以i结尾的最长有效括号子串 转移方程如下<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;s_len;i++)&#123;<br>    <span class=\"hljs-keyword\">if</span>(s[i]==<span class=\"hljs-string\">&#x27;)&#x27;</span>)&#123;<br>        <span class=\"hljs-keyword\">int</span> j=i-dp[i<span class=\"hljs-number\">-1</span>]<span class=\"hljs-number\">-1</span>;<br>        <span class=\"hljs-keyword\">if</span>(j&gt;=<span class=\"hljs-number\">0</span>&amp;&amp;s[j]==<span class=\"hljs-string\">&#x27;(&#x27;</span>)&#123;<br>            dp[i]=dp[i<span class=\"hljs-number\">-1</span>]+<span class=\"hljs-number\">2</span>;<br>            <span class=\"hljs-keyword\">if</span>(j<span class=\"hljs-number\">-1</span>&gt;=<span class=\"hljs-number\">0</span>)&#123;<br>                dp[i]+=dp[j<span class=\"hljs-number\">-1</span>];<br>            &#125;<br>        &#125;<br>        result=<span class=\"hljs-built_in\">max</span>(result, dp[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li>方法二：下标栈，栈低维护的是最后一个没有被匹配的右括号下标，如果s[i]==’(‘入栈下标; 如果s[i]==’)’, 栈中弹出一个元素，如果栈为空，直接push(i) continue，否则更新ans=max(ans, i-s.peek())</li>\n</ul>\n</li>\n<li><p>分割回文串系列题目</p>\n<ol>\n<li>分割回文串1</li>\n</ol>\n<ul>\n<li>动态规划+回溯dfs，求所有i， j之间的子字符串p[i][j]是否是回文（类似最长回文子串的题目）</li>\n</ul>\n<ol start=\"2\">\n<li>分割回文串2</li>\n</ol>\n<ul>\n<li>求最少分割次数<ul>\n<li>这道题不能使用枚举长度和左边界+枚举分割点的方式，时间复杂度太高（O(N^3)）</li>\n<li>正确的解决方案是，求dp[i] 从0到i需要分割的最少次数，同时事先需要使用动态规划求出任意i j之间是否是回文串；如果0-i是回文串，直接结果为0，否则依次遍历i之后的字符串，找到回文串j+1-i，同时更新dp[i]=min(dp[i], dp[j]+1)</li>\n<li>这道题可以和“子数组异或值为0的最多划分”进行类比（动态规划+map映射上一个位置）；不同之处这道题通过回文串映射到上一个位置，异或和是通过异或值为和当前值相同隐射到上一个位置<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;s_len;i++)&#123;<br>    dp[i]=INT_MAX;<br>&#125;<br>dp[<span class=\"hljs-number\">0</span>]=<span class=\"hljs-number\">1</span>;<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;s_len;i++)&#123;<br>    <span class=\"hljs-keyword\">if</span>(p[<span class=\"hljs-number\">0</span>][i])&#123;<br>        dp[i]=<span class=\"hljs-number\">0</span>;<br>    &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">0</span>;j&lt;i;j++)&#123; <span class=\"hljs-comment\">//类似最长递增序列 需要预处理，i, j之间是否为回文， 预处理代码i为逆序，j为顺序</span><br>            <span class=\"hljs-keyword\">if</span>(p[j+<span class=\"hljs-number\">1</span>][i])&#123;<br>                dp[i]=<span class=\"hljs-built_in\">min</span>(dp[i], dp[j]+<span class=\"hljs-number\">1</span>);<span class=\"hljs-comment\">//每一个被分割的子字符串都必须要为回文</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>&#125;<br><span class=\"hljs-keyword\">return</span> dp[s_len<span class=\"hljs-number\">-1</span>];<br></code></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<ol start=\"10\">\n<li><p>背包问题</p>\n<ul>\n<li><p>比较难的例题：货物转移（lintcode-困难） 反向dp（求背包数最少）+滚动数组+额外条件</p>\n<ul>\n<li>相当于转为两个题：</li>\n</ul>\n<ol>\n<li>从n个背包里面选择最少的背包使得背包容量大于等于sum（与选最大价值使得，重量小于sum相反）</li>\n<li>假设1求出来的结果为m, 从n个背包里面选择m个背包使得转移最少–&gt;选出的n个背包里面包含货物最多（weight最大）<br>相当于在状态转移方程再加上了一个weight数组的更新，具体代码如下：<br>dp[i]表示使得容量达到i（大于等于i），选择的最少的背包；<br>weight[i]表示使得背包容量达到i（大于等于i），在选择的背包最少的前提下，背包里原本包含的货物最多。<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;n;i++)&#123;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j=sum;j&gt;=<span class=\"hljs-number\">1</span>;j--)&#123; <span class=\"hljs-comment\">//0-1背包问题</span><br>            <span class=\"hljs-keyword\">int</span> tmp=<span class=\"hljs-built_in\">max</span>(j-b[i], <span class=\"hljs-number\">0</span>);<br>            <span class=\"hljs-comment\">// dp[j]=min(dp[tmp]+1, dp[j]); 实际上的状态转移</span><br>            <span class=\"hljs-keyword\">if</span>(dp[j]&lt;dp[tmp]+<span class=\"hljs-number\">1</span>)&#123;  <span class=\"hljs-comment\">//拆分后的状态转移</span><br>                <span class=\"hljs-comment\">// weight[j]=weight[tmp];</span><br>                <span class=\"hljs-keyword\">continue</span>;<br>            &#125;<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(dp[j]==dp[tmp]+<span class=\"hljs-number\">1</span>)&#123;<br>                weight[j]=<span class=\"hljs-built_in\">max</span>(weight[j], weight[tmp]+a[i]); <span class=\"hljs-comment\">//背包数量一样，选择权重加起来更大的背包</span><br>            &#125;<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(dp[j]&gt;dp[tmp]+<span class=\"hljs-number\">1</span>)&#123;<br>                dp[j]=dp[tmp]+<span class=\"hljs-number\">1</span>;<br>                weight[j]=weight[tmp]+a[i];<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></li>\n</ol>\n</li>\n<li><p>扩展的有关于 分组背包的问题（），每个组k的数量还不一样<br>分组背包：每组物品有若干个，同一组内的物品最多只能选一个。（每组中物品不同，个数和体积都可能不一样）<br>多重背包: 有N种物品和一个容量为V 的背包。第i种物品最多有Mi件可用，每件耗费的空间是Ci ，价值是Wi (每组物品相同，且个数相等)</p>\n<figure class=\"highlight c++\"><figcaption><span>分组背包伪代码 和多重背包有点类似也是三重循环</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-comment\">//注意这里是三层循环</span><br>    <span class=\"hljs-keyword\">for</span> 所有的组k<br>        <span class=\"hljs-keyword\">for</span> v=V to <span class=\"hljs-number\">0</span><br>            <span class=\"hljs-keyword\">for</span> 所有属于组k的i <br>            f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;<br>            end<br>        end<br>    end<br></code></pre></td></tr></table></figure>\n<p>例题：lc2218. 从栈中取出 K 个硬币的最大面值和（hard）</p>\n</li>\n<li><p>使用前缀和+动态规划</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"> <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;=n;i++)&#123; <span class=\"hljs-comment\">//注意1-n, 之后piles在进行下标访问的时候需要i-1</span><br>    <span class=\"hljs-keyword\">int</span> size=piles[i<span class=\"hljs-number\">-1</span>].<span class=\"hljs-built_in\">size</span>();<br>    <span class=\"hljs-function\">vector&lt;<span class=\"hljs-keyword\">int</span>&gt; <span class=\"hljs-title\">presum</span><span class=\"hljs-params\">(piles[i<span class=\"hljs-number\">-1</span>].size(), <span class=\"hljs-number\">0</span>)</span></span>;<br>    presum[<span class=\"hljs-number\">0</span>]=piles[i<span class=\"hljs-number\">-1</span>][<span class=\"hljs-number\">0</span>];<br>    <br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> k=<span class=\"hljs-number\">1</span>;k&lt;size;k++)&#123;<br>        presum[k]=presum[k<span class=\"hljs-number\">-1</span>]+piles[i<span class=\"hljs-number\">-1</span>][k]; <span class=\"hljs-comment\">//用前缀和表示选择前面z个</span><br>    &#125;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">1</span>;j&lt;=k;j++)&#123;<br>        dp[i][j]=dp[i<span class=\"hljs-number\">-1</span>][j];<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> z=<span class=\"hljs-number\">1</span>;z&lt;=size;z++)&#123; <span class=\"hljs-comment\">//每组的size可能都不相同</span><br>            <span class=\"hljs-keyword\">if</span>(j&gt;=z)&#123;<br>                dp[i][j]=<span class=\"hljs-built_in\">max</span>(dp[i<span class=\"hljs-number\">-1</span>][j-z]+presum[z<span class=\"hljs-number\">-1</span>], dp[i][j]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class=\"hljs-keyword\">return</span> dp[n][k];<br></code></pre></td></tr></table></figure></li>\n<li><p>背包问题求具体的转移方案：我们可以用g_{i,v}表示第 i件物品占用空间为 v的时候是否选择了此物品。</p>\n<figure class=\"highlight c++\"><figcaption><span>(感觉应该是0-1背包的)</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">int</span> v = V;  <span class=\"hljs-comment\">// 记录当前的存储空间</span><br><span class=\"hljs-comment\">// 因为最后一件物品存储的是最终状态，所以从最后一件物品进行循环</span><br><span class=\"hljs-keyword\">for</span> (从最后一件循环至第一件) &#123;<br><span class=\"hljs-keyword\">if</span> (g[i][v]) &#123;<br>    选了第 i 项物品;<br>    v -= 第 i 项物品的价值;<br>&#125; <span class=\"hljs-keyword\">else</span><br>    未选第 i 项物品;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>换钱问题<br>零钱兑换II：一定要注意虽然每个硬币都有无数个，但是不能出现重复，也就是 121  112这种情况，所以硬币的循环一定要放在最外层</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"> <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;coins.<span class=\"hljs-built_in\">size</span>();i++)&#123;<span class=\"hljs-comment\">//硬币放在最内层会发生错误</span><br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">0</span>;j&lt;=amount;j++)&#123;<br>        <span class=\"hljs-keyword\">if</span>(j&gt;=coins[i])&#123;<br>                dp[j]=dp[j]+dp[j-coins[i]];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li><p>通配符匹配问题（hard） 类似最短单词距离的动态转移</p>\n<ul>\n<li>一定要注意动态规划的状态转移方程式是i j 从 i-k j-k转移过来，不能出现i+k j+k(如果出现，一定是枚举的长度，例如回文串和打气球问题)</li>\n<li>易错点：<br>字符串的匹配问题，通常会在字符前面加上” “ dp[0][0]=1<br>同时如果i j从1开始取的话，需要初始化赋值dp[0][i] 和dp[i][0]<font color=\"blue\">\ncorner case:\ns = \"\"\np = \"******\" </font>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">dp[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">0</span>]=<span class=\"hljs-number\">1</span><br><span class=\"hljs-comment\">//下面这个循环是非常重要的</span><br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">2</span>;i&lt;p_len;i++)&#123;<br>    <span class=\"hljs-keyword\">if</span>(p[i]==<span class=\"hljs-string\">&#x27;*&#x27;</span>)&#123;<br>        dp[<span class=\"hljs-number\">0</span>][i]=dp[<span class=\"hljs-number\">0</span>][i<span class=\"hljs-number\">-1</span>]; <span class=\"hljs-comment\">// or dp[0][i]=dp[0][i-1];</span><br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;s_len;i++)&#123;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">1</span>;j&lt;p_len;j++)&#123;<br>        <span class=\"hljs-keyword\">if</span>(p[j]==<span class=\"hljs-string\">&#x27;*&#x27;</span>)&#123;<br>            dp[i][j]=dp[i<span class=\"hljs-number\">-1</span>][j]||dp[i][j<span class=\"hljs-number\">-1</span>];<br>        &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>            <span class=\"hljs-keyword\">if</span>(s[i]==p[j]||p[j]==<span class=\"hljs-string\">&#x27;?&#x27;</span>)&#123;<br>                dp[i][j]=dp[i<span class=\"hljs-number\">-1</span>][j<span class=\"hljs-number\">-1</span>]; <br>            &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>                dp[i][j]=<span class=\"hljs-number\">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li>如果不好赋值dp[i][0] or dp[0][i] 可以让i j 从0开始取，但是在状态转移的时候注意进行j 或者i的判断 if j&gt;=1  dp[j-1]<ol>\n<li>问题1：*可以匹配任意字符 </li>\n<li>问题2：*只能匹配前面字符的0个1个或多个(正则表达式匹配) 需要判断s[i] p[j-1]是否相等</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>打家劫舍</p>\n<ul>\n<li>求能够得到金额的最大值。</li>\n<li>环形可以转为dp[0][size-2]和dp[1][size-1]两者之中求最大值</li>\n<li>类似的一道题：删除并获得点数（题意：选了nums[i]， 就不能选择nums[i-1] 和nums[i+1]， 打家劫舍这里的i, i+1是下标的， 这道题是实际数字上的。两个问题都是使用dp </li>\n</ul>\n</li>\n<li><p>整数拆分 </p>\n<ul>\n<li>可以使用动态规划 二层循环 dp[i]= max(j*(i-j), j* dp[i-j])， 因为存在i-j &gt; dp[i-j]的情况</li>\n<li>或者使用数据规划，将余数为2（2<em>） 1（4</em>） 0(3*)情况区别对待</li>\n</ul>\n</li>\n<li><p>最大整除子集 </p>\n<ul>\n<li>和最长递增序列有相似之处）</li>\n<li>注意：在进行倒推序列的时候，需要记录当前的maxval 以及target_dpval, 这两者都需要在压入每个元素的时候更新</li>\n<li>相邻两个数的商不一定相等</li>\n</ul>\n</li>\n<li><p> 摆动序列 （序列最长问题）</p>\n</li>\n<li><p>无重叠区间 </p>\n<ul>\n<li>可以使用动态规划，找到以每个区间结尾的最长子序列（O(N^2)） 或者贪心，对区间右边进行排序然后选择 O(nlogn)</li>\n</ul>\n</li>\n<li><p>最后一块石头的重量 II</p>\n<ul>\n<li><p>需要理解题意之后转为背包问题，也就是最大最小问题</p>\n</li>\n<li><p>求两个子集相差的最小值 -&gt; 转为背包问题，背包容量是sum/2，求能够放入背包的最大数</p>\n<figure class=\"highlight inform7\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs inform7\">dp<span class=\"hljs-comment\">[i]</span><span class=\"hljs-comment\">[j]</span>=max(dp<span class=\"hljs-comment\">[i-1]</span><span class=\"hljs-comment\">[j]</span>, dp<span class=\"hljs-comment\">[i-1]</span><span class=\"hljs-comment\">[j-stone<span class=\"hljs-comment\">[i]</span>]</span>+stone<span class=\"hljs-comment\">[i]</span>)<br></code></pre></td></tr></table></figure></li>\n<li><p>0-1的最大背包问题，逆向枚举</p>\n</li>\n<li><p>多重背包问题也是，只能逆向枚举</p>\n</li>\n<li><p>完全背包（无限个）才是正向枚举！！！</p>\n</li>\n</ul>\n</li>\n<li><p>乘积为正数的最长子数组长度 (最长子数组系列题目)</p>\n<ul>\n<li>注意这道题是求最长的长度，不是最大的乘积，但是这两个问题都可以使用动态规划完成</li>\n</ul>\n<ol>\n<li>最长的长度，positive[i]表示以i结尾的为正数的子数组，negtive[i] i结尾的为负数的子数组，<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">if</span> (nums[<span class=\"hljs-number\">0</span>] &gt; <span class=\"hljs-number\">0</span>) &#123;<br>    positive[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">1</span>;<br>&#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (nums[<span class=\"hljs-number\">0</span>] &lt; <span class=\"hljs-number\">0</span>) &#123;<br>    negative[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">1</span>;<br>&#125;<br><span class=\"hljs-keyword\">int</span> maxLength = positive[<span class=\"hljs-number\">0</span>];<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt; length; i++) &#123;<br>    <span class=\"hljs-keyword\">if</span> (nums[i] &gt; <span class=\"hljs-number\">0</span>) &#123;<br>        positive[i] = positive[i - <span class=\"hljs-number\">1</span>] + <span class=\"hljs-number\">1</span>;<br>        negative[i] = negative[i - <span class=\"hljs-number\">1</span>] &gt; <span class=\"hljs-number\">0</span> ? negative[i - <span class=\"hljs-number\">1</span>] + <span class=\"hljs-number\">1</span> : <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">//注意一定要和0判断</span><br>    &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (nums[i] &lt; <span class=\"hljs-number\">0</span>) &#123;<br>        positive[i] = negative[i - <span class=\"hljs-number\">1</span>] &gt; <span class=\"hljs-number\">0</span> ? negative[i - <span class=\"hljs-number\">1</span>] + <span class=\"hljs-number\">1</span> : <span class=\"hljs-number\">0</span>;<br>        negative[i] = positive[i - <span class=\"hljs-number\">1</span>] + <span class=\"hljs-number\">1</span>;<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>        positive[i] = <span class=\"hljs-number\">0</span>;<br>        negative[i] = <span class=\"hljs-number\">0</span>;<br>    &#125;<br>    maxLength = Math.<span class=\"hljs-built_in\">max</span>(maxLength, positive[i]);<br>&#125;<br></code></pre></td></tr></table></figure></li>\n</ol>\n<ul>\n<li>我的思路：转为前缀和+hash<br>  题意转为：负数为1，正数为0， 0单独处理，相加和为偶数的最长子数组<br>  如果&lt;0, 那么sum+=1；<br>  如果&gt;0, 那么sum不变；<br>  如果=0, 那么sum=0，  hash.clear(), hash[0]=i；<br>  如果sum为偶数：<br>  res=max(res, i-hash[0])<br>  如果sum为奇数：<br>  如果hash[1]存在<br>  res=max(res, i-hash[1])<br>  否则hash[1]=i;</li>\n</ul>\n<ol start=\"2\">\n<li>最大乘积（可能为负数），dp1[i]表示以i结尾乘积最大子数组，dp2[i]的乘积最小(注意不一定为负数)的子数组<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;=size;i++)&#123;<br>    <span class=\"hljs-keyword\">if</span>(nums[i<span class=\"hljs-number\">-1</span>]&gt;<span class=\"hljs-number\">0</span>)&#123;<br>        dp1[i]=<span class=\"hljs-built_in\">max</span>(dp1[i<span class=\"hljs-number\">-1</span>]*nums[i<span class=\"hljs-number\">-1</span>], nums[i<span class=\"hljs-number\">-1</span>]);<br>        dp2[i]=<span class=\"hljs-built_in\">min</span>(dp2[i<span class=\"hljs-number\">-1</span>]*nums[i<span class=\"hljs-number\">-1</span>], nums[i<span class=\"hljs-number\">-1</span>]);<br>    &#125;<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(nums[i<span class=\"hljs-number\">-1</span>]&lt;<span class=\"hljs-number\">0</span>)&#123;<br>        dp1[i]=<span class=\"hljs-built_in\">max</span>(dp2[i<span class=\"hljs-number\">-1</span>]*nums[i<span class=\"hljs-number\">-1</span>], nums[i<span class=\"hljs-number\">-1</span>]);<br>        dp2[i]=<span class=\"hljs-built_in\">min</span>(dp1[i<span class=\"hljs-number\">-1</span>]*nums[i<span class=\"hljs-number\">-1</span>], nums[i<span class=\"hljs-number\">-1</span>]);<br>    &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>        dp1[i]=<span class=\"hljs-number\">0</span>;<br>        dp2[i]=<span class=\"hljs-number\">0</span>;<br>    &#125;<br>    res=<span class=\"hljs-built_in\">max</span>(res, dp1[i]);<br></code></pre></td></tr></table></figure></li>\n</ol>\n</li>\n</ol>\n<ol start=\"20\">\n<li><p>最低票价</p>\n<ul>\n<li><p>找到能够让days天都观光的最低票价，类似完全背包问题， 最少兑换钞票</p>\n</li>\n<li><p>dp[i]定义为至少让index==i天观光所需要的最低票价， 分别遍历决策1，决策2， 决策3需要的最低票价</p>\n</li>\n<li><p>solution 1：每天进行dp + 从后往前</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">int</span> len = days.length, maxDay = days[len - <span class=\"hljs-number\">1</span>], minDay = days[<span class=\"hljs-number\">0</span>];<br><span class=\"hljs-keyword\">int</span>[] dp = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[maxDay + <span class=\"hljs-number\">31</span>]; <span class=\"hljs-comment\">// 多扩几天，省得判断 365 的限制</span><br><span class=\"hljs-comment\">// 只需看 maxDay -&gt; minDay，此区间外都不需要出门，不会增加费用</span><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> d = maxDay, i = len - <span class=\"hljs-number\">1</span>; d &gt;= minDay; d--) &#123;<br>    <span class=\"hljs-comment\">// i 表示 days 的索引</span><br>    <span class=\"hljs-comment\">// 也可提前将所有 days 放入 Set，再通过 set.contains() 判断</span><br>    <span class=\"hljs-keyword\">if</span> (d == days[i]) &#123;<br>        dp[d] = Math.<span class=\"hljs-built_in\">min</span>(dp[d + <span class=\"hljs-number\">1</span>] + costs[<span class=\"hljs-number\">0</span>], dp[d + <span class=\"hljs-number\">7</span>] + costs[<span class=\"hljs-number\">1</span>]); <span class=\"hljs-comment\">//三种情况</span><br>        dp[d] = Math.<span class=\"hljs-built_in\">min</span>(dp[d], dp[d + <span class=\"hljs-number\">30</span>] + costs[<span class=\"hljs-number\">2</span>]);<br>        i--; <span class=\"hljs-comment\">// 别忘了递减一天</span><br>    &#125; <span class=\"hljs-keyword\">else</span> dp[d] = dp[d + <span class=\"hljs-number\">1</span>]; <span class=\"hljs-comment\">// 不需要出门</span><br>&#125;<br><span class=\"hljs-keyword\">return</span> dp[minDay]; <span class=\"hljs-comment\">// 从后向前遍历，返回最前的 minDay</span><br></code></pre></td></tr></table></figure></li>\n<li><p>solution 2：只从days包含的天数进行dp + 从前往后</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">int</span> valid[<span class=\"hljs-number\">3</span>]=&#123;<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">30</span>&#125;;<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;size;i++)&#123;<br>    dp[i]=INT_MAX;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">0</span>;j&lt;n;j++)&#123;<br>        <span class=\"hljs-keyword\">if</span>(days[i]-valid[j]&lt;days[<span class=\"hljs-number\">0</span>])&#123;<br>            dp[i]=<span class=\"hljs-built_in\">min</span>(dp[i], costs[j]); <br>        &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>            <span class=\"hljs-keyword\">int</span> index=<span class=\"hljs-built_in\">upper_bound</span>(days.<span class=\"hljs-built_in\">begin</span>(), days.<span class=\"hljs-built_in\">end</span>(), days[i]-valid[j])-days.<span class=\"hljs-built_in\">begin</span>();<br>            <span class=\"hljs-comment\">//找到对应的前面天数对应的下标</span><br>            <span class=\"hljs-comment\">// cout&lt;&lt;index&lt;&lt;endl;</span><br>            dp[i]=<span class=\"hljs-built_in\">min</span>(dp[index<span class=\"hljs-number\">-1</span>]+costs[j], dp[i]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"数学相关问题（找规律）\"><a href=\"#数学相关问题（找规律）\" class=\"headerlink\" title=\"数学相关问题（找规律）\"></a>数学相关问题（找规律）</h3><ol>\n<li><p>计算各个位数不同的数字个数 </p>\n<ul>\n<li>其实就是9* 9 * 8* 7这种情况）但是要注意是n位数以内的n位数都需要计算，开始各位数有10种情况，后面在当前数插入数据的时候，最开头有9种情况，后面数据有（10-1）种情况，因为后面的数据是可以为0的（固定前面，枚举后面）</li>\n</ul>\n</li>\n<li><p>消除游戏 和约瑟夫环问题</p>\n<ul>\n<li><p>解决方案一：使用之后的下标和之前下标的映射 来解决（删除后，末尾从1开始编号）<br>2 ~ 2k映射为k ~ 1那么还原的规律f(2k)=2*(k+1-f(k))</p>\n</li>\n<li><p>解决方案二：每次记录剩下链表的头结点，如果当前剩下的个数==1那么直接返回这个数</p>\n</li>\n<li><p>约瑟夫环递推问题的公式<br>𝑓(𝑛)=(𝑓(𝑛−1)+𝑚)%𝑛  （一共n个人，数到m的人被杀）<br>def lastRemaining(n, m):<br>if n == 1: return 0<br>return (lastRemaining(n-1, m) + m) % n</p>\n</li>\n</ul>\n</li>\n<li><p>第 N 位数字（一位）</p>\n<ul>\n<li><p>题意： 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,顺序排列后的第n位数字</p>\n</li>\n<li><p>找到不同位数包含的数字number= base*10-base,如果n&gt;这个数那么更新n-=number * weishu,否则就在这个位数里面查找</p>\n</li>\n<li><p>如果当前的数%位数==0，那么当前的数字是cur_num=base+n/weishu-1, 否则当前的数字为cur_num=base+n/weishu，然后计算在当前数字里面对应具体哪个数字， 为(cur_num/pow(10, weishu-n%weishu))%10</p>\n</li>\n<li><p>扩展：还有一个排序后的第n个数 （一个数）二叉树，求两个节点直接夹的数组，类似于上面这道题base* 10的操作，如果小于，那么就往二叉树的下一层节点走（a=a<em>10, b=b</em>10, 知道a大于n, 退出向下搜索的循环）</p>\n</li>\n</ul>\n</li>\n<li><p>灯泡开关/灯泡开关II</p>\n<ul>\n<li>主要是找到规律前6个灯泡可以推导出其他灯泡的状态，更进一步是，前三个灯可以推导后面所有的状态，因此有状态16种</li>\n<li>只需要枚举每个灯泡的每种状态(为0或者为1)就可以了因此是16种情况，用4位表示； 1的数量num num&lt; m， 而且num%2 == m%2</li>\n<li>同时要注意可能灯泡小于6， 因此需要shift=max(6-n, 0)</li>\n<li>然后再将每个状态异或起来就可以了<br>（找规律，但不是动态规划问题）</li>\n</ul>\n</li>\n</ol>\n<ol start=\"5\">\n<li><p>到达终点数字</p>\n<ul>\n<li>左右走，步数为1， 2， 3，…。也是属于找规律，但是不是动态规划的问题 </li>\n<li>找到连加中大于target的最小sum(cur=k),然后求delta=sum-target,如果为奇数那么k++, 直到为delta偶数 (那么就可以减去delta/2)，然后返回当前k值</li>\n</ul>\n</li>\n<li><p>子矩阵问题(lintcode)</p>\n<ol>\n<li><p>第一种题型，要求矩阵内部的元素全部为1，那么以i， j为右下角的最长矩阵边长为</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">if</span>(matrix[i][j]==<span class=\"hljs-number\">1</span>)&#123;<br>    dp[i][j]=<span class=\"hljs-built_in\">min</span>(dp[i][j<span class=\"hljs-number\">-1</span>], dp[i<span class=\"hljs-number\">-1</span>][j], dp[i<span class=\"hljs-number\">-1</span>][j<span class=\"hljs-number\">-1</span>])+<span class=\"hljs-number\">1</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>那么以 i， j为右下角的子矩阵的个数为dp[i][j]个</p>\n</li>\n<li><p>要求矩形框最长, 那么每个点需要为何它上面最长 up，和左边最长 left， 两个数组</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">int</span> tmp = <span class=\"hljs-built_in\">min</span>(left[i][j<span class=\"hljs-number\">-1</span>], up[i<span class=\"hljs-number\">-1</span>][j])+<span class=\"hljs-number\">1</span>;<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> len=tmp<span class=\"hljs-number\">-1</span>;len&gt;=<span class=\"hljs-number\">1</span>;len--)&#123; <span class=\"hljs-comment\">//枚举长度，使得4个边长都是在len之内，说明能围成一个框</span><br>    <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">min</span>(up[i][j-len], left[i-len][j])&gt;=len)&#123;<br>        <span class=\"hljs-keyword\">return</span> len+<span class=\"hljs-number\">1</span>;<span class=\"hljs-comment\">//返回枚举得到的最长边框</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n</ol>\n</li>\n</ol>\n<p><font color=\"red\">7. 捡苹果(lintcode) </font><br>    - 前后缀问题(找两个区间，一个区间连续k个数，一个区间连续l个数，两个区间不相交且和最大)<br>    - solution: 枚举中间的划分点i,使得<br>    <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">res=<span class=\"hljs-built_in\">max</span>(res, presumK[i]+postsumL[i+<span class=\"hljs-number\">1</span>])<br>res=<span class=\"hljs-built_in\">max</span>(res, presumL[i]+postsumK[i+<span class=\"hljs-number\">1</span>])<br></code></pre></td></tr></table></figure><br>    - 思路没问题：主要是没有找打0<del>i之前连续窗口最大值与i</del>len-1 连续窗口的最大值怎么求<br>    - 计算前缀和后缀数组，注意如果index转为1~size，那么后缀数组需要开size+2 !!!!<br>    <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=K;i&lt;=size;i++)&#123;<br>    presumK[i]=<span class=\"hljs-built_in\">max</span>(presum[i]-presum[i-K], presumK[i<span class=\"hljs-number\">-1</span>]);<br>&#125;<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=L;i&lt;=size;i++)&#123;<br>    presumL[i]=<span class=\"hljs-built_in\">max</span>(presum[i]-presum[i-L], presumL[i<span class=\"hljs-number\">-1</span>]);<br>&#125;<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=size-K+<span class=\"hljs-number\">1</span>;i&gt;=<span class=\"hljs-number\">1</span>;i--)&#123;<br>    postsumK[i]=<span class=\"hljs-built_in\">max</span>(presum[i+K<span class=\"hljs-number\">-1</span>]-presum[i<span class=\"hljs-number\">-1</span>], postsumK[i+<span class=\"hljs-number\">1</span>]);<br>&#125;<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=size-L+<span class=\"hljs-number\">1</span>;i&gt;=<span class=\"hljs-number\">1</span>;i--)&#123;<br>    postsumL[i]=<span class=\"hljs-built_in\">max</span>(presum[i+L<span class=\"hljs-number\">-1</span>]-presum[i<span class=\"hljs-number\">-1</span>], postsumL[i+<span class=\"hljs-number\">1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure></p>\n<ol start=\"8\">\n<li><p>钢笔和</p>\n<ul>\n<li>题意：找到两个不相交的区间，每个区间和都为target, 使得这两个区间len之和最小，其实也可以向上一题一样，分为pre post,然后枚举划分点，使用分治算法进行计算</li>\n</ul>\n</li>\n<li><p>可被三整除的最大和 这道题和lc1363 形成3的最大倍数是一样的思路</p>\n<ul>\n<li><p>不要求是连续</p>\n</li>\n<li><p>使用余数的递归公式 dp[i][j]表示以i结尾的余数为j的最大和</p>\n</li>\n<li><p>那么就要根据nums[i]%3的余数分类别更新dp[i][0], dp[i][1], dp[i][2]</p>\n</li>\n<li><p>一个更简单的方法是 </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">a=remainder[<span class=\"hljs-number\">0</span>]+nums[i]; <br>b=remainder[<span class=\"hljs-number\">1</span>]+nums[i];<br>c=remainder[<span class=\"hljs-number\">2</span>]+nums[i];<span class=\"hljs-comment\">//因为可以不连续</span><br>remainder[a%<span class=\"hljs-number\">3</span>]=<span class=\"hljs-built_in\">max</span>(remainder[a%<span class=\"hljs-number\">3</span>], a);<span class=\"hljs-comment\">//a对余数就是a%3,所以分在一组</span><br>remainder[b%<span class=\"hljs-number\">3</span>]=<span class=\"hljs-built_in\">max</span>(remainder[b%<span class=\"hljs-number\">3</span>], b);<br>remainder[c%<span class=\"hljs-number\">3</span>]=<span class=\"hljs-built_in\">max</span>(remainder[c%<span class=\"hljs-number\">3</span>], c);<br></code></pre></td></tr></table></figure></li>\n<li><p>PS: 类似的一个题：将字符串翻转到单调递增<br>dp[i][0]表示前i个数以0结尾，dp[i][0]表示前i个数以1结尾<br>易错点：dp[i][1]=min(dp[i-1][0], dp[i-1][1]) //以1结尾的时候，前面以0结尾是不需要+1的</p>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"博弈论相关问题\"><a href=\"#博弈论相关问题\" class=\"headerlink\" title=\"博弈论相关问题\"></a>博弈论相关问题</h3><ol>\n<li>石子问题</li>\n<li>预测家，当前只能从石子序列的头或者尾部进行取，那么使用枚举长度的动态规划+前缀和 （区dp） 注意这道题和lc1423. 可获得的最大点数 不一样因为这个是一定要拿完，而且有两个人拿，而lc1423是一个人拿，所以使用滑动窗口解决 n-k的窗口内数据最小就行</li>\n<li>能赢吗， 因为是从1-n中随机取，而且取了之后就不能取了，所以使用带记忆的dfs, 使用位图来记录当前状态是否遍历过 dp[state]</li>\n</ol>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><ol>\n<li><p>斐波拉切数列问题</p>\n</li>\n<li><p>成熟的牛不断生小牛的问题</p>\n</li>\n<li><p>汉罗塔问题</p>\n</li>\n<li><p>走地图问题（最短/最长价值/龙与地下城游戏）</p>\n</li>\n<li><p>扔鸡蛋问题</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">dp[i][j]=<span class=\"hljs-number\">1</span>+dp[i<span class=\"hljs-number\">-1</span>][j<span class=\"hljs-number\">-1</span>]+dp[i<span class=\"hljs-number\">-1</span>][j] <span class=\"hljs-comment\">//dp[i][j]表示用i次操作j个鸡蛋能够验证的最高高度</span><br></code></pre></td></tr></table></figure></li>\n<li><p>画匠问题</p>\n<ul>\n<li><p>动态规划或者二分算法</p>\n</li>\n<li><p>动态规划：类似于鸡蛋问题，可以使用滑动数组，将二维转为一维，但是在转的时候注意i j的顺序 dp[i-1][0<del>j]可以转 dp[0</del>i][j]不太好转</p>\n</li>\n<li><p>二分解法如下<br>二分法，限制所有画作完成的时长，然后检查在这个时长限制下画家的数量够不够。够的话说明时间还可以压缩，不够的话就要放宽时长限制，多给一些时间。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">getNumber</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> limit)</span></span>&#123;<br>    <span class=\"hljs-keyword\">int</span> cnt=<span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">int</span> tmpsum=<span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;arr.<span class=\"hljs-built_in\">size</span>();i++)&#123;<br>        tmpsum+=arr[i];<br>        <span class=\"hljs-keyword\">if</span>(tmpsum&gt;limit)&#123;<br>            cnt++;<br>            tmpsum=arr[i];<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> cnt+<span class=\"hljs-number\">1</span>;<br>&#125;<br><span class=\"hljs-keyword\">int</span> left=INT_MIN, right=<span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">//表示一个画家画的时长</span><br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;arr.<span class=\"hljs-built_in\">size</span>();i++)&#123;<br>    left=<span class=\"hljs-built_in\">max</span>(arr[i], left);<br>    right+=arr[i];<br>&#125;<br><br><span class=\"hljs-keyword\">if</span>(K&gt;=arr.<span class=\"hljs-built_in\">size</span>())&#123;<span class=\"hljs-comment\">//如果画家数量比画多</span><br>    <span class=\"hljs-keyword\">return</span> left;<span class=\"hljs-comment\">//返回时长最大的画</span><br>&#125;<br><br><span class=\"hljs-keyword\">while</span>(left&lt;right)&#123;<br>    <span class=\"hljs-keyword\">int</span> mid=left+(right-left)/<span class=\"hljs-number\">2</span>;<br>    <span class=\"hljs-keyword\">int</span> tmp=<span class=\"hljs-built_in\">getNumber</span>(mid);<br>    <span class=\"hljs-keyword\">if</span>(tmp==K)&#123;<br>        right=mid;<br>    &#125;<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(tmp&lt;K)&#123;<br>        right=mid<span class=\"hljs-number\">-1</span>;<span class=\"hljs-comment\">//应该也可以和tmp==K合并为right=mid</span><br>    &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>        left=mid+<span class=\"hljs-number\">1</span>;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">return</span> right;<span class=\"hljs-comment\">//最小的时长</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n<p><font color=\"red\">7. 邮局选址的问题</font><br>    - 转移状态的枚举类似于画匠问题<br>    - 因为两个邮局的情况，不清楚那个邮局负责哪些居民区，那么就枚举，然后求最小。<br>    - 这道题前提是要知道：建立一个邮局的时候，建在中间是最优的情况！<br>        1. 提前求i ~ j这段距离建立一个邮局的最小距离<br>        2. dp[i][j]表示0 ~ i这段居民区，有j+1个邮局的最小距离   也可以改成j对应j个邮局，这样初始化dp[i][1],循环j从 2 ~ num<br>        3. 初始化边界dp[i][0]=w[0][i];<br>        4. 建立转移方程： dp[i][j]=min(dp[k][j-1]+w[k+1][i], dp[i][j]) k从0到i，（官方题解：两端值都取!!!!!），表示建邮局的位置<br>        注意j&lt;=i，当j&gt;i dp=0; 每次进入k循环的时候，在初始化dp[i][j]=INT_MAX<br>        5. 返回结果 dp[n-1][K-1];<br>        <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">int</span> w[size+<span class=\"hljs-number\">1</span>][size+<span class=\"hljs-number\">1</span>];<br><span class=\"hljs-comment\">//求任意两个居民点之间建立一个邮局的最短距离</span><br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;size;i++)&#123;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j=i+<span class=\"hljs-number\">1</span>;j&lt;size;j++)&#123;<br>        w[i][j]=w[i][j<span class=\"hljs-number\">-1</span>]+a[j]-a[(i+j)/<span class=\"hljs-number\">2</span>];<br>    &#125;<br>&#125;<br>dp[i][<span class=\"hljs-number\">0</span>]=w[<span class=\"hljs-number\">0</span>][i];<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;=size<span class=\"hljs-number\">-1</span>;i++)&#123;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">1</span>;j&lt;=num<span class=\"hljs-number\">-1</span>;j++)&#123;  <br>        <span class=\"hljs-keyword\">if</span>(j&gt;=i)&#123;<span class=\"hljs-comment\">//邮局数量&gt;=居民区数量  如果不进行判断就需要 k&lt;=i，否则就会因为进不去 k 的循环，导致dp[i][j]=INT_MAX</span><br>            dp[i][j]=<span class=\"hljs-number\">0</span>;<br>        &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>            dp[i][j]=INT_MAX;<br>            <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> k=<span class=\"hljs-number\">0</span>;k&lt;i;k++)&#123;<br>                dp[i][j]=<span class=\"hljs-built_in\">min</span>(dp[k][j<span class=\"hljs-number\">-1</span>]+ w[k+<span class=\"hljs-number\">1</span>][i], dp[i][j]); <span class=\"hljs-comment\">//注意k+1可能==size，因此需要w需要size+1空间</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>        总结，从左到右开始建立，而不是使用二进制记录状态，随机建立<br>        状态转移类似最长递增子序列的思路， 需要提前计算i， j之间建立一个邮局的最短距离</p>\n<p><font color=\"red\">8. 数组的最大价值 (区间dp)</font><br>    - 题意，就是找任意不相交区间且每个区间首位值相等，使得这些区间加起来价值最大<br>    - 转移方程：<br>  <code>  dp[i]=max(dp[i-1], dp[j-1]+presum[i]-presum[j-1]); （a[i]==a[j]）</code><br>    因为需要a[j]==a[i]，如果使用二重循环会超时<br>    解决方案：<br>    （1）使用hash存储不同a[i]对应的下标<br>    （2）记录另外一个hash 使得hash[a[i]]=max(hash[a[i]], dp[i-1]-presum[i-1])<br>    - 之后再进行更新就不用循环找与i相同的下标j,可以直接更新dp[i]=max(dp[i-1], presum[i]+hash[a[i]]);<br>（注意要对hash[a[i]]是否存在进行分类讨论）</p>\n<p><font color=\"red\">9. 盒子放置（谷歌）/现在无权限查看</font><br>    - 使用动态规划的思想；<br>    - dp[i][j] 表示当前第i个box，第j个position能放置的最多的box数量。<br>    如果 box[i - 1] &lt;= position[j - 1]，则dp[i][j] = dp[i - 1][ j - 1] + 1 贪心，放在最后一个位置最好<br>    反之，dp[i][j] = max(dp[i-1][j], dp[i][j - 1]) 其中di[i-1][j]表示不放第i个box, dp[i][j - 1] 第i个box不放在j个位置<br>    **重要！！！！！**<br>    - 注意下标i从0 ~ n-1，但是这个因为有w，所以最好和w对应，不转为1 ~ n。<br>    从i从0开始取的话，每次k循环，划分两个部分相加， 后半部分都不会包含第一个数，因此j要从2开始取，否则就会造成dp[0][0]//第一个0代表有地址，第二个0代表无邮局，就会返回INT_MAX,造成结果错误<br>    背包问题，i下标是1~n 因为i可能从i-1推导，需要i&gt;=1</p>\n<ol start=\"8\">\n<li>“马”在棋盘上的概率<ul>\n<li>类似的==地图问题==，虽然当前位置可以由它四面八方的位置推出来，但是因为步数，所以对应的三维数组还是由之前的状态推导出来，因此仍然可以使用动态规划<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> K=<span class=\"hljs-number\">1</span>;K&lt;=k;K++)&#123;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;n;i++)&#123;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">0</span>;j&lt;n;j++)&#123;<br>            <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> q=<span class=\"hljs-number\">0</span>;q&lt;<span class=\"hljs-number\">8</span>;q++)&#123;<br>                <span class=\"hljs-keyword\">int</span> nextx=i+dx[q];<br>                <span class=\"hljs-keyword\">int</span> nexty=j+dy[q];<br>                <span class=\"hljs-keyword\">if</span>(nextx&gt;=<span class=\"hljs-number\">0</span>&amp;&amp;nextx&lt;n&amp;&amp;nexty&gt;=<span class=\"hljs-number\">0</span>&amp;&amp;nexty&lt;n)&#123;<br>                    dp[i][j][K]+=dp[nextx][nexty][K<span class=\"hljs-number\">-1</span>]/<span class=\"hljs-number\">8.0</span>; <span class=\"hljs-comment\">//下一个和当前反过来感觉也行</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class=\"hljs-keyword\">double</span> sum=<span class=\"hljs-number\">0.0</span>;<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;n;i++)&#123;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">0</span>;j&lt;n;j++)&#123;<br>        sum+=dp[i][j][k]; <span class=\"hljs-comment\">//k步走到每个棋盘的概率加起来</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"字符串与动态规划\"><a href=\"#字符串与动态规划\" class=\"headerlink\" title=\"字符串与动态规划\"></a>字符串与动态规划</h3><p>也可以划分到Trie树问题:一般是对单词建立Trie树</p>\n<ol>\n<li>单词拆分问题（<ul>\n<li>dp代表的是True or False</li>\n<li>dp+第二层循环枚举字典里面的每一个单词，看是否恰好是当前遍历序列0~i的最后几个字符<br>为了进一步减少时间，内层训练从i枚举到0，同时为true的时候直接退出<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;size;i++)&#123; <span class=\"hljs-comment\">//遍历字符串的每一个字符</span><br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j=i;j&gt;=<span class=\"hljs-number\">0</span>;j--)&#123;<br>        string tmp=s.<span class=\"hljs-built_in\">substr</span>(j, i-j+<span class=\"hljs-number\">1</span>);<br>        <span class=\"hljs-keyword\">if</span>(wordSet.<span class=\"hljs-built_in\">find</span>(tmp)!=wordSet.<span class=\"hljs-built_in\">end</span>())&#123;<br>            dp[i]=dp[i]|dp[j<span class=\"hljs-number\">-1</span>];<br>        &#125;<br>        <span class=\"hljs-keyword\">if</span>(dp[i])&#123;<br>            <span class=\"hljs-keyword\">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br>方法二：<br>以当前判断后面的字符串<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;=s.<span class=\"hljs-built_in\">size</span>();i++)&#123;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">0</span>;j&lt;wordDict.<span class=\"hljs-built_in\">size</span>();j++)&#123;<br>        <span class=\"hljs-keyword\">if</span>(!dp[i])&#123;<br>            <span class=\"hljs-keyword\">continue</span>;<br>        &#125;<br>        string tmp=s.<span class=\"hljs-built_in\">substr</span>(i,wordDict[j].<span class=\"hljs-built_in\">size</span>());<br>        <span class=\"hljs-keyword\">if</span>(tmp==wordDict[j])&#123;<br>            dp[i+wordDict[j].<span class=\"hljs-built_in\">size</span>()]=<span class=\"hljs-literal\">true</span>;<br>        <br>            path[i].<span class=\"hljs-built_in\">push_back</span>(i+wordDict[j].<span class=\"hljs-built_in\">size</span>());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<font color=\"red\">单词拆分II需要求出所有可行的解</font><br>为了避免重复的计算和对比，字符串的前缀是否包含单词表里面的单词，需要使用单词拆分1的方法将i后面对应的true的下标放在hash&lt;int, vector&gt;里面记录起来，这样之后再进行遍历的时候就不需要重复判断；<br>另外一个去处回溯的重复方案是， 将一个下标后面的字符串对应的可以拆分方案提前记录起来（hash&lt;int, vector&lt;vector<int>&gt;），这样的话，就不用对同一下标进行多次重复求值（类似于二叉树的组成类似的）</int></li>\n</ul>\n</li>\n</ol>\n<p><font color=\"red\">2. 恢复空格问题(代表的无效字符的个数)- 使用Trie树的经典案例 </font><br>    - 都可以转为Trie树+dp类型的题目<br>    - 这个不能暴力erase,因为可能出现一个单词是另外一个单词的前缀，可能导致erase顺序不同，结果不同；这个只能使用字典序；<br>    - 另外一个减少暴力深搜索带来的超时问题，可以使用第二层循环每次枚举dict的每个元素，看是否与当前遍历序列的最后几个字符相同，而不是每个不同长度的单词一个一个的进行比较。<br>    - 多次搜索：使用暴力的string find或者使用将small单词列表建立Trie树，然后big以每个字符为开头，查找字符串是否出现在Trie树中，在查找的路径中如果遇到isend=True说明找到了一个字符<br>    然后继续找下去</p>\n<ol start=\"3\">\n<li><p>环绕字符串中唯一的子字符串</p>\n<ul>\n<li>题意为：找到子串字符必须是连续的，这样的子串的个数，但是这样可以会出现重复比如abcbc，所以要使用dp (其实就是hash，记录以某个字符结尾的最长的子串)</li>\n<li>计算出26个英文字母中每一个英文字母的结尾的最长的连续的环绕字符串，然后求和</li>\n<li>PS：注意字符串去重，如果不考虑去重的话，可以直接使用滑动窗口记录子串个数；因为这个滑动窗口是直接出现不连续，窗口长度直接退化为1，所以可以只记录窗口长度，不记录窗口左右两端</li>\n</ul>\n</li>\n<li><p>lc97. 交错字符串</p>\n</li>\n</ol>\n<ul>\n<li>求第三个字符串是否能由第一个和第二个字符串组合得到，是否问题</li>\n<li>易错点：不能使用双指针，因为针对一个两个字符串相同的情况可能造成错误</li>\n<li>使用动态规划，dp[i][j]表示字符串1的前i个字符和字符串1的前j个字符能否组成第三个字符串的i+j个字符</li>\n</ul>\n<h3 id=\"状态压缩\"><a href=\"#状态压缩\" class=\"headerlink\" title=\"状态压缩\"></a>状态压缩</h3><ol>\n<li><p>划分为k个相同子集，也可以看做dfs+回溯+贪心</p>\n<ul>\n<li>状态压缩的话就是dp[i]中i的每一个数由二进制位的状态组成，然后遍历二进制的每一个状态，当前的状态可以由当前状态中任意取消一个1的状态转移过来，或者用当前的状态更新下一个状态（将状态中为0的转为1），只有只有dp[i]=true, 而且当前状态的和%target+nums[i]&lt;=target下一个状态才为true,否则为false<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">bool</span> <span class=\"hljs-title\">canPartitionKSubsets</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&amp; nums, <span class=\"hljs-keyword\">int</span> k)</span> </span>&#123;<br>        <span class=\"hljs-keyword\">int</span> size=nums.<span class=\"hljs-built_in\">size</span>();<br>        <span class=\"hljs-keyword\">int</span> total_sum=<span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;size;i++)&#123;<br>            total_sum+=nums[i];<br>        &#125;<br>        <span class=\"hljs-keyword\">if</span>(total_sum%k!=<span class=\"hljs-number\">0</span>)&#123;<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>        &#125;<br>        <span class=\"hljs-keyword\">int</span> target=total_sum/k;<br>        <span class=\"hljs-built_in\">sort</span>(nums.<span class=\"hljs-built_in\">begin</span>(), nums.<span class=\"hljs-built_in\">end</span>());<br>        <span class=\"hljs-keyword\">int</span> total_state=<span class=\"hljs-number\">1</span>&lt;&lt;size;<br>        <span class=\"hljs-function\">vector&lt;<span class=\"hljs-keyword\">bool</span>&gt; <span class=\"hljs-title\">dp</span><span class=\"hljs-params\">(total_state, <span class=\"hljs-literal\">false</span>)</span></span>;<br>        <span class=\"hljs-function\">vector&lt;<span class=\"hljs-keyword\">int</span>&gt; <span class=\"hljs-title\">sum</span><span class=\"hljs-params\">(total_state, <span class=\"hljs-number\">0</span>)</span></span>;<br>        dp[<span class=\"hljs-number\">0</span>]=<span class=\"hljs-literal\">true</span>;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;total_state;i++)&#123;<br>            <span class=\"hljs-keyword\">if</span>(!dp[i])&#123;<br>                <span class=\"hljs-keyword\">continue</span>;<br>            &#125;<br>            <span class=\"hljs-comment\">// cout&lt;&lt;i&lt;&lt;endl;</span><br>            <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">0</span>;j&lt;size;j++)&#123;<br>                <span class=\"hljs-comment\">// cout&lt;&lt;j&lt;&lt;endl;</span><br>                <span class=\"hljs-keyword\">if</span>((i&amp;(<span class=\"hljs-number\">1</span>&lt;&lt;j))==<span class=\"hljs-number\">0</span>)&#123;   <span class=\"hljs-comment\">//注意：位运算一定要记得打上括号之后再判断是否相等，否则会出错！！！！！</span><br>                    <span class=\"hljs-keyword\">int</span> next=i|(<span class=\"hljs-number\">1</span>&lt;&lt;j);<br>                    <span class=\"hljs-comment\">// cout&lt;&lt;next&lt;&lt;endl;</span><br>                    <span class=\"hljs-keyword\">if</span>(sum[i]%target+nums[j]&lt;=target)&#123;<br>                        sum[next]=sum[i]+nums[j];<br>                        dp[next]=<span class=\"hljs-literal\">true</span>;<br>                        cout&lt;&lt;next&lt;&lt;endl;<br>                    &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>                        <span class=\"hljs-keyword\">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> dp[total_state<span class=\"hljs-number\">-1</span>];<br></code></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>优美的排列</p>\n<ul>\n<li>也是状态压缩 或者回溯，相比第2题需要枚举当前位置放的数是哪个，所以多一层循环。上面那道题因为数的位置是固定的，所以只需要判断这个数放没放。</li>\n<li>其实还是顺序放，当前放了m个，那么下一个要放的数就是m+1， 所以也可以不同像下面的题解一样多一层循环（3月8日修改）<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> &#123;</span><br><span class=\"hljs-class\"><span class=\"hljs-title\">public</span>:</span><br>    <span class=\"hljs-built_in\">int</span> count(<span class=\"hljs-built_in\">int</span> number)&#123;<br>        <span class=\"hljs-built_in\">int</span> res=<span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-keyword\">while</span>(number!=<span class=\"hljs-number\">0</span>)&#123;<br>            <span class=\"hljs-keyword\">if</span>(number&amp;<span class=\"hljs-number\">1</span>)&#123;<br>                res++;<br>            &#125;<br>            number=number&gt;&gt;<span class=\"hljs-number\">1</span>;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> res;<br>    &#125;<br>    <span class=\"hljs-built_in\">int</span> countArrangement(<span class=\"hljs-built_in\">int</span> n) &#123;<br>        <span class=\"hljs-built_in\">int</span> state=<span class=\"hljs-number\">1</span>&lt;&lt;n;<br>        <br>        vector&lt;<span class=\"hljs-built_in\">int</span>&gt; dp(state, <span class=\"hljs-number\">0</span>);<br>        dp[<span class=\"hljs-number\">0</span>]=<span class=\"hljs-number\">1</span>;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-built_in\">int</span> num=<span class=\"hljs-number\">1</span>;num&lt;=n;num++)&#123; //类似背包的，当前放第num数， 标准答案是将状态放在外层， 然后通过<span class=\"hljs-number\">1</span>个个数判断当前的num<br>            <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-built_in\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;state;i++)&#123;<br>                // <span class=\"hljs-keyword\">if</span>(!dp[i])&#123;<br>                //     <span class=\"hljs-keyword\">continue</span>;<br>                // &#125;<br>                <span class=\"hljs-keyword\">if</span>(count(i)!=num-<span class=\"hljs-number\">1</span>)&#123;<br>                    <span class=\"hljs-keyword\">continue</span>;<br>                &#125;<br>                <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-built_in\">int</span> j=<span class=\"hljs-number\">0</span>;j&lt;n;j++)&#123;<br>                    <span class=\"hljs-keyword\">if</span>((i&amp;(<span class=\"hljs-number\">1</span>&lt;&lt;j))==<span class=\"hljs-number\">0</span>)&#123;<br>                        <span class=\"hljs-keyword\">if</span>(num%(j+<span class=\"hljs-number\">1</span>)==<span class=\"hljs-number\">0</span>||(j+<span class=\"hljs-number\">1</span>)%num==<span class=\"hljs-number\">0</span>)&#123;<br>                            <span class=\"hljs-built_in\">int</span> <span class=\"hljs-built_in\">next</span>=i^(<span class=\"hljs-number\">1</span>&lt;&lt;j);<br>                            dp[<span class=\"hljs-built_in\">next</span>]+=dp[i];<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> dp[state-<span class=\"hljs-number\">1</span>];<br>        <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>华为的一个机试题目</p>\n<ul>\n<li><p>需要在规定燃油内（规定长度内）得到的资源最大化（有点像0-1背包问题）， 但是这个不同之处在于：从不同点到相同的i，消耗的燃油是不一样的， 而且这个最后还需要回到原点，所以dist需要走过的位置mask 以及最后的位置i</p>\n</li>\n<li><p>其实就是先求每个mask的最小dist, 得到d[mask][i]:也就是以i结尾的最小燃油，然后遍历这个数组，如果d[mask][i]+fuel[i][0]&lt;=maxdist 那么更新ans<br>ans=max(ans, g[mask])</p>\n</li>\n<li><p>为什么不直接求d[fuel][i]的最大化，这样也会重复vis统一节点<br><a href=\"https://leetcode-cn.com/circle/discuss/a4pRYY/\">https://leetcode-cn.com/circle/discuss/a4pRYY/</a></p>\n</li>\n</ul>\n</li>\n<li><p>访问所有节点的最短路径(hard)</p>\n<ul>\n<li>题意：一笔走完所有的节点，注意可能重复访问同一个节点</li>\n<li>主要思路：<br>先求出任意两个节点间的距离，使用floyd，同时记得出事dist[i][i]=0<br>然后使用d[mask][i]:表示最后状态为mask,并且以i结尾的最短路径<br>最后遍历d[mask][i] 求最小值</li>\n<li>易错点，mask的循环一定要在节点i的循环的外面， 否则就会出错<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> mask=<span class=\"hljs-number\">1</span>;mask&lt;(<span class=\"hljs-number\">1</span>&lt;&lt;n);mask++)&#123;<br>          <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;n;i++)&#123;<br>              <span class=\"hljs-keyword\">if</span> (mask &amp; (<span class=\"hljs-number\">1</span> &lt;&lt; i)) &#123; <span class=\"hljs-comment\">//如果i这个点已经被选过</span><br>                  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> k=<span class=\"hljs-number\">0</span>;k&lt;n;k++)&#123;<br>                      <span class=\"hljs-keyword\">if</span>((mask&amp;(<span class=\"hljs-number\">1</span>&lt;&lt;k))==<span class=\"hljs-number\">0</span>)&#123;<br>                          d[mask|(<span class=\"hljs-number\">1</span>&lt;&lt;k)][k]=<span class=\"hljs-built_in\">min</span>(d[mask|(<span class=\"hljs-number\">1</span>&lt;&lt;k)][k],d[mask][i]+dist[i][k]); <span class=\"hljs-comment\">//需要先使用floy求出任意两点之间的最短距离</span><br>                      &#125;<br>                  &#125;<br>              &#125;<br>          &#125;<br>      &#125;<br></code></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>基于陈述统计最多好人数</p>\n<ul>\n<li>这个是枚举状态（二进制），与dp无关，但是和状态压缩dp有点类似</li>\n</ul>\n</li>\n<li><p>两个数组最小的异或值之和  / <font color=\"red\">lc2172： 数组的最大与和 </font></p>\n<ul>\n<li>这两道题都是位运算相关的状态压缩<br>第一题枚举nums2每个数应该放的位置<br>第二题需要先装为状态压缩的样子，因为每个index有两个slot,所以需要先转为2*n个slot，那么slot和index对应关系为j/2+1<br>然后枚举每个数应该放在哪个slot,同时注意这道题不是每个状态都有值，对于one_num of state i&gt;=num数量, 直接continue</li>\n<li>一个位可以放两个数的情况，需要展开分别讨论<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">int</span> ans = <span class=\"hljs-number\">0</span>;<br><span class=\"hljs-function\">vector&lt;<span class=\"hljs-keyword\">int</span>&gt; <span class=\"hljs-title\">f</span><span class=\"hljs-params\">(<span class=\"hljs-number\">1</span> &lt;&lt; (numSlots * <span class=\"hljs-number\">2</span>))</span></span>;<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; f.<span class=\"hljs-built_in\">size</span>(); ++i) &#123;<br>    <span class=\"hljs-keyword\">int</span> c = __builtin_popcount(i); <span class=\"hljs-comment\">//当前已经放了几个数，下一个放的数就是nums[c]</span><br>    <span class=\"hljs-keyword\">if</span> (c &gt;= nums.<span class=\"hljs-built_in\">size</span>()) <span class=\"hljs-keyword\">continue</span>; <span class=\"hljs-comment\">//直接跳过</span><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; numSlots * <span class=\"hljs-number\">2</span>; ++j) &#123;<br>        <span class=\"hljs-keyword\">if</span> ((i &amp; (<span class=\"hljs-number\">1</span> &lt;&lt; j)) == <span class=\"hljs-number\">0</span>) &#123; <span class=\"hljs-comment\">// 枚举空篮子 j</span><br>            <span class=\"hljs-keyword\">int</span> s = i | (<span class=\"hljs-number\">1</span> &lt;&lt; j);<br>            f[s] = <span class=\"hljs-built_in\">max</span>(f[s], f[i] + ((j / <span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">1</span>) &amp; nums[c]));<br>            ans = <span class=\"hljs-built_in\">max</span>(ans, f[s]); <span class=\"hljs-comment\">//有效的状态求结果</span><br>        &#125;<br>    &#125;<br>&#125;<br><span class=\"hljs-keyword\">return</span> ans;<br></code></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"动态规划-拓扑排序\"><a href=\"#动态规划-拓扑排序\" class=\"headerlink\" title=\"动态规划 + 拓扑排序\"></a>动态规划 + 拓扑排序</h3><ol>\n<li>并行课程III<br>题意：可能具有拓扑结构+每节课程都有上课时间， 任意两节不依赖课程可以同时上，求最短上完所有课程的时间<br>转化：拓扑排序的最长路径<br>两种解决方案：</li>\n</ol>\n<ul>\n<li>转为dfs，建立依赖关系的时候反向建立，然后将度为0的点放入队列之中（root）,dfs求深度，然后多棵树取最长深度</li>\n<li>使用拓扑排序，将度为0的点放入队列，同时每次在取出队列中的点的时候，用当前点的结果f[v]更新v后面所有后修课程的结果<br>f[w]=max(f[w], f[v]+time[v])</li>\n</ul>\n<h3 id=\"反向dp\"><a href=\"#反向dp\" class=\"headerlink\" title=\"反向dp\"></a>反向dp</h3><ol>\n<li><font color=\"red\">lc174. 地下城游戏</font></li>\n</ol>\n<ul>\n<li>正序的含义为“从起点出发，到达位置（i，j）所需要的最少血量”；正向dp有两个因素影响，可能每条路各有一个因素好，因此不知道选择哪条；（当前需要的血量，和整条路径中至少需要的血量）</li>\n<li>倒序的含义是“从（i，j）出发，到达终点需要最少的血量”。初始血量本来就是要求的，所以只能倒序dp</li>\n<li>转移方程：<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">if</span>(i==m<span class=\"hljs-number\">-1</span>&amp;&amp;j==n<span class=\"hljs-number\">-1</span>)&#123;<br>    dp[i][j]=<span class=\"hljs-built_in\">max</span>(<span class=\"hljs-number\">1</span>-dungeon[i][j], <span class=\"hljs-number\">1</span>);<br>&#125;<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(i==m<span class=\"hljs-number\">-1</span>)&#123;<br>    dp[i][j]=<span class=\"hljs-built_in\">max</span>(dp[i][j+<span class=\"hljs-number\">1</span>]-dungeon[i][j], <span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">//每个点的初始健康点都必须为正整数</span><br>&#125;<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(j==n<span class=\"hljs-number\">-1</span>)&#123;<br>        dp[i][j]=<span class=\"hljs-built_in\">max</span>(dp[i+<span class=\"hljs-number\">1</span>][j]-dungeon[i][j], <span class=\"hljs-number\">1</span>);                <br>&#125;<span class=\"hljs-keyword\">else</span>&#123;<br>        dp[i][j]=<span class=\"hljs-built_in\">max</span>(<span class=\"hljs-built_in\">min</span>(dp[i+<span class=\"hljs-number\">1</span>][j], dp[i][j+<span class=\"hljs-number\">1</span>])-dungeon[i][j], <span class=\"hljs-number\">1</span>); <br>&#125;   <br></code></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>ok  ok</p>\n<ol>\n<li><p>图与动态规划，一定要注意vis的问题，bellman-ford以及floyd算法都是图的动态规划的例子<br>但是注意因为bellman-ford是求距离最小，所以不会出现重复vis同一个节点的情况<br>但是如果求max的情况，使用动态规划+图就可能造成一个节点vis多次，因此最好考虑记忆化dfs或者状态压缩</p>\n</li>\n<li><p>状态压缩问题，将状态放在外层比较保险；如果是list数组，那么可以将num放在外面，如果是图，那么只能将状态放在外面。 通常状态压缩使用的题目是将数据放在哪个位置，得到最大/最小、/满足什么样的条件的XXX类似题型<br><font color=\"red\">图类型的状态压缩：求遍历这个图中所有节点的最小代价（代价指的是走过路径长度的总和， 应该是顺序走完）。状态压缩dp，注意不要理解成最小生成树</font></p>\n</li>\n</ol>\n<ol start=\"3\">\n<li>动态规划的关键是处理 i 取值范围 j取值范围，转移方程以及边界情况求动态规划<br>也就是找到dp[i]-&gt; dp[j] (j&lt; i) 的递推公式,这个递推可能由i，j之间回文，括号，或者异或和组成；特别的，如果是回文可以提前得到任何i，j之间是否为回文字符串，模板代码如下：<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=s_len<span class=\"hljs-number\">-1</span>;i&gt;=<span class=\"hljs-number\">0</span>;i--)&#123;<br>     <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j=i+<span class=\"hljs-number\">1</span>;j&lt;s_len;j++)&#123;<br>         p[i][j]=(s[i]==s[j]&amp;&amp;p[i+<span class=\"hljs-number\">1</span>][j<span class=\"hljs-number\">-1</span>]);<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure></li>\n</ol>\n<p>4.区间dp问题，外围长度的字符状态，可以由内围的长度的字符推导出来 dp[i][size]</p>\n<ol start=\"5\">\n<li><p>如果进行了状态压缩：<br>0-1的最大背包问题，逆向枚举<br>多重背包问题也是，只能逆向枚举<br>完全背包（无限个）才是正向枚举！！！</p>\n</li>\n<li><p>有的时候动态规划不好解决，考虑使用带记忆的dfs，（比如要求所有的路径，或者所有路径中花费最小等等） 而且dp 的index可以为一个vector（类似与状态压缩）</p>\n</li>\n<li><p>最短时间类似题，除了考虑动态规划，也可以向二分算法中思考，比如画匠问题</p>\n</li>\n<li><p>动态规划可以解决true/false（是否能化为k个相同区间，单词拆分问题）, 最小最大最长问题，总数问题</p>\n</li>\n<li><p>当动态规划的状态比较多的情况下<br>注意 res+=dp[i][m]%MOD(wrong answer)<br>res=(res+dp[m][i])%MOD(right answer);</p>\n</li>\n<li><p>划分性dp有两种情况：以i为结尾，和0-i之间，区分这两种情况就是判断在进行dp递推的时候，如果dp[i] 依赖于多个之前的dp[j]那么应该使用以i为结尾，如果dp[i]只依赖之前的一个dp[j]那么使用0-i之内的元素<br>（最长子序列和最长子串问题）</p>\n</li>\n<li><p>使用状态枚举（状态压缩）的方法，要求k&lt;32 !!!!如果n&lt;100那么就不能这么枚举</p>\n</li>\n<li><p>背包问题可能也会加一个额外的条件，类似于最短路径问题（Dijstra/bellman-ford/floyd）中再加一个额外条件,具体例题见“货物转移”(lintcode)模板： dp数量最小+weight最大类似题目</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">if</span>(d[j]+<span class=\"hljs-number\">1</span>&lt;d[i])&#123; <span class=\"hljs-comment\">//找到更优解</span><br>    d[i]=d[j]+<span class=\"hljs-number\">1</span>;<br>    weight[i]=weight[j]; <span class=\"hljs-comment\">// update weight and d</span><br>&#125;<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(d[i]==d[j]+<span class=\"hljs-number\">1</span>)&#123;<br>    weight[i]=max/<span class=\"hljs-built_in\">min</span>(weight[j], weight[i]); <span class=\"hljs-comment\">//only update weight</span><br>&#125;<span class=\"hljs-keyword\">else</span>&#123;<br>    <span class=\"hljs-keyword\">continue</span>; <span class=\"hljs-comment\">//do not update anything</span><br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li><p>动态规划一定要注意状态的初始化，在i 和 j都从1开始取的时候，一定要记得赋值dp[0][1到n] 以及dp[1到n][0]</p>\n</li>\n<li><p>如果出现反复将一个字符串的子串和字典中的每个字符比对的题目，可以使用Trie树，或者使用动态规划（True/False类型），提前判断某一个子字符串是否在字典中</p>\n</li>\n<li><p>刷一刷leetcode以面试题开始的题目</p>\n</li>\n<li><p>每个物品选择或者不选择，使得总体的方案是n, 同时花费最少的这种类似题可以使用动态规划<br>例题： lc1029. 两地调度</p>\n</li>\n</ol>\n<ul>\n<li>第一想法是使用二进制的暴力枚举</li>\n<li>因为整体的方案一定要是n, 所以一定要初始化dp[0][j] (j&gt;=2为一个比较大的值)； 同时dp[i][0] 为dp[i-1][0]+cost[i][1]<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"> dp[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">0</span>]=costs[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">1</span>];<br> dp[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">1</span>]=costs[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">0</span>];<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">2</span>;j&lt;=n/<span class=\"hljs-number\">2</span>;j++)&#123;<br>     dp[<span class=\"hljs-number\">0</span>][j]=<span class=\"hljs-number\">1000000</span>; <span class=\"hljs-comment\">//注意这个是非常重要的！！！！</span><br> &#125;<br> <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;n;i++)&#123;<br>     dp[i][<span class=\"hljs-number\">0</span>]=dp[i<span class=\"hljs-number\">-1</span>][<span class=\"hljs-number\">0</span>]+costs[i][<span class=\"hljs-number\">1</span>];<br>     <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">1</span>;j&lt;=n/<span class=\"hljs-number\">2</span>;j++)&#123; <span class=\"hljs-comment\">//j代表剩余的0类的数量</span><br>         dp[i][j]=<span class=\"hljs-built_in\">min</span>(dp[i<span class=\"hljs-number\">-1</span>][j]+costs[i][<span class=\"hljs-number\">1</span>], dp[i<span class=\"hljs-number\">-1</span>][j<span class=\"hljs-number\">-1</span>]+costs[i][<span class=\"hljs-number\">0</span>]);<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure></li>\n<li>第二种方法是贪心：<br>  a[i] - b[i]代表将i员工派往a地比派往b地的费钱程度，数值越高表示派往a地越不划算；<br>  将所有花费按a[i] - b[i]从小到大排序，则前n个为派往a地更划算的员工，后n个为派往b地更划算的员工。</li>\n</ul>\n<p>lc474. 一和零 （类似于0-1背包问题）</p>\n<ul>\n<li>选不选择每个字符串，满足0， 1不超过m, n同时使得最后的字符串个数最多; 或者选了这个不能选择左右两边， 类似问题都使用dp</li>\n<li>这种第一种想到的思路是回溯，更进一步的方法是动态规划</li>\n<li>回溯思路如果不求具体序列，只求总数的话，可以考虑动态规划解决<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">if</span>(j&gt;=zero_num&amp;&amp;k&gt;=one_num)&#123;<br>    dp[i][j][k]=<span class=\"hljs-built_in\">max</span>(dp[i<span class=\"hljs-number\">-1</span>][j-zero_num][k-one_num]+<span class=\"hljs-number\">1</span>, dp[i<span class=\"hljs-number\">-1</span>][j][k]);<br>&#125;<span class=\"hljs-keyword\">else</span>&#123;<br>    dp[i][j][k]=dp[i<span class=\"hljs-number\">-1</span>][j][k]; <span class=\"hljs-comment\">//一定注意else别忘了</span><br>&#125;<br></code></pre></td></tr></table></figure></li>\n</ul>\n<ol start=\"17\">\n<li><p>非常重要的资源：<a href=\"https://oi-wiki.org/dp/knapsack/\">https://oi-wiki.org/dp/knapsack/</a><br>OI-wiki  《背包九讲》</p>\n</li>\n<li><p>连续数组进行划分，是的划分个数满足条件，使用动态规划或者二分查找<br>例题：lc410. 分割数组的最大值(hard), 画匠问题</p>\n</li>\n<li><p>一定要注意数组越界可能不会报错，比如403. 青蛙过河，申请dp[size][size] size=18， 但是访问dp[18][29]范围为true<br>所以这道题关键在于一定要加上判断if(k&lt;=j+1) 才能进行dp的更新，否则就会发生访问到越界的数据</p>\n</li>\n</ol>\n","site":{"data":{}},"wordcount":26657,"excerpt":"","more":"<h3 id=\"求总数问题\"><a href=\"#求总数问题\" class=\"headerlink\" title=\"求总数问题\"></a>求总数问题</h3><ol>\n<li><p>回文字符串的个数</p>\n</li>\n<li><p>表达式为期望结果的总数</p>\n<ul>\n<li>也是区间dp, dp[i][j][0]或者dp[i][j][1])</li>\n<li>因为不是表达式的个数，而是达到期望值的个数，因此要记录一个表达式的值，用三维数组</li>\n</ul>\n</li>\n<li><p>能够组成的二叉树的个数</p>\n</li>\n<li><p>打气球的最大分数(区间dp)</p>\n<ul>\n<li>虽然不是求个数，而是求最大，但是也是与当前状态的左右边界有关。因为最终结果和左右两边有关，因此都是枚举的长度+右边界，计算左边界，进行动态规划<br>转移方程：考虑这个区间上最后一个气球的打破方式，即最后一个气球的打破位置。在左边右边和中间<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">f[i][j] = <span class=\"hljs-built_in\">max</span>( f[i][j], f[i][k - <span class=\"hljs-number\">1</span>] + f[k + <span class=\"hljs-number\">1</span>][j] + a[k] * a[i - <span class=\"hljs-number\">1</span>] * a[j + <span class=\"hljs-number\">1</span>]); <span class=\"hljs-comment\">//闭区间的更新方式</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n<p>在leetcode上面的一道原题，只是描述改变了<br>lc312. 戳气球</p>\n<ul>\n<li>这道题如果将dp[i][j]定义为开区间或得的最大值就更容易理解<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">状态转移： dp[i][j]=<span class=\"hljs-built_in\">max</span>(dp[i][j], dp[i][k]+dp[k][j]+val[i]*val[k]*val[j]);<span class=\"hljs-comment\">//开区间的更新方式</span><br></code></pre></td></tr></table></figure></li>\n<li>注意为了减少情况的分类讨论，需要在左右两边都加上1，这样的话枚举一个区间留下的最后一个数，也是可以求得值的</li>\n</ul>\n</li>\n<li><p>旋变字符串问题 (区间dp) lc87. 扰乱字符串</p>\n<ul>\n<li> 四重循环，三维dp（两个字符串两个端点+一个长度）</li>\n<li>这道题不是求个数，而是求是否，但是仍然是需要枚举长度的问题，因为是两个字符串，所以应该有4个边，但是运用长度相等的信息，将思维坐标转为左边坐标+size, 成为三维问题<br>dp[start1][start2][len] 而且这道题有两个长度：一个是总字符串长度，一个是总字符串化为为两个旋变字符串的长度<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> size = <span class=\"hljs-number\">2</span>; size &lt;= n; size++)&#123;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> l1 = <span class=\"hljs-number\">0</span>; l1 &lt;= n - size; l1++)&#123;<br>            <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> l2 = <span class=\"hljs-number\">0</span>; l2 &lt;= n - size; l2++)&#123;<br>                <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> leftPart = <span class=\"hljs-number\">1</span>; leftPart &lt; size; leftPart++)&#123;<br>                    <span class=\"hljs-keyword\">if</span>((dp[l1][l2][leftPart] &amp;&amp; dp[l1 + leftPart][l2 + leftPart][size - leftPart]) || <br>                        (dp[l1][l2 + size - leftPart][leftPart] &amp;&amp; dp[l1 + leftPart][l2][size - leftPart]))&#123;<br>                        dp[l1][l2][size] = <span class=\"hljs-literal\">true</span>;      <span class=\"hljs-comment\">// 只要有一个leftPart满足旋变串条件就可以break出去</span><br>                        <span class=\"hljs-keyword\">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>数字字符串转为字母组合的总数</p>\n<ul>\n<li>因为只是与之前的结果或者后面的结果有关，因此只需要从左到右枚举下标就可以了<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">递推式<br><span class=\"hljs-comment\">// 第 i 个字符只能单独转换为一个 字母</span><br><span class=\"hljs-comment\">// dp[i-1] ：第 i 个字符单独转换的方案数</span><br>dp[i]=dp[i<span class=\"hljs-number\">-1</span>];<br><span class=\"hljs-comment\">// 第 i 个字符 可以和 第 i-1 个字符 共同转换为一个 字母</span><br><span class=\"hljs-comment\">// dp[i-1] ：第 i 个字符单独转换的方案数</span><br><span class=\"hljs-comment\">// dp[i-2] ：第 i 个字符，结合第 i-1 个字符组合转换为一个字母的方案数</span><br>dp[i]=dp[i<span class=\"hljs-number\">-1</span>]+dp[i<span class=\"hljs-number\">-2</span>];<br><span class=\"hljs-comment\">//如果第i个字符不能单独存在那么</span><br>dp[i]=<span class=\"hljs-number\">0</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>组合总数IV， </p>\n<ul>\n<li>总结：如果排序不同算不同的排列组合的话那么 target循环在外侧， nums总数循环在内侧<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;=target;i++)&#123;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">0</span>;j&lt;size;j++)&#123;<br>            <span class=\"hljs-keyword\">if</span>(i&gt;=nums[j]&amp;&amp;dp[i - nums[j]] &lt; INT_MAX - dp[i])&#123;<br>                dp[i]+=dp[i-nums[j]];<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></li>\n<li>如果排序不同算相同的排列祝贺的话那么， target循环在内侧，nums总数循环在外侧, 完全背包问题<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;=size;i++)&#123;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">1</span>;j&lt;=target;j++)&#123;<br>        dp[i][j]+=dp[i<span class=\"hljs-number\">-1</span>][j];<br>        <span class=\"hljs-keyword\">if</span>(j&gt;=nums[i<span class=\"hljs-number\">-1</span>])&#123;<br>            dp[i][j]+=dp[i][j-nums[i<span class=\"hljs-number\">-1</span>]];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>删除回文子数组</p>\n<ul>\n<li>区间dp/枚举长度的dp</li>\n<li>数组，每次可以删除一个数字，或者删除掉一个回文串，求删除需要的最少次数<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">dp<span class=\"hljs-selector-attr\">[i]</span><span class=\"hljs-selector-attr\">[j]</span>=min(dp<span class=\"hljs-selector-attr\">[i+1]</span><span class=\"hljs-selector-attr\">[j-1]</span>, dp<span class=\"hljs-selector-attr\">[i]</span><span class=\"hljs-selector-attr\">[j]</span>) <span class=\"hljs-keyword\">if</span> <span class=\"hljs-selector-tag\">a</span><span class=\"hljs-selector-attr\">[i]</span>==<span class=\"hljs-selector-tag\">a</span><span class=\"hljs-selector-attr\">[j]</span><br>dp<span class=\"hljs-selector-attr\">[i]</span><span class=\"hljs-selector-attr\">[j]</span>=min(dp<span class=\"hljs-selector-attr\">[i]</span><span class=\"hljs-selector-attr\">[k]</span>+dp<span class=\"hljs-selector-attr\">[k+1]</span><span class=\"hljs-selector-attr\">[j]</span>, dp<span class=\"hljs-selector-attr\">[i]</span><span class=\"hljs-selector-attr\">[j]</span>)<br>dp长度从<span class=\"hljs-number\">3</span>开始，dp长度为<span class=\"hljs-number\">1</span>， <span class=\"hljs-number\">2</span>的时候使用初始化<br></code></pre></td></tr></table></figure></li>\n<li>答案见：<a href=\"https://cloud.tencent.com/developer/article/1659691\">https://cloud.tencent.com/developer/article/1659691</a> 可以作为区间dp模板，但是枚举长度和转移方程那里可以修改一下</li>\n</ul>\n</li>\n<li><p>lc115. 不同的子序列 (具体分析见字符串匹配问题)</p>\n</li>\n<li><ol start=\"446\">\n<li>等差数列划分 II - 子序列（hard）</li>\n</ol>\n</li>\n</ol>\n<ul>\n<li>题意：等差子序列个数，可不连续，每个序列至少包含3个数</li>\n<li>我的困难地方在于，这个序列长度要等于3，那么将序列==2的如何处理，如果出现重复如何处理 比如2  1 2 3</li>\n<li>官方解题方案是，计算弱等差子序列的个数（序列==2），然后再计算结果的时候遍历三个数，同时因为差为负数，所以使用hash_map数组vector&lt;unordered_map&lt;long long, int&gt;&gt; d(size)</li>\n<li>将记录以某一下标结尾的序列中包含的数个数，转为差为d的对数（个数-&gt;对数）</li>\n</ul>\n<ol start=\"11\">\n<li><ol start=\"1000\">\n<li>合并石头的最低成本(hard)</li>\n</ol>\n</li>\n</ol>\n<ul>\n<li>区间dp的经典题目，四重区间dp</li>\n<li>将i，j之间的num堆转为 区间划分前面1堆后面num-1堆，然后因为连续k堆可以转为一堆，所以单独对于dp[i][j][k]单独进行转换为dp[i][j][1]<br>dp[i][j][num]=min(dp[i][j][num], dp[i][q][1]+dp[q+1][j][num-1]); //num表示num堆， 注意没有必要枚举dp[i][q][2]+dp[q+1][j][num-2]//这种情况，因为下标划分已经达到枚举的作用</li>\n</ul>\n<h3 id=\"求最大最小问题\"><a href=\"#求最大最小问题\" class=\"headerlink\" title=\"求最大最小问题\"></a>求最大最小问题</h3><p>PS: 子串都是要求连续的，而子序列是不要求连续的</p>\n<ol>\n<li><p>扔鸡蛋 lc887<br> <a href=\"https://zhuanlan.zhihu.com/p/92288604\">https://zhuanlan.zhihu.com/p/92288604</a><br> 两种状态转移：<br> a. dp[k][n], k个鸡蛋n层楼， 需要最少扔多少次</p>\n<pre><code> dp[1][N] = N\n dp[..][0] = 0\n for i=1到n:\n  dp[k][n]=min(dp[k][n], max(dp[k][i-1]+dp[k-1][n-i])+1);//不需要在第i层再扔，因此删除i\n</code></pre>\n<p> b. dp[k][m], k个鸡蛋扔m次，可以验证的最大楼层数</p>\n<pre><code> dp[0][..] = 0\n dp[..][0] = 0\n whle(dp[K][m]&lt;N)&#123;\n     m++;\n     for (int k = 1; k &lt;= K; k++)&#123;\n         dp[k][m] = dp[k][m - 1] + dp[k - 1][m - 1] + 1;\n     &#125;\n &#125;\n</code></pre>\n <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">int</span> ans=<span class=\"hljs-number\">-1</span>;<br>vector&lt;vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&gt; <span class=\"hljs-built_in\">dp</span>(n+<span class=\"hljs-number\">1</span>,vector&lt;<span class=\"hljs-keyword\">int</span>&gt;(k+<span class=\"hljs-number\">1</span>));<br><span class=\"hljs-keyword\">if</span>(n==<span class=\"hljs-number\">1</span>&amp;k&gt;=<span class=\"hljs-number\">1</span>)&#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br>&#125;<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;=n;i++)&#123;<br>    dp[i][<span class=\"hljs-number\">1</span>]=i; <span class=\"hljs-comment\">//一个鸡蛋</span><br>&#125;<br><br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">1</span>;j&lt;=k;j++)&#123;<br>    dp[<span class=\"hljs-number\">1</span>][j]=<span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">//一次操作</span><br>&#125;<br><br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">2</span>;i&lt;=n;i++)&#123; <span class=\"hljs-comment\">//n次操作</span><br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">1</span>;j&lt;=k;j++)&#123; <span class=\"hljs-comment\">//k个鸡蛋</span><br>        dp[i][j]=dp[i<span class=\"hljs-number\">-1</span>][j]+dp[i<span class=\"hljs-number\">-1</span>][j<span class=\"hljs-number\">-1</span>]+<span class=\"hljs-number\">1</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span>(dp[i][k]&gt;=n)&#123;<br>            ans=i;<br>            <span class=\"hljs-keyword\">break</span>;<br>    &#125;<br>&#125;<br><span class=\"hljs-keyword\">return</span> ans;<br></code></pre></td></tr></table></figure></li>\n<li><p>最长递增子串</p>\n</li>\n<li><p>最长递增子序列<br> 两种方法：</p>\n<ul>\n<li>两重循环</li>\n<li>单调栈+二分查找<br>扩展 最长递增子序列的个数，时间复杂度仍然是O(n^2)，只是多了一个cnt, 每次出现最大就更新，否则进行cnt的累加</li>\n</ul>\n<p> 另外类似的题目: 1027. 最长等差数列<br> dp[i][j]表示以i结尾而且差为j的最长数列</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;size;i++)&#123;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">0</span>;j&lt;i;j++)&#123;<br>        <span class=\"hljs-keyword\">int</span> tmp=nums[i]-nums[j];<span class=\"hljs-comment\">//因为差可能是负数</span><br>        dp[i][tmp+<span class=\"hljs-number\">1000</span>]=dp[j][tmp+<span class=\"hljs-number\">1000</span>]+<span class=\"hljs-number\">1</span>;<br>        res=<span class=\"hljs-built_in\">max</span>(res, dp[i][tmp+<span class=\"hljs-number\">1000</span>]);   <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p> lc1218. 最长定差子序列： 这道题diff是定了，因此只需要一维hash就可以了</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;size;i++)&#123;<br>    hash[arr[i]]=<span class=\"hljs-built_in\">max</span>(hash[arr[i]-difference]+<span class=\"hljs-number\">1</span>, hash[arr[i]]);<br>    res=<span class=\"hljs-built_in\">max</span>(res, hash[arr[i]]);<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li><p>最长公共子串（要求连续）</p>\n<ul>\n<li>注意和子序列的区别：动态规划转移方程是 dp[i][j]=dp[i-1][j-1]+1 or dp[i][j]=0表示以i或者j结尾的子串， 最后遍历二维数组求最大值<br>求具体的最长公共子串，只需要动态规划的时候，记录最长的公共子串的下标，然后s.substr(start_pos = index-maxlen+1, len = maxlen)就可以了</li>\n</ul>\n</li>\n<li><p>最长公共子序列 （最长长度/最长具体序列/最短包含序列）</p>\n<ul>\n<li>题意改变，但是代码不变的题目–不相交的线</li>\n<li>相似的题目：</li>\n</ul>\n<ol>\n<li>编辑距离</li>\n<li>两个字符串的删除操作， 可以直接动态规划求最少的删除字符数量，也可以用最长公共子序列，然后用m+n-2*lcs</li>\n</ol>\n<ul>\n<li>如果要求具体删除的是哪些字符串，两种方法应该都是可以的</li>\n<li>动态规划转移方程是 <figure class=\"highlight inform7\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs inform7\">dp<span class=\"hljs-comment\">[i]</span><span class=\"hljs-comment\">[j]</span>=dp<span class=\"hljs-comment\">[i]</span><span class=\"hljs-comment\">[j]</span>+1 or dp<span class=\"hljs-comment\">[i]</span><span class=\"hljs-comment\">[j]</span>=max(dp<span class=\"hljs-comment\">[i]</span><span class=\"hljs-comment\">[j-1]</span>, dp<span class=\"hljs-comment\">[i-1]</span><span class=\"hljs-comment\">[j]</span>)<br></code></pre></td></tr></table></figure>\ndp[i-1][j] 表示以i或者j结尾的子串中包括的最长公共子序列（不一定是以i j结尾）， 所以最后只用直接返回dp[m][n]</li>\n<li>在求最长的公共子序列的时候，需要使用dp转换等式 i–,j– 或者j–, 或者i–来进行查找最长的公共子序列， 同时也可以求最短的删除的字符具体是哪些<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">int</span> i = m<span class=\"hljs-number\">-1</span>, j = n<span class=\"hljs-number\">-1</span>;<br><span class=\"hljs-keyword\">while</span>(i &gt;= <span class=\"hljs-number\">0</span> &amp;&amp; j &gt;= <span class=\"hljs-number\">0</span>)&#123;<br>    <span class=\"hljs-keyword\">if</span>(s1.<span class=\"hljs-built_in\">charAt</span>(i) == s2.<span class=\"hljs-built_in\">charAt</span>(j))&#123;<br>        res.<span class=\"hljs-built_in\">append</span>(s1.<span class=\"hljs-built_in\">charAt</span>(i));<br>        i--;<br>        j--;<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span>(i&gt;<span class=\"hljs-number\">0</span> &amp;&amp; j&gt;<span class=\"hljs-number\">0</span> &amp;&amp; s1.<span class=\"hljs-built_in\">charAt</span>(i) != s2.<span class=\"hljs-built_in\">charAt</span>(j))&#123;<br>        <span class=\"hljs-keyword\">if</span>(dp[i<span class=\"hljs-number\">-1</span>][j] &gt; dp[i][j<span class=\"hljs-number\">-1</span>])<br>            i--;<br>        <span class=\"hljs-keyword\">else</span><br>            j--;<br>        <span class=\"hljs-comment\">//dp[i-1][j] &lt; dp[i][j-1]时,j--;</span><br>        <span class=\"hljs-comment\">//dp[i-1][j] = dp[i][j-1]时,i--或j--,这里统一为j--;</span><br>    &#125;<br>    <br>    <span class=\"hljs-comment\">//行或列到达边界</span><br>    <span class=\"hljs-keyword\">if</span>(i==<span class=\"hljs-number\">0</span>)j--;<br>    <span class=\"hljs-keyword\">if</span>(j==<span class=\"hljs-number\">0</span>)i--;<br>&#125;<br></code></pre></td></tr></table></figure>\nPS: lc1092. 最短公共超序列</li>\n<li>求包含两个字符的最短序列， 其实就是m+n-k(k为公共序列的长度)<br>相比于公共序列， 会在i–, j– 都push_back字符; 求具体的公共序列的时候，只有相等的时候才push相等的字符<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">int</span> i=size1<span class=\"hljs-number\">-1</span>;<br><span class=\"hljs-keyword\">int</span> j=size2<span class=\"hljs-number\">-1</span>;<br>string res;<br><span class=\"hljs-keyword\">while</span>(i&gt;<span class=\"hljs-number\">0</span>&amp;&amp;j&gt;<span class=\"hljs-number\">0</span>)&#123;<br>    <span class=\"hljs-keyword\">if</span>(str1[i]==str2[j])&#123;<br>        res.<span class=\"hljs-built_in\">push_back</span>(str1[i]);<br>        i--;j--;<br>    &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>        <span class=\"hljs-keyword\">if</span>(dp[i<span class=\"hljs-number\">-1</span>][j]&gt;dp[i][j<span class=\"hljs-number\">-1</span>])&#123;<br>            res.<span class=\"hljs-built_in\">push_back</span>(str1[i]);<br>            i--;<br>        &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>            res.<span class=\"hljs-built_in\">push_back</span>(str2[j]);<br>            j--;<br>        &#125;<br>    &#125;<br>&#125;<br><span class=\"hljs-keyword\">while</span>(i&gt;<span class=\"hljs-number\">0</span>)&#123;<br>    res.<span class=\"hljs-built_in\">push_back</span>(str1[i--]);<br>&#125;<br> <span class=\"hljs-keyword\">while</span>(j&gt;<span class=\"hljs-number\">0</span>)&#123;<br>    res.<span class=\"hljs-built_in\">push_back</span>(str2[j--]);<br>&#125;<br><span class=\"hljs-built_in\">reverse</span>(res.<span class=\"hljs-built_in\">begin</span>(), res.<span class=\"hljs-built_in\">end</span>());<br></code></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>最长回文子序列</p>\n<ul>\n<li>不要求连续，枚举长度</li>\n<li>初始化长度为1和2的情况，然后<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> len=<span class=\"hljs-number\">3</span>;len&lt;=s_len;len++)&#123;<br>       <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> left=<span class=\"hljs-number\">0</span>;left&lt;s_len;left++)&#123;<br>           <span class=\"hljs-keyword\">int</span> right=left+len<span class=\"hljs-number\">-1</span>;<br>           <span class=\"hljs-keyword\">if</span>(right&lt;s_len)&#123;<br>               dp[left][right]=<span class=\"hljs-built_in\">max</span>(dp[left+<span class=\"hljs-number\">1</span>][right], dp[left][right<span class=\"hljs-number\">-1</span>]);<br>               <span class=\"hljs-keyword\">if</span>(s[left]==s[right])&#123;<br>                   dp[left][right]=<span class=\"hljs-built_in\">max</span>(dp[left][right],dp[left+<span class=\"hljs-number\">1</span>][right<span class=\"hljs-number\">-1</span>]+<span class=\"hljs-number\">2</span>);<br>               &#125; <br>           &#125;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>最长回文子串的问题 （判断true/false的dp系列）</p>\n<ul>\n<li>可以用动态规划也可以用从中间向两边扩展的方法<br>动态规划dp[left][right]不是表示长度，而是表示是否为回文子串，在求长度使用一个公共变量max_len,每求出dp 如果dp为1那么更新max_len</li>\n</ul>\n</li>\n<li><p>最长有效括号子串</p>\n<ul>\n<li>方法一：动态规划</li>\n<li>转移方程 dp[i]:以i结尾的最长有效括号子串 转移方程如下<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;s_len;i++)&#123;<br>    <span class=\"hljs-keyword\">if</span>(s[i]==<span class=\"hljs-string\">&#x27;)&#x27;</span>)&#123;<br>        <span class=\"hljs-keyword\">int</span> j=i-dp[i<span class=\"hljs-number\">-1</span>]<span class=\"hljs-number\">-1</span>;<br>        <span class=\"hljs-keyword\">if</span>(j&gt;=<span class=\"hljs-number\">0</span>&amp;&amp;s[j]==<span class=\"hljs-string\">&#x27;(&#x27;</span>)&#123;<br>            dp[i]=dp[i<span class=\"hljs-number\">-1</span>]+<span class=\"hljs-number\">2</span>;<br>            <span class=\"hljs-keyword\">if</span>(j<span class=\"hljs-number\">-1</span>&gt;=<span class=\"hljs-number\">0</span>)&#123;<br>                dp[i]+=dp[j<span class=\"hljs-number\">-1</span>];<br>            &#125;<br>        &#125;<br>        result=<span class=\"hljs-built_in\">max</span>(result, dp[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li>方法二：下标栈，栈低维护的是最后一个没有被匹配的右括号下标，如果s[i]==’(‘入栈下标; 如果s[i]==’)’, 栈中弹出一个元素，如果栈为空，直接push(i) continue，否则更新ans=max(ans, i-s.peek())</li>\n</ul>\n</li>\n<li><p>分割回文串系列题目</p>\n<ol>\n<li>分割回文串1</li>\n</ol>\n<ul>\n<li>动态规划+回溯dfs，求所有i， j之间的子字符串p[i][j]是否是回文（类似最长回文子串的题目）</li>\n</ul>\n<ol start=\"2\">\n<li>分割回文串2</li>\n</ol>\n<ul>\n<li>求最少分割次数<ul>\n<li>这道题不能使用枚举长度和左边界+枚举分割点的方式，时间复杂度太高（O(N^3)）</li>\n<li>正确的解决方案是，求dp[i] 从0到i需要分割的最少次数，同时事先需要使用动态规划求出任意i j之间是否是回文串；如果0-i是回文串，直接结果为0，否则依次遍历i之后的字符串，找到回文串j+1-i，同时更新dp[i]=min(dp[i], dp[j]+1)</li>\n<li>这道题可以和“子数组异或值为0的最多划分”进行类比（动态规划+map映射上一个位置）；不同之处这道题通过回文串映射到上一个位置，异或和是通过异或值为和当前值相同隐射到上一个位置<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;s_len;i++)&#123;<br>    dp[i]=INT_MAX;<br>&#125;<br>dp[<span class=\"hljs-number\">0</span>]=<span class=\"hljs-number\">1</span>;<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;s_len;i++)&#123;<br>    <span class=\"hljs-keyword\">if</span>(p[<span class=\"hljs-number\">0</span>][i])&#123;<br>        dp[i]=<span class=\"hljs-number\">0</span>;<br>    &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">0</span>;j&lt;i;j++)&#123; <span class=\"hljs-comment\">//类似最长递增序列 需要预处理，i, j之间是否为回文， 预处理代码i为逆序，j为顺序</span><br>            <span class=\"hljs-keyword\">if</span>(p[j+<span class=\"hljs-number\">1</span>][i])&#123;<br>                dp[i]=<span class=\"hljs-built_in\">min</span>(dp[i], dp[j]+<span class=\"hljs-number\">1</span>);<span class=\"hljs-comment\">//每一个被分割的子字符串都必须要为回文</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>&#125;<br><span class=\"hljs-keyword\">return</span> dp[s_len<span class=\"hljs-number\">-1</span>];<br></code></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<ol start=\"10\">\n<li><p>背包问题</p>\n<ul>\n<li><p>比较难的例题：货物转移（lintcode-困难） 反向dp（求背包数最少）+滚动数组+额外条件</p>\n<ul>\n<li>相当于转为两个题：</li>\n</ul>\n<ol>\n<li>从n个背包里面选择最少的背包使得背包容量大于等于sum（与选最大价值使得，重量小于sum相反）</li>\n<li>假设1求出来的结果为m, 从n个背包里面选择m个背包使得转移最少–&gt;选出的n个背包里面包含货物最多（weight最大）<br>相当于在状态转移方程再加上了一个weight数组的更新，具体代码如下：<br>dp[i]表示使得容量达到i（大于等于i），选择的最少的背包；<br>weight[i]表示使得背包容量达到i（大于等于i），在选择的背包最少的前提下，背包里原本包含的货物最多。<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;n;i++)&#123;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j=sum;j&gt;=<span class=\"hljs-number\">1</span>;j--)&#123; <span class=\"hljs-comment\">//0-1背包问题</span><br>            <span class=\"hljs-keyword\">int</span> tmp=<span class=\"hljs-built_in\">max</span>(j-b[i], <span class=\"hljs-number\">0</span>);<br>            <span class=\"hljs-comment\">// dp[j]=min(dp[tmp]+1, dp[j]); 实际上的状态转移</span><br>            <span class=\"hljs-keyword\">if</span>(dp[j]&lt;dp[tmp]+<span class=\"hljs-number\">1</span>)&#123;  <span class=\"hljs-comment\">//拆分后的状态转移</span><br>                <span class=\"hljs-comment\">// weight[j]=weight[tmp];</span><br>                <span class=\"hljs-keyword\">continue</span>;<br>            &#125;<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(dp[j]==dp[tmp]+<span class=\"hljs-number\">1</span>)&#123;<br>                weight[j]=<span class=\"hljs-built_in\">max</span>(weight[j], weight[tmp]+a[i]); <span class=\"hljs-comment\">//背包数量一样，选择权重加起来更大的背包</span><br>            &#125;<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(dp[j]&gt;dp[tmp]+<span class=\"hljs-number\">1</span>)&#123;<br>                dp[j]=dp[tmp]+<span class=\"hljs-number\">1</span>;<br>                weight[j]=weight[tmp]+a[i];<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></li>\n</ol>\n</li>\n<li><p>扩展的有关于 分组背包的问题（），每个组k的数量还不一样<br>分组背包：每组物品有若干个，同一组内的物品最多只能选一个。（每组中物品不同，个数和体积都可能不一样）<br>多重背包: 有N种物品和一个容量为V 的背包。第i种物品最多有Mi件可用，每件耗费的空间是Ci ，价值是Wi (每组物品相同，且个数相等)</p>\n<figure class=\"highlight c++\"><figcaption><span>分组背包伪代码 和多重背包有点类似也是三重循环</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-comment\">//注意这里是三层循环</span><br>    <span class=\"hljs-keyword\">for</span> 所有的组k<br>        <span class=\"hljs-keyword\">for</span> v=V to <span class=\"hljs-number\">0</span><br>            <span class=\"hljs-keyword\">for</span> 所有属于组k的i <br>            f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;<br>            end<br>        end<br>    end<br></code></pre></td></tr></table></figure>\n<p>例题：lc2218. 从栈中取出 K 个硬币的最大面值和（hard）</p>\n</li>\n<li><p>使用前缀和+动态规划</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"> <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;=n;i++)&#123; <span class=\"hljs-comment\">//注意1-n, 之后piles在进行下标访问的时候需要i-1</span><br>    <span class=\"hljs-keyword\">int</span> size=piles[i<span class=\"hljs-number\">-1</span>].<span class=\"hljs-built_in\">size</span>();<br>    <span class=\"hljs-function\">vector&lt;<span class=\"hljs-keyword\">int</span>&gt; <span class=\"hljs-title\">presum</span><span class=\"hljs-params\">(piles[i<span class=\"hljs-number\">-1</span>].size(), <span class=\"hljs-number\">0</span>)</span></span>;<br>    presum[<span class=\"hljs-number\">0</span>]=piles[i<span class=\"hljs-number\">-1</span>][<span class=\"hljs-number\">0</span>];<br>    <br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> k=<span class=\"hljs-number\">1</span>;k&lt;size;k++)&#123;<br>        presum[k]=presum[k<span class=\"hljs-number\">-1</span>]+piles[i<span class=\"hljs-number\">-1</span>][k]; <span class=\"hljs-comment\">//用前缀和表示选择前面z个</span><br>    &#125;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">1</span>;j&lt;=k;j++)&#123;<br>        dp[i][j]=dp[i<span class=\"hljs-number\">-1</span>][j];<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> z=<span class=\"hljs-number\">1</span>;z&lt;=size;z++)&#123; <span class=\"hljs-comment\">//每组的size可能都不相同</span><br>            <span class=\"hljs-keyword\">if</span>(j&gt;=z)&#123;<br>                dp[i][j]=<span class=\"hljs-built_in\">max</span>(dp[i<span class=\"hljs-number\">-1</span>][j-z]+presum[z<span class=\"hljs-number\">-1</span>], dp[i][j]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class=\"hljs-keyword\">return</span> dp[n][k];<br></code></pre></td></tr></table></figure></li>\n<li><p>背包问题求具体的转移方案：我们可以用g_{i,v}表示第 i件物品占用空间为 v的时候是否选择了此物品。</p>\n<figure class=\"highlight c++\"><figcaption><span>(感觉应该是0-1背包的)</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">int</span> v = V;  <span class=\"hljs-comment\">// 记录当前的存储空间</span><br><span class=\"hljs-comment\">// 因为最后一件物品存储的是最终状态，所以从最后一件物品进行循环</span><br><span class=\"hljs-keyword\">for</span> (从最后一件循环至第一件) &#123;<br><span class=\"hljs-keyword\">if</span> (g[i][v]) &#123;<br>    选了第 i 项物品;<br>    v -= 第 i 项物品的价值;<br>&#125; <span class=\"hljs-keyword\">else</span><br>    未选第 i 项物品;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>换钱问题<br>零钱兑换II：一定要注意虽然每个硬币都有无数个，但是不能出现重复，也就是 121  112这种情况，所以硬币的循环一定要放在最外层</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"> <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;coins.<span class=\"hljs-built_in\">size</span>();i++)&#123;<span class=\"hljs-comment\">//硬币放在最内层会发生错误</span><br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">0</span>;j&lt;=amount;j++)&#123;<br>        <span class=\"hljs-keyword\">if</span>(j&gt;=coins[i])&#123;<br>                dp[j]=dp[j]+dp[j-coins[i]];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li><p>通配符匹配问题（hard） 类似最短单词距离的动态转移</p>\n<ul>\n<li>一定要注意动态规划的状态转移方程式是i j 从 i-k j-k转移过来，不能出现i+k j+k(如果出现，一定是枚举的长度，例如回文串和打气球问题)</li>\n<li>易错点：<br>字符串的匹配问题，通常会在字符前面加上” “ dp[0][0]=1<br>同时如果i j从1开始取的话，需要初始化赋值dp[0][i] 和dp[i][0]<font color=\"blue\">\ncorner case:\ns = \"\"\np = \"******\" </font>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">dp[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">0</span>]=<span class=\"hljs-number\">1</span><br><span class=\"hljs-comment\">//下面这个循环是非常重要的</span><br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">2</span>;i&lt;p_len;i++)&#123;<br>    <span class=\"hljs-keyword\">if</span>(p[i]==<span class=\"hljs-string\">&#x27;*&#x27;</span>)&#123;<br>        dp[<span class=\"hljs-number\">0</span>][i]=dp[<span class=\"hljs-number\">0</span>][i<span class=\"hljs-number\">-1</span>]; <span class=\"hljs-comment\">// or dp[0][i]=dp[0][i-1];</span><br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;s_len;i++)&#123;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">1</span>;j&lt;p_len;j++)&#123;<br>        <span class=\"hljs-keyword\">if</span>(p[j]==<span class=\"hljs-string\">&#x27;*&#x27;</span>)&#123;<br>            dp[i][j]=dp[i<span class=\"hljs-number\">-1</span>][j]||dp[i][j<span class=\"hljs-number\">-1</span>];<br>        &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>            <span class=\"hljs-keyword\">if</span>(s[i]==p[j]||p[j]==<span class=\"hljs-string\">&#x27;?&#x27;</span>)&#123;<br>                dp[i][j]=dp[i<span class=\"hljs-number\">-1</span>][j<span class=\"hljs-number\">-1</span>]; <br>            &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>                dp[i][j]=<span class=\"hljs-number\">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li>如果不好赋值dp[i][0] or dp[0][i] 可以让i j 从0开始取，但是在状态转移的时候注意进行j 或者i的判断 if j&gt;=1  dp[j-1]<ol>\n<li>问题1：*可以匹配任意字符 </li>\n<li>问题2：*只能匹配前面字符的0个1个或多个(正则表达式匹配) 需要判断s[i] p[j-1]是否相等</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>打家劫舍</p>\n<ul>\n<li>求能够得到金额的最大值。</li>\n<li>环形可以转为dp[0][size-2]和dp[1][size-1]两者之中求最大值</li>\n<li>类似的一道题：删除并获得点数（题意：选了nums[i]， 就不能选择nums[i-1] 和nums[i+1]， 打家劫舍这里的i, i+1是下标的， 这道题是实际数字上的。两个问题都是使用dp </li>\n</ul>\n</li>\n<li><p>整数拆分 </p>\n<ul>\n<li>可以使用动态规划 二层循环 dp[i]= max(j*(i-j), j* dp[i-j])， 因为存在i-j &gt; dp[i-j]的情况</li>\n<li>或者使用数据规划，将余数为2（2<em>） 1（4</em>） 0(3*)情况区别对待</li>\n</ul>\n</li>\n<li><p>最大整除子集 </p>\n<ul>\n<li>和最长递增序列有相似之处）</li>\n<li>注意：在进行倒推序列的时候，需要记录当前的maxval 以及target_dpval, 这两者都需要在压入每个元素的时候更新</li>\n<li>相邻两个数的商不一定相等</li>\n</ul>\n</li>\n<li><p> 摆动序列 （序列最长问题）</p>\n</li>\n<li><p>无重叠区间 </p>\n<ul>\n<li>可以使用动态规划，找到以每个区间结尾的最长子序列（O(N^2)） 或者贪心，对区间右边进行排序然后选择 O(nlogn)</li>\n</ul>\n</li>\n<li><p>最后一块石头的重量 II</p>\n<ul>\n<li><p>需要理解题意之后转为背包问题，也就是最大最小问题</p>\n</li>\n<li><p>求两个子集相差的最小值 -&gt; 转为背包问题，背包容量是sum/2，求能够放入背包的最大数</p>\n<figure class=\"highlight inform7\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs inform7\">dp<span class=\"hljs-comment\">[i]</span><span class=\"hljs-comment\">[j]</span>=max(dp<span class=\"hljs-comment\">[i-1]</span><span class=\"hljs-comment\">[j]</span>, dp<span class=\"hljs-comment\">[i-1]</span><span class=\"hljs-comment\">[j-stone<span class=\"hljs-comment\">[i]</span>]</span>+stone<span class=\"hljs-comment\">[i]</span>)<br></code></pre></td></tr></table></figure></li>\n<li><p>0-1的最大背包问题，逆向枚举</p>\n</li>\n<li><p>多重背包问题也是，只能逆向枚举</p>\n</li>\n<li><p>完全背包（无限个）才是正向枚举！！！</p>\n</li>\n</ul>\n</li>\n<li><p>乘积为正数的最长子数组长度 (最长子数组系列题目)</p>\n<ul>\n<li>注意这道题是求最长的长度，不是最大的乘积，但是这两个问题都可以使用动态规划完成</li>\n</ul>\n<ol>\n<li>最长的长度，positive[i]表示以i结尾的为正数的子数组，negtive[i] i结尾的为负数的子数组，<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">if</span> (nums[<span class=\"hljs-number\">0</span>] &gt; <span class=\"hljs-number\">0</span>) &#123;<br>    positive[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">1</span>;<br>&#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (nums[<span class=\"hljs-number\">0</span>] &lt; <span class=\"hljs-number\">0</span>) &#123;<br>    negative[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">1</span>;<br>&#125;<br><span class=\"hljs-keyword\">int</span> maxLength = positive[<span class=\"hljs-number\">0</span>];<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt; length; i++) &#123;<br>    <span class=\"hljs-keyword\">if</span> (nums[i] &gt; <span class=\"hljs-number\">0</span>) &#123;<br>        positive[i] = positive[i - <span class=\"hljs-number\">1</span>] + <span class=\"hljs-number\">1</span>;<br>        negative[i] = negative[i - <span class=\"hljs-number\">1</span>] &gt; <span class=\"hljs-number\">0</span> ? negative[i - <span class=\"hljs-number\">1</span>] + <span class=\"hljs-number\">1</span> : <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">//注意一定要和0判断</span><br>    &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (nums[i] &lt; <span class=\"hljs-number\">0</span>) &#123;<br>        positive[i] = negative[i - <span class=\"hljs-number\">1</span>] &gt; <span class=\"hljs-number\">0</span> ? negative[i - <span class=\"hljs-number\">1</span>] + <span class=\"hljs-number\">1</span> : <span class=\"hljs-number\">0</span>;<br>        negative[i] = positive[i - <span class=\"hljs-number\">1</span>] + <span class=\"hljs-number\">1</span>;<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>        positive[i] = <span class=\"hljs-number\">0</span>;<br>        negative[i] = <span class=\"hljs-number\">0</span>;<br>    &#125;<br>    maxLength = Math.<span class=\"hljs-built_in\">max</span>(maxLength, positive[i]);<br>&#125;<br></code></pre></td></tr></table></figure></li>\n</ol>\n<ul>\n<li>我的思路：转为前缀和+hash<br>  题意转为：负数为1，正数为0， 0单独处理，相加和为偶数的最长子数组<br>  如果&lt;0, 那么sum+=1；<br>  如果&gt;0, 那么sum不变；<br>  如果=0, 那么sum=0，  hash.clear(), hash[0]=i；<br>  如果sum为偶数：<br>  res=max(res, i-hash[0])<br>  如果sum为奇数：<br>  如果hash[1]存在<br>  res=max(res, i-hash[1])<br>  否则hash[1]=i;</li>\n</ul>\n<ol start=\"2\">\n<li>最大乘积（可能为负数），dp1[i]表示以i结尾乘积最大子数组，dp2[i]的乘积最小(注意不一定为负数)的子数组<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;=size;i++)&#123;<br>    <span class=\"hljs-keyword\">if</span>(nums[i<span class=\"hljs-number\">-1</span>]&gt;<span class=\"hljs-number\">0</span>)&#123;<br>        dp1[i]=<span class=\"hljs-built_in\">max</span>(dp1[i<span class=\"hljs-number\">-1</span>]*nums[i<span class=\"hljs-number\">-1</span>], nums[i<span class=\"hljs-number\">-1</span>]);<br>        dp2[i]=<span class=\"hljs-built_in\">min</span>(dp2[i<span class=\"hljs-number\">-1</span>]*nums[i<span class=\"hljs-number\">-1</span>], nums[i<span class=\"hljs-number\">-1</span>]);<br>    &#125;<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(nums[i<span class=\"hljs-number\">-1</span>]&lt;<span class=\"hljs-number\">0</span>)&#123;<br>        dp1[i]=<span class=\"hljs-built_in\">max</span>(dp2[i<span class=\"hljs-number\">-1</span>]*nums[i<span class=\"hljs-number\">-1</span>], nums[i<span class=\"hljs-number\">-1</span>]);<br>        dp2[i]=<span class=\"hljs-built_in\">min</span>(dp1[i<span class=\"hljs-number\">-1</span>]*nums[i<span class=\"hljs-number\">-1</span>], nums[i<span class=\"hljs-number\">-1</span>]);<br>    &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>        dp1[i]=<span class=\"hljs-number\">0</span>;<br>        dp2[i]=<span class=\"hljs-number\">0</span>;<br>    &#125;<br>    res=<span class=\"hljs-built_in\">max</span>(res, dp1[i]);<br></code></pre></td></tr></table></figure></li>\n</ol>\n</li>\n</ol>\n<ol start=\"20\">\n<li><p>最低票价</p>\n<ul>\n<li><p>找到能够让days天都观光的最低票价，类似完全背包问题， 最少兑换钞票</p>\n</li>\n<li><p>dp[i]定义为至少让index==i天观光所需要的最低票价， 分别遍历决策1，决策2， 决策3需要的最低票价</p>\n</li>\n<li><p>solution 1：每天进行dp + 从后往前</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">int</span> len = days.length, maxDay = days[len - <span class=\"hljs-number\">1</span>], minDay = days[<span class=\"hljs-number\">0</span>];<br><span class=\"hljs-keyword\">int</span>[] dp = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[maxDay + <span class=\"hljs-number\">31</span>]; <span class=\"hljs-comment\">// 多扩几天，省得判断 365 的限制</span><br><span class=\"hljs-comment\">// 只需看 maxDay -&gt; minDay，此区间外都不需要出门，不会增加费用</span><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> d = maxDay, i = len - <span class=\"hljs-number\">1</span>; d &gt;= minDay; d--) &#123;<br>    <span class=\"hljs-comment\">// i 表示 days 的索引</span><br>    <span class=\"hljs-comment\">// 也可提前将所有 days 放入 Set，再通过 set.contains() 判断</span><br>    <span class=\"hljs-keyword\">if</span> (d == days[i]) &#123;<br>        dp[d] = Math.<span class=\"hljs-built_in\">min</span>(dp[d + <span class=\"hljs-number\">1</span>] + costs[<span class=\"hljs-number\">0</span>], dp[d + <span class=\"hljs-number\">7</span>] + costs[<span class=\"hljs-number\">1</span>]); <span class=\"hljs-comment\">//三种情况</span><br>        dp[d] = Math.<span class=\"hljs-built_in\">min</span>(dp[d], dp[d + <span class=\"hljs-number\">30</span>] + costs[<span class=\"hljs-number\">2</span>]);<br>        i--; <span class=\"hljs-comment\">// 别忘了递减一天</span><br>    &#125; <span class=\"hljs-keyword\">else</span> dp[d] = dp[d + <span class=\"hljs-number\">1</span>]; <span class=\"hljs-comment\">// 不需要出门</span><br>&#125;<br><span class=\"hljs-keyword\">return</span> dp[minDay]; <span class=\"hljs-comment\">// 从后向前遍历，返回最前的 minDay</span><br></code></pre></td></tr></table></figure></li>\n<li><p>solution 2：只从days包含的天数进行dp + 从前往后</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">int</span> valid[<span class=\"hljs-number\">3</span>]=&#123;<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">30</span>&#125;;<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;size;i++)&#123;<br>    dp[i]=INT_MAX;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">0</span>;j&lt;n;j++)&#123;<br>        <span class=\"hljs-keyword\">if</span>(days[i]-valid[j]&lt;days[<span class=\"hljs-number\">0</span>])&#123;<br>            dp[i]=<span class=\"hljs-built_in\">min</span>(dp[i], costs[j]); <br>        &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>            <span class=\"hljs-keyword\">int</span> index=<span class=\"hljs-built_in\">upper_bound</span>(days.<span class=\"hljs-built_in\">begin</span>(), days.<span class=\"hljs-built_in\">end</span>(), days[i]-valid[j])-days.<span class=\"hljs-built_in\">begin</span>();<br>            <span class=\"hljs-comment\">//找到对应的前面天数对应的下标</span><br>            <span class=\"hljs-comment\">// cout&lt;&lt;index&lt;&lt;endl;</span><br>            dp[i]=<span class=\"hljs-built_in\">min</span>(dp[index<span class=\"hljs-number\">-1</span>]+costs[j], dp[i]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"数学相关问题（找规律）\"><a href=\"#数学相关问题（找规律）\" class=\"headerlink\" title=\"数学相关问题（找规律）\"></a>数学相关问题（找规律）</h3><ol>\n<li><p>计算各个位数不同的数字个数 </p>\n<ul>\n<li>其实就是9* 9 * 8* 7这种情况）但是要注意是n位数以内的n位数都需要计算，开始各位数有10种情况，后面在当前数插入数据的时候，最开头有9种情况，后面数据有（10-1）种情况，因为后面的数据是可以为0的（固定前面，枚举后面）</li>\n</ul>\n</li>\n<li><p>消除游戏 和约瑟夫环问题</p>\n<ul>\n<li><p>解决方案一：使用之后的下标和之前下标的映射 来解决（删除后，末尾从1开始编号）<br>2 ~ 2k映射为k ~ 1那么还原的规律f(2k)=2*(k+1-f(k))</p>\n</li>\n<li><p>解决方案二：每次记录剩下链表的头结点，如果当前剩下的个数==1那么直接返回这个数</p>\n</li>\n<li><p>约瑟夫环递推问题的公式<br>𝑓(𝑛)=(𝑓(𝑛−1)+𝑚)%𝑛  （一共n个人，数到m的人被杀）<br>def lastRemaining(n, m):<br>if n == 1: return 0<br>return (lastRemaining(n-1, m) + m) % n</p>\n</li>\n</ul>\n</li>\n<li><p>第 N 位数字（一位）</p>\n<ul>\n<li><p>题意： 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,顺序排列后的第n位数字</p>\n</li>\n<li><p>找到不同位数包含的数字number= base*10-base,如果n&gt;这个数那么更新n-=number * weishu,否则就在这个位数里面查找</p>\n</li>\n<li><p>如果当前的数%位数==0，那么当前的数字是cur_num=base+n/weishu-1, 否则当前的数字为cur_num=base+n/weishu，然后计算在当前数字里面对应具体哪个数字， 为(cur_num/pow(10, weishu-n%weishu))%10</p>\n</li>\n<li><p>扩展：还有一个排序后的第n个数 （一个数）二叉树，求两个节点直接夹的数组，类似于上面这道题base* 10的操作，如果小于，那么就往二叉树的下一层节点走（a=a<em>10, b=b</em>10, 知道a大于n, 退出向下搜索的循环）</p>\n</li>\n</ul>\n</li>\n<li><p>灯泡开关/灯泡开关II</p>\n<ul>\n<li>主要是找到规律前6个灯泡可以推导出其他灯泡的状态，更进一步是，前三个灯可以推导后面所有的状态，因此有状态16种</li>\n<li>只需要枚举每个灯泡的每种状态(为0或者为1)就可以了因此是16种情况，用4位表示； 1的数量num num&lt; m， 而且num%2 == m%2</li>\n<li>同时要注意可能灯泡小于6， 因此需要shift=max(6-n, 0)</li>\n<li>然后再将每个状态异或起来就可以了<br>（找规律，但不是动态规划问题）</li>\n</ul>\n</li>\n</ol>\n<ol start=\"5\">\n<li><p>到达终点数字</p>\n<ul>\n<li>左右走，步数为1， 2， 3，…。也是属于找规律，但是不是动态规划的问题 </li>\n<li>找到连加中大于target的最小sum(cur=k),然后求delta=sum-target,如果为奇数那么k++, 直到为delta偶数 (那么就可以减去delta/2)，然后返回当前k值</li>\n</ul>\n</li>\n<li><p>子矩阵问题(lintcode)</p>\n<ol>\n<li><p>第一种题型，要求矩阵内部的元素全部为1，那么以i， j为右下角的最长矩阵边长为</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">if</span>(matrix[i][j]==<span class=\"hljs-number\">1</span>)&#123;<br>    dp[i][j]=<span class=\"hljs-built_in\">min</span>(dp[i][j<span class=\"hljs-number\">-1</span>], dp[i<span class=\"hljs-number\">-1</span>][j], dp[i<span class=\"hljs-number\">-1</span>][j<span class=\"hljs-number\">-1</span>])+<span class=\"hljs-number\">1</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>那么以 i， j为右下角的子矩阵的个数为dp[i][j]个</p>\n</li>\n<li><p>要求矩形框最长, 那么每个点需要为何它上面最长 up，和左边最长 left， 两个数组</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">int</span> tmp = <span class=\"hljs-built_in\">min</span>(left[i][j<span class=\"hljs-number\">-1</span>], up[i<span class=\"hljs-number\">-1</span>][j])+<span class=\"hljs-number\">1</span>;<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> len=tmp<span class=\"hljs-number\">-1</span>;len&gt;=<span class=\"hljs-number\">1</span>;len--)&#123; <span class=\"hljs-comment\">//枚举长度，使得4个边长都是在len之内，说明能围成一个框</span><br>    <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">min</span>(up[i][j-len], left[i-len][j])&gt;=len)&#123;<br>        <span class=\"hljs-keyword\">return</span> len+<span class=\"hljs-number\">1</span>;<span class=\"hljs-comment\">//返回枚举得到的最长边框</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n</ol>\n</li>\n</ol>\n<p><font color=\"red\">7. 捡苹果(lintcode) </font><br>    - 前后缀问题(找两个区间，一个区间连续k个数，一个区间连续l个数，两个区间不相交且和最大)<br>    - solution: 枚举中间的划分点i,使得<br>    <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">res=<span class=\"hljs-built_in\">max</span>(res, presumK[i]+postsumL[i+<span class=\"hljs-number\">1</span>])<br>res=<span class=\"hljs-built_in\">max</span>(res, presumL[i]+postsumK[i+<span class=\"hljs-number\">1</span>])<br></code></pre></td></tr></table></figure><br>    - 思路没问题：主要是没有找打0<del>i之前连续窗口最大值与i</del>len-1 连续窗口的最大值怎么求<br>    - 计算前缀和后缀数组，注意如果index转为1~size，那么后缀数组需要开size+2 !!!!<br>    <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=K;i&lt;=size;i++)&#123;<br>    presumK[i]=<span class=\"hljs-built_in\">max</span>(presum[i]-presum[i-K], presumK[i<span class=\"hljs-number\">-1</span>]);<br>&#125;<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=L;i&lt;=size;i++)&#123;<br>    presumL[i]=<span class=\"hljs-built_in\">max</span>(presum[i]-presum[i-L], presumL[i<span class=\"hljs-number\">-1</span>]);<br>&#125;<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=size-K+<span class=\"hljs-number\">1</span>;i&gt;=<span class=\"hljs-number\">1</span>;i--)&#123;<br>    postsumK[i]=<span class=\"hljs-built_in\">max</span>(presum[i+K<span class=\"hljs-number\">-1</span>]-presum[i<span class=\"hljs-number\">-1</span>], postsumK[i+<span class=\"hljs-number\">1</span>]);<br>&#125;<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=size-L+<span class=\"hljs-number\">1</span>;i&gt;=<span class=\"hljs-number\">1</span>;i--)&#123;<br>    postsumL[i]=<span class=\"hljs-built_in\">max</span>(presum[i+L<span class=\"hljs-number\">-1</span>]-presum[i<span class=\"hljs-number\">-1</span>], postsumL[i+<span class=\"hljs-number\">1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure></p>\n<ol start=\"8\">\n<li><p>钢笔和</p>\n<ul>\n<li>题意：找到两个不相交的区间，每个区间和都为target, 使得这两个区间len之和最小，其实也可以向上一题一样，分为pre post,然后枚举划分点，使用分治算法进行计算</li>\n</ul>\n</li>\n<li><p>可被三整除的最大和 这道题和lc1363 形成3的最大倍数是一样的思路</p>\n<ul>\n<li><p>不要求是连续</p>\n</li>\n<li><p>使用余数的递归公式 dp[i][j]表示以i结尾的余数为j的最大和</p>\n</li>\n<li><p>那么就要根据nums[i]%3的余数分类别更新dp[i][0], dp[i][1], dp[i][2]</p>\n</li>\n<li><p>一个更简单的方法是 </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">a=remainder[<span class=\"hljs-number\">0</span>]+nums[i]; <br>b=remainder[<span class=\"hljs-number\">1</span>]+nums[i];<br>c=remainder[<span class=\"hljs-number\">2</span>]+nums[i];<span class=\"hljs-comment\">//因为可以不连续</span><br>remainder[a%<span class=\"hljs-number\">3</span>]=<span class=\"hljs-built_in\">max</span>(remainder[a%<span class=\"hljs-number\">3</span>], a);<span class=\"hljs-comment\">//a对余数就是a%3,所以分在一组</span><br>remainder[b%<span class=\"hljs-number\">3</span>]=<span class=\"hljs-built_in\">max</span>(remainder[b%<span class=\"hljs-number\">3</span>], b);<br>remainder[c%<span class=\"hljs-number\">3</span>]=<span class=\"hljs-built_in\">max</span>(remainder[c%<span class=\"hljs-number\">3</span>], c);<br></code></pre></td></tr></table></figure></li>\n<li><p>PS: 类似的一个题：将字符串翻转到单调递增<br>dp[i][0]表示前i个数以0结尾，dp[i][0]表示前i个数以1结尾<br>易错点：dp[i][1]=min(dp[i-1][0], dp[i-1][1]) //以1结尾的时候，前面以0结尾是不需要+1的</p>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"博弈论相关问题\"><a href=\"#博弈论相关问题\" class=\"headerlink\" title=\"博弈论相关问题\"></a>博弈论相关问题</h3><ol>\n<li>石子问题</li>\n<li>预测家，当前只能从石子序列的头或者尾部进行取，那么使用枚举长度的动态规划+前缀和 （区dp） 注意这道题和lc1423. 可获得的最大点数 不一样因为这个是一定要拿完，而且有两个人拿，而lc1423是一个人拿，所以使用滑动窗口解决 n-k的窗口内数据最小就行</li>\n<li>能赢吗， 因为是从1-n中随机取，而且取了之后就不能取了，所以使用带记忆的dfs, 使用位图来记录当前状态是否遍历过 dp[state]</li>\n</ol>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><ol>\n<li><p>斐波拉切数列问题</p>\n</li>\n<li><p>成熟的牛不断生小牛的问题</p>\n</li>\n<li><p>汉罗塔问题</p>\n</li>\n<li><p>走地图问题（最短/最长价值/龙与地下城游戏）</p>\n</li>\n<li><p>扔鸡蛋问题</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">dp[i][j]=<span class=\"hljs-number\">1</span>+dp[i<span class=\"hljs-number\">-1</span>][j<span class=\"hljs-number\">-1</span>]+dp[i<span class=\"hljs-number\">-1</span>][j] <span class=\"hljs-comment\">//dp[i][j]表示用i次操作j个鸡蛋能够验证的最高高度</span><br></code></pre></td></tr></table></figure></li>\n<li><p>画匠问题</p>\n<ul>\n<li><p>动态规划或者二分算法</p>\n</li>\n<li><p>动态规划：类似于鸡蛋问题，可以使用滑动数组，将二维转为一维，但是在转的时候注意i j的顺序 dp[i-1][0<del>j]可以转 dp[0</del>i][j]不太好转</p>\n</li>\n<li><p>二分解法如下<br>二分法，限制所有画作完成的时长，然后检查在这个时长限制下画家的数量够不够。够的话说明时间还可以压缩，不够的话就要放宽时长限制，多给一些时间。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">getNumber</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> limit)</span></span>&#123;<br>    <span class=\"hljs-keyword\">int</span> cnt=<span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">int</span> tmpsum=<span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;arr.<span class=\"hljs-built_in\">size</span>();i++)&#123;<br>        tmpsum+=arr[i];<br>        <span class=\"hljs-keyword\">if</span>(tmpsum&gt;limit)&#123;<br>            cnt++;<br>            tmpsum=arr[i];<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> cnt+<span class=\"hljs-number\">1</span>;<br>&#125;<br><span class=\"hljs-keyword\">int</span> left=INT_MIN, right=<span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">//表示一个画家画的时长</span><br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;arr.<span class=\"hljs-built_in\">size</span>();i++)&#123;<br>    left=<span class=\"hljs-built_in\">max</span>(arr[i], left);<br>    right+=arr[i];<br>&#125;<br><br><span class=\"hljs-keyword\">if</span>(K&gt;=arr.<span class=\"hljs-built_in\">size</span>())&#123;<span class=\"hljs-comment\">//如果画家数量比画多</span><br>    <span class=\"hljs-keyword\">return</span> left;<span class=\"hljs-comment\">//返回时长最大的画</span><br>&#125;<br><br><span class=\"hljs-keyword\">while</span>(left&lt;right)&#123;<br>    <span class=\"hljs-keyword\">int</span> mid=left+(right-left)/<span class=\"hljs-number\">2</span>;<br>    <span class=\"hljs-keyword\">int</span> tmp=<span class=\"hljs-built_in\">getNumber</span>(mid);<br>    <span class=\"hljs-keyword\">if</span>(tmp==K)&#123;<br>        right=mid;<br>    &#125;<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(tmp&lt;K)&#123;<br>        right=mid<span class=\"hljs-number\">-1</span>;<span class=\"hljs-comment\">//应该也可以和tmp==K合并为right=mid</span><br>    &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>        left=mid+<span class=\"hljs-number\">1</span>;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">return</span> right;<span class=\"hljs-comment\">//最小的时长</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n<p><font color=\"red\">7. 邮局选址的问题</font><br>    - 转移状态的枚举类似于画匠问题<br>    - 因为两个邮局的情况，不清楚那个邮局负责哪些居民区，那么就枚举，然后求最小。<br>    - 这道题前提是要知道：建立一个邮局的时候，建在中间是最优的情况！<br>        1. 提前求i ~ j这段距离建立一个邮局的最小距离<br>        2. dp[i][j]表示0 ~ i这段居民区，有j+1个邮局的最小距离   也可以改成j对应j个邮局，这样初始化dp[i][1],循环j从 2 ~ num<br>        3. 初始化边界dp[i][0]=w[0][i];<br>        4. 建立转移方程： dp[i][j]=min(dp[k][j-1]+w[k+1][i], dp[i][j]) k从0到i，（官方题解：两端值都取!!!!!），表示建邮局的位置<br>        注意j&lt;=i，当j&gt;i dp=0; 每次进入k循环的时候，在初始化dp[i][j]=INT_MAX<br>        5. 返回结果 dp[n-1][K-1];<br>        <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">int</span> w[size+<span class=\"hljs-number\">1</span>][size+<span class=\"hljs-number\">1</span>];<br><span class=\"hljs-comment\">//求任意两个居民点之间建立一个邮局的最短距离</span><br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;size;i++)&#123;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j=i+<span class=\"hljs-number\">1</span>;j&lt;size;j++)&#123;<br>        w[i][j]=w[i][j<span class=\"hljs-number\">-1</span>]+a[j]-a[(i+j)/<span class=\"hljs-number\">2</span>];<br>    &#125;<br>&#125;<br>dp[i][<span class=\"hljs-number\">0</span>]=w[<span class=\"hljs-number\">0</span>][i];<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;=size<span class=\"hljs-number\">-1</span>;i++)&#123;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">1</span>;j&lt;=num<span class=\"hljs-number\">-1</span>;j++)&#123;  <br>        <span class=\"hljs-keyword\">if</span>(j&gt;=i)&#123;<span class=\"hljs-comment\">//邮局数量&gt;=居民区数量  如果不进行判断就需要 k&lt;=i，否则就会因为进不去 k 的循环，导致dp[i][j]=INT_MAX</span><br>            dp[i][j]=<span class=\"hljs-number\">0</span>;<br>        &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>            dp[i][j]=INT_MAX;<br>            <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> k=<span class=\"hljs-number\">0</span>;k&lt;i;k++)&#123;<br>                dp[i][j]=<span class=\"hljs-built_in\">min</span>(dp[k][j<span class=\"hljs-number\">-1</span>]+ w[k+<span class=\"hljs-number\">1</span>][i], dp[i][j]); <span class=\"hljs-comment\">//注意k+1可能==size，因此需要w需要size+1空间</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>        总结，从左到右开始建立，而不是使用二进制记录状态，随机建立<br>        状态转移类似最长递增子序列的思路， 需要提前计算i， j之间建立一个邮局的最短距离</p>\n<p><font color=\"red\">8. 数组的最大价值 (区间dp)</font><br>    - 题意，就是找任意不相交区间且每个区间首位值相等，使得这些区间加起来价值最大<br>    - 转移方程：<br>  <code>  dp[i]=max(dp[i-1], dp[j-1]+presum[i]-presum[j-1]); （a[i]==a[j]）</code><br>    因为需要a[j]==a[i]，如果使用二重循环会超时<br>    解决方案：<br>    （1）使用hash存储不同a[i]对应的下标<br>    （2）记录另外一个hash 使得hash[a[i]]=max(hash[a[i]], dp[i-1]-presum[i-1])<br>    - 之后再进行更新就不用循环找与i相同的下标j,可以直接更新dp[i]=max(dp[i-1], presum[i]+hash[a[i]]);<br>（注意要对hash[a[i]]是否存在进行分类讨论）</p>\n<p><font color=\"red\">9. 盒子放置（谷歌）/现在无权限查看</font><br>    - 使用动态规划的思想；<br>    - dp[i][j] 表示当前第i个box，第j个position能放置的最多的box数量。<br>    如果 box[i - 1] &lt;= position[j - 1]，则dp[i][j] = dp[i - 1][ j - 1] + 1 贪心，放在最后一个位置最好<br>    反之，dp[i][j] = max(dp[i-1][j], dp[i][j - 1]) 其中di[i-1][j]表示不放第i个box, dp[i][j - 1] 第i个box不放在j个位置<br>    **重要！！！！！**<br>    - 注意下标i从0 ~ n-1，但是这个因为有w，所以最好和w对应，不转为1 ~ n。<br>    从i从0开始取的话，每次k循环，划分两个部分相加， 后半部分都不会包含第一个数，因此j要从2开始取，否则就会造成dp[0][0]//第一个0代表有地址，第二个0代表无邮局，就会返回INT_MAX,造成结果错误<br>    背包问题，i下标是1~n 因为i可能从i-1推导，需要i&gt;=1</p>\n<ol start=\"8\">\n<li>“马”在棋盘上的概率<ul>\n<li>类似的==地图问题==，虽然当前位置可以由它四面八方的位置推出来，但是因为步数，所以对应的三维数组还是由之前的状态推导出来，因此仍然可以使用动态规划<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> K=<span class=\"hljs-number\">1</span>;K&lt;=k;K++)&#123;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;n;i++)&#123;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">0</span>;j&lt;n;j++)&#123;<br>            <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> q=<span class=\"hljs-number\">0</span>;q&lt;<span class=\"hljs-number\">8</span>;q++)&#123;<br>                <span class=\"hljs-keyword\">int</span> nextx=i+dx[q];<br>                <span class=\"hljs-keyword\">int</span> nexty=j+dy[q];<br>                <span class=\"hljs-keyword\">if</span>(nextx&gt;=<span class=\"hljs-number\">0</span>&amp;&amp;nextx&lt;n&amp;&amp;nexty&gt;=<span class=\"hljs-number\">0</span>&amp;&amp;nexty&lt;n)&#123;<br>                    dp[i][j][K]+=dp[nextx][nexty][K<span class=\"hljs-number\">-1</span>]/<span class=\"hljs-number\">8.0</span>; <span class=\"hljs-comment\">//下一个和当前反过来感觉也行</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class=\"hljs-keyword\">double</span> sum=<span class=\"hljs-number\">0.0</span>;<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;n;i++)&#123;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">0</span>;j&lt;n;j++)&#123;<br>        sum+=dp[i][j][k]; <span class=\"hljs-comment\">//k步走到每个棋盘的概率加起来</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"字符串与动态规划\"><a href=\"#字符串与动态规划\" class=\"headerlink\" title=\"字符串与动态规划\"></a>字符串与动态规划</h3><p>也可以划分到Trie树问题:一般是对单词建立Trie树</p>\n<ol>\n<li>单词拆分问题（<ul>\n<li>dp代表的是True or False</li>\n<li>dp+第二层循环枚举字典里面的每一个单词，看是否恰好是当前遍历序列0~i的最后几个字符<br>为了进一步减少时间，内层训练从i枚举到0，同时为true的时候直接退出<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;size;i++)&#123; <span class=\"hljs-comment\">//遍历字符串的每一个字符</span><br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j=i;j&gt;=<span class=\"hljs-number\">0</span>;j--)&#123;<br>        string tmp=s.<span class=\"hljs-built_in\">substr</span>(j, i-j+<span class=\"hljs-number\">1</span>);<br>        <span class=\"hljs-keyword\">if</span>(wordSet.<span class=\"hljs-built_in\">find</span>(tmp)!=wordSet.<span class=\"hljs-built_in\">end</span>())&#123;<br>            dp[i]=dp[i]|dp[j<span class=\"hljs-number\">-1</span>];<br>        &#125;<br>        <span class=\"hljs-keyword\">if</span>(dp[i])&#123;<br>            <span class=\"hljs-keyword\">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br>方法二：<br>以当前判断后面的字符串<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;=s.<span class=\"hljs-built_in\">size</span>();i++)&#123;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">0</span>;j&lt;wordDict.<span class=\"hljs-built_in\">size</span>();j++)&#123;<br>        <span class=\"hljs-keyword\">if</span>(!dp[i])&#123;<br>            <span class=\"hljs-keyword\">continue</span>;<br>        &#125;<br>        string tmp=s.<span class=\"hljs-built_in\">substr</span>(i,wordDict[j].<span class=\"hljs-built_in\">size</span>());<br>        <span class=\"hljs-keyword\">if</span>(tmp==wordDict[j])&#123;<br>            dp[i+wordDict[j].<span class=\"hljs-built_in\">size</span>()]=<span class=\"hljs-literal\">true</span>;<br>        <br>            path[i].<span class=\"hljs-built_in\">push_back</span>(i+wordDict[j].<span class=\"hljs-built_in\">size</span>());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<font color=\"red\">单词拆分II需要求出所有可行的解</font><br>为了避免重复的计算和对比，字符串的前缀是否包含单词表里面的单词，需要使用单词拆分1的方法将i后面对应的true的下标放在hash&lt;int, vector&gt;里面记录起来，这样之后再进行遍历的时候就不需要重复判断；<br>另外一个去处回溯的重复方案是， 将一个下标后面的字符串对应的可以拆分方案提前记录起来（hash&lt;int, vector&lt;vector<int>&gt;），这样的话，就不用对同一下标进行多次重复求值（类似于二叉树的组成类似的）</int></li>\n</ul>\n</li>\n</ol>\n<p><font color=\"red\">2. 恢复空格问题(代表的无效字符的个数)- 使用Trie树的经典案例 </font><br>    - 都可以转为Trie树+dp类型的题目<br>    - 这个不能暴力erase,因为可能出现一个单词是另外一个单词的前缀，可能导致erase顺序不同，结果不同；这个只能使用字典序；<br>    - 另外一个减少暴力深搜索带来的超时问题，可以使用第二层循环每次枚举dict的每个元素，看是否与当前遍历序列的最后几个字符相同，而不是每个不同长度的单词一个一个的进行比较。<br>    - 多次搜索：使用暴力的string find或者使用将small单词列表建立Trie树，然后big以每个字符为开头，查找字符串是否出现在Trie树中，在查找的路径中如果遇到isend=True说明找到了一个字符<br>    然后继续找下去</p>\n<ol start=\"3\">\n<li><p>环绕字符串中唯一的子字符串</p>\n<ul>\n<li>题意为：找到子串字符必须是连续的，这样的子串的个数，但是这样可以会出现重复比如abcbc，所以要使用dp (其实就是hash，记录以某个字符结尾的最长的子串)</li>\n<li>计算出26个英文字母中每一个英文字母的结尾的最长的连续的环绕字符串，然后求和</li>\n<li>PS：注意字符串去重，如果不考虑去重的话，可以直接使用滑动窗口记录子串个数；因为这个滑动窗口是直接出现不连续，窗口长度直接退化为1，所以可以只记录窗口长度，不记录窗口左右两端</li>\n</ul>\n</li>\n<li><p>lc97. 交错字符串</p>\n</li>\n</ol>\n<ul>\n<li>求第三个字符串是否能由第一个和第二个字符串组合得到，是否问题</li>\n<li>易错点：不能使用双指针，因为针对一个两个字符串相同的情况可能造成错误</li>\n<li>使用动态规划，dp[i][j]表示字符串1的前i个字符和字符串1的前j个字符能否组成第三个字符串的i+j个字符</li>\n</ul>\n<h3 id=\"状态压缩\"><a href=\"#状态压缩\" class=\"headerlink\" title=\"状态压缩\"></a>状态压缩</h3><ol>\n<li><p>划分为k个相同子集，也可以看做dfs+回溯+贪心</p>\n<ul>\n<li>状态压缩的话就是dp[i]中i的每一个数由二进制位的状态组成，然后遍历二进制的每一个状态，当前的状态可以由当前状态中任意取消一个1的状态转移过来，或者用当前的状态更新下一个状态（将状态中为0的转为1），只有只有dp[i]=true, 而且当前状态的和%target+nums[i]&lt;=target下一个状态才为true,否则为false<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">bool</span> <span class=\"hljs-title\">canPartitionKSubsets</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&amp; nums, <span class=\"hljs-keyword\">int</span> k)</span> </span>&#123;<br>        <span class=\"hljs-keyword\">int</span> size=nums.<span class=\"hljs-built_in\">size</span>();<br>        <span class=\"hljs-keyword\">int</span> total_sum=<span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;size;i++)&#123;<br>            total_sum+=nums[i];<br>        &#125;<br>        <span class=\"hljs-keyword\">if</span>(total_sum%k!=<span class=\"hljs-number\">0</span>)&#123;<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>        &#125;<br>        <span class=\"hljs-keyword\">int</span> target=total_sum/k;<br>        <span class=\"hljs-built_in\">sort</span>(nums.<span class=\"hljs-built_in\">begin</span>(), nums.<span class=\"hljs-built_in\">end</span>());<br>        <span class=\"hljs-keyword\">int</span> total_state=<span class=\"hljs-number\">1</span>&lt;&lt;size;<br>        <span class=\"hljs-function\">vector&lt;<span class=\"hljs-keyword\">bool</span>&gt; <span class=\"hljs-title\">dp</span><span class=\"hljs-params\">(total_state, <span class=\"hljs-literal\">false</span>)</span></span>;<br>        <span class=\"hljs-function\">vector&lt;<span class=\"hljs-keyword\">int</span>&gt; <span class=\"hljs-title\">sum</span><span class=\"hljs-params\">(total_state, <span class=\"hljs-number\">0</span>)</span></span>;<br>        dp[<span class=\"hljs-number\">0</span>]=<span class=\"hljs-literal\">true</span>;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;total_state;i++)&#123;<br>            <span class=\"hljs-keyword\">if</span>(!dp[i])&#123;<br>                <span class=\"hljs-keyword\">continue</span>;<br>            &#125;<br>            <span class=\"hljs-comment\">// cout&lt;&lt;i&lt;&lt;endl;</span><br>            <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">0</span>;j&lt;size;j++)&#123;<br>                <span class=\"hljs-comment\">// cout&lt;&lt;j&lt;&lt;endl;</span><br>                <span class=\"hljs-keyword\">if</span>((i&amp;(<span class=\"hljs-number\">1</span>&lt;&lt;j))==<span class=\"hljs-number\">0</span>)&#123;   <span class=\"hljs-comment\">//注意：位运算一定要记得打上括号之后再判断是否相等，否则会出错！！！！！</span><br>                    <span class=\"hljs-keyword\">int</span> next=i|(<span class=\"hljs-number\">1</span>&lt;&lt;j);<br>                    <span class=\"hljs-comment\">// cout&lt;&lt;next&lt;&lt;endl;</span><br>                    <span class=\"hljs-keyword\">if</span>(sum[i]%target+nums[j]&lt;=target)&#123;<br>                        sum[next]=sum[i]+nums[j];<br>                        dp[next]=<span class=\"hljs-literal\">true</span>;<br>                        cout&lt;&lt;next&lt;&lt;endl;<br>                    &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>                        <span class=\"hljs-keyword\">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> dp[total_state<span class=\"hljs-number\">-1</span>];<br></code></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>优美的排列</p>\n<ul>\n<li>也是状态压缩 或者回溯，相比第2题需要枚举当前位置放的数是哪个，所以多一层循环。上面那道题因为数的位置是固定的，所以只需要判断这个数放没放。</li>\n<li>其实还是顺序放，当前放了m个，那么下一个要放的数就是m+1， 所以也可以不同像下面的题解一样多一层循环（3月8日修改）<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> &#123;</span><br><span class=\"hljs-class\"><span class=\"hljs-title\">public</span>:</span><br>    <span class=\"hljs-built_in\">int</span> count(<span class=\"hljs-built_in\">int</span> number)&#123;<br>        <span class=\"hljs-built_in\">int</span> res=<span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-keyword\">while</span>(number!=<span class=\"hljs-number\">0</span>)&#123;<br>            <span class=\"hljs-keyword\">if</span>(number&amp;<span class=\"hljs-number\">1</span>)&#123;<br>                res++;<br>            &#125;<br>            number=number&gt;&gt;<span class=\"hljs-number\">1</span>;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> res;<br>    &#125;<br>    <span class=\"hljs-built_in\">int</span> countArrangement(<span class=\"hljs-built_in\">int</span> n) &#123;<br>        <span class=\"hljs-built_in\">int</span> state=<span class=\"hljs-number\">1</span>&lt;&lt;n;<br>        <br>        vector&lt;<span class=\"hljs-built_in\">int</span>&gt; dp(state, <span class=\"hljs-number\">0</span>);<br>        dp[<span class=\"hljs-number\">0</span>]=<span class=\"hljs-number\">1</span>;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-built_in\">int</span> num=<span class=\"hljs-number\">1</span>;num&lt;=n;num++)&#123; //类似背包的，当前放第num数， 标准答案是将状态放在外层， 然后通过<span class=\"hljs-number\">1</span>个个数判断当前的num<br>            <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-built_in\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;state;i++)&#123;<br>                // <span class=\"hljs-keyword\">if</span>(!dp[i])&#123;<br>                //     <span class=\"hljs-keyword\">continue</span>;<br>                // &#125;<br>                <span class=\"hljs-keyword\">if</span>(count(i)!=num-<span class=\"hljs-number\">1</span>)&#123;<br>                    <span class=\"hljs-keyword\">continue</span>;<br>                &#125;<br>                <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-built_in\">int</span> j=<span class=\"hljs-number\">0</span>;j&lt;n;j++)&#123;<br>                    <span class=\"hljs-keyword\">if</span>((i&amp;(<span class=\"hljs-number\">1</span>&lt;&lt;j))==<span class=\"hljs-number\">0</span>)&#123;<br>                        <span class=\"hljs-keyword\">if</span>(num%(j+<span class=\"hljs-number\">1</span>)==<span class=\"hljs-number\">0</span>||(j+<span class=\"hljs-number\">1</span>)%num==<span class=\"hljs-number\">0</span>)&#123;<br>                            <span class=\"hljs-built_in\">int</span> <span class=\"hljs-built_in\">next</span>=i^(<span class=\"hljs-number\">1</span>&lt;&lt;j);<br>                            dp[<span class=\"hljs-built_in\">next</span>]+=dp[i];<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> dp[state-<span class=\"hljs-number\">1</span>];<br>        <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>华为的一个机试题目</p>\n<ul>\n<li><p>需要在规定燃油内（规定长度内）得到的资源最大化（有点像0-1背包问题）， 但是这个不同之处在于：从不同点到相同的i，消耗的燃油是不一样的， 而且这个最后还需要回到原点，所以dist需要走过的位置mask 以及最后的位置i</p>\n</li>\n<li><p>其实就是先求每个mask的最小dist, 得到d[mask][i]:也就是以i结尾的最小燃油，然后遍历这个数组，如果d[mask][i]+fuel[i][0]&lt;=maxdist 那么更新ans<br>ans=max(ans, g[mask])</p>\n</li>\n<li><p>为什么不直接求d[fuel][i]的最大化，这样也会重复vis统一节点<br><a href=\"https://leetcode-cn.com/circle/discuss/a4pRYY/\">https://leetcode-cn.com/circle/discuss/a4pRYY/</a></p>\n</li>\n</ul>\n</li>\n<li><p>访问所有节点的最短路径(hard)</p>\n<ul>\n<li>题意：一笔走完所有的节点，注意可能重复访问同一个节点</li>\n<li>主要思路：<br>先求出任意两个节点间的距离，使用floyd，同时记得出事dist[i][i]=0<br>然后使用d[mask][i]:表示最后状态为mask,并且以i结尾的最短路径<br>最后遍历d[mask][i] 求最小值</li>\n<li>易错点，mask的循环一定要在节点i的循环的外面， 否则就会出错<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> mask=<span class=\"hljs-number\">1</span>;mask&lt;(<span class=\"hljs-number\">1</span>&lt;&lt;n);mask++)&#123;<br>          <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;n;i++)&#123;<br>              <span class=\"hljs-keyword\">if</span> (mask &amp; (<span class=\"hljs-number\">1</span> &lt;&lt; i)) &#123; <span class=\"hljs-comment\">//如果i这个点已经被选过</span><br>                  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> k=<span class=\"hljs-number\">0</span>;k&lt;n;k++)&#123;<br>                      <span class=\"hljs-keyword\">if</span>((mask&amp;(<span class=\"hljs-number\">1</span>&lt;&lt;k))==<span class=\"hljs-number\">0</span>)&#123;<br>                          d[mask|(<span class=\"hljs-number\">1</span>&lt;&lt;k)][k]=<span class=\"hljs-built_in\">min</span>(d[mask|(<span class=\"hljs-number\">1</span>&lt;&lt;k)][k],d[mask][i]+dist[i][k]); <span class=\"hljs-comment\">//需要先使用floy求出任意两点之间的最短距离</span><br>                      &#125;<br>                  &#125;<br>              &#125;<br>          &#125;<br>      &#125;<br></code></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>基于陈述统计最多好人数</p>\n<ul>\n<li>这个是枚举状态（二进制），与dp无关，但是和状态压缩dp有点类似</li>\n</ul>\n</li>\n<li><p>两个数组最小的异或值之和  / <font color=\"red\">lc2172： 数组的最大与和 </font></p>\n<ul>\n<li>这两道题都是位运算相关的状态压缩<br>第一题枚举nums2每个数应该放的位置<br>第二题需要先装为状态压缩的样子，因为每个index有两个slot,所以需要先转为2*n个slot，那么slot和index对应关系为j/2+1<br>然后枚举每个数应该放在哪个slot,同时注意这道题不是每个状态都有值，对于one_num of state i&gt;=num数量, 直接continue</li>\n<li>一个位可以放两个数的情况，需要展开分别讨论<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">int</span> ans = <span class=\"hljs-number\">0</span>;<br><span class=\"hljs-function\">vector&lt;<span class=\"hljs-keyword\">int</span>&gt; <span class=\"hljs-title\">f</span><span class=\"hljs-params\">(<span class=\"hljs-number\">1</span> &lt;&lt; (numSlots * <span class=\"hljs-number\">2</span>))</span></span>;<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; f.<span class=\"hljs-built_in\">size</span>(); ++i) &#123;<br>    <span class=\"hljs-keyword\">int</span> c = __builtin_popcount(i); <span class=\"hljs-comment\">//当前已经放了几个数，下一个放的数就是nums[c]</span><br>    <span class=\"hljs-keyword\">if</span> (c &gt;= nums.<span class=\"hljs-built_in\">size</span>()) <span class=\"hljs-keyword\">continue</span>; <span class=\"hljs-comment\">//直接跳过</span><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; numSlots * <span class=\"hljs-number\">2</span>; ++j) &#123;<br>        <span class=\"hljs-keyword\">if</span> ((i &amp; (<span class=\"hljs-number\">1</span> &lt;&lt; j)) == <span class=\"hljs-number\">0</span>) &#123; <span class=\"hljs-comment\">// 枚举空篮子 j</span><br>            <span class=\"hljs-keyword\">int</span> s = i | (<span class=\"hljs-number\">1</span> &lt;&lt; j);<br>            f[s] = <span class=\"hljs-built_in\">max</span>(f[s], f[i] + ((j / <span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">1</span>) &amp; nums[c]));<br>            ans = <span class=\"hljs-built_in\">max</span>(ans, f[s]); <span class=\"hljs-comment\">//有效的状态求结果</span><br>        &#125;<br>    &#125;<br>&#125;<br><span class=\"hljs-keyword\">return</span> ans;<br></code></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"动态规划-拓扑排序\"><a href=\"#动态规划-拓扑排序\" class=\"headerlink\" title=\"动态规划 + 拓扑排序\"></a>动态规划 + 拓扑排序</h3><ol>\n<li>并行课程III<br>题意：可能具有拓扑结构+每节课程都有上课时间， 任意两节不依赖课程可以同时上，求最短上完所有课程的时间<br>转化：拓扑排序的最长路径<br>两种解决方案：</li>\n</ol>\n<ul>\n<li>转为dfs，建立依赖关系的时候反向建立，然后将度为0的点放入队列之中（root）,dfs求深度，然后多棵树取最长深度</li>\n<li>使用拓扑排序，将度为0的点放入队列，同时每次在取出队列中的点的时候，用当前点的结果f[v]更新v后面所有后修课程的结果<br>f[w]=max(f[w], f[v]+time[v])</li>\n</ul>\n<h3 id=\"反向dp\"><a href=\"#反向dp\" class=\"headerlink\" title=\"反向dp\"></a>反向dp</h3><ol>\n<li><font color=\"red\">lc174. 地下城游戏</font></li>\n</ol>\n<ul>\n<li>正序的含义为“从起点出发，到达位置（i，j）所需要的最少血量”；正向dp有两个因素影响，可能每条路各有一个因素好，因此不知道选择哪条；（当前需要的血量，和整条路径中至少需要的血量）</li>\n<li>倒序的含义是“从（i，j）出发，到达终点需要最少的血量”。初始血量本来就是要求的，所以只能倒序dp</li>\n<li>转移方程：<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">if</span>(i==m<span class=\"hljs-number\">-1</span>&amp;&amp;j==n<span class=\"hljs-number\">-1</span>)&#123;<br>    dp[i][j]=<span class=\"hljs-built_in\">max</span>(<span class=\"hljs-number\">1</span>-dungeon[i][j], <span class=\"hljs-number\">1</span>);<br>&#125;<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(i==m<span class=\"hljs-number\">-1</span>)&#123;<br>    dp[i][j]=<span class=\"hljs-built_in\">max</span>(dp[i][j+<span class=\"hljs-number\">1</span>]-dungeon[i][j], <span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">//每个点的初始健康点都必须为正整数</span><br>&#125;<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(j==n<span class=\"hljs-number\">-1</span>)&#123;<br>        dp[i][j]=<span class=\"hljs-built_in\">max</span>(dp[i+<span class=\"hljs-number\">1</span>][j]-dungeon[i][j], <span class=\"hljs-number\">1</span>);                <br>&#125;<span class=\"hljs-keyword\">else</span>&#123;<br>        dp[i][j]=<span class=\"hljs-built_in\">max</span>(<span class=\"hljs-built_in\">min</span>(dp[i+<span class=\"hljs-number\">1</span>][j], dp[i][j+<span class=\"hljs-number\">1</span>])-dungeon[i][j], <span class=\"hljs-number\">1</span>); <br>&#125;   <br></code></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>ok  ok</p>\n<ol>\n<li><p>图与动态规划，一定要注意vis的问题，bellman-ford以及floyd算法都是图的动态规划的例子<br>但是注意因为bellman-ford是求距离最小，所以不会出现重复vis同一个节点的情况<br>但是如果求max的情况，使用动态规划+图就可能造成一个节点vis多次，因此最好考虑记忆化dfs或者状态压缩</p>\n</li>\n<li><p>状态压缩问题，将状态放在外层比较保险；如果是list数组，那么可以将num放在外面，如果是图，那么只能将状态放在外面。 通常状态压缩使用的题目是将数据放在哪个位置，得到最大/最小、/满足什么样的条件的XXX类似题型<br><font color=\"red\">图类型的状态压缩：求遍历这个图中所有节点的最小代价（代价指的是走过路径长度的总和， 应该是顺序走完）。状态压缩dp，注意不要理解成最小生成树</font></p>\n</li>\n</ol>\n<ol start=\"3\">\n<li>动态规划的关键是处理 i 取值范围 j取值范围，转移方程以及边界情况求动态规划<br>也就是找到dp[i]-&gt; dp[j] (j&lt; i) 的递推公式,这个递推可能由i，j之间回文，括号，或者异或和组成；特别的，如果是回文可以提前得到任何i，j之间是否为回文字符串，模板代码如下：<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=s_len<span class=\"hljs-number\">-1</span>;i&gt;=<span class=\"hljs-number\">0</span>;i--)&#123;<br>     <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j=i+<span class=\"hljs-number\">1</span>;j&lt;s_len;j++)&#123;<br>         p[i][j]=(s[i]==s[j]&amp;&amp;p[i+<span class=\"hljs-number\">1</span>][j<span class=\"hljs-number\">-1</span>]);<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure></li>\n</ol>\n<p>4.区间dp问题，外围长度的字符状态，可以由内围的长度的字符推导出来 dp[i][size]</p>\n<ol start=\"5\">\n<li><p>如果进行了状态压缩：<br>0-1的最大背包问题，逆向枚举<br>多重背包问题也是，只能逆向枚举<br>完全背包（无限个）才是正向枚举！！！</p>\n</li>\n<li><p>有的时候动态规划不好解决，考虑使用带记忆的dfs，（比如要求所有的路径，或者所有路径中花费最小等等） 而且dp 的index可以为一个vector（类似与状态压缩）</p>\n</li>\n<li><p>最短时间类似题，除了考虑动态规划，也可以向二分算法中思考，比如画匠问题</p>\n</li>\n<li><p>动态规划可以解决true/false（是否能化为k个相同区间，单词拆分问题）, 最小最大最长问题，总数问题</p>\n</li>\n<li><p>当动态规划的状态比较多的情况下<br>注意 res+=dp[i][m]%MOD(wrong answer)<br>res=(res+dp[m][i])%MOD(right answer);</p>\n</li>\n<li><p>划分性dp有两种情况：以i为结尾，和0-i之间，区分这两种情况就是判断在进行dp递推的时候，如果dp[i] 依赖于多个之前的dp[j]那么应该使用以i为结尾，如果dp[i]只依赖之前的一个dp[j]那么使用0-i之内的元素<br>（最长子序列和最长子串问题）</p>\n</li>\n<li><p>使用状态枚举（状态压缩）的方法，要求k&lt;32 !!!!如果n&lt;100那么就不能这么枚举</p>\n</li>\n<li><p>背包问题可能也会加一个额外的条件，类似于最短路径问题（Dijstra/bellman-ford/floyd）中再加一个额外条件,具体例题见“货物转移”(lintcode)模板： dp数量最小+weight最大类似题目</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">if</span>(d[j]+<span class=\"hljs-number\">1</span>&lt;d[i])&#123; <span class=\"hljs-comment\">//找到更优解</span><br>    d[i]=d[j]+<span class=\"hljs-number\">1</span>;<br>    weight[i]=weight[j]; <span class=\"hljs-comment\">// update weight and d</span><br>&#125;<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(d[i]==d[j]+<span class=\"hljs-number\">1</span>)&#123;<br>    weight[i]=max/<span class=\"hljs-built_in\">min</span>(weight[j], weight[i]); <span class=\"hljs-comment\">//only update weight</span><br>&#125;<span class=\"hljs-keyword\">else</span>&#123;<br>    <span class=\"hljs-keyword\">continue</span>; <span class=\"hljs-comment\">//do not update anything</span><br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li><p>动态规划一定要注意状态的初始化，在i 和 j都从1开始取的时候，一定要记得赋值dp[0][1到n] 以及dp[1到n][0]</p>\n</li>\n<li><p>如果出现反复将一个字符串的子串和字典中的每个字符比对的题目，可以使用Trie树，或者使用动态规划（True/False类型），提前判断某一个子字符串是否在字典中</p>\n</li>\n<li><p>刷一刷leetcode以面试题开始的题目</p>\n</li>\n<li><p>每个物品选择或者不选择，使得总体的方案是n, 同时花费最少的这种类似题可以使用动态规划<br>例题： lc1029. 两地调度</p>\n</li>\n</ol>\n<ul>\n<li>第一想法是使用二进制的暴力枚举</li>\n<li>因为整体的方案一定要是n, 所以一定要初始化dp[0][j] (j&gt;=2为一个比较大的值)； 同时dp[i][0] 为dp[i-1][0]+cost[i][1]<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"> dp[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">0</span>]=costs[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">1</span>];<br> dp[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">1</span>]=costs[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">0</span>];<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">2</span>;j&lt;=n/<span class=\"hljs-number\">2</span>;j++)&#123;<br>     dp[<span class=\"hljs-number\">0</span>][j]=<span class=\"hljs-number\">1000000</span>; <span class=\"hljs-comment\">//注意这个是非常重要的！！！！</span><br> &#125;<br> <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;n;i++)&#123;<br>     dp[i][<span class=\"hljs-number\">0</span>]=dp[i<span class=\"hljs-number\">-1</span>][<span class=\"hljs-number\">0</span>]+costs[i][<span class=\"hljs-number\">1</span>];<br>     <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">1</span>;j&lt;=n/<span class=\"hljs-number\">2</span>;j++)&#123; <span class=\"hljs-comment\">//j代表剩余的0类的数量</span><br>         dp[i][j]=<span class=\"hljs-built_in\">min</span>(dp[i<span class=\"hljs-number\">-1</span>][j]+costs[i][<span class=\"hljs-number\">1</span>], dp[i<span class=\"hljs-number\">-1</span>][j<span class=\"hljs-number\">-1</span>]+costs[i][<span class=\"hljs-number\">0</span>]);<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure></li>\n<li>第二种方法是贪心：<br>  a[i] - b[i]代表将i员工派往a地比派往b地的费钱程度，数值越高表示派往a地越不划算；<br>  将所有花费按a[i] - b[i]从小到大排序，则前n个为派往a地更划算的员工，后n个为派往b地更划算的员工。</li>\n</ul>\n<p>lc474. 一和零 （类似于0-1背包问题）</p>\n<ul>\n<li>选不选择每个字符串，满足0， 1不超过m, n同时使得最后的字符串个数最多; 或者选了这个不能选择左右两边， 类似问题都使用dp</li>\n<li>这种第一种想到的思路是回溯，更进一步的方法是动态规划</li>\n<li>回溯思路如果不求具体序列，只求总数的话，可以考虑动态规划解决<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">if</span>(j&gt;=zero_num&amp;&amp;k&gt;=one_num)&#123;<br>    dp[i][j][k]=<span class=\"hljs-built_in\">max</span>(dp[i<span class=\"hljs-number\">-1</span>][j-zero_num][k-one_num]+<span class=\"hljs-number\">1</span>, dp[i<span class=\"hljs-number\">-1</span>][j][k]);<br>&#125;<span class=\"hljs-keyword\">else</span>&#123;<br>    dp[i][j][k]=dp[i<span class=\"hljs-number\">-1</span>][j][k]; <span class=\"hljs-comment\">//一定注意else别忘了</span><br>&#125;<br></code></pre></td></tr></table></figure></li>\n</ul>\n<ol start=\"17\">\n<li><p>非常重要的资源：<a href=\"https://oi-wiki.org/dp/knapsack/\">https://oi-wiki.org/dp/knapsack/</a><br>OI-wiki  《背包九讲》</p>\n</li>\n<li><p>连续数组进行划分，是的划分个数满足条件，使用动态规划或者二分查找<br>例题：lc410. 分割数组的最大值(hard), 画匠问题</p>\n</li>\n<li><p>一定要注意数组越界可能不会报错，比如403. 青蛙过河，申请dp[size][size] size=18， 但是访问dp[18][29]范围为true<br>所以这道题关键在于一定要加上判断if(k&lt;=j+1) 才能进行dp的更新，否则就会发生访问到越界的数据</p>\n</li>\n</ol>\n"},{"title":"单调栈","category":["leetcode 题目汇总"],"date":"2021-11-13T08:51:36.000Z","_content":"\n\n### 单调栈相关题目：\n\n1. 去除重复字母\n    - 使得去除重复字母之后，字符串的字典序最小\n    - 值栈\n    记录剩下字符串中是否包含这个字符，如果包含，那么就可以弹出（如果当前字符比这个字符小，就弹出）\n\n2. 接雨水\n    - 方法一：每个地方能接的雨水是当前下标左右两边最大值（LeftMax and RightMax）的较小一个 -->值栈\n    - 方法二：使用单调递减栈，维护top and left（单调栈的top下面的值） -->下标栈\n\n    接雨水II:\n    - 二维接雨水\n    - 上下左右四个方向分别取最大值再求短板这种想法在二维接雨水中，是不能获得正确结果的。\n    - 正确的解法是，先将矩阵的外围放入优先队列中，然后取出最端的一个点，更新它四周的（需要使用vis数组，有的更新过就不能更新了），\n    如果没有被vis而且当前点比他高，那么res+=h-matrix[i][j], 然后将改点压入栈中（高度为max(h, matrix[i][j])）；否则直接压入栈中\n\n\n3. 直方图最大矩阵面积\n    - 求离当前直方图左右两边第一个小于该直方图的下标，使用左边单调递增+右边单调递增\n    - 注意边缘的节点，因此需要提前向栈push -1或者size， 作为哨兵节点\n    - 下标栈\n\n\n4. 围成矩形的最大面积 \n    - 转为每行的直方图的最大面积 O(mn)\n    - （下标栈）\n扩展： 最大正方形：使用dp\n    ```C++\n        for(int i=1;i<=m;i++){\n            for(int j=1;j<=n;j++){\n                if(matrix[i-1][j-1]=='1'){\n                    dp[i][j]=min(dp[i-1][j-1],min(dp[i-1][j],dp[i][j-1]))+1;\n                    result=max(dp[i][j],result);\n                }\n            }\n        }\n    ```\n\n5. 公式字符串求值\n    - 可以遇到（）后进入递归，或者压入op栈中.注意（-15）这种要特别判断，if(s[i]=='-') && if(i==0||s[i-1]=='(') 那么就循环获得一个负数（括号可以进入op栈中，也可以直接跳过）\n    - 在计算优先级的时候：可以不用传入两个判断，可以给每一个运算符一个分数\n    ```\n    int grade( char op ) {\n        if (op == '(') return 1;\n        if (op == '+' || op == '-') return 2;\n        if (op == '*' || op == '/') return 3;\n        return 0;\n    }\n    ```\n\n6. 逆波兰表达式\n\n7. 滑动窗口的最大值\n    - 可以使用优先队列， 单调递减的双向队列\n    - 一定要注意最开始压入0~k-1个字符的时候，就要压入一个结果，而不是下一个压入前面一个字符的结果，因为这样可能导致压入少一个字符\n\n8. 频率最高的k个字符\n    - 使用大小为k的最小堆，其实也是使用优先队列实现的堆，需要自定义排序方式\n    ```C++\n        // 小顶堆\n        class mycomparison {\n        public:\n            bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {\n                return lhs.second > rhs.second;\n            }\n        };\n    ```\n\n9. 有的模拟题也是用栈的，\n    - 比如文件的最长路径，栈中维护递增level的长度，如果当前的level<栈顶的level那么弹栈；如果遇到当前是文件，那么统计栈中元素加起来的值和result比较取最大\n    - 这种题一般需要对token先进行划分，然后进行统计\n\n10. 移掉 K 位数字\n    - 使用单调栈，如果当前的字符小于栈顶的元素，那么循环弹出。易错点：剩下的字符包含头部0元素，以及最后如何结果为空字符串的话，应该返回“0”而不是“”\n\n11. 下一个更大元素|| \n\n    - 题意：找到每个元素后面，第一个大于当前元素的数\n    - 我的解法：从后往前，前面在进行判断的时候使用后面的nextid,可以跳过一些数，next[i]==-1表示没有比当前数更大的，next[i]==-2表示当前数还没有计算 nextid有值那么直接进行跳转nextid=next[nextid]\n    - 官方题解：单调栈，但是因为是训练列表，所以需要遍历n+n-1个数据\n\n\n12. 子数组的最小值之和\n    - 题意：这道题求每个数左边比他小的第一个数的下标，和右边第一个比他小于或等于的数的下标\n    - 解决：使用单调递减栈； 结果就是：arr[i]*(i-left[i]) * (right[i]-i)\n    注意为了处理两个数相同的情况，使用左边小于，右边小于等于！！！ \n    - 比如：1 2 4 8 1\n\n13. 最小栈\n    - 题目：如何用时间O(1)和空间O(1)的复杂度得到栈中的最小值\n    - 解决：原始的数据栈用来记录数据与min的差值 （value-min），同时用一个min变量记录当前栈的最小值;注意如果数值没有限制的话，差值的计算可能会溢出。\n        - getmin()：始终返回min变量的值\n        - void pop(): 如果栈顶元素小于0，那么说明当前栈顶元素就是min(如果需要返回栈顶元素只，那么返回min),同时更新min为min-stack.top();否则不更新min\n        - void push(value): 当栈为空，直接压入value, 令min=value, push(0); 如果不为空，计算 value-min，并压入栈中; 如果小于0, 那么修改min为value, 否则min不变。\n        ```C++\n        public class 设计一个有gitMin的栈 {\n\n            private Stack<Integer> stack = new Stack<Integer>();\n            private int min;\n            \n            public void push(int x) {\n                if (stack.isEmpty()) {\n                    min = x;\n                    stack.push(0);\n                } else {\n                    // 计算差值\n                    int compare = x - min;\n                    stack.push(compare);\n                    // 如果差值小于0，显然 x 成为最小值，否则最小值不变\n                    min = compare < 0 ? x : min;\n                }\n            }\n\n            public void pop() {\n                int top = stack.peek();\n                // 如果top小于0，显然最小值也一并会被删除，此时更新最小值\n                min = top < 0 ? (min - top) : min;\n                stack.pop();\n            }\n\n            public int getMin() {\n                return min;\n            }\n        }\n\n        ```\n\n### 括号相关的题目专题\n**总结:** 一般来说括号相关的题使用栈解决，但是有的题目也使用动态规划解决。同时栈的方式也可以演变为更加简单的整数加减问题，不需要额外的空间。左括号出现那么+1， 右括号出现那么如果有左括号，那么左括号-1否则右括号+1\n\n1. 有效的括号字符串\n    - 因为*既可以当左括号，又可以当右括号，又可以当空白字符\n    - 因此需要两个栈，当左括号栈为空的时候，从星号栈弹，否则从左括号栈弹、如果最后左括号不为空，那么比较信号栈顶和左括号栈顶下标，如果星号栈顶下标大，那么同时弹出，重复上述过程\n    - 如果是动态规划的话； 就是判断dp[i][j]是否为true, 判断标准是 如果i=='('或者'*' 且j==')'或者 ' *'那么dp[i][j]=dp[i+1][j-1] 同时遍历i 到j之间的每一个元素，dp[i][j] |=dp[i][k]&&dp[k][j] (发现为true就break)\n    类似长度的动态规划（最长回文子串）\n    len==1 s[i]=='*' dp[i][i]=true\n    len==2 (s[i]=='('||s[i]=='*' ) && (s[j]==')'||s[j]=='*')\n\n2. 括号的生成，使用dfs， 左括号的数量应该时刻保持>=右括号的数量， 因此可以使用每使用一个左括号，可使用的右括号数量+1， 左括号：n->0, 右括号：0->n\n\n3. 最长有效括号（动态规划中也有总结）\n\n    ```C++\n    public int longestValidParentheses(String s) {\n            int maxans = 0;\n            int[] dp = new int[s.length()];\n            for (int i = 1; i < s.length(); i++) {\n                if (s.charAt(i) == ')') {\n                    if (s.charAt(i - 1) == '(') {\n                        dp[i] = (i >= 2 ? dp[i - 2] : 0) + 2;\n                    } else if (i - dp[i - 1] > 0 && s.charAt(i - dp[i - 1] - 1) == '(') {\n                        dp[i] = dp[i - 1] + ((i - dp[i - 1]) >= 2 ? dp[i - dp[i - 1] - 2] : 0) + 2;\n                    }\n                    maxans = Math.max(maxans, dp[i]);\n                }\n            }\n            return maxans;\n        }\n    ```\n<font color=red> 4. 删除无效的括号 </font>\n    - 因为是需要知道删除后所有有效的情况，所以应该dfs，同时难点在于去重\n    - solution: 先计算得到要删除的左右括号的数量，然后再dfs求所有合格的情况\n    - 和其他dfs不一样在于，dfs遍历的是删除的括号，而不是留下的括号\n    - 使用dfs的两种剪枝技巧：\n        1. 不重复遍历相同的 if i!=cur && char[i]==char[i-1] continue\n        2. 记录当前左括号和右括号的数量，只有左括号的数量大于等于右括号，再遍历需要这个右括号的这种情况，否则就不遍历这种情况（这道题没用）\n    - 注意这道题在进行递归的时候，不是一个字符一个字符的判断到底加不加当前的字符，而是使用一个循环，从当前字符遍历到最后一个字符，然后将当前字符前面和后面的字符串进行拼接， 然后仍然从当前遍历的下标，进入下一个循环。通过这种方式可以跳过一些重复的循环， 比如（（（）， 这种方式只需要移除一个（ ， 没必要每个进行判断\n\n    回溯+剪枝+去冗余（set/循环去）+括号匹配check, 这道题是遍历删除的字符，而不是留下的字符，因此需要用到path.substr，来进行删除后字符串的重新组合\n    \n    - 这道题可以扩展出另外一个题：如何判断一个字符串应该删除多少左括号，多少右括号使得剩下括号有效\n    ```C++\n    left=0, right=0; //需要删除的左右括号数量\n    for(int i=0;i<size;i++){\n        if(s[i]=='('){\n            left++;\n        }else{\n            if(left>0){\n                left--;\n            }else{\n                right++;\n            }\n        }\n    }\n    ```\n\n\n<font color=blue>5. 最多能完成排序的块 I/II</font>\n    - 总结：==最大的元素标记了一个段==\n    - 题解\n\n        1. 无重复的元素：可以直接i==maxnum的时候res++\n        2. 有重复的元素\n            使用单调栈\n            1.如果大于等于栈顶，直接入栈， 也就是重复元素是可以单独成块的\n            2.如果小于，那么将栈顶下面小于当前值的元素pop掉，然后压入原来的栈顶\n\n\n<font color = red>6. 基本计算器/基本计算器||/基本计算器||| （表达式中可能有空格）</font>\n第一个是只有正负符号和括号，（直接将括号展开）因此不需要转化逆波兰，只需要一个递归符号的栈+一个当前数的前面的符号就可以了；res+=s.top()* sign *num   易错点：注意在（ 要手动赋值当前的sign=1\n第二个是有+-*/ ，但是全是正整数，因此只需要逆波兰，一个数字栈一个符号栈，在压栈的同时，根据优先级计算结果，同时在最后判断符号栈是否为空，如果不为空的话，需要将符号栈里面的元素逐个弹出\n第三个是有+-*/ 和括号，如题2，在（压入栈中，在）依次弹出符号栈中的符号\n第四个，自己的扩展，在第三个上面加上数据可以为正负； 难点在于判断-是负号还是减号\n    1）将所有空格去掉 ，题目必须保证两个运算符号不会同时出现\n    2）在num里面压入0 \n    3）在（-变为（0-；将（+ 变为（0+\n    4）题解如第三题\n\n\n\n\n7. 16. lc362. design-hit-counter\n这道题和单调没有什么关系，主要是队列\n- 这道题让我们设计一个点击计数器（设计数据结构），能够返回五分钟内的点击数，提示了有可能同一时间内有多次点击。\n- 由于操作都是按时间顺序的，下一次的时间戳都会大于等于本次的时间戳，那么最直接的方法就是用一个队列queue，每次点击时都将当前时间戳加入queue中，然后在需要获取点击数时，我们从队列开头开始看，如果开头的时间戳在5分钟以外了，就删掉，直到开头的时间戳在5分钟以内停止，然后返回queue的元素个数即为所求的点击数，\n- follow up： 比较重要，因为在每个时间戳可能有多个数，所以可以用两个300大小数组，记录时间戳和点击数，节省时间和空间，每个时间戳应该放在timestamp%300的位置，因为多个timestamp映射同一个位置，所以需要先判断当前位置是不是放的当前这个数；然后read的时候，遍历300次，如果满足在5分钟内的条件，就res+=times[i]\n- 解题链接：https://www.cnblogs.com/grandyang/p/5605552.html\n\n\n\n\n<font color=red>8. lc456. 132 Pattern</font>\n- 找到是否存在132这样的数对\n- 枚举3， 然后维护遍历到3左边的最小值，那么就找到了1， 问题的关键在于如何找到2， 就是找到3右边最大小于3的数\n- 方法1： 使用单调栈（找到每个数右边，第一个小于这个数的最大数，注意不是第一个小于他的数，而是小于他的最大数）进行预处理，并将结果存在一个vector中，时间复杂度为O(nlogn)\n第一个小于他的数： 左到右， 单增\n第一个小于这个数的最大数：二分查找（multiset） 转为找到第一个大于leftmin的数\n\n- 方法二：使用栈记录3（左到右，递增，3越来越大）， 变量记录2，使得3 2都尽可能大; 然后枚举1，如果1小于当前变量记录值two，那么return true;\n在这个过程中，two会逐渐变高，不会出现two下降的情况\n```C++\nint two = INT_MIN;\nfor (int i = size - 1; i >= 0; i--)\n{\n    if(nums[i]<two){\n        return true;\n    }\n    while(!s.empty()&&nums[i]>s.top()){ //找到小于他的最大值, 逐渐增大two\n        two = s.top();\n        s.pop();\n    }\n    s.push(nums[i]);\n}\n```\n\n类似的一个题: lc334. 递增的三元子序列 （类似模式123）\n- 找到i, j, k使得nums[i]< nums[j] < nums[k]\n- 使用一个单调递增栈，同时不断减少当前数字在栈中位置的那个数， 比如1 5，7 后来访问到 3改为 1， 3， 7（一定注意使用lower_bound） 类似最长递增子序列长度大于3\n- 方法二：两次遍历，求每个数的leftMin 和rightMax, 看是否有一个数在两者之间\n\n\n9. lc895. 最大频率栈\n- 这个和LFU有点相像，但是实际上是不同的， LFU是删除最低频率的元素，但是这个是删除最高频率的栈中元素\n- 因此不需要每次改变频率的时候都从原来的频率栈中弹出，同理，每次减低频率的时候，也不用弹出+加入新的频率\n- 实际的解决方法用两个hash, 一个存储<k, freq> 一个存储<freq, vector<k>>/<freq, stack<k>>\n- 一定要注意这两个hash一定要同时修改，不能只修改一个，频率包含的元素在变，元素当前的频率在变\n- LFU是使用unordered_map<int, NodeList*> 存储频率到一个双向链表； 以及一个unordered_map<int, Node*> 存储key到节点的位置\n\n\n\n\n### 总结\nok \n\n1. 一定要清楚是单调递增栈还是单调递减栈；判断是单减栈还是单增栈的关键：是弹出的元素对后面的结果不会有影响。同时要注意push的是下标还是值\n\n2. 栈适合题目：括号相关，左右的第一个最大最小，表达式求值，模拟文件层数，树结构题目，数字数组（也可能用二分）操作。\n\n3. 括号是否匹配也可以转为整数加减问题\n\n4.表达式求值可以直接将表达式转为逆波兰，在对逆波兰求值；或者直接用一个栈求值\n第一种方法：使用一个结果栈（vector<char>），一个符号栈；如果遇到数字，直接压栈；如果遇到（，压栈；反括号，弹出符号栈中所有符号到结果栈，直到遇到（，并弹出（；运算符，如果符号栈顶符号优先级高于当前栈，那么弹出并压入结果栈，否则直接压入符号栈；最后如何符号栈有值，那么弹出所有符号到结果栈；注意是否有正负， 字母这些边界情况的处理\n\n5. 求每个数右边第一个比当前数大的数，使用单调递增栈（栈顶到栈底），弹出的时候进行判断\n//正序遍历求右边，用单调递增栈（栈顶到栈底），弹出的时候判断；逆序遍历，单调递增栈 \n注意：单增还是单减，看从栈顶到栈顶，不是栈低到栈顶\n（底部）1，2，3，4，5（头部）   是单调递减\n\n6. 口诀：左右两边第一个比他大的数，用单调递增栈；比他小的数，用单调递减栈\n    找较大，那么应该越远越大；找较小，应该越远越小","source":"_posts/leetcode/单调栈相关.md","raw":"---\ntitle: 单调栈\ncategory:\n  - leetcode 题目汇总\ntags: '栈, 单调栈'\ncategories:\n  - leetcode\ndate: 2021-11-13 16:51:36\n---\n\n\n### 单调栈相关题目：\n\n1. 去除重复字母\n    - 使得去除重复字母之后，字符串的字典序最小\n    - 值栈\n    记录剩下字符串中是否包含这个字符，如果包含，那么就可以弹出（如果当前字符比这个字符小，就弹出）\n\n2. 接雨水\n    - 方法一：每个地方能接的雨水是当前下标左右两边最大值（LeftMax and RightMax）的较小一个 -->值栈\n    - 方法二：使用单调递减栈，维护top and left（单调栈的top下面的值） -->下标栈\n\n    接雨水II:\n    - 二维接雨水\n    - 上下左右四个方向分别取最大值再求短板这种想法在二维接雨水中，是不能获得正确结果的。\n    - 正确的解法是，先将矩阵的外围放入优先队列中，然后取出最端的一个点，更新它四周的（需要使用vis数组，有的更新过就不能更新了），\n    如果没有被vis而且当前点比他高，那么res+=h-matrix[i][j], 然后将改点压入栈中（高度为max(h, matrix[i][j])）；否则直接压入栈中\n\n\n3. 直方图最大矩阵面积\n    - 求离当前直方图左右两边第一个小于该直方图的下标，使用左边单调递增+右边单调递增\n    - 注意边缘的节点，因此需要提前向栈push -1或者size， 作为哨兵节点\n    - 下标栈\n\n\n4. 围成矩形的最大面积 \n    - 转为每行的直方图的最大面积 O(mn)\n    - （下标栈）\n扩展： 最大正方形：使用dp\n    ```C++\n        for(int i=1;i<=m;i++){\n            for(int j=1;j<=n;j++){\n                if(matrix[i-1][j-1]=='1'){\n                    dp[i][j]=min(dp[i-1][j-1],min(dp[i-1][j],dp[i][j-1]))+1;\n                    result=max(dp[i][j],result);\n                }\n            }\n        }\n    ```\n\n5. 公式字符串求值\n    - 可以遇到（）后进入递归，或者压入op栈中.注意（-15）这种要特别判断，if(s[i]=='-') && if(i==0||s[i-1]=='(') 那么就循环获得一个负数（括号可以进入op栈中，也可以直接跳过）\n    - 在计算优先级的时候：可以不用传入两个判断，可以给每一个运算符一个分数\n    ```\n    int grade( char op ) {\n        if (op == '(') return 1;\n        if (op == '+' || op == '-') return 2;\n        if (op == '*' || op == '/') return 3;\n        return 0;\n    }\n    ```\n\n6. 逆波兰表达式\n\n7. 滑动窗口的最大值\n    - 可以使用优先队列， 单调递减的双向队列\n    - 一定要注意最开始压入0~k-1个字符的时候，就要压入一个结果，而不是下一个压入前面一个字符的结果，因为这样可能导致压入少一个字符\n\n8. 频率最高的k个字符\n    - 使用大小为k的最小堆，其实也是使用优先队列实现的堆，需要自定义排序方式\n    ```C++\n        // 小顶堆\n        class mycomparison {\n        public:\n            bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {\n                return lhs.second > rhs.second;\n            }\n        };\n    ```\n\n9. 有的模拟题也是用栈的，\n    - 比如文件的最长路径，栈中维护递增level的长度，如果当前的level<栈顶的level那么弹栈；如果遇到当前是文件，那么统计栈中元素加起来的值和result比较取最大\n    - 这种题一般需要对token先进行划分，然后进行统计\n\n10. 移掉 K 位数字\n    - 使用单调栈，如果当前的字符小于栈顶的元素，那么循环弹出。易错点：剩下的字符包含头部0元素，以及最后如何结果为空字符串的话，应该返回“0”而不是“”\n\n11. 下一个更大元素|| \n\n    - 题意：找到每个元素后面，第一个大于当前元素的数\n    - 我的解法：从后往前，前面在进行判断的时候使用后面的nextid,可以跳过一些数，next[i]==-1表示没有比当前数更大的，next[i]==-2表示当前数还没有计算 nextid有值那么直接进行跳转nextid=next[nextid]\n    - 官方题解：单调栈，但是因为是训练列表，所以需要遍历n+n-1个数据\n\n\n12. 子数组的最小值之和\n    - 题意：这道题求每个数左边比他小的第一个数的下标，和右边第一个比他小于或等于的数的下标\n    - 解决：使用单调递减栈； 结果就是：arr[i]*(i-left[i]) * (right[i]-i)\n    注意为了处理两个数相同的情况，使用左边小于，右边小于等于！！！ \n    - 比如：1 2 4 8 1\n\n13. 最小栈\n    - 题目：如何用时间O(1)和空间O(1)的复杂度得到栈中的最小值\n    - 解决：原始的数据栈用来记录数据与min的差值 （value-min），同时用一个min变量记录当前栈的最小值;注意如果数值没有限制的话，差值的计算可能会溢出。\n        - getmin()：始终返回min变量的值\n        - void pop(): 如果栈顶元素小于0，那么说明当前栈顶元素就是min(如果需要返回栈顶元素只，那么返回min),同时更新min为min-stack.top();否则不更新min\n        - void push(value): 当栈为空，直接压入value, 令min=value, push(0); 如果不为空，计算 value-min，并压入栈中; 如果小于0, 那么修改min为value, 否则min不变。\n        ```C++\n        public class 设计一个有gitMin的栈 {\n\n            private Stack<Integer> stack = new Stack<Integer>();\n            private int min;\n            \n            public void push(int x) {\n                if (stack.isEmpty()) {\n                    min = x;\n                    stack.push(0);\n                } else {\n                    // 计算差值\n                    int compare = x - min;\n                    stack.push(compare);\n                    // 如果差值小于0，显然 x 成为最小值，否则最小值不变\n                    min = compare < 0 ? x : min;\n                }\n            }\n\n            public void pop() {\n                int top = stack.peek();\n                // 如果top小于0，显然最小值也一并会被删除，此时更新最小值\n                min = top < 0 ? (min - top) : min;\n                stack.pop();\n            }\n\n            public int getMin() {\n                return min;\n            }\n        }\n\n        ```\n\n### 括号相关的题目专题\n**总结:** 一般来说括号相关的题使用栈解决，但是有的题目也使用动态规划解决。同时栈的方式也可以演变为更加简单的整数加减问题，不需要额外的空间。左括号出现那么+1， 右括号出现那么如果有左括号，那么左括号-1否则右括号+1\n\n1. 有效的括号字符串\n    - 因为*既可以当左括号，又可以当右括号，又可以当空白字符\n    - 因此需要两个栈，当左括号栈为空的时候，从星号栈弹，否则从左括号栈弹、如果最后左括号不为空，那么比较信号栈顶和左括号栈顶下标，如果星号栈顶下标大，那么同时弹出，重复上述过程\n    - 如果是动态规划的话； 就是判断dp[i][j]是否为true, 判断标准是 如果i=='('或者'*' 且j==')'或者 ' *'那么dp[i][j]=dp[i+1][j-1] 同时遍历i 到j之间的每一个元素，dp[i][j] |=dp[i][k]&&dp[k][j] (发现为true就break)\n    类似长度的动态规划（最长回文子串）\n    len==1 s[i]=='*' dp[i][i]=true\n    len==2 (s[i]=='('||s[i]=='*' ) && (s[j]==')'||s[j]=='*')\n\n2. 括号的生成，使用dfs， 左括号的数量应该时刻保持>=右括号的数量， 因此可以使用每使用一个左括号，可使用的右括号数量+1， 左括号：n->0, 右括号：0->n\n\n3. 最长有效括号（动态规划中也有总结）\n\n    ```C++\n    public int longestValidParentheses(String s) {\n            int maxans = 0;\n            int[] dp = new int[s.length()];\n            for (int i = 1; i < s.length(); i++) {\n                if (s.charAt(i) == ')') {\n                    if (s.charAt(i - 1) == '(') {\n                        dp[i] = (i >= 2 ? dp[i - 2] : 0) + 2;\n                    } else if (i - dp[i - 1] > 0 && s.charAt(i - dp[i - 1] - 1) == '(') {\n                        dp[i] = dp[i - 1] + ((i - dp[i - 1]) >= 2 ? dp[i - dp[i - 1] - 2] : 0) + 2;\n                    }\n                    maxans = Math.max(maxans, dp[i]);\n                }\n            }\n            return maxans;\n        }\n    ```\n<font color=red> 4. 删除无效的括号 </font>\n    - 因为是需要知道删除后所有有效的情况，所以应该dfs，同时难点在于去重\n    - solution: 先计算得到要删除的左右括号的数量，然后再dfs求所有合格的情况\n    - 和其他dfs不一样在于，dfs遍历的是删除的括号，而不是留下的括号\n    - 使用dfs的两种剪枝技巧：\n        1. 不重复遍历相同的 if i!=cur && char[i]==char[i-1] continue\n        2. 记录当前左括号和右括号的数量，只有左括号的数量大于等于右括号，再遍历需要这个右括号的这种情况，否则就不遍历这种情况（这道题没用）\n    - 注意这道题在进行递归的时候，不是一个字符一个字符的判断到底加不加当前的字符，而是使用一个循环，从当前字符遍历到最后一个字符，然后将当前字符前面和后面的字符串进行拼接， 然后仍然从当前遍历的下标，进入下一个循环。通过这种方式可以跳过一些重复的循环， 比如（（（）， 这种方式只需要移除一个（ ， 没必要每个进行判断\n\n    回溯+剪枝+去冗余（set/循环去）+括号匹配check, 这道题是遍历删除的字符，而不是留下的字符，因此需要用到path.substr，来进行删除后字符串的重新组合\n    \n    - 这道题可以扩展出另外一个题：如何判断一个字符串应该删除多少左括号，多少右括号使得剩下括号有效\n    ```C++\n    left=0, right=0; //需要删除的左右括号数量\n    for(int i=0;i<size;i++){\n        if(s[i]=='('){\n            left++;\n        }else{\n            if(left>0){\n                left--;\n            }else{\n                right++;\n            }\n        }\n    }\n    ```\n\n\n<font color=blue>5. 最多能完成排序的块 I/II</font>\n    - 总结：==最大的元素标记了一个段==\n    - 题解\n\n        1. 无重复的元素：可以直接i==maxnum的时候res++\n        2. 有重复的元素\n            使用单调栈\n            1.如果大于等于栈顶，直接入栈， 也就是重复元素是可以单独成块的\n            2.如果小于，那么将栈顶下面小于当前值的元素pop掉，然后压入原来的栈顶\n\n\n<font color = red>6. 基本计算器/基本计算器||/基本计算器||| （表达式中可能有空格）</font>\n第一个是只有正负符号和括号，（直接将括号展开）因此不需要转化逆波兰，只需要一个递归符号的栈+一个当前数的前面的符号就可以了；res+=s.top()* sign *num   易错点：注意在（ 要手动赋值当前的sign=1\n第二个是有+-*/ ，但是全是正整数，因此只需要逆波兰，一个数字栈一个符号栈，在压栈的同时，根据优先级计算结果，同时在最后判断符号栈是否为空，如果不为空的话，需要将符号栈里面的元素逐个弹出\n第三个是有+-*/ 和括号，如题2，在（压入栈中，在）依次弹出符号栈中的符号\n第四个，自己的扩展，在第三个上面加上数据可以为正负； 难点在于判断-是负号还是减号\n    1）将所有空格去掉 ，题目必须保证两个运算符号不会同时出现\n    2）在num里面压入0 \n    3）在（-变为（0-；将（+ 变为（0+\n    4）题解如第三题\n\n\n\n\n7. 16. lc362. design-hit-counter\n这道题和单调没有什么关系，主要是队列\n- 这道题让我们设计一个点击计数器（设计数据结构），能够返回五分钟内的点击数，提示了有可能同一时间内有多次点击。\n- 由于操作都是按时间顺序的，下一次的时间戳都会大于等于本次的时间戳，那么最直接的方法就是用一个队列queue，每次点击时都将当前时间戳加入queue中，然后在需要获取点击数时，我们从队列开头开始看，如果开头的时间戳在5分钟以外了，就删掉，直到开头的时间戳在5分钟以内停止，然后返回queue的元素个数即为所求的点击数，\n- follow up： 比较重要，因为在每个时间戳可能有多个数，所以可以用两个300大小数组，记录时间戳和点击数，节省时间和空间，每个时间戳应该放在timestamp%300的位置，因为多个timestamp映射同一个位置，所以需要先判断当前位置是不是放的当前这个数；然后read的时候，遍历300次，如果满足在5分钟内的条件，就res+=times[i]\n- 解题链接：https://www.cnblogs.com/grandyang/p/5605552.html\n\n\n\n\n<font color=red>8. lc456. 132 Pattern</font>\n- 找到是否存在132这样的数对\n- 枚举3， 然后维护遍历到3左边的最小值，那么就找到了1， 问题的关键在于如何找到2， 就是找到3右边最大小于3的数\n- 方法1： 使用单调栈（找到每个数右边，第一个小于这个数的最大数，注意不是第一个小于他的数，而是小于他的最大数）进行预处理，并将结果存在一个vector中，时间复杂度为O(nlogn)\n第一个小于他的数： 左到右， 单增\n第一个小于这个数的最大数：二分查找（multiset） 转为找到第一个大于leftmin的数\n\n- 方法二：使用栈记录3（左到右，递增，3越来越大）， 变量记录2，使得3 2都尽可能大; 然后枚举1，如果1小于当前变量记录值two，那么return true;\n在这个过程中，two会逐渐变高，不会出现two下降的情况\n```C++\nint two = INT_MIN;\nfor (int i = size - 1; i >= 0; i--)\n{\n    if(nums[i]<two){\n        return true;\n    }\n    while(!s.empty()&&nums[i]>s.top()){ //找到小于他的最大值, 逐渐增大two\n        two = s.top();\n        s.pop();\n    }\n    s.push(nums[i]);\n}\n```\n\n类似的一个题: lc334. 递增的三元子序列 （类似模式123）\n- 找到i, j, k使得nums[i]< nums[j] < nums[k]\n- 使用一个单调递增栈，同时不断减少当前数字在栈中位置的那个数， 比如1 5，7 后来访问到 3改为 1， 3， 7（一定注意使用lower_bound） 类似最长递增子序列长度大于3\n- 方法二：两次遍历，求每个数的leftMin 和rightMax, 看是否有一个数在两者之间\n\n\n9. lc895. 最大频率栈\n- 这个和LFU有点相像，但是实际上是不同的， LFU是删除最低频率的元素，但是这个是删除最高频率的栈中元素\n- 因此不需要每次改变频率的时候都从原来的频率栈中弹出，同理，每次减低频率的时候，也不用弹出+加入新的频率\n- 实际的解决方法用两个hash, 一个存储<k, freq> 一个存储<freq, vector<k>>/<freq, stack<k>>\n- 一定要注意这两个hash一定要同时修改，不能只修改一个，频率包含的元素在变，元素当前的频率在变\n- LFU是使用unordered_map<int, NodeList*> 存储频率到一个双向链表； 以及一个unordered_map<int, Node*> 存储key到节点的位置\n\n\n\n\n### 总结\nok \n\n1. 一定要清楚是单调递增栈还是单调递减栈；判断是单减栈还是单增栈的关键：是弹出的元素对后面的结果不会有影响。同时要注意push的是下标还是值\n\n2. 栈适合题目：括号相关，左右的第一个最大最小，表达式求值，模拟文件层数，树结构题目，数字数组（也可能用二分）操作。\n\n3. 括号是否匹配也可以转为整数加减问题\n\n4.表达式求值可以直接将表达式转为逆波兰，在对逆波兰求值；或者直接用一个栈求值\n第一种方法：使用一个结果栈（vector<char>），一个符号栈；如果遇到数字，直接压栈；如果遇到（，压栈；反括号，弹出符号栈中所有符号到结果栈，直到遇到（，并弹出（；运算符，如果符号栈顶符号优先级高于当前栈，那么弹出并压入结果栈，否则直接压入符号栈；最后如何符号栈有值，那么弹出所有符号到结果栈；注意是否有正负， 字母这些边界情况的处理\n\n5. 求每个数右边第一个比当前数大的数，使用单调递增栈（栈顶到栈底），弹出的时候进行判断\n//正序遍历求右边，用单调递增栈（栈顶到栈底），弹出的时候判断；逆序遍历，单调递增栈 \n注意：单增还是单减，看从栈顶到栈顶，不是栈低到栈顶\n（底部）1，2，3，4，5（头部）   是单调递减\n\n6. 口诀：左右两边第一个比他大的数，用单调递增栈；比他小的数，用单调递减栈\n    找较大，那么应该越远越大；找较小，应该越远越小","slug":"leetcode/单调栈相关","published":1,"updated":"2023-07-10T10:36:19.544Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clk5ceinj000fjpjbbx0y5m51","content":"<h3 id=\"单调栈相关题目：\"><a href=\"#单调栈相关题目：\" class=\"headerlink\" title=\"单调栈相关题目：\"></a>单调栈相关题目：</h3><ol>\n<li><p>去除重复字母</p>\n<ul>\n<li>使得去除重复字母之后，字符串的字典序最小</li>\n<li>值栈<br>记录剩下字符串中是否包含这个字符，如果包含，那么就可以弹出（如果当前字符比这个字符小，就弹出）</li>\n</ul>\n</li>\n<li><p>接雨水</p>\n<ul>\n<li>方法一：每个地方能接的雨水是当前下标左右两边最大值（LeftMax and RightMax）的较小一个 –&gt;值栈</li>\n<li>方法二：使用单调递减栈，维护top and left（单调栈的top下面的值） –&gt;下标栈</li>\n</ul>\n<p> 接雨水II:</p>\n<ul>\n<li>二维接雨水</li>\n<li>上下左右四个方向分别取最大值再求短板这种想法在二维接雨水中，是不能获得正确结果的。</li>\n<li>正确的解法是，先将矩阵的外围放入优先队列中，然后取出最端的一个点，更新它四周的（需要使用vis数组，有的更新过就不能更新了），<br>如果没有被vis而且当前点比他高，那么res+=h-matrix[i][j], 然后将改点压入栈中（高度为max(h, matrix[i][j])）；否则直接压入栈中</li>\n</ul>\n</li>\n</ol>\n<ol start=\"3\">\n<li>直方图最大矩阵面积<ul>\n<li>求离当前直方图左右两边第一个小于该直方图的下标，使用左边单调递增+右边单调递增</li>\n<li>注意边缘的节点，因此需要提前向栈push -1或者size， 作为哨兵节点</li>\n<li>下标栈</li>\n</ul>\n</li>\n</ol>\n<ol start=\"4\">\n<li><p>围成矩形的最大面积 </p>\n<ul>\n<li>转为每行的直方图的最大面积 O(mn)</li>\n<li>（下标栈）<br>扩展： 最大正方形：使用dp<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;=m;i++)&#123;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">1</span>;j&lt;=n;j++)&#123;<br>        <span class=\"hljs-keyword\">if</span>(matrix[i<span class=\"hljs-number\">-1</span>][j<span class=\"hljs-number\">-1</span>]==<span class=\"hljs-string\">&#x27;1&#x27;</span>)&#123;<br>            dp[i][j]=<span class=\"hljs-built_in\">min</span>(dp[i<span class=\"hljs-number\">-1</span>][j<span class=\"hljs-number\">-1</span>],<span class=\"hljs-built_in\">min</span>(dp[i<span class=\"hljs-number\">-1</span>][j],dp[i][j<span class=\"hljs-number\">-1</span>]))+<span class=\"hljs-number\">1</span>;<br>            result=<span class=\"hljs-built_in\">max</span>(dp[i][j],result);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>公式字符串求值</p>\n<ul>\n<li>可以遇到（）后进入递归，或者压入op栈中.注意（-15）这种要特别判断，if(s[i]==’-‘) &amp;&amp; if(i==0||s[i-1]==’(‘) 那么就循环获得一个负数（括号可以进入op栈中，也可以直接跳过）</li>\n<li>在计算优先级的时候：可以不用传入两个判断，可以给每一个运算符一个分数<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs kotlin\">int grade( char op ) &#123;<br>    <span class=\"hljs-keyword\">if</span> (op == <span class=\"hljs-string\">&#x27;(&#x27;</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">if</span> (op == <span class=\"hljs-string\">&#x27;+&#x27;</span> || op == <span class=\"hljs-string\">&#x27;-&#x27;</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">2</span>;<br>    <span class=\"hljs-keyword\">if</span> (op == <span class=\"hljs-string\">&#x27;*&#x27;</span> || op == <span class=\"hljs-string\">&#x27;/&#x27;</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">3</span>;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>逆波兰表达式</p>\n</li>\n<li><p>滑动窗口的最大值</p>\n<ul>\n<li>可以使用优先队列， 单调递减的双向队列</li>\n<li>一定要注意最开始压入0~k-1个字符的时候，就要压入一个结果，而不是下一个压入前面一个字符的结果，因为这样可能导致压入少一个字符</li>\n</ul>\n</li>\n<li><p>频率最高的k个字符</p>\n<ul>\n<li>使用大小为k的最小堆，其实也是使用优先队列实现的堆，需要自定义排序方式<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-comment\">// 小顶堆</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">mycomparison</span> &#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">bool</span> <span class=\"hljs-title\">operator</span><span class=\"hljs-params\">()</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> pair&lt;<span class=\"hljs-keyword\">int</span>, <span class=\"hljs-keyword\">int</span>&gt;&amp; lhs, <span class=\"hljs-keyword\">const</span> pair&lt;<span class=\"hljs-keyword\">int</span>, <span class=\"hljs-keyword\">int</span>&gt;&amp; rhs)</span> </span>&#123;<br>        <span class=\"hljs-keyword\">return</span> lhs.second &gt; rhs.second;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>有的模拟题也是用栈的，</p>\n<ul>\n<li>比如文件的最长路径，栈中维护递增level的长度，如果当前的level&lt;栈顶的level那么弹栈；如果遇到当前是文件，那么统计栈中元素加起来的值和result比较取最大</li>\n<li>这种题一般需要对token先进行划分，然后进行统计</li>\n</ul>\n</li>\n<li><p>移掉 K 位数字</p>\n<ul>\n<li>使用单调栈，如果当前的字符小于栈顶的元素，那么循环弹出。易错点：剩下的字符包含头部0元素，以及最后如何结果为空字符串的话，应该返回“0”而不是“”</li>\n</ul>\n</li>\n<li><p>下一个更大元素|| </p>\n<ul>\n<li>题意：找到每个元素后面，第一个大于当前元素的数</li>\n<li>我的解法：从后往前，前面在进行判断的时候使用后面的nextid,可以跳过一些数，next[i]==-1表示没有比当前数更大的，next[i]==-2表示当前数还没有计算 nextid有值那么直接进行跳转nextid=next[nextid]</li>\n<li>官方题解：单调栈，但是因为是训练列表，所以需要遍历n+n-1个数据</li>\n</ul>\n</li>\n</ol>\n<ol start=\"12\">\n<li><p>子数组的最小值之和</p>\n<ul>\n<li>题意：这道题求每个数左边比他小的第一个数的下标，和右边第一个比他小于或等于的数的下标</li>\n<li>解决：使用单调递减栈； 结果就是：arr[i]*(i-left[i]) * (right[i]-i)<br>注意为了处理两个数相同的情况，使用左边小于，右边小于等于！！！ </li>\n<li>比如：1 2 4 8 1</li>\n</ul>\n</li>\n<li><p>最小栈</p>\n<ul>\n<li>题目：如何用时间O(1)和空间O(1)的复杂度得到栈中的最小值</li>\n<li>解决：原始的数据栈用来记录数据与min的差值 （value-min），同时用一个min变量记录当前栈的最小值;注意如果数值没有限制的话，差值的计算可能会溢出。<ul>\n<li>getmin()：始终返回min变量的值</li>\n<li>void pop(): 如果栈顶元素小于0，那么说明当前栈顶元素就是min(如果需要返回栈顶元素只，那么返回min),同时更新min为min-stack.top();否则不更新min</li>\n<li>void push(value): 当栈为空，直接压入value, 令min=value, push(0); 如果不为空，计算 value-min，并压入栈中; 如果小于0, 那么修改min为value, 否则min不变。<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> 设计一个有<span class=\"hljs-title\">gitMin</span>的栈 &#123;</span><br><br>    <span class=\"hljs-keyword\">private</span> Stack&lt;Integer&gt; stack = <span class=\"hljs-keyword\">new</span> Stack&lt;Integer&gt;();<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> min;<br>    <br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">push</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> x)</span> </span>&#123;<br>        <span class=\"hljs-keyword\">if</span> (stack.<span class=\"hljs-built_in\">isEmpty</span>()) &#123;<br>            min = x;<br>            stack.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-number\">0</span>);<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            <span class=\"hljs-comment\">// 计算差值</span><br>            <span class=\"hljs-keyword\">int</span> compare = x - min;<br>            stack.<span class=\"hljs-built_in\">push</span>(compare);<br>            <span class=\"hljs-comment\">// 如果差值小于0，显然 x 成为最小值，否则最小值不变</span><br>            min = compare &lt; <span class=\"hljs-number\">0</span> ? x : min;<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">pop</span><span class=\"hljs-params\">()</span> </span>&#123;<br>        <span class=\"hljs-keyword\">int</span> top = stack.<span class=\"hljs-built_in\">peek</span>();<br>        <span class=\"hljs-comment\">// 如果top小于0，显然最小值也一并会被删除，此时更新最小值</span><br>        min = top &lt; <span class=\"hljs-number\">0</span> ? (min - top) : min;<br>        stack.<span class=\"hljs-built_in\">pop</span>();<br>    &#125;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">getMin</span><span class=\"hljs-params\">()</span> </span>&#123;<br>        <span class=\"hljs-keyword\">return</span> min;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"括号相关的题目专题\"><a href=\"#括号相关的题目专题\" class=\"headerlink\" title=\"括号相关的题目专题\"></a>括号相关的题目专题</h3><p><strong>总结:</strong> 一般来说括号相关的题使用栈解决，但是有的题目也使用动态规划解决。同时栈的方式也可以演变为更加简单的整数加减问题，不需要额外的空间。左括号出现那么+1， 右括号出现那么如果有左括号，那么左括号-1否则右括号+1</p>\n<ol>\n<li><p>有效的括号字符串</p>\n<ul>\n<li>因为*既可以当左括号，又可以当右括号，又可以当空白字符</li>\n<li>因此需要两个栈，当左括号栈为空的时候，从星号栈弹，否则从左括号栈弹、如果最后左括号不为空，那么比较信号栈顶和左括号栈顶下标，如果星号栈顶下标大，那么同时弹出，重复上述过程</li>\n<li>如果是动态规划的话； 就是判断dp[i][j]是否为true, 判断标准是 如果i==’(‘或者’<em>‘ 且j==’)’或者 ‘ <em>‘那么dp[i][j]=dp[i+1][j-1] 同时遍历i 到j之间的每一个元素，dp[i][j] |=dp[i][k]&amp;&amp;dp[k][j] (发现为true就break)<br>类似长度的动态规划（最长回文子串）<br>len==1 s[i]==’</em>‘ dp[i][i]=true<br>len==2 (s[i]==’(‘||s[i]==’</em>‘ ) &amp;&amp; (s[j]==’)’||s[j]==’*’)</li>\n</ul>\n</li>\n<li><p>括号的生成，使用dfs， 左括号的数量应该时刻保持&gt;=右括号的数量， 因此可以使用每使用一个左括号，可使用的右括号数量+1， 左括号：n-&gt;0, 右括号：0-&gt;n</p>\n</li>\n<li><p>最长有效括号（动态规划中也有总结）</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">longestValidParentheses</span><span class=\"hljs-params\">(String s)</span> </span>&#123;<br>        <span class=\"hljs-keyword\">int</span> maxans = <span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-keyword\">int</span>[] dp = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[s.<span class=\"hljs-built_in\">length</span>()];<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt; s.<span class=\"hljs-built_in\">length</span>(); i++) &#123;<br>            <span class=\"hljs-keyword\">if</span> (s.<span class=\"hljs-built_in\">charAt</span>(i) == <span class=\"hljs-string\">&#x27;)&#x27;</span>) &#123;<br>                <span class=\"hljs-keyword\">if</span> (s.<span class=\"hljs-built_in\">charAt</span>(i - <span class=\"hljs-number\">1</span>) == <span class=\"hljs-string\">&#x27;(&#x27;</span>) &#123;<br>                    dp[i] = (i &gt;= <span class=\"hljs-number\">2</span> ? dp[i - <span class=\"hljs-number\">2</span>] : <span class=\"hljs-number\">0</span>) + <span class=\"hljs-number\">2</span>;<br>                &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (i - dp[i - <span class=\"hljs-number\">1</span>] &gt; <span class=\"hljs-number\">0</span> &amp;&amp; s.<span class=\"hljs-built_in\">charAt</span>(i - dp[i - <span class=\"hljs-number\">1</span>] - <span class=\"hljs-number\">1</span>) == <span class=\"hljs-string\">&#x27;(&#x27;</span>) &#123;<br>                    dp[i] = dp[i - <span class=\"hljs-number\">1</span>] + ((i - dp[i - <span class=\"hljs-number\">1</span>]) &gt;= <span class=\"hljs-number\">2</span> ? dp[i - dp[i - <span class=\"hljs-number\">1</span>] - <span class=\"hljs-number\">2</span>] : <span class=\"hljs-number\">0</span>) + <span class=\"hljs-number\">2</span>;<br>                &#125;<br>                maxans = Math.<span class=\"hljs-built_in\">max</span>(maxans, dp[i]);<br>            &#125;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> maxans;<br>    &#125;<br></code></pre></td></tr></table></figure>\n<p><font color=\"red\"> 4. 删除无效的括号 </font></p>\n<ul>\n<li>因为是需要知道删除后所有有效的情况，所以应该dfs，同时难点在于去重</li>\n<li>solution: 先计算得到要删除的左右括号的数量，然后再dfs求所有合格的情况</li>\n<li>和其他dfs不一样在于，dfs遍历的是删除的括号，而不是留下的括号</li>\n<li>使用dfs的两种剪枝技巧：<ol>\n<li>不重复遍历相同的 if i!=cur &amp;&amp; char[i]==char[i-1] continue</li>\n<li>记录当前左括号和右括号的数量，只有左括号的数量大于等于右括号，再遍历需要这个右括号的这种情况，否则就不遍历这种情况（这道题没用）</li>\n</ol>\n</li>\n<li>注意这道题在进行递归的时候，不是一个字符一个字符的判断到底加不加当前的字符，而是使用一个循环，从当前字符遍历到最后一个字符，然后将当前字符前面和后面的字符串进行拼接， 然后仍然从当前遍历的下标，进入下一个循环。通过这种方式可以跳过一些重复的循环， 比如（（（）， 这种方式只需要移除一个（ ， 没必要每个进行判断</li>\n</ul>\n<p> 回溯+剪枝+去冗余（set/循环去）+括号匹配check, 这道题是遍历删除的字符，而不是留下的字符，因此需要用到path.substr，来进行删除后字符串的重新组合</p>\n<ul>\n<li>这道题可以扩展出另外一个题：如何判断一个字符串应该删除多少左括号，多少右括号使得剩下括号有效<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">left=<span class=\"hljs-number\">0</span>, right=<span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">//需要删除的左右括号数量</span><br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;size;i++)&#123;<br>    <span class=\"hljs-keyword\">if</span>(s[i]==<span class=\"hljs-string\">&#x27;(&#x27;</span>)&#123;<br>        left++;<br>    &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>        <span class=\"hljs-keyword\">if</span>(left&gt;<span class=\"hljs-number\">0</span>)&#123;<br>            left--;<br>        &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>            right++;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n<p><font color=\"blue\">5. 最多能完成排序的块 I/II</font><br>    - 总结：==最大的元素标记了一个段==<br>    - 题解</p>\n<pre><code>    1. 无重复的元素：可以直接i==maxnum的时候res++\n    2. 有重复的元素\n        使用单调栈\n        1.如果大于等于栈顶，直接入栈， 也就是重复元素是可以单独成块的\n        2.如果小于，那么将栈顶下面小于当前值的元素pop掉，然后压入原来的栈顶\n</code></pre>\n<p><font color=\"red\">6. 基本计算器/基本计算器||/基本计算器||| （表达式中可能有空格）</font><br>第一个是只有正负符号和括号，（直接将括号展开）因此不需要转化逆波兰，只需要一个递归符号的栈+一个当前数的前面的符号就可以了；res+=s.top()* sign <em>num   易错点：注意在（ 要手动赋值当前的sign=1<br>第二个是有+-</em>/ ，但是全是正整数，因此只需要逆波兰，一个数字栈一个符号栈，在压栈的同时，根据优先级计算结果，同时在最后判断符号栈是否为空，如果不为空的话，需要将符号栈里面的元素逐个弹出<br>第三个是有+-*/ 和括号，如题2，在（压入栈中，在）依次弹出符号栈中的符号<br>第四个，自己的扩展，在第三个上面加上数据可以为正负； 难点在于判断-是负号还是减号<br>    1）将所有空格去掉 ，题目必须保证两个运算符号不会同时出现<br>    2）在num里面压入0<br>    3）在（-变为（0-；将（+ 变为（0+<br>    4）题解如第三题</p>\n<ol start=\"7\">\n<li><ol start=\"16\">\n<li>lc362. design-hit-counter<br>这道题和单调没有什么关系，主要是队列</li>\n</ol>\n</li>\n</ol>\n<ul>\n<li>这道题让我们设计一个点击计数器（设计数据结构），能够返回五分钟内的点击数，提示了有可能同一时间内有多次点击。</li>\n<li>由于操作都是按时间顺序的，下一次的时间戳都会大于等于本次的时间戳，那么最直接的方法就是用一个队列queue，每次点击时都将当前时间戳加入queue中，然后在需要获取点击数时，我们从队列开头开始看，如果开头的时间戳在5分钟以外了，就删掉，直到开头的时间戳在5分钟以内停止，然后返回queue的元素个数即为所求的点击数，</li>\n<li>follow up： 比较重要，因为在每个时间戳可能有多个数，所以可以用两个300大小数组，记录时间戳和点击数，节省时间和空间，每个时间戳应该放在timestamp%300的位置，因为多个timestamp映射同一个位置，所以需要先判断当前位置是不是放的当前这个数；然后read的时候，遍历300次，如果满足在5分钟内的条件，就res+=times[i]</li>\n<li>解题链接：<a href=\"https://www.cnblogs.com/grandyang/p/5605552.html\">https://www.cnblogs.com/grandyang/p/5605552.html</a></li>\n</ul>\n<p><font color=\"red\">8. lc456. 132 Pattern</font></p>\n<ul>\n<li><p>找到是否存在132这样的数对</p>\n</li>\n<li><p>枚举3， 然后维护遍历到3左边的最小值，那么就找到了1， 问题的关键在于如何找到2， 就是找到3右边最大小于3的数</p>\n</li>\n<li><p>方法1： 使用单调栈（找到每个数右边，第一个小于这个数的最大数，注意不是第一个小于他的数，而是小于他的最大数）进行预处理，并将结果存在一个vector中，时间复杂度为O(nlogn)<br>第一个小于他的数： 左到右， 单增<br>第一个小于这个数的最大数：二分查找（multiset） 转为找到第一个大于leftmin的数</p>\n</li>\n<li><p>方法二：使用栈记录3（左到右，递增，3越来越大）， 变量记录2，使得3 2都尽可能大; 然后枚举1，如果1小于当前变量记录值two，那么return true;<br>在这个过程中，two会逐渐变高，不会出现two下降的情况</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">int</span> two = INT_MIN;<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = size - <span class=\"hljs-number\">1</span>; i &gt;= <span class=\"hljs-number\">0</span>; i--)<br>&#123;<br>    <span class=\"hljs-keyword\">if</span>(nums[i]&lt;two)&#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">while</span>(!s.<span class=\"hljs-built_in\">empty</span>()&amp;&amp;nums[i]&gt;s.<span class=\"hljs-built_in\">top</span>())&#123; <span class=\"hljs-comment\">//找到小于他的最大值, 逐渐增大two</span><br>        two = s.<span class=\"hljs-built_in\">top</span>();<br>        s.<span class=\"hljs-built_in\">pop</span>();<br>    &#125;<br>    s.<span class=\"hljs-built_in\">push</span>(nums[i]);<br>&#125;<br></code></pre></td></tr></table></figure></li>\n</ul>\n<p>类似的一个题: lc334. 递增的三元子序列 （类似模式123）</p>\n<ul>\n<li>找到i, j, k使得nums[i]&lt; nums[j] &lt; nums[k]</li>\n<li>使用一个单调递增栈，同时不断减少当前数字在栈中位置的那个数， 比如1 5，7 后来访问到 3改为 1， 3， 7（一定注意使用lower_bound） 类似最长递增子序列长度大于3</li>\n<li>方法二：两次遍历，求每个数的leftMin 和rightMax, 看是否有一个数在两者之间</li>\n</ul>\n<ol start=\"9\">\n<li>lc895. 最大频率栈</li>\n</ol>\n<ul>\n<li>这个和LFU有点相像，但是实际上是不同的， LFU是删除最低频率的元素，但是这个是删除最高频率的栈中元素</li>\n<li>因此不需要每次改变频率的时候都从原来的频率栈中弹出，同理，每次减低频率的时候，也不用弹出+加入新的频率</li>\n<li>实际的解决方法用两个hash, 一个存储&lt;k, freq&gt; 一个存储&lt;freq, vector<k>&gt;/&lt;freq, stack<k>&gt;</k></k></li>\n<li>一定要注意这两个hash一定要同时修改，不能只修改一个，频率包含的元素在变，元素当前的频率在变</li>\n<li>LFU是使用unordered_map&lt;int, NodeList*&gt; 存储频率到一个双向链表； 以及一个unordered_map&lt;int, Node*&gt; 存储key到节点的位置</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>ok </p>\n<ol>\n<li><p>一定要清楚是单调递增栈还是单调递减栈；判断是单减栈还是单增栈的关键：是弹出的元素对后面的结果不会有影响。同时要注意push的是下标还是值</p>\n</li>\n<li><p>栈适合题目：括号相关，左右的第一个最大最小，表达式求值，模拟文件层数，树结构题目，数字数组（也可能用二分）操作。</p>\n</li>\n<li><p>括号是否匹配也可以转为整数加减问题</p>\n</li>\n</ol>\n<p>4.表达式求值可以直接将表达式转为逆波兰，在对逆波兰求值；或者直接用一个栈求值<br>第一种方法：使用一个结果栈（vector<char>），一个符号栈；如果遇到数字，直接压栈；如果遇到（，压栈；反括号，弹出符号栈中所有符号到结果栈，直到遇到（，并弹出（；运算符，如果符号栈顶符号优先级高于当前栈，那么弹出并压入结果栈，否则直接压入符号栈；最后如何符号栈有值，那么弹出所有符号到结果栈；注意是否有正负， 字母这些边界情况的处理</char></p>\n<ol start=\"5\">\n<li><p>求每个数右边第一个比当前数大的数，使用单调递增栈（栈顶到栈底），弹出的时候进行判断<br>//正序遍历求右边，用单调递增栈（栈顶到栈底），弹出的时候判断；逆序遍历，单调递增栈<br>注意：单增还是单减，看从栈顶到栈顶，不是栈低到栈顶<br>（底部）1，2，3，4，5（头部）   是单调递减</p>\n</li>\n<li><p>口诀：左右两边第一个比他大的数，用单调递增栈；比他小的数，用单调递减栈<br> 找较大，那么应该越远越大；找较小，应该越远越小</p>\n</li>\n</ol>\n","site":{"data":{}},"wordcount":7089,"excerpt":"","more":"<h3 id=\"单调栈相关题目：\"><a href=\"#单调栈相关题目：\" class=\"headerlink\" title=\"单调栈相关题目：\"></a>单调栈相关题目：</h3><ol>\n<li><p>去除重复字母</p>\n<ul>\n<li>使得去除重复字母之后，字符串的字典序最小</li>\n<li>值栈<br>记录剩下字符串中是否包含这个字符，如果包含，那么就可以弹出（如果当前字符比这个字符小，就弹出）</li>\n</ul>\n</li>\n<li><p>接雨水</p>\n<ul>\n<li>方法一：每个地方能接的雨水是当前下标左右两边最大值（LeftMax and RightMax）的较小一个 –&gt;值栈</li>\n<li>方法二：使用单调递减栈，维护top and left（单调栈的top下面的值） –&gt;下标栈</li>\n</ul>\n<p> 接雨水II:</p>\n<ul>\n<li>二维接雨水</li>\n<li>上下左右四个方向分别取最大值再求短板这种想法在二维接雨水中，是不能获得正确结果的。</li>\n<li>正确的解法是，先将矩阵的外围放入优先队列中，然后取出最端的一个点，更新它四周的（需要使用vis数组，有的更新过就不能更新了），<br>如果没有被vis而且当前点比他高，那么res+=h-matrix[i][j], 然后将改点压入栈中（高度为max(h, matrix[i][j])）；否则直接压入栈中</li>\n</ul>\n</li>\n</ol>\n<ol start=\"3\">\n<li>直方图最大矩阵面积<ul>\n<li>求离当前直方图左右两边第一个小于该直方图的下标，使用左边单调递增+右边单调递增</li>\n<li>注意边缘的节点，因此需要提前向栈push -1或者size， 作为哨兵节点</li>\n<li>下标栈</li>\n</ul>\n</li>\n</ol>\n<ol start=\"4\">\n<li><p>围成矩形的最大面积 </p>\n<ul>\n<li>转为每行的直方图的最大面积 O(mn)</li>\n<li>（下标栈）<br>扩展： 最大正方形：使用dp<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;=m;i++)&#123;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">1</span>;j&lt;=n;j++)&#123;<br>        <span class=\"hljs-keyword\">if</span>(matrix[i<span class=\"hljs-number\">-1</span>][j<span class=\"hljs-number\">-1</span>]==<span class=\"hljs-string\">&#x27;1&#x27;</span>)&#123;<br>            dp[i][j]=<span class=\"hljs-built_in\">min</span>(dp[i<span class=\"hljs-number\">-1</span>][j<span class=\"hljs-number\">-1</span>],<span class=\"hljs-built_in\">min</span>(dp[i<span class=\"hljs-number\">-1</span>][j],dp[i][j<span class=\"hljs-number\">-1</span>]))+<span class=\"hljs-number\">1</span>;<br>            result=<span class=\"hljs-built_in\">max</span>(dp[i][j],result);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>公式字符串求值</p>\n<ul>\n<li>可以遇到（）后进入递归，或者压入op栈中.注意（-15）这种要特别判断，if(s[i]==’-‘) &amp;&amp; if(i==0||s[i-1]==’(‘) 那么就循环获得一个负数（括号可以进入op栈中，也可以直接跳过）</li>\n<li>在计算优先级的时候：可以不用传入两个判断，可以给每一个运算符一个分数<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs kotlin\">int grade( char op ) &#123;<br>    <span class=\"hljs-keyword\">if</span> (op == <span class=\"hljs-string\">&#x27;(&#x27;</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">if</span> (op == <span class=\"hljs-string\">&#x27;+&#x27;</span> || op == <span class=\"hljs-string\">&#x27;-&#x27;</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">2</span>;<br>    <span class=\"hljs-keyword\">if</span> (op == <span class=\"hljs-string\">&#x27;*&#x27;</span> || op == <span class=\"hljs-string\">&#x27;/&#x27;</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">3</span>;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>逆波兰表达式</p>\n</li>\n<li><p>滑动窗口的最大值</p>\n<ul>\n<li>可以使用优先队列， 单调递减的双向队列</li>\n<li>一定要注意最开始压入0~k-1个字符的时候，就要压入一个结果，而不是下一个压入前面一个字符的结果，因为这样可能导致压入少一个字符</li>\n</ul>\n</li>\n<li><p>频率最高的k个字符</p>\n<ul>\n<li>使用大小为k的最小堆，其实也是使用优先队列实现的堆，需要自定义排序方式<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-comment\">// 小顶堆</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">mycomparison</span> &#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">bool</span> <span class=\"hljs-title\">operator</span><span class=\"hljs-params\">()</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> pair&lt;<span class=\"hljs-keyword\">int</span>, <span class=\"hljs-keyword\">int</span>&gt;&amp; lhs, <span class=\"hljs-keyword\">const</span> pair&lt;<span class=\"hljs-keyword\">int</span>, <span class=\"hljs-keyword\">int</span>&gt;&amp; rhs)</span> </span>&#123;<br>        <span class=\"hljs-keyword\">return</span> lhs.second &gt; rhs.second;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>有的模拟题也是用栈的，</p>\n<ul>\n<li>比如文件的最长路径，栈中维护递增level的长度，如果当前的level&lt;栈顶的level那么弹栈；如果遇到当前是文件，那么统计栈中元素加起来的值和result比较取最大</li>\n<li>这种题一般需要对token先进行划分，然后进行统计</li>\n</ul>\n</li>\n<li><p>移掉 K 位数字</p>\n<ul>\n<li>使用单调栈，如果当前的字符小于栈顶的元素，那么循环弹出。易错点：剩下的字符包含头部0元素，以及最后如何结果为空字符串的话，应该返回“0”而不是“”</li>\n</ul>\n</li>\n<li><p>下一个更大元素|| </p>\n<ul>\n<li>题意：找到每个元素后面，第一个大于当前元素的数</li>\n<li>我的解法：从后往前，前面在进行判断的时候使用后面的nextid,可以跳过一些数，next[i]==-1表示没有比当前数更大的，next[i]==-2表示当前数还没有计算 nextid有值那么直接进行跳转nextid=next[nextid]</li>\n<li>官方题解：单调栈，但是因为是训练列表，所以需要遍历n+n-1个数据</li>\n</ul>\n</li>\n</ol>\n<ol start=\"12\">\n<li><p>子数组的最小值之和</p>\n<ul>\n<li>题意：这道题求每个数左边比他小的第一个数的下标，和右边第一个比他小于或等于的数的下标</li>\n<li>解决：使用单调递减栈； 结果就是：arr[i]*(i-left[i]) * (right[i]-i)<br>注意为了处理两个数相同的情况，使用左边小于，右边小于等于！！！ </li>\n<li>比如：1 2 4 8 1</li>\n</ul>\n</li>\n<li><p>最小栈</p>\n<ul>\n<li>题目：如何用时间O(1)和空间O(1)的复杂度得到栈中的最小值</li>\n<li>解决：原始的数据栈用来记录数据与min的差值 （value-min），同时用一个min变量记录当前栈的最小值;注意如果数值没有限制的话，差值的计算可能会溢出。<ul>\n<li>getmin()：始终返回min变量的值</li>\n<li>void pop(): 如果栈顶元素小于0，那么说明当前栈顶元素就是min(如果需要返回栈顶元素只，那么返回min),同时更新min为min-stack.top();否则不更新min</li>\n<li>void push(value): 当栈为空，直接压入value, 令min=value, push(0); 如果不为空，计算 value-min，并压入栈中; 如果小于0, 那么修改min为value, 否则min不变。<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> 设计一个有<span class=\"hljs-title\">gitMin</span>的栈 &#123;</span><br><br>    <span class=\"hljs-keyword\">private</span> Stack&lt;Integer&gt; stack = <span class=\"hljs-keyword\">new</span> Stack&lt;Integer&gt;();<br>    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> min;<br>    <br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">push</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> x)</span> </span>&#123;<br>        <span class=\"hljs-keyword\">if</span> (stack.<span class=\"hljs-built_in\">isEmpty</span>()) &#123;<br>            min = x;<br>            stack.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-number\">0</span>);<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            <span class=\"hljs-comment\">// 计算差值</span><br>            <span class=\"hljs-keyword\">int</span> compare = x - min;<br>            stack.<span class=\"hljs-built_in\">push</span>(compare);<br>            <span class=\"hljs-comment\">// 如果差值小于0，显然 x 成为最小值，否则最小值不变</span><br>            min = compare &lt; <span class=\"hljs-number\">0</span> ? x : min;<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">pop</span><span class=\"hljs-params\">()</span> </span>&#123;<br>        <span class=\"hljs-keyword\">int</span> top = stack.<span class=\"hljs-built_in\">peek</span>();<br>        <span class=\"hljs-comment\">// 如果top小于0，显然最小值也一并会被删除，此时更新最小值</span><br>        min = top &lt; <span class=\"hljs-number\">0</span> ? (min - top) : min;<br>        stack.<span class=\"hljs-built_in\">pop</span>();<br>    &#125;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">getMin</span><span class=\"hljs-params\">()</span> </span>&#123;<br>        <span class=\"hljs-keyword\">return</span> min;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"括号相关的题目专题\"><a href=\"#括号相关的题目专题\" class=\"headerlink\" title=\"括号相关的题目专题\"></a>括号相关的题目专题</h3><p><strong>总结:</strong> 一般来说括号相关的题使用栈解决，但是有的题目也使用动态规划解决。同时栈的方式也可以演变为更加简单的整数加减问题，不需要额外的空间。左括号出现那么+1， 右括号出现那么如果有左括号，那么左括号-1否则右括号+1</p>\n<ol>\n<li><p>有效的括号字符串</p>\n<ul>\n<li>因为*既可以当左括号，又可以当右括号，又可以当空白字符</li>\n<li>因此需要两个栈，当左括号栈为空的时候，从星号栈弹，否则从左括号栈弹、如果最后左括号不为空，那么比较信号栈顶和左括号栈顶下标，如果星号栈顶下标大，那么同时弹出，重复上述过程</li>\n<li>如果是动态规划的话； 就是判断dp[i][j]是否为true, 判断标准是 如果i==’(‘或者’<em>‘ 且j==’)’或者 ‘ <em>‘那么dp[i][j]=dp[i+1][j-1] 同时遍历i 到j之间的每一个元素，dp[i][j] |=dp[i][k]&amp;&amp;dp[k][j] (发现为true就break)<br>类似长度的动态规划（最长回文子串）<br>len==1 s[i]==’</em>‘ dp[i][i]=true<br>len==2 (s[i]==’(‘||s[i]==’</em>‘ ) &amp;&amp; (s[j]==’)’||s[j]==’*’)</li>\n</ul>\n</li>\n<li><p>括号的生成，使用dfs， 左括号的数量应该时刻保持&gt;=右括号的数量， 因此可以使用每使用一个左括号，可使用的右括号数量+1， 左括号：n-&gt;0, 右括号：0-&gt;n</p>\n</li>\n<li><p>最长有效括号（动态规划中也有总结）</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">longestValidParentheses</span><span class=\"hljs-params\">(String s)</span> </span>&#123;<br>        <span class=\"hljs-keyword\">int</span> maxans = <span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-keyword\">int</span>[] dp = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[s.<span class=\"hljs-built_in\">length</span>()];<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt; s.<span class=\"hljs-built_in\">length</span>(); i++) &#123;<br>            <span class=\"hljs-keyword\">if</span> (s.<span class=\"hljs-built_in\">charAt</span>(i) == <span class=\"hljs-string\">&#x27;)&#x27;</span>) &#123;<br>                <span class=\"hljs-keyword\">if</span> (s.<span class=\"hljs-built_in\">charAt</span>(i - <span class=\"hljs-number\">1</span>) == <span class=\"hljs-string\">&#x27;(&#x27;</span>) &#123;<br>                    dp[i] = (i &gt;= <span class=\"hljs-number\">2</span> ? dp[i - <span class=\"hljs-number\">2</span>] : <span class=\"hljs-number\">0</span>) + <span class=\"hljs-number\">2</span>;<br>                &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (i - dp[i - <span class=\"hljs-number\">1</span>] &gt; <span class=\"hljs-number\">0</span> &amp;&amp; s.<span class=\"hljs-built_in\">charAt</span>(i - dp[i - <span class=\"hljs-number\">1</span>] - <span class=\"hljs-number\">1</span>) == <span class=\"hljs-string\">&#x27;(&#x27;</span>) &#123;<br>                    dp[i] = dp[i - <span class=\"hljs-number\">1</span>] + ((i - dp[i - <span class=\"hljs-number\">1</span>]) &gt;= <span class=\"hljs-number\">2</span> ? dp[i - dp[i - <span class=\"hljs-number\">1</span>] - <span class=\"hljs-number\">2</span>] : <span class=\"hljs-number\">0</span>) + <span class=\"hljs-number\">2</span>;<br>                &#125;<br>                maxans = Math.<span class=\"hljs-built_in\">max</span>(maxans, dp[i]);<br>            &#125;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> maxans;<br>    &#125;<br></code></pre></td></tr></table></figure>\n<p><font color=\"red\"> 4. 删除无效的括号 </font></p>\n<ul>\n<li>因为是需要知道删除后所有有效的情况，所以应该dfs，同时难点在于去重</li>\n<li>solution: 先计算得到要删除的左右括号的数量，然后再dfs求所有合格的情况</li>\n<li>和其他dfs不一样在于，dfs遍历的是删除的括号，而不是留下的括号</li>\n<li>使用dfs的两种剪枝技巧：<ol>\n<li>不重复遍历相同的 if i!=cur &amp;&amp; char[i]==char[i-1] continue</li>\n<li>记录当前左括号和右括号的数量，只有左括号的数量大于等于右括号，再遍历需要这个右括号的这种情况，否则就不遍历这种情况（这道题没用）</li>\n</ol>\n</li>\n<li>注意这道题在进行递归的时候，不是一个字符一个字符的判断到底加不加当前的字符，而是使用一个循环，从当前字符遍历到最后一个字符，然后将当前字符前面和后面的字符串进行拼接， 然后仍然从当前遍历的下标，进入下一个循环。通过这种方式可以跳过一些重复的循环， 比如（（（）， 这种方式只需要移除一个（ ， 没必要每个进行判断</li>\n</ul>\n<p> 回溯+剪枝+去冗余（set/循环去）+括号匹配check, 这道题是遍历删除的字符，而不是留下的字符，因此需要用到path.substr，来进行删除后字符串的重新组合</p>\n<ul>\n<li>这道题可以扩展出另外一个题：如何判断一个字符串应该删除多少左括号，多少右括号使得剩下括号有效<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">left=<span class=\"hljs-number\">0</span>, right=<span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">//需要删除的左右括号数量</span><br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;size;i++)&#123;<br>    <span class=\"hljs-keyword\">if</span>(s[i]==<span class=\"hljs-string\">&#x27;(&#x27;</span>)&#123;<br>        left++;<br>    &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>        <span class=\"hljs-keyword\">if</span>(left&gt;<span class=\"hljs-number\">0</span>)&#123;<br>            left--;<br>        &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>            right++;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n<p><font color=\"blue\">5. 最多能完成排序的块 I/II</font><br>    - 总结：==最大的元素标记了一个段==<br>    - 题解</p>\n<pre><code>    1. 无重复的元素：可以直接i==maxnum的时候res++\n    2. 有重复的元素\n        使用单调栈\n        1.如果大于等于栈顶，直接入栈， 也就是重复元素是可以单独成块的\n        2.如果小于，那么将栈顶下面小于当前值的元素pop掉，然后压入原来的栈顶\n</code></pre>\n<p><font color=\"red\">6. 基本计算器/基本计算器||/基本计算器||| （表达式中可能有空格）</font><br>第一个是只有正负符号和括号，（直接将括号展开）因此不需要转化逆波兰，只需要一个递归符号的栈+一个当前数的前面的符号就可以了；res+=s.top()* sign <em>num   易错点：注意在（ 要手动赋值当前的sign=1<br>第二个是有+-</em>/ ，但是全是正整数，因此只需要逆波兰，一个数字栈一个符号栈，在压栈的同时，根据优先级计算结果，同时在最后判断符号栈是否为空，如果不为空的话，需要将符号栈里面的元素逐个弹出<br>第三个是有+-*/ 和括号，如题2，在（压入栈中，在）依次弹出符号栈中的符号<br>第四个，自己的扩展，在第三个上面加上数据可以为正负； 难点在于判断-是负号还是减号<br>    1）将所有空格去掉 ，题目必须保证两个运算符号不会同时出现<br>    2）在num里面压入0<br>    3）在（-变为（0-；将（+ 变为（0+<br>    4）题解如第三题</p>\n<ol start=\"7\">\n<li><ol start=\"16\">\n<li>lc362. design-hit-counter<br>这道题和单调没有什么关系，主要是队列</li>\n</ol>\n</li>\n</ol>\n<ul>\n<li>这道题让我们设计一个点击计数器（设计数据结构），能够返回五分钟内的点击数，提示了有可能同一时间内有多次点击。</li>\n<li>由于操作都是按时间顺序的，下一次的时间戳都会大于等于本次的时间戳，那么最直接的方法就是用一个队列queue，每次点击时都将当前时间戳加入queue中，然后在需要获取点击数时，我们从队列开头开始看，如果开头的时间戳在5分钟以外了，就删掉，直到开头的时间戳在5分钟以内停止，然后返回queue的元素个数即为所求的点击数，</li>\n<li>follow up： 比较重要，因为在每个时间戳可能有多个数，所以可以用两个300大小数组，记录时间戳和点击数，节省时间和空间，每个时间戳应该放在timestamp%300的位置，因为多个timestamp映射同一个位置，所以需要先判断当前位置是不是放的当前这个数；然后read的时候，遍历300次，如果满足在5分钟内的条件，就res+=times[i]</li>\n<li>解题链接：<a href=\"https://www.cnblogs.com/grandyang/p/5605552.html\">https://www.cnblogs.com/grandyang/p/5605552.html</a></li>\n</ul>\n<p><font color=\"red\">8. lc456. 132 Pattern</font></p>\n<ul>\n<li><p>找到是否存在132这样的数对</p>\n</li>\n<li><p>枚举3， 然后维护遍历到3左边的最小值，那么就找到了1， 问题的关键在于如何找到2， 就是找到3右边最大小于3的数</p>\n</li>\n<li><p>方法1： 使用单调栈（找到每个数右边，第一个小于这个数的最大数，注意不是第一个小于他的数，而是小于他的最大数）进行预处理，并将结果存在一个vector中，时间复杂度为O(nlogn)<br>第一个小于他的数： 左到右， 单增<br>第一个小于这个数的最大数：二分查找（multiset） 转为找到第一个大于leftmin的数</p>\n</li>\n<li><p>方法二：使用栈记录3（左到右，递增，3越来越大）， 变量记录2，使得3 2都尽可能大; 然后枚举1，如果1小于当前变量记录值two，那么return true;<br>在这个过程中，two会逐渐变高，不会出现two下降的情况</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">int</span> two = INT_MIN;<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = size - <span class=\"hljs-number\">1</span>; i &gt;= <span class=\"hljs-number\">0</span>; i--)<br>&#123;<br>    <span class=\"hljs-keyword\">if</span>(nums[i]&lt;two)&#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">while</span>(!s.<span class=\"hljs-built_in\">empty</span>()&amp;&amp;nums[i]&gt;s.<span class=\"hljs-built_in\">top</span>())&#123; <span class=\"hljs-comment\">//找到小于他的最大值, 逐渐增大two</span><br>        two = s.<span class=\"hljs-built_in\">top</span>();<br>        s.<span class=\"hljs-built_in\">pop</span>();<br>    &#125;<br>    s.<span class=\"hljs-built_in\">push</span>(nums[i]);<br>&#125;<br></code></pre></td></tr></table></figure></li>\n</ul>\n<p>类似的一个题: lc334. 递增的三元子序列 （类似模式123）</p>\n<ul>\n<li>找到i, j, k使得nums[i]&lt; nums[j] &lt; nums[k]</li>\n<li>使用一个单调递增栈，同时不断减少当前数字在栈中位置的那个数， 比如1 5，7 后来访问到 3改为 1， 3， 7（一定注意使用lower_bound） 类似最长递增子序列长度大于3</li>\n<li>方法二：两次遍历，求每个数的leftMin 和rightMax, 看是否有一个数在两者之间</li>\n</ul>\n<ol start=\"9\">\n<li>lc895. 最大频率栈</li>\n</ol>\n<ul>\n<li>这个和LFU有点相像，但是实际上是不同的， LFU是删除最低频率的元素，但是这个是删除最高频率的栈中元素</li>\n<li>因此不需要每次改变频率的时候都从原来的频率栈中弹出，同理，每次减低频率的时候，也不用弹出+加入新的频率</li>\n<li>实际的解决方法用两个hash, 一个存储&lt;k, freq&gt; 一个存储&lt;freq, vector<k>&gt;/&lt;freq, stack<k>&gt;</k></k></li>\n<li>一定要注意这两个hash一定要同时修改，不能只修改一个，频率包含的元素在变，元素当前的频率在变</li>\n<li>LFU是使用unordered_map&lt;int, NodeList*&gt; 存储频率到一个双向链表； 以及一个unordered_map&lt;int, Node*&gt; 存储key到节点的位置</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>ok </p>\n<ol>\n<li><p>一定要清楚是单调递增栈还是单调递减栈；判断是单减栈还是单增栈的关键：是弹出的元素对后面的结果不会有影响。同时要注意push的是下标还是值</p>\n</li>\n<li><p>栈适合题目：括号相关，左右的第一个最大最小，表达式求值，模拟文件层数，树结构题目，数字数组（也可能用二分）操作。</p>\n</li>\n<li><p>括号是否匹配也可以转为整数加减问题</p>\n</li>\n</ol>\n<p>4.表达式求值可以直接将表达式转为逆波兰，在对逆波兰求值；或者直接用一个栈求值<br>第一种方法：使用一个结果栈（vector<char>），一个符号栈；如果遇到数字，直接压栈；如果遇到（，压栈；反括号，弹出符号栈中所有符号到结果栈，直到遇到（，并弹出（；运算符，如果符号栈顶符号优先级高于当前栈，那么弹出并压入结果栈，否则直接压入符号栈；最后如何符号栈有值，那么弹出所有符号到结果栈；注意是否有正负， 字母这些边界情况的处理</char></p>\n<ol start=\"5\">\n<li><p>求每个数右边第一个比当前数大的数，使用单调递增栈（栈顶到栈底），弹出的时候进行判断<br>//正序遍历求右边，用单调递增栈（栈顶到栈底），弹出的时候判断；逆序遍历，单调递增栈<br>注意：单增还是单减，看从栈顶到栈顶，不是栈低到栈顶<br>（底部）1，2，3，4，5（头部）   是单调递减</p>\n</li>\n<li><p>口诀：左右两边第一个比他大的数，用单调递增栈；比他小的数，用单调递减栈<br> 找较大，那么应该越远越大；找较小，应该越远越小</p>\n</li>\n</ol>\n"},{"title":"双指针","catogory":["leetcode 题目汇总"],"date":"2021-11-13T09:22:25.000Z","_content":"\n### 例题\n#### 双指针+字符串\n// 反转字符串s中左闭又闭的区间[start, end]\nvoid reverse(string& s, int start, int end) {\n    for (int i = start, j = end; i < j; i++, j--) {\n        swap(s[i], s[j]);\n    }\n}\n\n\n<font color=red> 2. 替换后的最长重复字符</font>\n    - 经典滑动窗口题目，但是和其他滑动窗口不一样；主要是由于窗口内最多的字符是未知的，因为窗口即使收缩，长度也不会变小\n    - 如果k=0就是求连续的最长重复字符， 注意使用maxn保存滑动窗口内相同字母出现次数的 历史 最大值(注意不是当前最大值，而是历史最大值)， 所以窗口的长度只会增加或者保持不变不会减少；\n\n注意不是找当前窗口重复字符的最长，而是历史最长！！！\n\n\n3. 字符串的排列\n滑动窗口和双指针都可以，注意这道题只需要记录needle数组就可以了，不需要记录count\n因为这道题不是找到包含目标子串的子串，而是一定要包含子串，而且不多出额外字符（目标子串的任意排列）\n所以这道题也可以用固定长度的窗口\n\n所以只需要needle, needle小于0，就可以收缩窗口了。但是如果是包含关系，那么needle<0还不能收缩窗口，之后count==0才能收缩（题意应该为：包含目标子串的最短字符串）\n\n\n\n####  双指针与数组/hash\n两数之和\n三数之和\n四数之和\n\nlc16, 最近三数之和，思路和三数之和差不多==target的时候直接返回\nlc259. 3Sum Smaller 三数之和较小值， 找到nums[i] + nums[j] + nums[k] < target. 数量\n- 仍然使用三数之和的双指针方法，只是在找到< target的时候 res+=right-left; left++;(因为小于right三数之后都满足条件)； \n否则right--\n\n\n有效三角形的个数\n- 排序后使用二分查找\n- 或者使用双指针， 类似于三数之和，只不过这道题求的是两数之和大于第三数， 而不是两数之和等于第三数，因此也不需要hash\n\n01交换（把1全部换到后面）\n我的思路：所有1全部往右移动，1的顺序不变\n答案：右边第一个0，左边第一个1，如果左边_index<右边_index，那么res+=right-left+1(1的顺序是可以打乱的)\n\nlc 80. 删除有序数组中的重复项 II\n快慢指针\n```C++\n///k次\nint u = 0; \nfor (int x : nums) {\n    if (u < k || nums[u - k] != x) nums[u++] = x; //保证每个元素最多重复两次，同理可以类推到k次\n}\nreturn u;\n\n```\n\nlc202. 快乐数\n- 快慢指针不一定用在链表中判断是否有环，还可以用在数组中，以及用在替换hash， 查看这个数是否之前被访问过\n```C++\nint slow = n, fast = n;\ndo{\n    slow = bitSquareSum(slow);\n    fast = bitSquareSum(fast);\n    fast = bitSquareSum(fast);\n}while(slow != fast);\n```\n\n\n\n#### 其他（与栈有关）\n<font color=red>1. 盛最多水的容器</font>\n因为水的容量=左右较小值*len;那么移动较大值是不会增加容量的大小的\n双指针的问题，常用于排序数组中找target数，特征就是知道当前的值，能够容易的判断，下一个是移动左边还是右边指针\n注意这个是容积因此是长*宽，\n区分：对于和大于0的最长这道题，使用先遍历一次降序，然后逆序判断，这种方法是求长度最长，不是容积最大\n\n<font color=blue>2. 通过删除字母匹配到字典里最长单词</font>\n双指针来查找一个字符串是否为另一个字符串的子序列。\n同时这道题可以使用序列自动机来避免重复的字符查找。dp[i][j]  就是存储 s字符串从大于等于i开始的 第一个等于j的下标，如果s[i]==j那么dp[i][j]=i, 否则，dp[i][j]=dp[i+1][j]， 应该从后向前计算dp数组\n\n\n#### 双指针与枚举子集\n1. 乘积小于K的数组\n找到符合条件的子集的个数\n模板代码\n```C++\nint left=0, right=0;\nint cur=1;\nint res=0;\nif(k==0||k==1){\n    return res;\n}\nwhile(right<size){\n    cur=cur*nums[right];\n    if(cur<k){\n        res+=right-left+1; //注意需要+1\n    }else{\n        while(cur>=k){\n            cur/=nums[left];\n            left++;\n        }\n        res+=right-left+1;\n        \n    }\n    right++;\n}\nreturn res;\n```\n\n另外一种求所有子集的方式是使用统计计算，比如有窗口有cnt个数据，那么子集个数为cnt*(cnt+1)/2\n\nlc349.数组的交集（easy）\n排序之后+双指针，相等时候判断加不加这个数\n\n#### 双指针和链表\nlc86. 分隔链表\n- 将小于target放在大于等于target的前面，同时小于和大于target的数相对顺序不能变\n- 将链表分为smallList 和largeList (一个链表拆分成两个链表)， 同时为了避免空的讨论，使用dummy节点\n- 易错点， largeList的末尾节点->next一定要赋值为NULL\n\n\n\n### 总结\nok\n1. 双指针通常和滑动窗口， dp， hash共同来解决 字符串/数组等问题\n2. 左右移动的双指针通常满足在移动一边的指针的时候拥有一个递增或者递减的规律\n3. 两个有序数组中任意选一个数出来，之间的最短距离是多少; 较小的一个向前移动\n```C++\nwhile (i < index1.length && j < index2.length) {\n    const idx1 = index1[i], idx2 = index2[j];\n    if (idx1 > idx2) {\n      j++;\n    } else if (idx2 > idx1) {\n      i++;\n    }\n    min = Math.min(min, Math.abs(idx1 - idx2));\n  }\n```\n4. 当以字符串作为hash的key时候，可以使用字符数组 string s(26, '0'); 也可以对字符串进行排序后作为key\n\n5. 翻转交换类型的题目使用双指针，比如交换一个字符串里面全部的元音字母\n\n6. 快慢指针不一定用在链表中判断是否有环，还可以用在数组中，以及用在替换hash， 查看这个数是否之前被访问过；还可以用在去除冗余（类似于双指针）（lc442 数组中重复的数据/ 80. 删除有序数组中的重复项 II）\n但是lc442用原地hash或者置换到应该在的位置更好理解，使用快慢指针不好理解\n\n找到环路起点的标准模板代码：\n```C++\nint slow = 0, fast = 0;\ndo {\n  slow = nums[slow];\n  fast = nums[nums[fast]];\n} while (slow != fast);\nslow = 0;\nwhile (slow != fast) {\n  slow = nums[slow];\n  fast = nums[fast];\n}\nreturn slow;\n```","source":"_posts/leetcode/双指针.md","raw":"---\ntitle: 双指针\ncatogory:\n  - leetcode 题目汇总\ntags: 双指针\ncategories:\n  - leetcode\ndate: 2021-11-13 17:22:25\n---\n\n### 例题\n#### 双指针+字符串\n// 反转字符串s中左闭又闭的区间[start, end]\nvoid reverse(string& s, int start, int end) {\n    for (int i = start, j = end; i < j; i++, j--) {\n        swap(s[i], s[j]);\n    }\n}\n\n\n<font color=red> 2. 替换后的最长重复字符</font>\n    - 经典滑动窗口题目，但是和其他滑动窗口不一样；主要是由于窗口内最多的字符是未知的，因为窗口即使收缩，长度也不会变小\n    - 如果k=0就是求连续的最长重复字符， 注意使用maxn保存滑动窗口内相同字母出现次数的 历史 最大值(注意不是当前最大值，而是历史最大值)， 所以窗口的长度只会增加或者保持不变不会减少；\n\n注意不是找当前窗口重复字符的最长，而是历史最长！！！\n\n\n3. 字符串的排列\n滑动窗口和双指针都可以，注意这道题只需要记录needle数组就可以了，不需要记录count\n因为这道题不是找到包含目标子串的子串，而是一定要包含子串，而且不多出额外字符（目标子串的任意排列）\n所以这道题也可以用固定长度的窗口\n\n所以只需要needle, needle小于0，就可以收缩窗口了。但是如果是包含关系，那么needle<0还不能收缩窗口，之后count==0才能收缩（题意应该为：包含目标子串的最短字符串）\n\n\n\n####  双指针与数组/hash\n两数之和\n三数之和\n四数之和\n\nlc16, 最近三数之和，思路和三数之和差不多==target的时候直接返回\nlc259. 3Sum Smaller 三数之和较小值， 找到nums[i] + nums[j] + nums[k] < target. 数量\n- 仍然使用三数之和的双指针方法，只是在找到< target的时候 res+=right-left; left++;(因为小于right三数之后都满足条件)； \n否则right--\n\n\n有效三角形的个数\n- 排序后使用二分查找\n- 或者使用双指针， 类似于三数之和，只不过这道题求的是两数之和大于第三数， 而不是两数之和等于第三数，因此也不需要hash\n\n01交换（把1全部换到后面）\n我的思路：所有1全部往右移动，1的顺序不变\n答案：右边第一个0，左边第一个1，如果左边_index<右边_index，那么res+=right-left+1(1的顺序是可以打乱的)\n\nlc 80. 删除有序数组中的重复项 II\n快慢指针\n```C++\n///k次\nint u = 0; \nfor (int x : nums) {\n    if (u < k || nums[u - k] != x) nums[u++] = x; //保证每个元素最多重复两次，同理可以类推到k次\n}\nreturn u;\n\n```\n\nlc202. 快乐数\n- 快慢指针不一定用在链表中判断是否有环，还可以用在数组中，以及用在替换hash， 查看这个数是否之前被访问过\n```C++\nint slow = n, fast = n;\ndo{\n    slow = bitSquareSum(slow);\n    fast = bitSquareSum(fast);\n    fast = bitSquareSum(fast);\n}while(slow != fast);\n```\n\n\n\n#### 其他（与栈有关）\n<font color=red>1. 盛最多水的容器</font>\n因为水的容量=左右较小值*len;那么移动较大值是不会增加容量的大小的\n双指针的问题，常用于排序数组中找target数，特征就是知道当前的值，能够容易的判断，下一个是移动左边还是右边指针\n注意这个是容积因此是长*宽，\n区分：对于和大于0的最长这道题，使用先遍历一次降序，然后逆序判断，这种方法是求长度最长，不是容积最大\n\n<font color=blue>2. 通过删除字母匹配到字典里最长单词</font>\n双指针来查找一个字符串是否为另一个字符串的子序列。\n同时这道题可以使用序列自动机来避免重复的字符查找。dp[i][j]  就是存储 s字符串从大于等于i开始的 第一个等于j的下标，如果s[i]==j那么dp[i][j]=i, 否则，dp[i][j]=dp[i+1][j]， 应该从后向前计算dp数组\n\n\n#### 双指针与枚举子集\n1. 乘积小于K的数组\n找到符合条件的子集的个数\n模板代码\n```C++\nint left=0, right=0;\nint cur=1;\nint res=0;\nif(k==0||k==1){\n    return res;\n}\nwhile(right<size){\n    cur=cur*nums[right];\n    if(cur<k){\n        res+=right-left+1; //注意需要+1\n    }else{\n        while(cur>=k){\n            cur/=nums[left];\n            left++;\n        }\n        res+=right-left+1;\n        \n    }\n    right++;\n}\nreturn res;\n```\n\n另外一种求所有子集的方式是使用统计计算，比如有窗口有cnt个数据，那么子集个数为cnt*(cnt+1)/2\n\nlc349.数组的交集（easy）\n排序之后+双指针，相等时候判断加不加这个数\n\n#### 双指针和链表\nlc86. 分隔链表\n- 将小于target放在大于等于target的前面，同时小于和大于target的数相对顺序不能变\n- 将链表分为smallList 和largeList (一个链表拆分成两个链表)， 同时为了避免空的讨论，使用dummy节点\n- 易错点， largeList的末尾节点->next一定要赋值为NULL\n\n\n\n### 总结\nok\n1. 双指针通常和滑动窗口， dp， hash共同来解决 字符串/数组等问题\n2. 左右移动的双指针通常满足在移动一边的指针的时候拥有一个递增或者递减的规律\n3. 两个有序数组中任意选一个数出来，之间的最短距离是多少; 较小的一个向前移动\n```C++\nwhile (i < index1.length && j < index2.length) {\n    const idx1 = index1[i], idx2 = index2[j];\n    if (idx1 > idx2) {\n      j++;\n    } else if (idx2 > idx1) {\n      i++;\n    }\n    min = Math.min(min, Math.abs(idx1 - idx2));\n  }\n```\n4. 当以字符串作为hash的key时候，可以使用字符数组 string s(26, '0'); 也可以对字符串进行排序后作为key\n\n5. 翻转交换类型的题目使用双指针，比如交换一个字符串里面全部的元音字母\n\n6. 快慢指针不一定用在链表中判断是否有环，还可以用在数组中，以及用在替换hash， 查看这个数是否之前被访问过；还可以用在去除冗余（类似于双指针）（lc442 数组中重复的数据/ 80. 删除有序数组中的重复项 II）\n但是lc442用原地hash或者置换到应该在的位置更好理解，使用快慢指针不好理解\n\n找到环路起点的标准模板代码：\n```C++\nint slow = 0, fast = 0;\ndo {\n  slow = nums[slow];\n  fast = nums[nums[fast]];\n} while (slow != fast);\nslow = 0;\nwhile (slow != fast) {\n  slow = nums[slow];\n  fast = nums[fast];\n}\nreturn slow;\n```","slug":"leetcode/双指针","published":1,"updated":"2023-07-10T10:36:19.571Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clk5ceink000ijpjbdjhrgk2k","content":"<h3 id=\"例题\"><a href=\"#例题\" class=\"headerlink\" title=\"例题\"></a>例题</h3><h4 id=\"双指针-字符串\"><a href=\"#双指针-字符串\" class=\"headerlink\" title=\"双指针+字符串\"></a>双指针+字符串</h4><p>// 反转字符串s中左闭又闭的区间[start, end]<br>void reverse(string&amp; s, int start, int end) {<br>    for (int i = start, j = end; i &lt; j; i++, j–) {<br>        swap(s[i], s[j]);<br>    }<br>}</p>\n<p><font color=\"red\"> 2. 替换后的最长重复字符</font><br>    - 经典滑动窗口题目，但是和其他滑动窗口不一样；主要是由于窗口内最多的字符是未知的，因为窗口即使收缩，长度也不会变小<br>    - 如果k=0就是求连续的最长重复字符， 注意使用maxn保存滑动窗口内相同字母出现次数的 历史 最大值(注意不是当前最大值，而是历史最大值)， 所以窗口的长度只会增加或者保持不变不会减少；</p>\n<p>注意不是找当前窗口重复字符的最长，而是历史最长！！！</p>\n<ol start=\"3\">\n<li>字符串的排列<br>滑动窗口和双指针都可以，注意这道题只需要记录needle数组就可以了，不需要记录count<br>因为这道题不是找到包含目标子串的子串，而是一定要包含子串，而且不多出额外字符（目标子串的任意排列）<br>所以这道题也可以用固定长度的窗口</li>\n</ol>\n<p>所以只需要needle, needle小于0，就可以收缩窗口了。但是如果是包含关系，那么needle&lt;0还不能收缩窗口，之后count==0才能收缩（题意应该为：包含目标子串的最短字符串）</p>\n<h4 id=\"双指针与数组-hash\"><a href=\"#双指针与数组-hash\" class=\"headerlink\" title=\"双指针与数组/hash\"></a>双指针与数组/hash</h4><p>两数之和<br>三数之和<br>四数之和</p>\n<p>lc16, 最近三数之和，思路和三数之和差不多==target的时候直接返回<br>lc259. 3Sum Smaller 三数之和较小值， 找到nums[i] + nums[j] + nums[k] &lt; target. 数量</p>\n<ul>\n<li>仍然使用三数之和的双指针方法，只是在找到&lt; target的时候 res+=right-left; left++;(因为小于right三数之后都满足条件)；<br>否则right–</li>\n</ul>\n<p>有效三角形的个数</p>\n<ul>\n<li>排序后使用二分查找</li>\n<li>或者使用双指针， 类似于三数之和，只不过这道题求的是两数之和大于第三数， 而不是两数之和等于第三数，因此也不需要hash</li>\n</ul>\n<p>01交换（把1全部换到后面）<br>我的思路：所有1全部往右移动，1的顺序不变<br>答案：右边第一个0，左边第一个1，如果左边_index&lt;右边_index，那么res+=right-left+1(1的顺序是可以打乱的)</p>\n<p>lc 80. 删除有序数组中的重复项 II<br>快慢指针</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-comment\">///k次</span><br><span class=\"hljs-keyword\">int</span> u = <span class=\"hljs-number\">0</span>; <br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> x : nums) &#123;<br>    <span class=\"hljs-keyword\">if</span> (u &lt; k || nums[u - k] != x) nums[u++] = x; <span class=\"hljs-comment\">//保证每个元素最多重复两次，同理可以类推到k次</span><br>&#125;<br><span class=\"hljs-keyword\">return</span> u;<br><br></code></pre></td></tr></table></figure>\n\n<p>lc202. 快乐数</p>\n<ul>\n<li>快慢指针不一定用在链表中判断是否有环，还可以用在数组中，以及用在替换hash， 查看这个数是否之前被访问过<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">int</span> slow = n, fast = n;<br><span class=\"hljs-keyword\">do</span>&#123;<br>    slow = <span class=\"hljs-built_in\">bitSquareSum</span>(slow);<br>    fast = <span class=\"hljs-built_in\">bitSquareSum</span>(fast);<br>    fast = <span class=\"hljs-built_in\">bitSquareSum</span>(fast);<br>&#125;<span class=\"hljs-keyword\">while</span>(slow != fast);<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"其他（与栈有关）\"><a href=\"#其他（与栈有关）\" class=\"headerlink\" title=\"其他（与栈有关）\"></a>其他（与栈有关）</h4><p><font color=\"red\">1. 盛最多水的容器</font><br>因为水的容量=左右较小值<em>len;那么移动较大值是不会增加容量的大小的<br>双指针的问题，常用于排序数组中找target数，特征就是知道当前的值，能够容易的判断，下一个是移动左边还是右边指针<br>注意这个是容积因此是长</em>宽，<br>区分：对于和大于0的最长这道题，使用先遍历一次降序，然后逆序判断，这种方法是求长度最长，不是容积最大</p>\n<p><font color=\"blue\">2. 通过删除字母匹配到字典里最长单词</font><br>双指针来查找一个字符串是否为另一个字符串的子序列。<br>同时这道题可以使用序列自动机来避免重复的字符查找。dp[i][j]  就是存储 s字符串从大于等于i开始的 第一个等于j的下标，如果s[i]==j那么dp[i][j]=i, 否则，dp[i][j]=dp[i+1][j]， 应该从后向前计算dp数组</p>\n<h4 id=\"双指针与枚举子集\"><a href=\"#双指针与枚举子集\" class=\"headerlink\" title=\"双指针与枚举子集\"></a>双指针与枚举子集</h4><ol>\n<li>乘积小于K的数组<br>找到符合条件的子集的个数<br>模板代码<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">int</span> left=<span class=\"hljs-number\">0</span>, right=<span class=\"hljs-number\">0</span>;<br><span class=\"hljs-keyword\">int</span> cur=<span class=\"hljs-number\">1</span>;<br><span class=\"hljs-keyword\">int</span> res=<span class=\"hljs-number\">0</span>;<br><span class=\"hljs-keyword\">if</span>(k==<span class=\"hljs-number\">0</span>||k==<span class=\"hljs-number\">1</span>)&#123;<br>    <span class=\"hljs-keyword\">return</span> res;<br>&#125;<br><span class=\"hljs-keyword\">while</span>(right&lt;size)&#123;<br>    cur=cur*nums[right];<br>    <span class=\"hljs-keyword\">if</span>(cur&lt;k)&#123;<br>        res+=right-left+<span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">//注意需要+1</span><br>    &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>        <span class=\"hljs-keyword\">while</span>(cur&gt;=k)&#123;<br>            cur/=nums[left];<br>            left++;<br>        &#125;<br>        res+=right-left+<span class=\"hljs-number\">1</span>;<br>        <br>    &#125;<br>    right++;<br>&#125;<br><span class=\"hljs-keyword\">return</span> res;<br></code></pre></td></tr></table></figure></li>\n</ol>\n<p>另外一种求所有子集的方式是使用统计计算，比如有窗口有cnt个数据，那么子集个数为cnt*(cnt+1)/2</p>\n<p>lc349.数组的交集（easy）<br>排序之后+双指针，相等时候判断加不加这个数</p>\n<h4 id=\"双指针和链表\"><a href=\"#双指针和链表\" class=\"headerlink\" title=\"双指针和链表\"></a>双指针和链表</h4><p>lc86. 分隔链表</p>\n<ul>\n<li>将小于target放在大于等于target的前面，同时小于和大于target的数相对顺序不能变</li>\n<li>将链表分为smallList 和largeList (一个链表拆分成两个链表)， 同时为了避免空的讨论，使用dummy节点</li>\n<li>易错点， largeList的末尾节点-&gt;next一定要赋值为NULL</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>ok</p>\n<ol>\n<li><p>双指针通常和滑动窗口， dp， hash共同来解决 字符串/数组等问题</p>\n</li>\n<li><p>左右移动的双指针通常满足在移动一边的指针的时候拥有一个递增或者递减的规律</p>\n</li>\n<li><p>两个有序数组中任意选一个数出来，之间的最短距离是多少; 较小的一个向前移动</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">while</span> (i &lt; index1.length &amp;&amp; j &lt; index2.length) &#123;<br>    <span class=\"hljs-keyword\">const</span> idx1 = index1[i], idx2 = index2[j];<br>    <span class=\"hljs-keyword\">if</span> (idx1 &gt; idx2) &#123;<br>      j++;<br>    &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (idx2 &gt; idx1) &#123;<br>      i++;<br>    &#125;<br>    min = Math.<span class=\"hljs-built_in\">min</span>(min, Math.<span class=\"hljs-built_in\">abs</span>(idx1 - idx2));<br>  &#125;<br></code></pre></td></tr></table></figure></li>\n<li><p>当以字符串作为hash的key时候，可以使用字符数组 string s(26, ‘0’); 也可以对字符串进行排序后作为key</p>\n</li>\n<li><p>翻转交换类型的题目使用双指针，比如交换一个字符串里面全部的元音字母</p>\n</li>\n<li><p>快慢指针不一定用在链表中判断是否有环，还可以用在数组中，以及用在替换hash， 查看这个数是否之前被访问过；还可以用在去除冗余（类似于双指针）（lc442 数组中重复的数据/ 80. 删除有序数组中的重复项 II）<br>但是lc442用原地hash或者置换到应该在的位置更好理解，使用快慢指针不好理解</p>\n</li>\n</ol>\n<p>找到环路起点的标准模板代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">int</span> slow = <span class=\"hljs-number\">0</span>, fast = <span class=\"hljs-number\">0</span>;<br><span class=\"hljs-keyword\">do</span> &#123;<br>  slow = nums[slow];<br>  fast = nums[nums[fast]];<br>&#125; <span class=\"hljs-keyword\">while</span> (slow != fast);<br>slow = <span class=\"hljs-number\">0</span>;<br><span class=\"hljs-keyword\">while</span> (slow != fast) &#123;<br>  slow = nums[slow];<br>  fast = nums[fast];<br>&#125;<br><span class=\"hljs-keyword\">return</span> slow;<br></code></pre></td></tr></table></figure>","site":{"data":{}},"wordcount":2912,"excerpt":"","more":"<h3 id=\"例题\"><a href=\"#例题\" class=\"headerlink\" title=\"例题\"></a>例题</h3><h4 id=\"双指针-字符串\"><a href=\"#双指针-字符串\" class=\"headerlink\" title=\"双指针+字符串\"></a>双指针+字符串</h4><p>// 反转字符串s中左闭又闭的区间[start, end]<br>void reverse(string&amp; s, int start, int end) {<br>    for (int i = start, j = end; i &lt; j; i++, j–) {<br>        swap(s[i], s[j]);<br>    }<br>}</p>\n<p><font color=\"red\"> 2. 替换后的最长重复字符</font><br>    - 经典滑动窗口题目，但是和其他滑动窗口不一样；主要是由于窗口内最多的字符是未知的，因为窗口即使收缩，长度也不会变小<br>    - 如果k=0就是求连续的最长重复字符， 注意使用maxn保存滑动窗口内相同字母出现次数的 历史 最大值(注意不是当前最大值，而是历史最大值)， 所以窗口的长度只会增加或者保持不变不会减少；</p>\n<p>注意不是找当前窗口重复字符的最长，而是历史最长！！！</p>\n<ol start=\"3\">\n<li>字符串的排列<br>滑动窗口和双指针都可以，注意这道题只需要记录needle数组就可以了，不需要记录count<br>因为这道题不是找到包含目标子串的子串，而是一定要包含子串，而且不多出额外字符（目标子串的任意排列）<br>所以这道题也可以用固定长度的窗口</li>\n</ol>\n<p>所以只需要needle, needle小于0，就可以收缩窗口了。但是如果是包含关系，那么needle&lt;0还不能收缩窗口，之后count==0才能收缩（题意应该为：包含目标子串的最短字符串）</p>\n<h4 id=\"双指针与数组-hash\"><a href=\"#双指针与数组-hash\" class=\"headerlink\" title=\"双指针与数组/hash\"></a>双指针与数组/hash</h4><p>两数之和<br>三数之和<br>四数之和</p>\n<p>lc16, 最近三数之和，思路和三数之和差不多==target的时候直接返回<br>lc259. 3Sum Smaller 三数之和较小值， 找到nums[i] + nums[j] + nums[k] &lt; target. 数量</p>\n<ul>\n<li>仍然使用三数之和的双指针方法，只是在找到&lt; target的时候 res+=right-left; left++;(因为小于right三数之后都满足条件)；<br>否则right–</li>\n</ul>\n<p>有效三角形的个数</p>\n<ul>\n<li>排序后使用二分查找</li>\n<li>或者使用双指针， 类似于三数之和，只不过这道题求的是两数之和大于第三数， 而不是两数之和等于第三数，因此也不需要hash</li>\n</ul>\n<p>01交换（把1全部换到后面）<br>我的思路：所有1全部往右移动，1的顺序不变<br>答案：右边第一个0，左边第一个1，如果左边_index&lt;右边_index，那么res+=right-left+1(1的顺序是可以打乱的)</p>\n<p>lc 80. 删除有序数组中的重复项 II<br>快慢指针</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-comment\">///k次</span><br><span class=\"hljs-keyword\">int</span> u = <span class=\"hljs-number\">0</span>; <br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> x : nums) &#123;<br>    <span class=\"hljs-keyword\">if</span> (u &lt; k || nums[u - k] != x) nums[u++] = x; <span class=\"hljs-comment\">//保证每个元素最多重复两次，同理可以类推到k次</span><br>&#125;<br><span class=\"hljs-keyword\">return</span> u;<br><br></code></pre></td></tr></table></figure>\n\n<p>lc202. 快乐数</p>\n<ul>\n<li>快慢指针不一定用在链表中判断是否有环，还可以用在数组中，以及用在替换hash， 查看这个数是否之前被访问过<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">int</span> slow = n, fast = n;<br><span class=\"hljs-keyword\">do</span>&#123;<br>    slow = <span class=\"hljs-built_in\">bitSquareSum</span>(slow);<br>    fast = <span class=\"hljs-built_in\">bitSquareSum</span>(fast);<br>    fast = <span class=\"hljs-built_in\">bitSquareSum</span>(fast);<br>&#125;<span class=\"hljs-keyword\">while</span>(slow != fast);<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"其他（与栈有关）\"><a href=\"#其他（与栈有关）\" class=\"headerlink\" title=\"其他（与栈有关）\"></a>其他（与栈有关）</h4><p><font color=\"red\">1. 盛最多水的容器</font><br>因为水的容量=左右较小值<em>len;那么移动较大值是不会增加容量的大小的<br>双指针的问题，常用于排序数组中找target数，特征就是知道当前的值，能够容易的判断，下一个是移动左边还是右边指针<br>注意这个是容积因此是长</em>宽，<br>区分：对于和大于0的最长这道题，使用先遍历一次降序，然后逆序判断，这种方法是求长度最长，不是容积最大</p>\n<p><font color=\"blue\">2. 通过删除字母匹配到字典里最长单词</font><br>双指针来查找一个字符串是否为另一个字符串的子序列。<br>同时这道题可以使用序列自动机来避免重复的字符查找。dp[i][j]  就是存储 s字符串从大于等于i开始的 第一个等于j的下标，如果s[i]==j那么dp[i][j]=i, 否则，dp[i][j]=dp[i+1][j]， 应该从后向前计算dp数组</p>\n<h4 id=\"双指针与枚举子集\"><a href=\"#双指针与枚举子集\" class=\"headerlink\" title=\"双指针与枚举子集\"></a>双指针与枚举子集</h4><ol>\n<li>乘积小于K的数组<br>找到符合条件的子集的个数<br>模板代码<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">int</span> left=<span class=\"hljs-number\">0</span>, right=<span class=\"hljs-number\">0</span>;<br><span class=\"hljs-keyword\">int</span> cur=<span class=\"hljs-number\">1</span>;<br><span class=\"hljs-keyword\">int</span> res=<span class=\"hljs-number\">0</span>;<br><span class=\"hljs-keyword\">if</span>(k==<span class=\"hljs-number\">0</span>||k==<span class=\"hljs-number\">1</span>)&#123;<br>    <span class=\"hljs-keyword\">return</span> res;<br>&#125;<br><span class=\"hljs-keyword\">while</span>(right&lt;size)&#123;<br>    cur=cur*nums[right];<br>    <span class=\"hljs-keyword\">if</span>(cur&lt;k)&#123;<br>        res+=right-left+<span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">//注意需要+1</span><br>    &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>        <span class=\"hljs-keyword\">while</span>(cur&gt;=k)&#123;<br>            cur/=nums[left];<br>            left++;<br>        &#125;<br>        res+=right-left+<span class=\"hljs-number\">1</span>;<br>        <br>    &#125;<br>    right++;<br>&#125;<br><span class=\"hljs-keyword\">return</span> res;<br></code></pre></td></tr></table></figure></li>\n</ol>\n<p>另外一种求所有子集的方式是使用统计计算，比如有窗口有cnt个数据，那么子集个数为cnt*(cnt+1)/2</p>\n<p>lc349.数组的交集（easy）<br>排序之后+双指针，相等时候判断加不加这个数</p>\n<h4 id=\"双指针和链表\"><a href=\"#双指针和链表\" class=\"headerlink\" title=\"双指针和链表\"></a>双指针和链表</h4><p>lc86. 分隔链表</p>\n<ul>\n<li>将小于target放在大于等于target的前面，同时小于和大于target的数相对顺序不能变</li>\n<li>将链表分为smallList 和largeList (一个链表拆分成两个链表)， 同时为了避免空的讨论，使用dummy节点</li>\n<li>易错点， largeList的末尾节点-&gt;next一定要赋值为NULL</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>ok</p>\n<ol>\n<li><p>双指针通常和滑动窗口， dp， hash共同来解决 字符串/数组等问题</p>\n</li>\n<li><p>左右移动的双指针通常满足在移动一边的指针的时候拥有一个递增或者递减的规律</p>\n</li>\n<li><p>两个有序数组中任意选一个数出来，之间的最短距离是多少; 较小的一个向前移动</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">while</span> (i &lt; index1.length &amp;&amp; j &lt; index2.length) &#123;<br>    <span class=\"hljs-keyword\">const</span> idx1 = index1[i], idx2 = index2[j];<br>    <span class=\"hljs-keyword\">if</span> (idx1 &gt; idx2) &#123;<br>      j++;<br>    &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (idx2 &gt; idx1) &#123;<br>      i++;<br>    &#125;<br>    min = Math.<span class=\"hljs-built_in\">min</span>(min, Math.<span class=\"hljs-built_in\">abs</span>(idx1 - idx2));<br>  &#125;<br></code></pre></td></tr></table></figure></li>\n<li><p>当以字符串作为hash的key时候，可以使用字符数组 string s(26, ‘0’); 也可以对字符串进行排序后作为key</p>\n</li>\n<li><p>翻转交换类型的题目使用双指针，比如交换一个字符串里面全部的元音字母</p>\n</li>\n<li><p>快慢指针不一定用在链表中判断是否有环，还可以用在数组中，以及用在替换hash， 查看这个数是否之前被访问过；还可以用在去除冗余（类似于双指针）（lc442 数组中重复的数据/ 80. 删除有序数组中的重复项 II）<br>但是lc442用原地hash或者置换到应该在的位置更好理解，使用快慢指针不好理解</p>\n</li>\n</ol>\n<p>找到环路起点的标准模板代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">int</span> slow = <span class=\"hljs-number\">0</span>, fast = <span class=\"hljs-number\">0</span>;<br><span class=\"hljs-keyword\">do</span> &#123;<br>  slow = nums[slow];<br>  fast = nums[nums[fast]];<br>&#125; <span class=\"hljs-keyword\">while</span> (slow != fast);<br>slow = <span class=\"hljs-number\">0</span>;<br><span class=\"hljs-keyword\">while</span> (slow != fast) &#123;<br>  slow = nums[slow];<br>  fast = nums[fast];<br>&#125;<br><span class=\"hljs-keyword\">return</span> slow;<br></code></pre></td></tr></table></figure>"},{"title":"哈希相关","date":"2021-11-13T11:58:31.000Z","_content":"\n#### 前缀和 + hash题目汇总\n一定要注意先判断hash[presum-target]是否存在并更新结果，再更新hash[presum]++， 因为可能nums[i]=0\n\n例题：\n面试题 17.05.  字母与数字，要求字母和数字个数相同，那么就是将字母转为1， 数字转为-1的时候，前缀和为0的最长序列；\n另外使用这种思想是的”和等于 k 的最长子数组长度“ ”和等于k子数组“ （hash+前缀和）\n```C++\n//hash+前缀和的模板代码\nhash[0]=-1;\nint sum=0;\nint res=0;\nfor(int i=0;i<nums.size();++i){\n    sum += nums[i];\n    if(hash.count(sum-k))  res= max(res,i-hash[sum-k]);\n    if(!hash.count(sum)) hash[sum]=i; // 因为要的是第一次出现的值\n}\n\n```\n\n <font color=red>”1371. 每个元音包含偶数次的最长子字符串“</font>:\n题解：为了表明每个元音出现了偶数次，可以使用二进制数，如果一个位经过一轮之后仍然为当前的值，那么说明这个位出现了偶数次或者没出现过，\n通过这种方法可以类推到特定字符出现k数次，那么就使用k进制；同时注意是每个元音出现偶数次，而不是元音总个数为偶数次，如果是第二种情况\n可以使用元音为奇数表示，sum%2==0表示元音个数为偶数）\n    k进制的加法过程类似于大数相加\n\n\n1. 连续的子数组和 注意这道题不是说连续的子数组为目标数，而是为目标数的倍数，但是仍然可以用这种方法来做，因为为目标数的倍数，意味着前缀和%该数得到的余数相同，因为可以用hash记录第一次出现该余数的下标，然后再次出现时，判断数组长度是否大于等于2， 一定要注意在开始的时候hash[0]=-1!!!\n\n3. 连续数组 相同的0和1的个数，其实也是前缀和，只不过遇到0变为-1\n\n4. 和相同的二元子数组\n这道题是统计个数，之前是求最长为目标和的连续子数组，所有hash映射为sum的个数\n注意一定要先查找hash[presum-target]，更新hash[presum]++\n主要是针对0的情况，如果先更新hash就会报错\n注意最开始要设置hash[0]要为1个\n\n\n5. 统计「优美子数组」\n将奇数转为1， 偶数转为0， 然后求和为k的子数组个数\n\n#### 前缀和+单调栈\n<font color=red>leetcode 1124表现良好的最长时间段</font>\n题意就是转化为1， -1的数组，和大于0的最长连续子数组 （注意是和大于0，不是和最大）\n解决方案： 整体思路：前缀和，对于每一个下标对应的当前的前缀和，应该求比他小的前缀和的下标最小的一个+这是1， -1的数组，因此前缀和应该是连续的\n如果前缀和大于0，那么一定是从下标0到当前的数的长度最长\n如果前缀和小于0，那么就是当前前缀和-1到当前的长度最长\n先顺序遍历，如果当前数小于栈顶就push,否则continue(因为当前值不可能为最优)，然后逆序遍历，如果当前的前缀和大于栈顶，那么循环弹出，同时还需要更新最大结果，直到当前的前缀和不大于栈顶；遍历下一个数\n\n<font color=red>类似的一个题目：962. 最大宽度坡 - 单调栈比较经典的题目</font>\n- 这道题除了用正序单减栈+逆序遍历外，还可以用排序方法\n- 排序方法：用结构体存储值和下标，然后按照值排序，针对每个元素，找到它左边的元素中（都比他小），最小的下标（i - min(indexes_previously_written)）\n\n\n#### hash + 双指针\n一定要注意返回的是元素还是元素的下标，一个可以排序使用指针，一个不能使用指针\n两数之和：用双指针只能针对已经排好序的数组，没有排好序的数组，但是要求要返回下标，那么就用hash (unordered_set)\n三数之和\n四数之和：三重循环，因此有是三个去重的部分，不要只去重最后一层循环，忘了i j 层循环的去重\n\n注意！！！\n1. hash方法是不能去重的，要去重只能使用循环+双指针；同时返回坐标不能用双指针，返回值才能使用双指针\n2. 去重放在==target的if语句之内（==循环去重==），同时可以用一些剪枝策略，但是要记得四个数相加可能出现溢出，所以如果要剪枝，记得强转为long型\n```C++ 去重模板\nwhile(i < j && nums[i] == nums[++i]);while(i < j && nums[j] == nums[--j]);\n\n```\n3. 数组不一定是排好序的，因此需要先对数组进行排序\n\n变形：数组中的k-diff数对，这里只是换成了绝对值差，而不是目标值; 而且因为数组中存在重复的数字，因此需要先用set记录结果，然后再返回set.size\n这道题也可以用排序+二分查找（找到目标的k+nums[i]），同时需要过滤掉已经找的数据\n\n拓展：\n注意前面三个题是可能包含重复的元素，但是需要返回不重复的元组对，下面这个题是找出所有的元组对，因此是包含重复的元组对的\n<font color=red>题目：三数之和的多种可能</font>\n解决方案：仍然是三数之和的方法的，但是在进行计算的时候， 需要判断左右指针指向的数是否相等，来计算可能组成的相同数对的个数\n如果arr[left]!=arr[right]那么res+=hash[left]*hash[right] (用while循环找到hash[left]-相同数的数量，或者提前计算)\n如果arr[left]==arr[right] res+=(right-left+1)*(right-left)/2\n\n#### 代码模板（去重+找四数之和为target）\n```C++\nint size=nums.size();\nsort(nums.begin(), nums.end());\nfor(int i=0;i<nums.size()-3;i++){\n    while(i-1>=0&&nums[i]==nums[i-1]){\n        continue; //去重\n    }\n    if((long) nums[i]+nums[i+1]+nums[i+2]+nums[i+3]>target){\n            break;\n    }\n    if((long) nums[i]+nums[size-3]+nums[size-2]+nums[size-1]<target){\n            continue;\n    }\n    for(int j=i+1;j<nums.size()-2;j++){\n        if (j > i + 1 && nums[j] == nums[j - 1]) {\n                    continue; //去重\n        }\n        if((long) nums[i]+nums[j]+nums[j+1]+nums[j+2]>target){\n                break; //注意是break不是continue\n        }\n        if((long) nums[i]+nums[j]+nums[size-2]+nums[size-1]<target){\n                continue;\n        }\n\n        int k=j+1, q=size-1;\n        int find_num=target-nums[i]-nums[j];\n        while(k<q){ //双指针\n            if(nums[k]+nums[q]>find_num){\n                q--;\n            }else if (nums[k]+nums[q]<find_num){\n                k++;\n            }else if (nums[k]+nums[q]==find_num){\n                res.push_back({nums[i], nums[j], nums[q], nums[k]});\n                k++;\n                q--;\n                while(k<q&&nums[k]==nums[k-1]){ //去重\n                    k++;\n                }\n                while(k<q&&nums[q]==nums[q+1]){\n                q--;\n                }\n            }\n        }\n\n        \n    }\n}\n```\n\n> 参考链接：[四数之和答案](https://leetcode-cn.com/problems/4sum/solution/si-shu-zhi-he-by-leetcode-solution/)\n\n\n#### HashMap的底层实现（java）\nJDK1.7 的底层是数组加链表，而 JDK1.8 的底层是数组加链表加红黑树，红黑树相对于AVL树来说，牺牲了部分平衡性以换取插入/删除操作时少量的旋转操作，整体来说性能要优于AVL树。\n\n使用hash函数（hash算法： index = HashCode（Key） & （Length - 1）），将数据放在数组中，如果数组已经将要放的位置满了，就使用链表链接在那个位置的后面；使用树是为了防止链表过长,设定阈值为8，那么大于这个阈值就将这个链表转为红黑树，小于6的时候链化， 避免查询时间过长。（8树化、6链化），而且设置为8个节点时，红黑树的性能优势也会开始展现出来，因此8是一个较合理的数字。\n\nhashmap初始长度是16，每次扩展或者手动初始化必须是2的幂：是为了服务从key到index的hash算法：index = HashCode（Key） & （Length - 1），使得使用位运算计算的结果等同于取模（x mod 2^n = x & (2^n - 1)），也就是只取决于hashcode的二进制后面几位，只要HashCode本身分布均匀，Hash算法的结果就是均匀的，从而大大提高性能。\n\n高并发情况下，hashmap可能会出现死锁\nJDK1.7以及前是在头结点插入的，在JDK1.8之后是在尾节点插入的。，因为JDK1.7在多进程的情况下可能会出现死循环，由循环链表造成（rehash的时候，一个进程在e, next的时候挂起，另外一个进程已经将数据都扩容好，进程1又开始扩容），但是JDK1.8仍然可能会出现数据丢失（进程1要在插入时候，时间片用完，进程2插入元素在一个相同位置，进程1就会直接将进程2插入的元素覆盖），并发下扩容数据丢失\n\n\n<font color=red>避免hash冲突的方法：</font>\n开放定址法（再hash）\n    线性探查：可能会出现大量的错误\n    平方探查\n    二次散列/平方探查：导致hash表空间利用率很低，出现大量重复\n\n    优点：存储结构连续，因此查找的IO开销更小\n    缺点：1）在插入的元素大于hash表的时候，需要扩容 2）hash表存储空间利用率低 3）删除操作的时间复杂度高，因为不能直接删除，因为它的后面可能有数据，因此需要设置删除标记，需要额外的空间 4）探查序列如何设计比较复杂可能会降低hash的性能\n\n拉链法：\n    可能导致数据存储的物理空间不连续导致大量I/O开销\n\n    优点：1）对于记录总数是动态变化的情况比较好，不需要频繁扩容 2）存储空间动态分配，因此hash的空间利用率高 3）删除记录也比较方便\n    缺点：1）因为使用的链表，因此在查询记录时，相比结构紧凑的数据类型（比如数组），哈希表的跳转访问会带来额外的时间开销 2)由于使用指针，记录不容易进行序列化（serialize）操作\n\n\n例题：lc706. 设计哈希映射\n- 使用链地址法实现，每个节点除了key val, 还需要一个next域, 然后使用vector充当数组\n- 易错点：\n    1. 删除的时候需要判断删除这个节点是否是头节点，和尾结点\n    2. 插入的时候需要判断key是不是本身在hash中\n    3. 指针在进行取值或者取下一个值（cur->key||cur->next）的时候，一定要保证这个指针(cur)不为NULL, 否则会报错\n\nlc705. 设计哈希集合\n- 这个和上面一题一样，不同的是这个不需要val字段，其余都相同\n\n\n#### hash+动态规划\n1. 最长定差子序列\n转移方程： dp[arr[i]]=dp[arr[i]-diff]+1\n因为不知道arr[i]的最大值，以及可能出现负数的下标， 所以直接使用hash，而不是数组\ndp[x] 表示以 x 结尾的最长等差子序列的长度；\n\n\n#### 分布式一致性hash算法\n针对的问题是如何将数据均匀的分布在key-value的分布式缓存中，如果使用mod方法，均匀但是可能导致插入删除节点，所有的数据需要重新hash\n1)第一种是将存储节点和数据都映射到一个首尾相连的hash环上，数据存储在hash环上顺时针的第一个节点，插入节点就只影响相邻节点的后续节点，对其他节点没有影响。但是可能造成不均衡的局面，\n2）因此改进就是对一个存储节点使用虚拟节点，映射在环上的多个位置\n\n\n#### 总结\nOK OK\n1. 最长类似题目，可以使用dp, 前缀和，双指针，以及单栈+逆序遍历\n2. 前缀和+hash可以做数组最长题目或者为目标类的连续子数组的个数，一个hash用来记录之前前缀和的下标，一个用来记录前缀和为sum的个数\n（个数和长度问题）","source":"_posts/leetcode/哈希相关.md","raw":"---\ntitle: 哈希相关\ncategories:\n  - leetcode\ndate: 2021-11-13 19:58:31\ntags:\n---\n\n#### 前缀和 + hash题目汇总\n一定要注意先判断hash[presum-target]是否存在并更新结果，再更新hash[presum]++， 因为可能nums[i]=0\n\n例题：\n面试题 17.05.  字母与数字，要求字母和数字个数相同，那么就是将字母转为1， 数字转为-1的时候，前缀和为0的最长序列；\n另外使用这种思想是的”和等于 k 的最长子数组长度“ ”和等于k子数组“ （hash+前缀和）\n```C++\n//hash+前缀和的模板代码\nhash[0]=-1;\nint sum=0;\nint res=0;\nfor(int i=0;i<nums.size();++i){\n    sum += nums[i];\n    if(hash.count(sum-k))  res= max(res,i-hash[sum-k]);\n    if(!hash.count(sum)) hash[sum]=i; // 因为要的是第一次出现的值\n}\n\n```\n\n <font color=red>”1371. 每个元音包含偶数次的最长子字符串“</font>:\n题解：为了表明每个元音出现了偶数次，可以使用二进制数，如果一个位经过一轮之后仍然为当前的值，那么说明这个位出现了偶数次或者没出现过，\n通过这种方法可以类推到特定字符出现k数次，那么就使用k进制；同时注意是每个元音出现偶数次，而不是元音总个数为偶数次，如果是第二种情况\n可以使用元音为奇数表示，sum%2==0表示元音个数为偶数）\n    k进制的加法过程类似于大数相加\n\n\n1. 连续的子数组和 注意这道题不是说连续的子数组为目标数，而是为目标数的倍数，但是仍然可以用这种方法来做，因为为目标数的倍数，意味着前缀和%该数得到的余数相同，因为可以用hash记录第一次出现该余数的下标，然后再次出现时，判断数组长度是否大于等于2， 一定要注意在开始的时候hash[0]=-1!!!\n\n3. 连续数组 相同的0和1的个数，其实也是前缀和，只不过遇到0变为-1\n\n4. 和相同的二元子数组\n这道题是统计个数，之前是求最长为目标和的连续子数组，所有hash映射为sum的个数\n注意一定要先查找hash[presum-target]，更新hash[presum]++\n主要是针对0的情况，如果先更新hash就会报错\n注意最开始要设置hash[0]要为1个\n\n\n5. 统计「优美子数组」\n将奇数转为1， 偶数转为0， 然后求和为k的子数组个数\n\n#### 前缀和+单调栈\n<font color=red>leetcode 1124表现良好的最长时间段</font>\n题意就是转化为1， -1的数组，和大于0的最长连续子数组 （注意是和大于0，不是和最大）\n解决方案： 整体思路：前缀和，对于每一个下标对应的当前的前缀和，应该求比他小的前缀和的下标最小的一个+这是1， -1的数组，因此前缀和应该是连续的\n如果前缀和大于0，那么一定是从下标0到当前的数的长度最长\n如果前缀和小于0，那么就是当前前缀和-1到当前的长度最长\n先顺序遍历，如果当前数小于栈顶就push,否则continue(因为当前值不可能为最优)，然后逆序遍历，如果当前的前缀和大于栈顶，那么循环弹出，同时还需要更新最大结果，直到当前的前缀和不大于栈顶；遍历下一个数\n\n<font color=red>类似的一个题目：962. 最大宽度坡 - 单调栈比较经典的题目</font>\n- 这道题除了用正序单减栈+逆序遍历外，还可以用排序方法\n- 排序方法：用结构体存储值和下标，然后按照值排序，针对每个元素，找到它左边的元素中（都比他小），最小的下标（i - min(indexes_previously_written)）\n\n\n#### hash + 双指针\n一定要注意返回的是元素还是元素的下标，一个可以排序使用指针，一个不能使用指针\n两数之和：用双指针只能针对已经排好序的数组，没有排好序的数组，但是要求要返回下标，那么就用hash (unordered_set)\n三数之和\n四数之和：三重循环，因此有是三个去重的部分，不要只去重最后一层循环，忘了i j 层循环的去重\n\n注意！！！\n1. hash方法是不能去重的，要去重只能使用循环+双指针；同时返回坐标不能用双指针，返回值才能使用双指针\n2. 去重放在==target的if语句之内（==循环去重==），同时可以用一些剪枝策略，但是要记得四个数相加可能出现溢出，所以如果要剪枝，记得强转为long型\n```C++ 去重模板\nwhile(i < j && nums[i] == nums[++i]);while(i < j && nums[j] == nums[--j]);\n\n```\n3. 数组不一定是排好序的，因此需要先对数组进行排序\n\n变形：数组中的k-diff数对，这里只是换成了绝对值差，而不是目标值; 而且因为数组中存在重复的数字，因此需要先用set记录结果，然后再返回set.size\n这道题也可以用排序+二分查找（找到目标的k+nums[i]），同时需要过滤掉已经找的数据\n\n拓展：\n注意前面三个题是可能包含重复的元素，但是需要返回不重复的元组对，下面这个题是找出所有的元组对，因此是包含重复的元组对的\n<font color=red>题目：三数之和的多种可能</font>\n解决方案：仍然是三数之和的方法的，但是在进行计算的时候， 需要判断左右指针指向的数是否相等，来计算可能组成的相同数对的个数\n如果arr[left]!=arr[right]那么res+=hash[left]*hash[right] (用while循环找到hash[left]-相同数的数量，或者提前计算)\n如果arr[left]==arr[right] res+=(right-left+1)*(right-left)/2\n\n#### 代码模板（去重+找四数之和为target）\n```C++\nint size=nums.size();\nsort(nums.begin(), nums.end());\nfor(int i=0;i<nums.size()-3;i++){\n    while(i-1>=0&&nums[i]==nums[i-1]){\n        continue; //去重\n    }\n    if((long) nums[i]+nums[i+1]+nums[i+2]+nums[i+3]>target){\n            break;\n    }\n    if((long) nums[i]+nums[size-3]+nums[size-2]+nums[size-1]<target){\n            continue;\n    }\n    for(int j=i+1;j<nums.size()-2;j++){\n        if (j > i + 1 && nums[j] == nums[j - 1]) {\n                    continue; //去重\n        }\n        if((long) nums[i]+nums[j]+nums[j+1]+nums[j+2]>target){\n                break; //注意是break不是continue\n        }\n        if((long) nums[i]+nums[j]+nums[size-2]+nums[size-1]<target){\n                continue;\n        }\n\n        int k=j+1, q=size-1;\n        int find_num=target-nums[i]-nums[j];\n        while(k<q){ //双指针\n            if(nums[k]+nums[q]>find_num){\n                q--;\n            }else if (nums[k]+nums[q]<find_num){\n                k++;\n            }else if (nums[k]+nums[q]==find_num){\n                res.push_back({nums[i], nums[j], nums[q], nums[k]});\n                k++;\n                q--;\n                while(k<q&&nums[k]==nums[k-1]){ //去重\n                    k++;\n                }\n                while(k<q&&nums[q]==nums[q+1]){\n                q--;\n                }\n            }\n        }\n\n        \n    }\n}\n```\n\n> 参考链接：[四数之和答案](https://leetcode-cn.com/problems/4sum/solution/si-shu-zhi-he-by-leetcode-solution/)\n\n\n#### HashMap的底层实现（java）\nJDK1.7 的底层是数组加链表，而 JDK1.8 的底层是数组加链表加红黑树，红黑树相对于AVL树来说，牺牲了部分平衡性以换取插入/删除操作时少量的旋转操作，整体来说性能要优于AVL树。\n\n使用hash函数（hash算法： index = HashCode（Key） & （Length - 1）），将数据放在数组中，如果数组已经将要放的位置满了，就使用链表链接在那个位置的后面；使用树是为了防止链表过长,设定阈值为8，那么大于这个阈值就将这个链表转为红黑树，小于6的时候链化， 避免查询时间过长。（8树化、6链化），而且设置为8个节点时，红黑树的性能优势也会开始展现出来，因此8是一个较合理的数字。\n\nhashmap初始长度是16，每次扩展或者手动初始化必须是2的幂：是为了服务从key到index的hash算法：index = HashCode（Key） & （Length - 1），使得使用位运算计算的结果等同于取模（x mod 2^n = x & (2^n - 1)），也就是只取决于hashcode的二进制后面几位，只要HashCode本身分布均匀，Hash算法的结果就是均匀的，从而大大提高性能。\n\n高并发情况下，hashmap可能会出现死锁\nJDK1.7以及前是在头结点插入的，在JDK1.8之后是在尾节点插入的。，因为JDK1.7在多进程的情况下可能会出现死循环，由循环链表造成（rehash的时候，一个进程在e, next的时候挂起，另外一个进程已经将数据都扩容好，进程1又开始扩容），但是JDK1.8仍然可能会出现数据丢失（进程1要在插入时候，时间片用完，进程2插入元素在一个相同位置，进程1就会直接将进程2插入的元素覆盖），并发下扩容数据丢失\n\n\n<font color=red>避免hash冲突的方法：</font>\n开放定址法（再hash）\n    线性探查：可能会出现大量的错误\n    平方探查\n    二次散列/平方探查：导致hash表空间利用率很低，出现大量重复\n\n    优点：存储结构连续，因此查找的IO开销更小\n    缺点：1）在插入的元素大于hash表的时候，需要扩容 2）hash表存储空间利用率低 3）删除操作的时间复杂度高，因为不能直接删除，因为它的后面可能有数据，因此需要设置删除标记，需要额外的空间 4）探查序列如何设计比较复杂可能会降低hash的性能\n\n拉链法：\n    可能导致数据存储的物理空间不连续导致大量I/O开销\n\n    优点：1）对于记录总数是动态变化的情况比较好，不需要频繁扩容 2）存储空间动态分配，因此hash的空间利用率高 3）删除记录也比较方便\n    缺点：1）因为使用的链表，因此在查询记录时，相比结构紧凑的数据类型（比如数组），哈希表的跳转访问会带来额外的时间开销 2)由于使用指针，记录不容易进行序列化（serialize）操作\n\n\n例题：lc706. 设计哈希映射\n- 使用链地址法实现，每个节点除了key val, 还需要一个next域, 然后使用vector充当数组\n- 易错点：\n    1. 删除的时候需要判断删除这个节点是否是头节点，和尾结点\n    2. 插入的时候需要判断key是不是本身在hash中\n    3. 指针在进行取值或者取下一个值（cur->key||cur->next）的时候，一定要保证这个指针(cur)不为NULL, 否则会报错\n\nlc705. 设计哈希集合\n- 这个和上面一题一样，不同的是这个不需要val字段，其余都相同\n\n\n#### hash+动态规划\n1. 最长定差子序列\n转移方程： dp[arr[i]]=dp[arr[i]-diff]+1\n因为不知道arr[i]的最大值，以及可能出现负数的下标， 所以直接使用hash，而不是数组\ndp[x] 表示以 x 结尾的最长等差子序列的长度；\n\n\n#### 分布式一致性hash算法\n针对的问题是如何将数据均匀的分布在key-value的分布式缓存中，如果使用mod方法，均匀但是可能导致插入删除节点，所有的数据需要重新hash\n1)第一种是将存储节点和数据都映射到一个首尾相连的hash环上，数据存储在hash环上顺时针的第一个节点，插入节点就只影响相邻节点的后续节点，对其他节点没有影响。但是可能造成不均衡的局面，\n2）因此改进就是对一个存储节点使用虚拟节点，映射在环上的多个位置\n\n\n#### 总结\nOK OK\n1. 最长类似题目，可以使用dp, 前缀和，双指针，以及单栈+逆序遍历\n2. 前缀和+hash可以做数组最长题目或者为目标类的连续子数组的个数，一个hash用来记录之前前缀和的下标，一个用来记录前缀和为sum的个数\n（个数和长度问题）","slug":"leetcode/哈希相关","published":1,"updated":"2023-07-10T10:36:19.572Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clk5ceinl000kjpjbc2270nlk","content":"<h4 id=\"前缀和-hash题目汇总\"><a href=\"#前缀和-hash题目汇总\" class=\"headerlink\" title=\"前缀和 + hash题目汇总\"></a>前缀和 + hash题目汇总</h4><p>一定要注意先判断hash[presum-target]是否存在并更新结果，再更新hash[presum]++， 因为可能nums[i]=0</p>\n<p>例题：<br>面试题 17.05.  字母与数字，要求字母和数字个数相同，那么就是将字母转为1， 数字转为-1的时候，前缀和为0的最长序列；<br>另外使用这种思想是的”和等于 k 的最长子数组长度“ ”和等于k子数组“ （hash+前缀和）</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-comment\">//hash+前缀和的模板代码</span><br>hash[<span class=\"hljs-number\">0</span>]=<span class=\"hljs-number\">-1</span>;<br><span class=\"hljs-keyword\">int</span> sum=<span class=\"hljs-number\">0</span>;<br><span class=\"hljs-keyword\">int</span> res=<span class=\"hljs-number\">0</span>;<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;nums.<span class=\"hljs-built_in\">size</span>();++i)&#123;<br>    sum += nums[i];<br>    <span class=\"hljs-keyword\">if</span>(hash.<span class=\"hljs-built_in\">count</span>(sum-k))  res= <span class=\"hljs-built_in\">max</span>(res,i-hash[sum-k]);<br>    <span class=\"hljs-keyword\">if</span>(!hash.<span class=\"hljs-built_in\">count</span>(sum)) hash[sum]=i; <span class=\"hljs-comment\">// 因为要的是第一次出现的值</span><br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<p> <font color=\"red\">”1371. 每个元音包含偶数次的最长子字符串“</font>:<br>题解：为了表明每个元音出现了偶数次，可以使用二进制数，如果一个位经过一轮之后仍然为当前的值，那么说明这个位出现了偶数次或者没出现过，<br>通过这种方法可以类推到特定字符出现k数次，那么就使用k进制；同时注意是每个元音出现偶数次，而不是元音总个数为偶数次，如果是第二种情况<br>可以使用元音为奇数表示，sum%2==0表示元音个数为偶数）<br>    k进制的加法过程类似于大数相加</p>\n<ol>\n<li><p>连续的子数组和 注意这道题不是说连续的子数组为目标数，而是为目标数的倍数，但是仍然可以用这种方法来做，因为为目标数的倍数，意味着前缀和%该数得到的余数相同，因为可以用hash记录第一次出现该余数的下标，然后再次出现时，判断数组长度是否大于等于2， 一定要注意在开始的时候hash[0]=-1!!!</p>\n</li>\n<li><p>连续数组 相同的0和1的个数，其实也是前缀和，只不过遇到0变为-1</p>\n</li>\n<li><p>和相同的二元子数组<br>这道题是统计个数，之前是求最长为目标和的连续子数组，所有hash映射为sum的个数<br>注意一定要先查找hash[presum-target]，更新hash[presum]++<br>主要是针对0的情况，如果先更新hash就会报错<br>注意最开始要设置hash[0]要为1个</p>\n</li>\n</ol>\n<ol start=\"5\">\n<li>统计「优美子数组」<br>将奇数转为1， 偶数转为0， 然后求和为k的子数组个数</li>\n</ol>\n<h4 id=\"前缀和-单调栈\"><a href=\"#前缀和-单调栈\" class=\"headerlink\" title=\"前缀和+单调栈\"></a>前缀和+单调栈</h4><p><font color=\"red\">leetcode 1124表现良好的最长时间段</font><br>题意就是转化为1， -1的数组，和大于0的最长连续子数组 （注意是和大于0，不是和最大）<br>解决方案： 整体思路：前缀和，对于每一个下标对应的当前的前缀和，应该求比他小的前缀和的下标最小的一个+这是1， -1的数组，因此前缀和应该是连续的<br>如果前缀和大于0，那么一定是从下标0到当前的数的长度最长<br>如果前缀和小于0，那么就是当前前缀和-1到当前的长度最长<br>先顺序遍历，如果当前数小于栈顶就push,否则continue(因为当前值不可能为最优)，然后逆序遍历，如果当前的前缀和大于栈顶，那么循环弹出，同时还需要更新最大结果，直到当前的前缀和不大于栈顶；遍历下一个数</p>\n<p><font color=\"red\">类似的一个题目：962. 最大宽度坡 - 单调栈比较经典的题目</font></p>\n<ul>\n<li>这道题除了用正序单减栈+逆序遍历外，还可以用排序方法</li>\n<li>排序方法：用结构体存储值和下标，然后按照值排序，针对每个元素，找到它左边的元素中（都比他小），最小的下标（i - min(indexes_previously_written)）</li>\n</ul>\n<h4 id=\"hash-双指针\"><a href=\"#hash-双指针\" class=\"headerlink\" title=\"hash + 双指针\"></a>hash + 双指针</h4><p>一定要注意返回的是元素还是元素的下标，一个可以排序使用指针，一个不能使用指针<br>两数之和：用双指针只能针对已经排好序的数组，没有排好序的数组，但是要求要返回下标，那么就用hash (unordered_set)<br>三数之和<br>四数之和：三重循环，因此有是三个去重的部分，不要只去重最后一层循环，忘了i j 层循环的去重</p>\n<p>注意！！！</p>\n<ol>\n<li>hash方法是不能去重的，要去重只能使用循环+双指针；同时返回坐标不能用双指针，返回值才能使用双指针</li>\n<li>去重放在==target的if语句之内（==循环去重==），同时可以用一些剪枝策略，但是要记得四个数相加可能出现溢出，所以如果要剪枝，记得强转为long型<figure class=\"highlight c++\"><figcaption><span>去重模板</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">while</span>(i &lt; j &amp;&amp; nums[i] == nums[++i]);<span class=\"hljs-keyword\">while</span>(i &lt; j &amp;&amp; nums[j] == nums[--j]);<br><br></code></pre></td></tr></table></figure></li>\n<li>数组不一定是排好序的，因此需要先对数组进行排序</li>\n</ol>\n<p>变形：数组中的k-diff数对，这里只是换成了绝对值差，而不是目标值; 而且因为数组中存在重复的数字，因此需要先用set记录结果，然后再返回set.size<br>这道题也可以用排序+二分查找（找到目标的k+nums[i]），同时需要过滤掉已经找的数据</p>\n<p>拓展：<br>注意前面三个题是可能包含重复的元素，但是需要返回不重复的元组对，下面这个题是找出所有的元组对，因此是包含重复的元组对的<br><font color=\"red\">题目：三数之和的多种可能</font><br>解决方案：仍然是三数之和的方法的，但是在进行计算的时候， 需要判断左右指针指向的数是否相等，来计算可能组成的相同数对的个数<br>如果arr[left]!=arr[right]那么res+=hash[left]<em>hash[right] (用while循环找到hash[left]-相同数的数量，或者提前计算)<br>如果arr[left]==arr[right] res+=(right-left+1)</em>(right-left)/2</p>\n<h4 id=\"代码模板（去重-找四数之和为target）\"><a href=\"#代码模板（去重-找四数之和为target）\" class=\"headerlink\" title=\"代码模板（去重+找四数之和为target）\"></a>代码模板（去重+找四数之和为target）</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">int</span> size=nums.<span class=\"hljs-built_in\">size</span>();<br><span class=\"hljs-built_in\">sort</span>(nums.<span class=\"hljs-built_in\">begin</span>(), nums.<span class=\"hljs-built_in\">end</span>());<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;nums.<span class=\"hljs-built_in\">size</span>()<span class=\"hljs-number\">-3</span>;i++)&#123;<br>    <span class=\"hljs-keyword\">while</span>(i<span class=\"hljs-number\">-1</span>&gt;=<span class=\"hljs-number\">0</span>&amp;&amp;nums[i]==nums[i<span class=\"hljs-number\">-1</span>])&#123;<br>        <span class=\"hljs-keyword\">continue</span>; <span class=\"hljs-comment\">//去重</span><br>    &#125;<br>    <span class=\"hljs-keyword\">if</span>((<span class=\"hljs-keyword\">long</span>) nums[i]+nums[i+<span class=\"hljs-number\">1</span>]+nums[i+<span class=\"hljs-number\">2</span>]+nums[i+<span class=\"hljs-number\">3</span>]&gt;target)&#123;<br>            <span class=\"hljs-keyword\">break</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span>((<span class=\"hljs-keyword\">long</span>) nums[i]+nums[size<span class=\"hljs-number\">-3</span>]+nums[size<span class=\"hljs-number\">-2</span>]+nums[size<span class=\"hljs-number\">-1</span>]&lt;target)&#123;<br>            <span class=\"hljs-keyword\">continue</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j=i+<span class=\"hljs-number\">1</span>;j&lt;nums.<span class=\"hljs-built_in\">size</span>()<span class=\"hljs-number\">-2</span>;j++)&#123;<br>        <span class=\"hljs-keyword\">if</span> (j &gt; i + <span class=\"hljs-number\">1</span> &amp;&amp; nums[j] == nums[j - <span class=\"hljs-number\">1</span>]) &#123;<br>                    <span class=\"hljs-keyword\">continue</span>; <span class=\"hljs-comment\">//去重</span><br>        &#125;<br>        <span class=\"hljs-keyword\">if</span>((<span class=\"hljs-keyword\">long</span>) nums[i]+nums[j]+nums[j+<span class=\"hljs-number\">1</span>]+nums[j+<span class=\"hljs-number\">2</span>]&gt;target)&#123;<br>                <span class=\"hljs-keyword\">break</span>; <span class=\"hljs-comment\">//注意是break不是continue</span><br>        &#125;<br>        <span class=\"hljs-keyword\">if</span>((<span class=\"hljs-keyword\">long</span>) nums[i]+nums[j]+nums[size<span class=\"hljs-number\">-2</span>]+nums[size<span class=\"hljs-number\">-1</span>]&lt;target)&#123;<br>                <span class=\"hljs-keyword\">continue</span>;<br>        &#125;<br><br>        <span class=\"hljs-keyword\">int</span> k=j+<span class=\"hljs-number\">1</span>, q=size<span class=\"hljs-number\">-1</span>;<br>        <span class=\"hljs-keyword\">int</span> find_num=target-nums[i]-nums[j];<br>        <span class=\"hljs-keyword\">while</span>(k&lt;q)&#123; <span class=\"hljs-comment\">//双指针</span><br>            <span class=\"hljs-keyword\">if</span>(nums[k]+nums[q]&gt;find_num)&#123;<br>                q--;<br>            &#125;<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (nums[k]+nums[q]&lt;find_num)&#123;<br>                k++;<br>            &#125;<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (nums[k]+nums[q]==find_num)&#123;<br>                res.<span class=\"hljs-built_in\">push_back</span>(&#123;nums[i], nums[j], nums[q], nums[k]&#125;);<br>                k++;<br>                q--;<br>                <span class=\"hljs-keyword\">while</span>(k&lt;q&amp;&amp;nums[k]==nums[k<span class=\"hljs-number\">-1</span>])&#123; <span class=\"hljs-comment\">//去重</span><br>                    k++;<br>                &#125;<br>                <span class=\"hljs-keyword\">while</span>(k&lt;q&amp;&amp;nums[q]==nums[q+<span class=\"hljs-number\">1</span>])&#123;<br>                q--;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>参考链接：<a href=\"https://leetcode-cn.com/problems/4sum/solution/si-shu-zhi-he-by-leetcode-solution/\">四数之和答案</a></p>\n</blockquote>\n<h4 id=\"HashMap的底层实现（java）\"><a href=\"#HashMap的底层实现（java）\" class=\"headerlink\" title=\"HashMap的底层实现（java）\"></a>HashMap的底层实现（java）</h4><p>JDK1.7 的底层是数组加链表，而 JDK1.8 的底层是数组加链表加红黑树，红黑树相对于AVL树来说，牺牲了部分平衡性以换取插入/删除操作时少量的旋转操作，整体来说性能要优于AVL树。</p>\n<p>使用hash函数（hash算法： index = HashCode（Key） &amp; （Length - 1）），将数据放在数组中，如果数组已经将要放的位置满了，就使用链表链接在那个位置的后面；使用树是为了防止链表过长,设定阈值为8，那么大于这个阈值就将这个链表转为红黑树，小于6的时候链化， 避免查询时间过长。（8树化、6链化），而且设置为8个节点时，红黑树的性能优势也会开始展现出来，因此8是一个较合理的数字。</p>\n<p>hashmap初始长度是16，每次扩展或者手动初始化必须是2的幂：是为了服务从key到index的hash算法：index = HashCode（Key） &amp; （Length - 1），使得使用位运算计算的结果等同于取模（x mod 2^n = x &amp; (2^n - 1)），也就是只取决于hashcode的二进制后面几位，只要HashCode本身分布均匀，Hash算法的结果就是均匀的，从而大大提高性能。</p>\n<p>高并发情况下，hashmap可能会出现死锁<br>JDK1.7以及前是在头结点插入的，在JDK1.8之后是在尾节点插入的。，因为JDK1.7在多进程的情况下可能会出现死循环，由循环链表造成（rehash的时候，一个进程在e, next的时候挂起，另外一个进程已经将数据都扩容好，进程1又开始扩容），但是JDK1.8仍然可能会出现数据丢失（进程1要在插入时候，时间片用完，进程2插入元素在一个相同位置，进程1就会直接将进程2插入的元素覆盖），并发下扩容数据丢失</p>\n<p><font color=\"red\">避免hash冲突的方法：</font><br>开放定址法（再hash）<br>    线性探查：可能会出现大量的错误<br>    平方探查<br>    二次散列/平方探查：导致hash表空间利用率很低，出现大量重复</p>\n<pre><code>优点：存储结构连续，因此查找的IO开销更小\n缺点：1）在插入的元素大于hash表的时候，需要扩容 2）hash表存储空间利用率低 3）删除操作的时间复杂度高，因为不能直接删除，因为它的后面可能有数据，因此需要设置删除标记，需要额外的空间 4）探查序列如何设计比较复杂可能会降低hash的性能\n</code></pre>\n<p>拉链法：<br>    可能导致数据存储的物理空间不连续导致大量I/O开销</p>\n<pre><code>优点：1）对于记录总数是动态变化的情况比较好，不需要频繁扩容 2）存储空间动态分配，因此hash的空间利用率高 3）删除记录也比较方便\n缺点：1）因为使用的链表，因此在查询记录时，相比结构紧凑的数据类型（比如数组），哈希表的跳转访问会带来额外的时间开销 2)由于使用指针，记录不容易进行序列化（serialize）操作\n</code></pre>\n<p>例题：lc706. 设计哈希映射</p>\n<ul>\n<li>使用链地址法实现，每个节点除了key val, 还需要一个next域, 然后使用vector充当数组</li>\n<li>易错点：<ol>\n<li>删除的时候需要判断删除这个节点是否是头节点，和尾结点</li>\n<li>插入的时候需要判断key是不是本身在hash中</li>\n<li>指针在进行取值或者取下一个值（cur-&gt;key||cur-&gt;next）的时候，一定要保证这个指针(cur)不为NULL, 否则会报错</li>\n</ol>\n</li>\n</ul>\n<p>lc705. 设计哈希集合</p>\n<ul>\n<li>这个和上面一题一样，不同的是这个不需要val字段，其余都相同</li>\n</ul>\n<h4 id=\"hash-动态规划\"><a href=\"#hash-动态规划\" class=\"headerlink\" title=\"hash+动态规划\"></a>hash+动态规划</h4><ol>\n<li>最长定差子序列<br>转移方程： dp[arr[i]]=dp[arr[i]-diff]+1<br>因为不知道arr[i]的最大值，以及可能出现负数的下标， 所以直接使用hash，而不是数组<br>dp[x] 表示以 x 结尾的最长等差子序列的长度；</li>\n</ol>\n<h4 id=\"分布式一致性hash算法\"><a href=\"#分布式一致性hash算法\" class=\"headerlink\" title=\"分布式一致性hash算法\"></a>分布式一致性hash算法</h4><p>针对的问题是如何将数据均匀的分布在key-value的分布式缓存中，如果使用mod方法，均匀但是可能导致插入删除节点，所有的数据需要重新hash<br>1)第一种是将存储节点和数据都映射到一个首尾相连的hash环上，数据存储在hash环上顺时针的第一个节点，插入节点就只影响相邻节点的后续节点，对其他节点没有影响。但是可能造成不均衡的局面，<br>2）因此改进就是对一个存储节点使用虚拟节点，映射在环上的多个位置</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>OK OK</p>\n<ol>\n<li>最长类似题目，可以使用dp, 前缀和，双指针，以及单栈+逆序遍历</li>\n<li>前缀和+hash可以做数组最长题目或者为目标类的连续子数组的个数，一个hash用来记录之前前缀和的下标，一个用来记录前缀和为sum的个数<br>（个数和长度问题）</li>\n</ol>\n","site":{"data":{}},"wordcount":5123,"excerpt":"","more":"<h4 id=\"前缀和-hash题目汇总\"><a href=\"#前缀和-hash题目汇总\" class=\"headerlink\" title=\"前缀和 + hash题目汇总\"></a>前缀和 + hash题目汇总</h4><p>一定要注意先判断hash[presum-target]是否存在并更新结果，再更新hash[presum]++， 因为可能nums[i]=0</p>\n<p>例题：<br>面试题 17.05.  字母与数字，要求字母和数字个数相同，那么就是将字母转为1， 数字转为-1的时候，前缀和为0的最长序列；<br>另外使用这种思想是的”和等于 k 的最长子数组长度“ ”和等于k子数组“ （hash+前缀和）</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-comment\">//hash+前缀和的模板代码</span><br>hash[<span class=\"hljs-number\">0</span>]=<span class=\"hljs-number\">-1</span>;<br><span class=\"hljs-keyword\">int</span> sum=<span class=\"hljs-number\">0</span>;<br><span class=\"hljs-keyword\">int</span> res=<span class=\"hljs-number\">0</span>;<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;nums.<span class=\"hljs-built_in\">size</span>();++i)&#123;<br>    sum += nums[i];<br>    <span class=\"hljs-keyword\">if</span>(hash.<span class=\"hljs-built_in\">count</span>(sum-k))  res= <span class=\"hljs-built_in\">max</span>(res,i-hash[sum-k]);<br>    <span class=\"hljs-keyword\">if</span>(!hash.<span class=\"hljs-built_in\">count</span>(sum)) hash[sum]=i; <span class=\"hljs-comment\">// 因为要的是第一次出现的值</span><br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<p> <font color=\"red\">”1371. 每个元音包含偶数次的最长子字符串“</font>:<br>题解：为了表明每个元音出现了偶数次，可以使用二进制数，如果一个位经过一轮之后仍然为当前的值，那么说明这个位出现了偶数次或者没出现过，<br>通过这种方法可以类推到特定字符出现k数次，那么就使用k进制；同时注意是每个元音出现偶数次，而不是元音总个数为偶数次，如果是第二种情况<br>可以使用元音为奇数表示，sum%2==0表示元音个数为偶数）<br>    k进制的加法过程类似于大数相加</p>\n<ol>\n<li><p>连续的子数组和 注意这道题不是说连续的子数组为目标数，而是为目标数的倍数，但是仍然可以用这种方法来做，因为为目标数的倍数，意味着前缀和%该数得到的余数相同，因为可以用hash记录第一次出现该余数的下标，然后再次出现时，判断数组长度是否大于等于2， 一定要注意在开始的时候hash[0]=-1!!!</p>\n</li>\n<li><p>连续数组 相同的0和1的个数，其实也是前缀和，只不过遇到0变为-1</p>\n</li>\n<li><p>和相同的二元子数组<br>这道题是统计个数，之前是求最长为目标和的连续子数组，所有hash映射为sum的个数<br>注意一定要先查找hash[presum-target]，更新hash[presum]++<br>主要是针对0的情况，如果先更新hash就会报错<br>注意最开始要设置hash[0]要为1个</p>\n</li>\n</ol>\n<ol start=\"5\">\n<li>统计「优美子数组」<br>将奇数转为1， 偶数转为0， 然后求和为k的子数组个数</li>\n</ol>\n<h4 id=\"前缀和-单调栈\"><a href=\"#前缀和-单调栈\" class=\"headerlink\" title=\"前缀和+单调栈\"></a>前缀和+单调栈</h4><p><font color=\"red\">leetcode 1124表现良好的最长时间段</font><br>题意就是转化为1， -1的数组，和大于0的最长连续子数组 （注意是和大于0，不是和最大）<br>解决方案： 整体思路：前缀和，对于每一个下标对应的当前的前缀和，应该求比他小的前缀和的下标最小的一个+这是1， -1的数组，因此前缀和应该是连续的<br>如果前缀和大于0，那么一定是从下标0到当前的数的长度最长<br>如果前缀和小于0，那么就是当前前缀和-1到当前的长度最长<br>先顺序遍历，如果当前数小于栈顶就push,否则continue(因为当前值不可能为最优)，然后逆序遍历，如果当前的前缀和大于栈顶，那么循环弹出，同时还需要更新最大结果，直到当前的前缀和不大于栈顶；遍历下一个数</p>\n<p><font color=\"red\">类似的一个题目：962. 最大宽度坡 - 单调栈比较经典的题目</font></p>\n<ul>\n<li>这道题除了用正序单减栈+逆序遍历外，还可以用排序方法</li>\n<li>排序方法：用结构体存储值和下标，然后按照值排序，针对每个元素，找到它左边的元素中（都比他小），最小的下标（i - min(indexes_previously_written)）</li>\n</ul>\n<h4 id=\"hash-双指针\"><a href=\"#hash-双指针\" class=\"headerlink\" title=\"hash + 双指针\"></a>hash + 双指针</h4><p>一定要注意返回的是元素还是元素的下标，一个可以排序使用指针，一个不能使用指针<br>两数之和：用双指针只能针对已经排好序的数组，没有排好序的数组，但是要求要返回下标，那么就用hash (unordered_set)<br>三数之和<br>四数之和：三重循环，因此有是三个去重的部分，不要只去重最后一层循环，忘了i j 层循环的去重</p>\n<p>注意！！！</p>\n<ol>\n<li>hash方法是不能去重的，要去重只能使用循环+双指针；同时返回坐标不能用双指针，返回值才能使用双指针</li>\n<li>去重放在==target的if语句之内（==循环去重==），同时可以用一些剪枝策略，但是要记得四个数相加可能出现溢出，所以如果要剪枝，记得强转为long型<figure class=\"highlight c++\"><figcaption><span>去重模板</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">while</span>(i &lt; j &amp;&amp; nums[i] == nums[++i]);<span class=\"hljs-keyword\">while</span>(i &lt; j &amp;&amp; nums[j] == nums[--j]);<br><br></code></pre></td></tr></table></figure></li>\n<li>数组不一定是排好序的，因此需要先对数组进行排序</li>\n</ol>\n<p>变形：数组中的k-diff数对，这里只是换成了绝对值差，而不是目标值; 而且因为数组中存在重复的数字，因此需要先用set记录结果，然后再返回set.size<br>这道题也可以用排序+二分查找（找到目标的k+nums[i]），同时需要过滤掉已经找的数据</p>\n<p>拓展：<br>注意前面三个题是可能包含重复的元素，但是需要返回不重复的元组对，下面这个题是找出所有的元组对，因此是包含重复的元组对的<br><font color=\"red\">题目：三数之和的多种可能</font><br>解决方案：仍然是三数之和的方法的，但是在进行计算的时候， 需要判断左右指针指向的数是否相等，来计算可能组成的相同数对的个数<br>如果arr[left]!=arr[right]那么res+=hash[left]<em>hash[right] (用while循环找到hash[left]-相同数的数量，或者提前计算)<br>如果arr[left]==arr[right] res+=(right-left+1)</em>(right-left)/2</p>\n<h4 id=\"代码模板（去重-找四数之和为target）\"><a href=\"#代码模板（去重-找四数之和为target）\" class=\"headerlink\" title=\"代码模板（去重+找四数之和为target）\"></a>代码模板（去重+找四数之和为target）</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">int</span> size=nums.<span class=\"hljs-built_in\">size</span>();<br><span class=\"hljs-built_in\">sort</span>(nums.<span class=\"hljs-built_in\">begin</span>(), nums.<span class=\"hljs-built_in\">end</span>());<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;nums.<span class=\"hljs-built_in\">size</span>()<span class=\"hljs-number\">-3</span>;i++)&#123;<br>    <span class=\"hljs-keyword\">while</span>(i<span class=\"hljs-number\">-1</span>&gt;=<span class=\"hljs-number\">0</span>&amp;&amp;nums[i]==nums[i<span class=\"hljs-number\">-1</span>])&#123;<br>        <span class=\"hljs-keyword\">continue</span>; <span class=\"hljs-comment\">//去重</span><br>    &#125;<br>    <span class=\"hljs-keyword\">if</span>((<span class=\"hljs-keyword\">long</span>) nums[i]+nums[i+<span class=\"hljs-number\">1</span>]+nums[i+<span class=\"hljs-number\">2</span>]+nums[i+<span class=\"hljs-number\">3</span>]&gt;target)&#123;<br>            <span class=\"hljs-keyword\">break</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span>((<span class=\"hljs-keyword\">long</span>) nums[i]+nums[size<span class=\"hljs-number\">-3</span>]+nums[size<span class=\"hljs-number\">-2</span>]+nums[size<span class=\"hljs-number\">-1</span>]&lt;target)&#123;<br>            <span class=\"hljs-keyword\">continue</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j=i+<span class=\"hljs-number\">1</span>;j&lt;nums.<span class=\"hljs-built_in\">size</span>()<span class=\"hljs-number\">-2</span>;j++)&#123;<br>        <span class=\"hljs-keyword\">if</span> (j &gt; i + <span class=\"hljs-number\">1</span> &amp;&amp; nums[j] == nums[j - <span class=\"hljs-number\">1</span>]) &#123;<br>                    <span class=\"hljs-keyword\">continue</span>; <span class=\"hljs-comment\">//去重</span><br>        &#125;<br>        <span class=\"hljs-keyword\">if</span>((<span class=\"hljs-keyword\">long</span>) nums[i]+nums[j]+nums[j+<span class=\"hljs-number\">1</span>]+nums[j+<span class=\"hljs-number\">2</span>]&gt;target)&#123;<br>                <span class=\"hljs-keyword\">break</span>; <span class=\"hljs-comment\">//注意是break不是continue</span><br>        &#125;<br>        <span class=\"hljs-keyword\">if</span>((<span class=\"hljs-keyword\">long</span>) nums[i]+nums[j]+nums[size<span class=\"hljs-number\">-2</span>]+nums[size<span class=\"hljs-number\">-1</span>]&lt;target)&#123;<br>                <span class=\"hljs-keyword\">continue</span>;<br>        &#125;<br><br>        <span class=\"hljs-keyword\">int</span> k=j+<span class=\"hljs-number\">1</span>, q=size<span class=\"hljs-number\">-1</span>;<br>        <span class=\"hljs-keyword\">int</span> find_num=target-nums[i]-nums[j];<br>        <span class=\"hljs-keyword\">while</span>(k&lt;q)&#123; <span class=\"hljs-comment\">//双指针</span><br>            <span class=\"hljs-keyword\">if</span>(nums[k]+nums[q]&gt;find_num)&#123;<br>                q--;<br>            &#125;<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (nums[k]+nums[q]&lt;find_num)&#123;<br>                k++;<br>            &#125;<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (nums[k]+nums[q]==find_num)&#123;<br>                res.<span class=\"hljs-built_in\">push_back</span>(&#123;nums[i], nums[j], nums[q], nums[k]&#125;);<br>                k++;<br>                q--;<br>                <span class=\"hljs-keyword\">while</span>(k&lt;q&amp;&amp;nums[k]==nums[k<span class=\"hljs-number\">-1</span>])&#123; <span class=\"hljs-comment\">//去重</span><br>                    k++;<br>                &#125;<br>                <span class=\"hljs-keyword\">while</span>(k&lt;q&amp;&amp;nums[q]==nums[q+<span class=\"hljs-number\">1</span>])&#123;<br>                q--;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>参考链接：<a href=\"https://leetcode-cn.com/problems/4sum/solution/si-shu-zhi-he-by-leetcode-solution/\">四数之和答案</a></p>\n</blockquote>\n<h4 id=\"HashMap的底层实现（java）\"><a href=\"#HashMap的底层实现（java）\" class=\"headerlink\" title=\"HashMap的底层实现（java）\"></a>HashMap的底层实现（java）</h4><p>JDK1.7 的底层是数组加链表，而 JDK1.8 的底层是数组加链表加红黑树，红黑树相对于AVL树来说，牺牲了部分平衡性以换取插入/删除操作时少量的旋转操作，整体来说性能要优于AVL树。</p>\n<p>使用hash函数（hash算法： index = HashCode（Key） &amp; （Length - 1）），将数据放在数组中，如果数组已经将要放的位置满了，就使用链表链接在那个位置的后面；使用树是为了防止链表过长,设定阈值为8，那么大于这个阈值就将这个链表转为红黑树，小于6的时候链化， 避免查询时间过长。（8树化、6链化），而且设置为8个节点时，红黑树的性能优势也会开始展现出来，因此8是一个较合理的数字。</p>\n<p>hashmap初始长度是16，每次扩展或者手动初始化必须是2的幂：是为了服务从key到index的hash算法：index = HashCode（Key） &amp; （Length - 1），使得使用位运算计算的结果等同于取模（x mod 2^n = x &amp; (2^n - 1)），也就是只取决于hashcode的二进制后面几位，只要HashCode本身分布均匀，Hash算法的结果就是均匀的，从而大大提高性能。</p>\n<p>高并发情况下，hashmap可能会出现死锁<br>JDK1.7以及前是在头结点插入的，在JDK1.8之后是在尾节点插入的。，因为JDK1.7在多进程的情况下可能会出现死循环，由循环链表造成（rehash的时候，一个进程在e, next的时候挂起，另外一个进程已经将数据都扩容好，进程1又开始扩容），但是JDK1.8仍然可能会出现数据丢失（进程1要在插入时候，时间片用完，进程2插入元素在一个相同位置，进程1就会直接将进程2插入的元素覆盖），并发下扩容数据丢失</p>\n<p><font color=\"red\">避免hash冲突的方法：</font><br>开放定址法（再hash）<br>    线性探查：可能会出现大量的错误<br>    平方探查<br>    二次散列/平方探查：导致hash表空间利用率很低，出现大量重复</p>\n<pre><code>优点：存储结构连续，因此查找的IO开销更小\n缺点：1）在插入的元素大于hash表的时候，需要扩容 2）hash表存储空间利用率低 3）删除操作的时间复杂度高，因为不能直接删除，因为它的后面可能有数据，因此需要设置删除标记，需要额外的空间 4）探查序列如何设计比较复杂可能会降低hash的性能\n</code></pre>\n<p>拉链法：<br>    可能导致数据存储的物理空间不连续导致大量I/O开销</p>\n<pre><code>优点：1）对于记录总数是动态变化的情况比较好，不需要频繁扩容 2）存储空间动态分配，因此hash的空间利用率高 3）删除记录也比较方便\n缺点：1）因为使用的链表，因此在查询记录时，相比结构紧凑的数据类型（比如数组），哈希表的跳转访问会带来额外的时间开销 2)由于使用指针，记录不容易进行序列化（serialize）操作\n</code></pre>\n<p>例题：lc706. 设计哈希映射</p>\n<ul>\n<li>使用链地址法实现，每个节点除了key val, 还需要一个next域, 然后使用vector充当数组</li>\n<li>易错点：<ol>\n<li>删除的时候需要判断删除这个节点是否是头节点，和尾结点</li>\n<li>插入的时候需要判断key是不是本身在hash中</li>\n<li>指针在进行取值或者取下一个值（cur-&gt;key||cur-&gt;next）的时候，一定要保证这个指针(cur)不为NULL, 否则会报错</li>\n</ol>\n</li>\n</ul>\n<p>lc705. 设计哈希集合</p>\n<ul>\n<li>这个和上面一题一样，不同的是这个不需要val字段，其余都相同</li>\n</ul>\n<h4 id=\"hash-动态规划\"><a href=\"#hash-动态规划\" class=\"headerlink\" title=\"hash+动态规划\"></a>hash+动态规划</h4><ol>\n<li>最长定差子序列<br>转移方程： dp[arr[i]]=dp[arr[i]-diff]+1<br>因为不知道arr[i]的最大值，以及可能出现负数的下标， 所以直接使用hash，而不是数组<br>dp[x] 表示以 x 结尾的最长等差子序列的长度；</li>\n</ol>\n<h4 id=\"分布式一致性hash算法\"><a href=\"#分布式一致性hash算法\" class=\"headerlink\" title=\"分布式一致性hash算法\"></a>分布式一致性hash算法</h4><p>针对的问题是如何将数据均匀的分布在key-value的分布式缓存中，如果使用mod方法，均匀但是可能导致插入删除节点，所有的数据需要重新hash<br>1)第一种是将存储节点和数据都映射到一个首尾相连的hash环上，数据存储在hash环上顺时针的第一个节点，插入节点就只影响相邻节点的后续节点，对其他节点没有影响。但是可能造成不均衡的局面，<br>2）因此改进就是对一个存储节点使用虚拟节点，映射在环上的多个位置</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>OK OK</p>\n<ol>\n<li>最长类似题目，可以使用dp, 前缀和，双指针，以及单栈+逆序遍历</li>\n<li>前缀和+hash可以做数组最长题目或者为目标类的连续子数组的个数，一个hash用来记录之前前缀和的下标，一个用来记录前缀和为sum的个数<br>（个数和长度问题）</li>\n</ol>\n"},{"title":"回溯_DFS_BFS","catogory":["leetcode 题目汇总"],"date":"2021-11-13T09:23:50.000Z","_content":"\n#### 例题\n1. 字符串的转换路径问题:\n    单词接龙I:只返回最短转换序列的长度（使用BFS）\n    单词接龙II：返回所有最短转换序列具体是什么\n    标准答案是既用到了深度优先搜索，也用到了宽度优先搜索\n    （最短距离）\n    首先判断endWord是否在字典中，不在的话直接返回空\n    在进行单词找相邻，可以遍历单词每个字符，判断与当前是否只有一个不相等（O(mn)）；或者将当前单词的每一位替换成 26 个小写英文字母，查找是否在字典中（推荐）(O(26n));一定要注意改变了某一个位之后要记得还原该位！！！！！！\n    方法1：\n    - 使用BFS建立每个单词的前向节点，需要使用steps[nextWord] 记录每个单词到start的最短。\n    如果steps[nextWord]==step,那么from[nextWord].insert(currentWord), 然后判断nextWord是否被vis, 或者是否还在dict中，如果在，加入队列中，进行下列操作；如果不在(已经加入过队列中或者被访问过)，直接continue\n    ```C++\n    // 如果从一个单词扩展出来的单词以前遍历过，距离一定更远，为了避免搜索到已经遍历到，且距离更远的单词，需要将它从 dict 中删除\n    dict.erase(nextWord); //删除或者设置vis\n    // 这一层扩展出的单词进入队列\n    q.push(nextWord);\n    // 记录 nextWord 从 currWord 而来\n    from[nextWord].insert(currWord);\n    // 记录 nextWord 的 step\n    steps[nextWord] = step;\n    ``` \n    - DFS （从endWord到startWord）反向求具体路径，同时在进入下层循环是需要判断，当前的距离是不是当前节点到start的最短距离，如果是进入循环，否则剪枝\n\n    方法2：\n    - 使用BFS求最短路，同时建立每个单词的pre单词，因为同一层两个单词可能到一个单词的距离相等，因此需要每层元素遍历完了之后再vis, 以及再队列push next_element\n    next_ele.erase(unique(next_ele.begin(), next_ele.end()), next_ele.end()); //也可以直接用set来去重\n    - 反向DFS求具体路径\n2. 单词转换\n[leetcode链接](https://leetcode-cn.com/problems/word-transformer-lcci/solution/c-python3-dfsbu-neng-hui-su-yin-wei-bu-s-u45m/)\n求其中一条路径使用DFS （因为没说要最短）\n求所有的路径使用BFS+DFS 在一轮访问完之后再赋值vis以及去重/或者记录每个节点d, 然后dfs的时候判断到这个节点的d时候是当前的深度对应\n求最短的路径，用BFS\n\nPS: 其他解决字符串的相关问题的方案\n使用动态规划+Trie树，或者暴力string find，或者转为数组（数字）等等，\n\nPS类似的题目： 单词接龙和最小基因变化， 最小基因变化的这道题在进行单词转换的时候，找相邻的两种方式：(1)对每个字符，4种情况 ACGT都进行测试（也就是每个字符需要验证4n次）， (2)在单词库中查找只有一个字符变化的\n\n<font color=red>3. 组合总数 ：一定要注意如果给出的列表中包含重复的数据的话，一定要记得去重，以及通过一些条件可以提前剪枝</font>\n\n组合总数I， II, III, VI 在进行回溯的时候需要注意的几个点：\n- 每类的数据是否可以重复选择，如果可以重复选择，那么需要在递归到某一个类的时候，将这个类的所有的数据（一个或者target/candidate[i]个）都选择完\n- 是只求总数还是求所有的序列，如果只求总数可以使用动态规划（一定要注意if和else的状态转移情况都要考虑到），如果求序列需要使用递归回溯剪枝\n- 相同结果不用元素组合算一种还是多种（2，2，3）和（2，2，3） 原数据为（2，2，2，2，3）\n- 给的列表是否包含重复的数据，如果包含需要对数据进行排序后，再进行回溯\n- 给的列表是否可以重复取，如果可以那么 改为 dfs(candidates,target-k*candidates[i],i+1,count);其中count[i]=k\n为了防止递归层数太深；同时一定要递归到最后pos==size&&target==0才代表找到了这样一个序列（以为count需要修改）\n- 如果每个数都只能取一次，而且取的个数一定要是相等的话，可以使用二进制位进行枚举具体的序列\n\n\n4. 将数组拆分为斐波拉切数列  枚举最开始的a b，求出c判断后面的字符是不是c\n\n- 可以使用stoi将字符串转为整数（一定要注意stoi字符溢出的问题， 以及stol溢出可能性）\n\n  long long tmp=stoi(a)+stoi(b) 如果整数相加超过了INT_MAX还是会报错，所以左边的写法是错误的，应该写为 long long tmp=stol(a)+stol(b)\n\n- 也可以使用 回溯一个字符一个字符的累加，如果size>2的情况下计算当前数+pre是否能够达到target,如果小于那么继续循环，如果大于那么退出循环 cur = cur*10 + S[i] - '0';\n\n\n5. 求图长度，或者多叉树的树高\n```C++\n//注意开始遍历每个节点的时候，一定要记得将根节点设置为vis\n  int dfs(int cur, vector<vector<int>>& graph, vector<int> &vis){\n          int ans=0;\n          for(int i=0;i<graph[cur].size();i++){\n              if(!vis[graph[cur][i]]){\n                  vis[graph[cur][i]]=1;\n                  ans= max(ans, dfs(graph[cur][i], graph, vis));\n              }\n          }\n          return ans+1;\n      }\n\n```\n\n6. 最小高度树（有两个类似的题目）\n让根节点是排序数组的中点\n使用的是拓扑排序，如果求以每个节点为根节点的树，会导致超出时间限制，因此需要使用拓扑排序，每次删除叶节点（degrees[i] ），求到最中间的几个点\n\n\n7. 水壶问题，使用深度优先搜索，或者数学推导\n深度优先搜索，因为超过了系统的搜索的层数，所以需要自己模拟压栈和出栈， 同时需要知道当前状态可以转化为其他状态，其他状态包括，将X倒满，将Y倒满，将X倒空，将Y倒空，将x的水导入Y中，将Y的水倒数X中 6种撞他\n或者使用数学方式解决，每次水的变化量（X+Y）一定是X或者Y, 那么有不等式 ax+by=z; 那么z一定x和y最小公因数的倍数\n\n<font color=red>8. 字典序 或者 全排列使用深度优先搜索</font>\n字典序返回[1-n]所有整数\n```C++\nvoid dfs(int n, int cur, vector<int>& res){\n      if(cur>n){\n          return;\n      }\n      res.push_back(cur);//在dfs的同时push\n      for(int i=0;i<=9;i++){\n          dfs(n, cur*10+i, res);\n      }\n  }\n  vector<int> lexicalOrder(int n) {\n      vector<int> res;\n      for(int i=1;i<=9;i++){\n          dfs(n, i, res);\n      }\n      return res;\n  }\n```\n```C++ 无重复数字的全排列 \n方法1\nvoid all_permute(vector<int>& nums,vector<vector<int>> &result,int cur ) {\n    int size=nums.size();\n    if(cur==size-1){\n        result.push_back(nums);\n        return;\n    }\n    for(int i=cur;i<size;i++){\n        swap(nums[cur], nums[i]);\n        all_permute(nums, result, cur+1);\n        swap(nums[cur], nums[i]);\n    }\n}\n//方法2：\nvoid dfs(int index, string &S, string &path, vector<int> &used){\n    int size=S.size();\n        if(index==size){\n        res.push_back(path);\n        return;\n    }\n    for(int i=0;i<size;i++){\n        if(used[i]){ //最重要的两个if判断\n            continue;\n        }\n        path.push_back(S[i]);\n        used[i]=true;\n        dfs(index+1, S, path, used);\n        used[i]=false;\n        path.pop_back();\n    }\n}\n```\n\n\n\n<font color=red> 有重复数字的全排列</font>\n答案解析：lc:全排列II\n```C++\n    sort(S.begin(), S.end()); //在主函数进行排序， 同时使用used数组，判断S中的某个字符是否被用过， 用一个string path，表示现在拼起来的字符\n    void dfs(int index, string &S, string &path, vector<int> &used){\n        int size=S.size();\n         if(index==size){\n            res.push_back(path);\n            return;\n        }\n        for(int i=0;i<size;i++){\n            if(used[i]){ //最重要的两个if判断\n                continue;\n            }\n            if(i!=0&&S[i]==S[i-1]&&!used[i-1]){ //注意这一层的判断\n                continue;\n            }\n            path.push_back(S[i]);\n            used[i]=true;\n            dfs(index+1, S, path, used);\n            used[i]=false;\n            path.pop_back();\n        }\n    }\n```\n\n扩展：排列中的下一个排列\n```c++\n//先找一个一个顺序相邻， 然后交换当前数和为后面第一个大于它的数，然后让后面的数递增；注意特殊情况，如果当前数已经是全排雷的最后一个，那么直接返回第一个排列\n    int i=nums.size()-2;\n    while(i>=0&&nums[i]>=nums[i+1]){\n        i--;\n    }\n    if(i>=0){\n        int j=nums.size()-1;\n        while(nums[i]>=nums[j]){\n            j--;\n        }\n        swap(nums[i],nums[j]);\n        reverse(nums.begin()+i+1,nums.end());\n    }else{\n        reverse(nums.begin()+i+1,nums.end());\n    }\n```\nlc60. 排列序列 （hard）\n求全排列的第k个排列\n易错点：需要最开始使用k--;因为第k个排列前面有k-1个排列\n然后计算当前每一位应该放哪个第一位 前面的数为num = k/(n-1)! ，固定了第一个位, 之后更新k=k%(n-1)!\n第二个位，前面的数 num = k/(n-2)! ，固定了第一个位, 之后更新k=k%(n-2)!，同时使用了一个数，需要标记为访问\n重复这样的过程\n```C++\nstring res;\nk--; //非常重要\nfor(int j=1;j<=n;j++){\n    int num=k/frac[n-j]; //前面的数\n    num++; //当前应该选择的数\n    // cout<<num<<endl;\n    for(int i=1;i<=n;i++){\n        if(!vis[i]){\n            num--;\n            if(num==0){\n                vis[i]=1;\n                res+=i+'0';\n            }\n        }\n        \n    }\n    k=k%frac[n-j];\n}\nreturn res;\n```\n\nlc90, 子集II\n- 题意：求有重复数据数列的所有子集\n- 使用dfs+去重+路径中一直push到res中\n```C++\ndfs():\n    res.push_back(path);\n    if(index>=size){\n        return;\n    }\n    for(int i=index;i<size;i++){\n        if(i!=index&&nums[i]==nums[i-1]){ //去重方式和四数之和一样\n            continue;\n        }\n        path.push_back(nums[i]);\n        dfs(i+1, nums, path);\n        path.pop_back();\n    }\n```\n\n9. 01矩阵 <font color=blue>多源BFS</font>\n找到1距离0的距离是从0开始进行bfs，而不是从1开始\n解法：\n    - 广度优先搜索+记忆数组（将为0的点放入队列中，然后一层层向外扩散，记得访问过的点记得标记为visit, 或者用matrix !=-1来判定该点时候被访问过）\n    - 左上到右下；再从右下到左上\n\n10. 大礼包。注意这道题可以学习的是状态的记忆过程，使用map<vector<int>, int>, 当然这道题直接用dfs搜索每一个状态也是可以的\n注意这道题在dfs的时候，除了要循环选择每个大礼包，退出循环后，还要判断当前计算值和==全部不用大礼包==谁更小！！！\n无法使用完全背包+dp解决，因为dp的内层循环无法枚举，因为是一个vector, 而不是一个简单的int\n\n\n<font color=red>11. 划分为k个相同的子集：</font>\n这道题既可以使用状态压缩的dp也可以使用回溯+贪心\n方法一：\n- 需要对数组排序，从大的数最开始进行匹配，贪心策略（这样压栈次数会更少）\n- 使用回溯的时候需要使用一个vis数组，如果当前值小于target 那么继续向前遍历；如果==target那么从头开始遍历，同时k-1;如果大于target,那么循环内部判断数组下一个数是否合适  (循环数组的时候多次dfs 判断是否都能凑出<=target)\nhttps://zhuanlan.zhihu.com/p/78031844\n\n方法二：\n- 建立n个桶，然后判断每个数应该放在哪个桶内(只用记录桶中总数，不用记录具体放到什么)；如果当前这个数放在哪个桶都不行，那么当前循环return false；仍然使用贪心减少遍历次数\n- https://leetcode-cn.com/problems/partition-to-k-equal-sum-subsets/solution/liang-chong-bu-tong-de-hui-su-si-lu-cong-5rnw/\n\n\n<font color =blue>12. 地图分析，多源BFS的例题</font>\n和正向题目描述的思路反过来，从为1的陆地出发，而不是从每个海洋出发求最短距离。先将所有为1的节点的位置放在队列中，每访问一个节点，就修改节点位置的值，那么就不需要使用vis数组\n\n13.组合总数||\n因为这个是要求具体的组合，用dfs,同时注意去重\n```C++\n  for(int i=index;i<size;i++){\n      if(i>index&&candidates[i]==candidates[i-1]){//去重\n          continue;\n      }\n      path.push_back(candidates[i]);\n      dfs(candidates, target-candidates[i], i+1, path);\n      path.pop_back();\n      // dfs(candidates, target, i+1, path); //注意这个一定不能要\n  }\n```\n\n\n14. 面试题 16.22. 兰顿蚂蚁\n    类似于走地图的题目，是一个模拟题\n    因为x, y的坐标可能为负数，因此使用map< pair<int, int>, char> matrix; (使用unordered_map会报错)\n    同时在进行打印的时候，应该y在外层，x在内层；如果map中没有找到这个坐标，那么应该打印出“_”, 记录当前地图的左上和右下坐标\n\n\n15. 双向BFS\n- 使用两个队列， 每次更新一个size比较小的队列里面的所有元素，同时使用两个unordered_map记录走到某个字符串/位置，走的步数（同时有vis数组的功能）。 如果当前更新的字符串，在另外一个队列的map中也能找到记录说明两个队列相遇了， 返回step + 1 + other[copy];\n\n<font color=red>16. 逃脱迷宫需要移除的最少砖头数量</font>\n-  使用BFS+优先队列+vis， 队列里面存放到x, y, 和到每个节点的最少要移除的砖头数量， 循环在nextx nexty=n-1的时候返回结果， 具体代码实现看模板代码/逃脱迷宫\n-  不能使用dfs+记忆化数组+vis，因为到达当前节点的时候，前面vis 路径不一定是最优的，导致计算出来d不一定是最佳的，从而之后的计算都出现错误； 记忆化数组可以使用场景就是，之前的选择不会对之后的选择造成影响， 或者需要另外用一个状态位运算来记录之前走的路径到底是怎样的（见lc980, 下面有分析）\n- 这道题的思路和lc752: 打开转盘锁一样，不能走回头路，lc752可以使用双端BFS，感觉这个不适合双堆队列，因为map里面的数据并不都是同一层，同时两个队列size感觉都是一样的，从两个对角线出发；这道题使用优先队列更佳\n-  不一样的是这个每走一步不一定+1， 队列数据不一定在同一层（因此需要使用优先队列）， 但是逃脱迷宫是每走一步都+1， 队列里面的数据都在同一层，使用普通队列\n- 总结，使用bfs查找从源到目的节点的最短路径\n    1. 将源节点压入队列中，同时设置为vis\n    2. 如果一层的cost一样，那么每层进行遍历（否则需要压入的时候，记录压入节点的cost）,计算当前节点的下一个节点，判断下一个节点的合理性（vis和index边缘）\n    3. 如果合理，那么判断下一个节点是否是目标节点，如果是直接返回step+1,否则向队列中压入下一个节点\n    4. 重复上述过程，知道队列为空\n    5. 如果队列空都没有找到，说明源节点无法到达目标节点\n\n\n15， 克隆图\n- 使用BFS\n- 这个题类似于 剑指 Offer 35. 复杂链表的复制，需要建立原始node和新node之间的映射, 同时这个hash也能充当vis数组，判断当前节点是否被访问过；复杂链表复制那道题只需要顺序两次遍历链表就可以了，不需要vis或者bfs\n\n<font color=red>16. 给表达式添加运算符（hard）</font>\n使用回溯\n易错点：\n    1. 乘法是有优先级的，因此之前计算dfs计算的结果有可能是需要回退一个数组，然后再进行计算\n    2. 每次压入的数字可能是包含多个位的\n    3. 不能包含前导0，但是这个数又不是0的情况\n    ```C++\n    if(i!=index&&num[index]=='0'){\n        return;\n    }\n    ```\n    4. 回溯是时候一定要记得将符号pop_back!!!!\n\n\n17. lc980. 不同路径 III\n- 求从起点到终点，经过二维矩阵的每个空方格（注意是每个都要走一次，而且不能重复），的不同路径总数\n- 使用记忆化的dfs 因为到达每个点前面的路径是不一定相同的，因此需要使用dp[i][j][i*C+j^之前的路径] 表示到达当前的状态之前走过的路径是怎样的\n注意题目表示1 <= grid.length * grid[0].length <= 20，才能使用这种位运算来记录矩阵的状态（状态压缩的条件）\n\n\n\n18. 单词拆分II\n- 需要找到所有拆分的具体方案\n- 为了减少回溯的重复，使用一个hash<int, vector<string>> 将以i下标为开始后面形成的所有可能都存储下来，这样之后寻找的时候就不用重复判断 （类似二叉搜索树的所有可能那种题目）， 记忆化dfs\n\n\n19. lc741. 摘樱桃(hard)\n- 这道题用dp理解起来比较困难，所以使用记忆化dfs\n- 易错点：贪心，第一次选最大+第二次选剩下的最大不一定是最优解\n- 正确方法，需要dfs，然后需要有两条路径，就相当于同时对**两个点进行dfs**, 这两个点x1+y1=x2+y2 (有关系)然后需要判断这两个是不是同一个点，如果是，那么+grid[x1][y1]， 否则+grid[x1][y1]+grid[x2][y2]\n\n\n20. lc934. Shortest Bridge 最短的桥梁\n- 使用多源最短路径，两个技巧：先dfs找到岛屿上的所有点，并将将访问过的岛屿转为2；2. BFS使用层次bfs, 因为修改了访问的点为2，所以不用使用vis数组\n\n\n\n#### 总结\nok ok\n1. 注意dfs和回溯还是有区别的，dfs，遇到不合适的条件可以直接退出，但是回溯，退出前要将之前的状态修改； BFS常用于求最短路径，或者最少xxxx(结合优先队列)\n\n2. dfs和记忆化搜索和dp都有联系，有时候一道题这两种方法都可以用\n例如：\n- 分汤(因为都是25的倍数，所以n可以直接/25+1(如果余数不为0), 分配操作同样变为-4、-2、-1\ndfs如果状态比较多，可以使用记忆化数组，同时如果状态都是某一个数的倍数，那么可以对数据进行归一化后再进行dfs\n这样的话记忆化搜索的状态数量就会减少\n```C++\n double ans = 0.0;\n                if (i == 0) ans = 1.0;\n                if (i == 0 && j == 0) ans = 0.5;\n                if (i > 0 && j > 0) {\n                    ans = 0.25 * (memo[M(i-4)][j] + memo[M(i-3)][M(j-1)] +\n                                  memo[M(i-2)][M(j-2)] + memo[M(i-1)][M(j-3)]);\n                }\n```\n- 类似的概率转移dfs/dp有leet935. 马”在棋盘上的概率（可以最后/pow(8,N), 不用每次/8）\n\n3. 如果要求岛屿的形状相同，那么可以将岛屿的位置使用string的形式存储下来，然后使用set<string>来存储，返回size就是形状不同的岛屿（忽略翻折和旋转）\n\n4. 递归转为非递归的方式，使用堆或者栈（lc100.相同的数（dfs/宽度优先遍历））\n\n5. 注意如果dfs中数据包含重复，一定要记得去重（如排列，组合）\n\n","source":"_posts/leetcode/回溯_DFS_BFS.md","raw":"---\ntitle: 回溯_DFS_BFS\ncatogory:\n  - leetcode 题目汇总\ntags: 回溯算法, DFS, BFS\ncategories:\n  - leetcode\ndate: 2021-11-13 17:23:50\n---\n\n#### 例题\n1. 字符串的转换路径问题:\n    单词接龙I:只返回最短转换序列的长度（使用BFS）\n    单词接龙II：返回所有最短转换序列具体是什么\n    标准答案是既用到了深度优先搜索，也用到了宽度优先搜索\n    （最短距离）\n    首先判断endWord是否在字典中，不在的话直接返回空\n    在进行单词找相邻，可以遍历单词每个字符，判断与当前是否只有一个不相等（O(mn)）；或者将当前单词的每一位替换成 26 个小写英文字母，查找是否在字典中（推荐）(O(26n));一定要注意改变了某一个位之后要记得还原该位！！！！！！\n    方法1：\n    - 使用BFS建立每个单词的前向节点，需要使用steps[nextWord] 记录每个单词到start的最短。\n    如果steps[nextWord]==step,那么from[nextWord].insert(currentWord), 然后判断nextWord是否被vis, 或者是否还在dict中，如果在，加入队列中，进行下列操作；如果不在(已经加入过队列中或者被访问过)，直接continue\n    ```C++\n    // 如果从一个单词扩展出来的单词以前遍历过，距离一定更远，为了避免搜索到已经遍历到，且距离更远的单词，需要将它从 dict 中删除\n    dict.erase(nextWord); //删除或者设置vis\n    // 这一层扩展出的单词进入队列\n    q.push(nextWord);\n    // 记录 nextWord 从 currWord 而来\n    from[nextWord].insert(currWord);\n    // 记录 nextWord 的 step\n    steps[nextWord] = step;\n    ``` \n    - DFS （从endWord到startWord）反向求具体路径，同时在进入下层循环是需要判断，当前的距离是不是当前节点到start的最短距离，如果是进入循环，否则剪枝\n\n    方法2：\n    - 使用BFS求最短路，同时建立每个单词的pre单词，因为同一层两个单词可能到一个单词的距离相等，因此需要每层元素遍历完了之后再vis, 以及再队列push next_element\n    next_ele.erase(unique(next_ele.begin(), next_ele.end()), next_ele.end()); //也可以直接用set来去重\n    - 反向DFS求具体路径\n2. 单词转换\n[leetcode链接](https://leetcode-cn.com/problems/word-transformer-lcci/solution/c-python3-dfsbu-neng-hui-su-yin-wei-bu-s-u45m/)\n求其中一条路径使用DFS （因为没说要最短）\n求所有的路径使用BFS+DFS 在一轮访问完之后再赋值vis以及去重/或者记录每个节点d, 然后dfs的时候判断到这个节点的d时候是当前的深度对应\n求最短的路径，用BFS\n\nPS: 其他解决字符串的相关问题的方案\n使用动态规划+Trie树，或者暴力string find，或者转为数组（数字）等等，\n\nPS类似的题目： 单词接龙和最小基因变化， 最小基因变化的这道题在进行单词转换的时候，找相邻的两种方式：(1)对每个字符，4种情况 ACGT都进行测试（也就是每个字符需要验证4n次）， (2)在单词库中查找只有一个字符变化的\n\n<font color=red>3. 组合总数 ：一定要注意如果给出的列表中包含重复的数据的话，一定要记得去重，以及通过一些条件可以提前剪枝</font>\n\n组合总数I， II, III, VI 在进行回溯的时候需要注意的几个点：\n- 每类的数据是否可以重复选择，如果可以重复选择，那么需要在递归到某一个类的时候，将这个类的所有的数据（一个或者target/candidate[i]个）都选择完\n- 是只求总数还是求所有的序列，如果只求总数可以使用动态规划（一定要注意if和else的状态转移情况都要考虑到），如果求序列需要使用递归回溯剪枝\n- 相同结果不用元素组合算一种还是多种（2，2，3）和（2，2，3） 原数据为（2，2，2，2，3）\n- 给的列表是否包含重复的数据，如果包含需要对数据进行排序后，再进行回溯\n- 给的列表是否可以重复取，如果可以那么 改为 dfs(candidates,target-k*candidates[i],i+1,count);其中count[i]=k\n为了防止递归层数太深；同时一定要递归到最后pos==size&&target==0才代表找到了这样一个序列（以为count需要修改）\n- 如果每个数都只能取一次，而且取的个数一定要是相等的话，可以使用二进制位进行枚举具体的序列\n\n\n4. 将数组拆分为斐波拉切数列  枚举最开始的a b，求出c判断后面的字符是不是c\n\n- 可以使用stoi将字符串转为整数（一定要注意stoi字符溢出的问题， 以及stol溢出可能性）\n\n  long long tmp=stoi(a)+stoi(b) 如果整数相加超过了INT_MAX还是会报错，所以左边的写法是错误的，应该写为 long long tmp=stol(a)+stol(b)\n\n- 也可以使用 回溯一个字符一个字符的累加，如果size>2的情况下计算当前数+pre是否能够达到target,如果小于那么继续循环，如果大于那么退出循环 cur = cur*10 + S[i] - '0';\n\n\n5. 求图长度，或者多叉树的树高\n```C++\n//注意开始遍历每个节点的时候，一定要记得将根节点设置为vis\n  int dfs(int cur, vector<vector<int>>& graph, vector<int> &vis){\n          int ans=0;\n          for(int i=0;i<graph[cur].size();i++){\n              if(!vis[graph[cur][i]]){\n                  vis[graph[cur][i]]=1;\n                  ans= max(ans, dfs(graph[cur][i], graph, vis));\n              }\n          }\n          return ans+1;\n      }\n\n```\n\n6. 最小高度树（有两个类似的题目）\n让根节点是排序数组的中点\n使用的是拓扑排序，如果求以每个节点为根节点的树，会导致超出时间限制，因此需要使用拓扑排序，每次删除叶节点（degrees[i] ），求到最中间的几个点\n\n\n7. 水壶问题，使用深度优先搜索，或者数学推导\n深度优先搜索，因为超过了系统的搜索的层数，所以需要自己模拟压栈和出栈， 同时需要知道当前状态可以转化为其他状态，其他状态包括，将X倒满，将Y倒满，将X倒空，将Y倒空，将x的水导入Y中，将Y的水倒数X中 6种撞他\n或者使用数学方式解决，每次水的变化量（X+Y）一定是X或者Y, 那么有不等式 ax+by=z; 那么z一定x和y最小公因数的倍数\n\n<font color=red>8. 字典序 或者 全排列使用深度优先搜索</font>\n字典序返回[1-n]所有整数\n```C++\nvoid dfs(int n, int cur, vector<int>& res){\n      if(cur>n){\n          return;\n      }\n      res.push_back(cur);//在dfs的同时push\n      for(int i=0;i<=9;i++){\n          dfs(n, cur*10+i, res);\n      }\n  }\n  vector<int> lexicalOrder(int n) {\n      vector<int> res;\n      for(int i=1;i<=9;i++){\n          dfs(n, i, res);\n      }\n      return res;\n  }\n```\n```C++ 无重复数字的全排列 \n方法1\nvoid all_permute(vector<int>& nums,vector<vector<int>> &result,int cur ) {\n    int size=nums.size();\n    if(cur==size-1){\n        result.push_back(nums);\n        return;\n    }\n    for(int i=cur;i<size;i++){\n        swap(nums[cur], nums[i]);\n        all_permute(nums, result, cur+1);\n        swap(nums[cur], nums[i]);\n    }\n}\n//方法2：\nvoid dfs(int index, string &S, string &path, vector<int> &used){\n    int size=S.size();\n        if(index==size){\n        res.push_back(path);\n        return;\n    }\n    for(int i=0;i<size;i++){\n        if(used[i]){ //最重要的两个if判断\n            continue;\n        }\n        path.push_back(S[i]);\n        used[i]=true;\n        dfs(index+1, S, path, used);\n        used[i]=false;\n        path.pop_back();\n    }\n}\n```\n\n\n\n<font color=red> 有重复数字的全排列</font>\n答案解析：lc:全排列II\n```C++\n    sort(S.begin(), S.end()); //在主函数进行排序， 同时使用used数组，判断S中的某个字符是否被用过， 用一个string path，表示现在拼起来的字符\n    void dfs(int index, string &S, string &path, vector<int> &used){\n        int size=S.size();\n         if(index==size){\n            res.push_back(path);\n            return;\n        }\n        for(int i=0;i<size;i++){\n            if(used[i]){ //最重要的两个if判断\n                continue;\n            }\n            if(i!=0&&S[i]==S[i-1]&&!used[i-1]){ //注意这一层的判断\n                continue;\n            }\n            path.push_back(S[i]);\n            used[i]=true;\n            dfs(index+1, S, path, used);\n            used[i]=false;\n            path.pop_back();\n        }\n    }\n```\n\n扩展：排列中的下一个排列\n```c++\n//先找一个一个顺序相邻， 然后交换当前数和为后面第一个大于它的数，然后让后面的数递增；注意特殊情况，如果当前数已经是全排雷的最后一个，那么直接返回第一个排列\n    int i=nums.size()-2;\n    while(i>=0&&nums[i]>=nums[i+1]){\n        i--;\n    }\n    if(i>=0){\n        int j=nums.size()-1;\n        while(nums[i]>=nums[j]){\n            j--;\n        }\n        swap(nums[i],nums[j]);\n        reverse(nums.begin()+i+1,nums.end());\n    }else{\n        reverse(nums.begin()+i+1,nums.end());\n    }\n```\nlc60. 排列序列 （hard）\n求全排列的第k个排列\n易错点：需要最开始使用k--;因为第k个排列前面有k-1个排列\n然后计算当前每一位应该放哪个第一位 前面的数为num = k/(n-1)! ，固定了第一个位, 之后更新k=k%(n-1)!\n第二个位，前面的数 num = k/(n-2)! ，固定了第一个位, 之后更新k=k%(n-2)!，同时使用了一个数，需要标记为访问\n重复这样的过程\n```C++\nstring res;\nk--; //非常重要\nfor(int j=1;j<=n;j++){\n    int num=k/frac[n-j]; //前面的数\n    num++; //当前应该选择的数\n    // cout<<num<<endl;\n    for(int i=1;i<=n;i++){\n        if(!vis[i]){\n            num--;\n            if(num==0){\n                vis[i]=1;\n                res+=i+'0';\n            }\n        }\n        \n    }\n    k=k%frac[n-j];\n}\nreturn res;\n```\n\nlc90, 子集II\n- 题意：求有重复数据数列的所有子集\n- 使用dfs+去重+路径中一直push到res中\n```C++\ndfs():\n    res.push_back(path);\n    if(index>=size){\n        return;\n    }\n    for(int i=index;i<size;i++){\n        if(i!=index&&nums[i]==nums[i-1]){ //去重方式和四数之和一样\n            continue;\n        }\n        path.push_back(nums[i]);\n        dfs(i+1, nums, path);\n        path.pop_back();\n    }\n```\n\n9. 01矩阵 <font color=blue>多源BFS</font>\n找到1距离0的距离是从0开始进行bfs，而不是从1开始\n解法：\n    - 广度优先搜索+记忆数组（将为0的点放入队列中，然后一层层向外扩散，记得访问过的点记得标记为visit, 或者用matrix !=-1来判定该点时候被访问过）\n    - 左上到右下；再从右下到左上\n\n10. 大礼包。注意这道题可以学习的是状态的记忆过程，使用map<vector<int>, int>, 当然这道题直接用dfs搜索每一个状态也是可以的\n注意这道题在dfs的时候，除了要循环选择每个大礼包，退出循环后，还要判断当前计算值和==全部不用大礼包==谁更小！！！\n无法使用完全背包+dp解决，因为dp的内层循环无法枚举，因为是一个vector, 而不是一个简单的int\n\n\n<font color=red>11. 划分为k个相同的子集：</font>\n这道题既可以使用状态压缩的dp也可以使用回溯+贪心\n方法一：\n- 需要对数组排序，从大的数最开始进行匹配，贪心策略（这样压栈次数会更少）\n- 使用回溯的时候需要使用一个vis数组，如果当前值小于target 那么继续向前遍历；如果==target那么从头开始遍历，同时k-1;如果大于target,那么循环内部判断数组下一个数是否合适  (循环数组的时候多次dfs 判断是否都能凑出<=target)\nhttps://zhuanlan.zhihu.com/p/78031844\n\n方法二：\n- 建立n个桶，然后判断每个数应该放在哪个桶内(只用记录桶中总数，不用记录具体放到什么)；如果当前这个数放在哪个桶都不行，那么当前循环return false；仍然使用贪心减少遍历次数\n- https://leetcode-cn.com/problems/partition-to-k-equal-sum-subsets/solution/liang-chong-bu-tong-de-hui-su-si-lu-cong-5rnw/\n\n\n<font color =blue>12. 地图分析，多源BFS的例题</font>\n和正向题目描述的思路反过来，从为1的陆地出发，而不是从每个海洋出发求最短距离。先将所有为1的节点的位置放在队列中，每访问一个节点，就修改节点位置的值，那么就不需要使用vis数组\n\n13.组合总数||\n因为这个是要求具体的组合，用dfs,同时注意去重\n```C++\n  for(int i=index;i<size;i++){\n      if(i>index&&candidates[i]==candidates[i-1]){//去重\n          continue;\n      }\n      path.push_back(candidates[i]);\n      dfs(candidates, target-candidates[i], i+1, path);\n      path.pop_back();\n      // dfs(candidates, target, i+1, path); //注意这个一定不能要\n  }\n```\n\n\n14. 面试题 16.22. 兰顿蚂蚁\n    类似于走地图的题目，是一个模拟题\n    因为x, y的坐标可能为负数，因此使用map< pair<int, int>, char> matrix; (使用unordered_map会报错)\n    同时在进行打印的时候，应该y在外层，x在内层；如果map中没有找到这个坐标，那么应该打印出“_”, 记录当前地图的左上和右下坐标\n\n\n15. 双向BFS\n- 使用两个队列， 每次更新一个size比较小的队列里面的所有元素，同时使用两个unordered_map记录走到某个字符串/位置，走的步数（同时有vis数组的功能）。 如果当前更新的字符串，在另外一个队列的map中也能找到记录说明两个队列相遇了， 返回step + 1 + other[copy];\n\n<font color=red>16. 逃脱迷宫需要移除的最少砖头数量</font>\n-  使用BFS+优先队列+vis， 队列里面存放到x, y, 和到每个节点的最少要移除的砖头数量， 循环在nextx nexty=n-1的时候返回结果， 具体代码实现看模板代码/逃脱迷宫\n-  不能使用dfs+记忆化数组+vis，因为到达当前节点的时候，前面vis 路径不一定是最优的，导致计算出来d不一定是最佳的，从而之后的计算都出现错误； 记忆化数组可以使用场景就是，之前的选择不会对之后的选择造成影响， 或者需要另外用一个状态位运算来记录之前走的路径到底是怎样的（见lc980, 下面有分析）\n- 这道题的思路和lc752: 打开转盘锁一样，不能走回头路，lc752可以使用双端BFS，感觉这个不适合双堆队列，因为map里面的数据并不都是同一层，同时两个队列size感觉都是一样的，从两个对角线出发；这道题使用优先队列更佳\n-  不一样的是这个每走一步不一定+1， 队列数据不一定在同一层（因此需要使用优先队列）， 但是逃脱迷宫是每走一步都+1， 队列里面的数据都在同一层，使用普通队列\n- 总结，使用bfs查找从源到目的节点的最短路径\n    1. 将源节点压入队列中，同时设置为vis\n    2. 如果一层的cost一样，那么每层进行遍历（否则需要压入的时候，记录压入节点的cost）,计算当前节点的下一个节点，判断下一个节点的合理性（vis和index边缘）\n    3. 如果合理，那么判断下一个节点是否是目标节点，如果是直接返回step+1,否则向队列中压入下一个节点\n    4. 重复上述过程，知道队列为空\n    5. 如果队列空都没有找到，说明源节点无法到达目标节点\n\n\n15， 克隆图\n- 使用BFS\n- 这个题类似于 剑指 Offer 35. 复杂链表的复制，需要建立原始node和新node之间的映射, 同时这个hash也能充当vis数组，判断当前节点是否被访问过；复杂链表复制那道题只需要顺序两次遍历链表就可以了，不需要vis或者bfs\n\n<font color=red>16. 给表达式添加运算符（hard）</font>\n使用回溯\n易错点：\n    1. 乘法是有优先级的，因此之前计算dfs计算的结果有可能是需要回退一个数组，然后再进行计算\n    2. 每次压入的数字可能是包含多个位的\n    3. 不能包含前导0，但是这个数又不是0的情况\n    ```C++\n    if(i!=index&&num[index]=='0'){\n        return;\n    }\n    ```\n    4. 回溯是时候一定要记得将符号pop_back!!!!\n\n\n17. lc980. 不同路径 III\n- 求从起点到终点，经过二维矩阵的每个空方格（注意是每个都要走一次，而且不能重复），的不同路径总数\n- 使用记忆化的dfs 因为到达每个点前面的路径是不一定相同的，因此需要使用dp[i][j][i*C+j^之前的路径] 表示到达当前的状态之前走过的路径是怎样的\n注意题目表示1 <= grid.length * grid[0].length <= 20，才能使用这种位运算来记录矩阵的状态（状态压缩的条件）\n\n\n\n18. 单词拆分II\n- 需要找到所有拆分的具体方案\n- 为了减少回溯的重复，使用一个hash<int, vector<string>> 将以i下标为开始后面形成的所有可能都存储下来，这样之后寻找的时候就不用重复判断 （类似二叉搜索树的所有可能那种题目）， 记忆化dfs\n\n\n19. lc741. 摘樱桃(hard)\n- 这道题用dp理解起来比较困难，所以使用记忆化dfs\n- 易错点：贪心，第一次选最大+第二次选剩下的最大不一定是最优解\n- 正确方法，需要dfs，然后需要有两条路径，就相当于同时对**两个点进行dfs**, 这两个点x1+y1=x2+y2 (有关系)然后需要判断这两个是不是同一个点，如果是，那么+grid[x1][y1]， 否则+grid[x1][y1]+grid[x2][y2]\n\n\n20. lc934. Shortest Bridge 最短的桥梁\n- 使用多源最短路径，两个技巧：先dfs找到岛屿上的所有点，并将将访问过的岛屿转为2；2. BFS使用层次bfs, 因为修改了访问的点为2，所以不用使用vis数组\n\n\n\n#### 总结\nok ok\n1. 注意dfs和回溯还是有区别的，dfs，遇到不合适的条件可以直接退出，但是回溯，退出前要将之前的状态修改； BFS常用于求最短路径，或者最少xxxx(结合优先队列)\n\n2. dfs和记忆化搜索和dp都有联系，有时候一道题这两种方法都可以用\n例如：\n- 分汤(因为都是25的倍数，所以n可以直接/25+1(如果余数不为0), 分配操作同样变为-4、-2、-1\ndfs如果状态比较多，可以使用记忆化数组，同时如果状态都是某一个数的倍数，那么可以对数据进行归一化后再进行dfs\n这样的话记忆化搜索的状态数量就会减少\n```C++\n double ans = 0.0;\n                if (i == 0) ans = 1.0;\n                if (i == 0 && j == 0) ans = 0.5;\n                if (i > 0 && j > 0) {\n                    ans = 0.25 * (memo[M(i-4)][j] + memo[M(i-3)][M(j-1)] +\n                                  memo[M(i-2)][M(j-2)] + memo[M(i-1)][M(j-3)]);\n                }\n```\n- 类似的概率转移dfs/dp有leet935. 马”在棋盘上的概率（可以最后/pow(8,N), 不用每次/8）\n\n3. 如果要求岛屿的形状相同，那么可以将岛屿的位置使用string的形式存储下来，然后使用set<string>来存储，返回size就是形状不同的岛屿（忽略翻折和旋转）\n\n4. 递归转为非递归的方式，使用堆或者栈（lc100.相同的数（dfs/宽度优先遍历））\n\n5. 注意如果dfs中数据包含重复，一定要记得去重（如排列，组合）\n\n","slug":"leetcode/回溯_DFS_BFS","published":1,"updated":"2023-07-10T10:36:19.572Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clk5ceino000ojpjb7nl31coc","content":"<h4 id=\"例题\"><a href=\"#例题\" class=\"headerlink\" title=\"例题\"></a>例题</h4><ol>\n<li><p>字符串的转换路径问题:<br> 单词接龙I:只返回最短转换序列的长度（使用BFS）<br> 单词接龙II：返回所有最短转换序列具体是什么<br> 标准答案是既用到了深度优先搜索，也用到了宽度优先搜索<br> （最短距离）<br> 首先判断endWord是否在字典中，不在的话直接返回空<br> 在进行单词找相邻，可以遍历单词每个字符，判断与当前是否只有一个不相等（O(mn)）；或者将当前单词的每一位替换成 26 个小写英文字母，查找是否在字典中（推荐）(O(26n));一定要注意改变了某一个位之后要记得还原该位！！！！！！<br> 方法1：</p>\n<ul>\n<li>使用BFS建立每个单词的前向节点，需要使用steps[nextWord] 记录每个单词到start的最短。<br>如果steps[nextWord]==step,那么from[nextWord].insert(currentWord), 然后判断nextWord是否被vis, 或者是否还在dict中，如果在，加入队列中，进行下列操作；如果不在(已经加入过队列中或者被访问过)，直接continue<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-comment\">// 如果从一个单词扩展出来的单词以前遍历过，距离一定更远，为了避免搜索到已经遍历到，且距离更远的单词，需要将它从 dict 中删除</span><br>dict.<span class=\"hljs-built_in\">erase</span>(nextWord); <span class=\"hljs-comment\">//删除或者设置vis</span><br><span class=\"hljs-comment\">// 这一层扩展出的单词进入队列</span><br>q.<span class=\"hljs-built_in\">push</span>(nextWord);<br><span class=\"hljs-comment\">// 记录 nextWord 从 currWord 而来</span><br>from[nextWord].<span class=\"hljs-built_in\">insert</span>(currWord);<br><span class=\"hljs-comment\">// 记录 nextWord 的 step</span><br>steps[nextWord] = step;<br></code></pre></td></tr></table></figure></li>\n<li>DFS （从endWord到startWord）反向求具体路径，同时在进入下层循环是需要判断，当前的距离是不是当前节点到start的最短距离，如果是进入循环，否则剪枝</li>\n</ul>\n<p> 方法2：</p>\n<ul>\n<li>使用BFS求最短路，同时建立每个单词的pre单词，因为同一层两个单词可能到一个单词的距离相等，因此需要每层元素遍历完了之后再vis, 以及再队列push next_element<br>next_ele.erase(unique(next_ele.begin(), next_ele.end()), next_ele.end()); //也可以直接用set来去重</li>\n<li>反向DFS求具体路径</li>\n</ul>\n</li>\n<li><p>单词转换<br><a href=\"https://leetcode-cn.com/problems/word-transformer-lcci/solution/c-python3-dfsbu-neng-hui-su-yin-wei-bu-s-u45m/\">leetcode链接</a><br>求其中一条路径使用DFS （因为没说要最短）<br>求所有的路径使用BFS+DFS 在一轮访问完之后再赋值vis以及去重/或者记录每个节点d, 然后dfs的时候判断到这个节点的d时候是当前的深度对应<br>求最短的路径，用BFS</p>\n</li>\n</ol>\n<p>PS: 其他解决字符串的相关问题的方案<br>使用动态规划+Trie树，或者暴力string find，或者转为数组（数字）等等，</p>\n<p>PS类似的题目： 单词接龙和最小基因变化， 最小基因变化的这道题在进行单词转换的时候，找相邻的两种方式：(1)对每个字符，4种情况 ACGT都进行测试（也就是每个字符需要验证4n次）， (2)在单词库中查找只有一个字符变化的</p>\n<p><font color=\"red\">3. 组合总数 ：一定要注意如果给出的列表中包含重复的数据的话，一定要记得去重，以及通过一些条件可以提前剪枝</font></p>\n<p>组合总数I， II, III, VI 在进行回溯的时候需要注意的几个点：</p>\n<ul>\n<li>每类的数据是否可以重复选择，如果可以重复选择，那么需要在递归到某一个类的时候，将这个类的所有的数据（一个或者target/candidate[i]个）都选择完</li>\n<li>是只求总数还是求所有的序列，如果只求总数可以使用动态规划（一定要注意if和else的状态转移情况都要考虑到），如果求序列需要使用递归回溯剪枝</li>\n<li>相同结果不用元素组合算一种还是多种（2，2，3）和（2，2，3） 原数据为（2，2，2，2，3）</li>\n<li>给的列表是否包含重复的数据，如果包含需要对数据进行排序后，再进行回溯</li>\n<li>给的列表是否可以重复取，如果可以那么 改为 dfs(candidates,target-k*candidates[i],i+1,count);其中count[i]=k<br>为了防止递归层数太深；同时一定要递归到最后pos==size&amp;&amp;target==0才代表找到了这样一个序列（以为count需要修改）</li>\n<li>如果每个数都只能取一次，而且取的个数一定要是相等的话，可以使用二进制位进行枚举具体的序列</li>\n</ul>\n<ol start=\"4\">\n<li>将数组拆分为斐波拉切数列  枚举最开始的a b，求出c判断后面的字符是不是c</li>\n</ol>\n<ul>\n<li><p>可以使用stoi将字符串转为整数（一定要注意stoi字符溢出的问题， 以及stol溢出可能性）</p>\n<p>long long tmp=stoi(a)+stoi(b) 如果整数相加超过了INT_MAX还是会报错，所以左边的写法是错误的，应该写为 long long tmp=stol(a)+stol(b)</p>\n</li>\n<li><p>也可以使用 回溯一个字符一个字符的累加，如果size&gt;2的情况下计算当前数+pre是否能够达到target,如果小于那么继续循环，如果大于那么退出循环 cur = cur*10 + S[i] - ‘0’;</p>\n</li>\n</ul>\n<ol start=\"5\">\n<li><p>求图长度，或者多叉树的树高</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-comment\">//注意开始遍历每个节点的时候，一定要记得将根节点设置为vis</span><br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">dfs</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> cur, vector&lt;vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&gt;&amp; graph, vector&lt;<span class=\"hljs-keyword\">int</span>&gt; &amp;vis)</span></span>&#123;<br>          <span class=\"hljs-keyword\">int</span> ans=<span class=\"hljs-number\">0</span>;<br>          <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;graph[cur].<span class=\"hljs-built_in\">size</span>();i++)&#123;<br>              <span class=\"hljs-keyword\">if</span>(!vis[graph[cur][i]])&#123;<br>                  vis[graph[cur][i]]=<span class=\"hljs-number\">1</span>;<br>                  ans= <span class=\"hljs-built_in\">max</span>(ans, <span class=\"hljs-built_in\">dfs</span>(graph[cur][i], graph, vis));<br>              &#125;<br>          &#125;<br>          <span class=\"hljs-keyword\">return</span> ans+<span class=\"hljs-number\">1</span>;<br>      &#125;<br><br></code></pre></td></tr></table></figure></li>\n<li><p>最小高度树（有两个类似的题目）<br>让根节点是排序数组的中点<br>使用的是拓扑排序，如果求以每个节点为根节点的树，会导致超出时间限制，因此需要使用拓扑排序，每次删除叶节点（degrees[i] ），求到最中间的几个点</p>\n</li>\n</ol>\n<ol start=\"7\">\n<li>水壶问题，使用深度优先搜索，或者数学推导<br>深度优先搜索，因为超过了系统的搜索的层数，所以需要自己模拟压栈和出栈， 同时需要知道当前状态可以转化为其他状态，其他状态包括，将X倒满，将Y倒满，将X倒空，将Y倒空，将x的水导入Y中，将Y的水倒数X中 6种撞他<br>或者使用数学方式解决，每次水的变化量（X+Y）一定是X或者Y, 那么有不等式 ax+by=z; 那么z一定x和y最小公因数的倍数</li>\n</ol>\n<p><font color=\"red\">8. 字典序 或者 全排列使用深度优先搜索</font><br>字典序返回[1-n]所有整数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">dfs</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> n, <span class=\"hljs-keyword\">int</span> cur, vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&amp; res)</span></span>&#123;<br>      <span class=\"hljs-keyword\">if</span>(cur&gt;n)&#123;<br>          <span class=\"hljs-keyword\">return</span>;<br>      &#125;<br>      res.<span class=\"hljs-built_in\">push_back</span>(cur);<span class=\"hljs-comment\">//在dfs的同时push</span><br>      <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;=<span class=\"hljs-number\">9</span>;i++)&#123;<br>          <span class=\"hljs-built_in\">dfs</span>(n, cur*<span class=\"hljs-number\">10</span>+i, res);<br>      &#125;<br>  &#125;<br>  <span class=\"hljs-function\">vector&lt;<span class=\"hljs-keyword\">int</span>&gt; <span class=\"hljs-title\">lexicalOrder</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> n)</span> </span>&#123;<br>      vector&lt;<span class=\"hljs-keyword\">int</span>&gt; res;<br>      <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;=<span class=\"hljs-number\">9</span>;i++)&#123;<br>          <span class=\"hljs-built_in\">dfs</span>(n, i, res);<br>      &#125;<br>      <span class=\"hljs-keyword\">return</span> res;<br>  &#125;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><figcaption><span>无重复数字的全排列</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">方法<span class=\"hljs-number\">1</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">all_permute</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&amp; nums,vector&lt;vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&gt; &amp;result,<span class=\"hljs-keyword\">int</span> cur )</span> </span>&#123;<br>    <span class=\"hljs-keyword\">int</span> size=nums.<span class=\"hljs-built_in\">size</span>();<br>    <span class=\"hljs-keyword\">if</span>(cur==size<span class=\"hljs-number\">-1</span>)&#123;<br>        result.<span class=\"hljs-built_in\">push_back</span>(nums);<br>        <span class=\"hljs-keyword\">return</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=cur;i&lt;size;i++)&#123;<br>        <span class=\"hljs-built_in\">swap</span>(nums[cur], nums[i]);<br>        <span class=\"hljs-built_in\">all_permute</span>(nums, result, cur+<span class=\"hljs-number\">1</span>);<br>        <span class=\"hljs-built_in\">swap</span>(nums[cur], nums[i]);<br>    &#125;<br>&#125;<br><span class=\"hljs-comment\">//方法2：</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">dfs</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> index, string &amp;S, string &amp;path, vector&lt;<span class=\"hljs-keyword\">int</span>&gt; &amp;used)</span></span>&#123;<br>    <span class=\"hljs-keyword\">int</span> size=S.<span class=\"hljs-built_in\">size</span>();<br>        <span class=\"hljs-keyword\">if</span>(index==size)&#123;<br>        res.<span class=\"hljs-built_in\">push_back</span>(path);<br>        <span class=\"hljs-keyword\">return</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;size;i++)&#123;<br>        <span class=\"hljs-keyword\">if</span>(used[i])&#123; <span class=\"hljs-comment\">//最重要的两个if判断</span><br>            <span class=\"hljs-keyword\">continue</span>;<br>        &#125;<br>        path.<span class=\"hljs-built_in\">push_back</span>(S[i]);<br>        used[i]=<span class=\"hljs-literal\">true</span>;<br>        <span class=\"hljs-built_in\">dfs</span>(index+<span class=\"hljs-number\">1</span>, S, path, used);<br>        used[i]=<span class=\"hljs-literal\">false</span>;<br>        path.<span class=\"hljs-built_in\">pop_back</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<p><font color=\"red\"> 有重复数字的全排列</font><br>答案解析：lc:全排列II</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-built_in\">sort</span>(S.<span class=\"hljs-built_in\">begin</span>(), S.<span class=\"hljs-built_in\">end</span>()); <span class=\"hljs-comment\">//在主函数进行排序， 同时使用used数组，判断S中的某个字符是否被用过， 用一个string path，表示现在拼起来的字符</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">dfs</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> index, string &amp;S, string &amp;path, vector&lt;<span class=\"hljs-keyword\">int</span>&gt; &amp;used)</span></span>&#123;<br>    <span class=\"hljs-keyword\">int</span> size=S.<span class=\"hljs-built_in\">size</span>();<br>     <span class=\"hljs-keyword\">if</span>(index==size)&#123;<br>        res.<span class=\"hljs-built_in\">push_back</span>(path);<br>        <span class=\"hljs-keyword\">return</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;size;i++)&#123;<br>        <span class=\"hljs-keyword\">if</span>(used[i])&#123; <span class=\"hljs-comment\">//最重要的两个if判断</span><br>            <span class=\"hljs-keyword\">continue</span>;<br>        &#125;<br>        <span class=\"hljs-keyword\">if</span>(i!=<span class=\"hljs-number\">0</span>&amp;&amp;S[i]==S[i<span class=\"hljs-number\">-1</span>]&amp;&amp;!used[i<span class=\"hljs-number\">-1</span>])&#123; <span class=\"hljs-comment\">//注意这一层的判断</span><br>            <span class=\"hljs-keyword\">continue</span>;<br>        &#125;<br>        path.<span class=\"hljs-built_in\">push_back</span>(S[i]);<br>        used[i]=<span class=\"hljs-literal\">true</span>;<br>        <span class=\"hljs-built_in\">dfs</span>(index+<span class=\"hljs-number\">1</span>, S, path, used);<br>        used[i]=<span class=\"hljs-literal\">false</span>;<br>        path.<span class=\"hljs-built_in\">pop_back</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>扩展：排列中的下一个排列</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">//先找一个一个顺序相邻， 然后交换当前数和为后面第一个大于它的数，然后让后面的数递增；注意特殊情况，如果当前数已经是全排雷的最后一个，那么直接返回第一个排列</span><br>    <span class=\"hljs-keyword\">int</span> i=nums.<span class=\"hljs-built_in\">size</span>()<span class=\"hljs-number\">-2</span>;<br>    <span class=\"hljs-keyword\">while</span>(i&gt;=<span class=\"hljs-number\">0</span>&amp;&amp;nums[i]&gt;=nums[i+<span class=\"hljs-number\">1</span>])&#123;<br>        i--;<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span>(i&gt;=<span class=\"hljs-number\">0</span>)&#123;<br>        <span class=\"hljs-keyword\">int</span> j=nums.<span class=\"hljs-built_in\">size</span>()<span class=\"hljs-number\">-1</span>;<br>        <span class=\"hljs-keyword\">while</span>(nums[i]&gt;=nums[j])&#123;<br>            j--;<br>        &#125;<br>        <span class=\"hljs-built_in\">swap</span>(nums[i],nums[j]);<br>        <span class=\"hljs-built_in\">reverse</span>(nums.<span class=\"hljs-built_in\">begin</span>()+i+<span class=\"hljs-number\">1</span>,nums.<span class=\"hljs-built_in\">end</span>());<br>    &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>        <span class=\"hljs-built_in\">reverse</span>(nums.<span class=\"hljs-built_in\">begin</span>()+i+<span class=\"hljs-number\">1</span>,nums.<span class=\"hljs-built_in\">end</span>());<br>    &#125;<br></code></pre></td></tr></table></figure>\n<p>lc60. 排列序列 （hard）<br>求全排列的第k个排列<br>易错点：需要最开始使用k–;因为第k个排列前面有k-1个排列<br>然后计算当前每一位应该放哪个第一位 前面的数为num = k/(n-1)! ，固定了第一个位, 之后更新k=k%(n-1)!<br>第二个位，前面的数 num = k/(n-2)! ，固定了第一个位, 之后更新k=k%(n-2)!，同时使用了一个数，需要标记为访问<br>重复这样的过程</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">string res;<br>k--; <span class=\"hljs-comment\">//非常重要</span><br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">1</span>;j&lt;=n;j++)&#123;<br>    <span class=\"hljs-keyword\">int</span> num=k/frac[n-j]; <span class=\"hljs-comment\">//前面的数</span><br>    num++; <span class=\"hljs-comment\">//当前应该选择的数</span><br>    <span class=\"hljs-comment\">// cout&lt;&lt;num&lt;&lt;endl;</span><br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;=n;i++)&#123;<br>        <span class=\"hljs-keyword\">if</span>(!vis[i])&#123;<br>            num--;<br>            <span class=\"hljs-keyword\">if</span>(num==<span class=\"hljs-number\">0</span>)&#123;<br>                vis[i]=<span class=\"hljs-number\">1</span>;<br>                res+=i+<span class=\"hljs-string\">&#x27;0&#x27;</span>;<br>            &#125;<br>        &#125;<br>        <br>    &#125;<br>    k=k%frac[n-j];<br>&#125;<br><span class=\"hljs-keyword\">return</span> res;<br></code></pre></td></tr></table></figure>\n\n<p>lc90, 子集II</p>\n<ul>\n<li>题意：求有重复数据数列的所有子集</li>\n<li>使用dfs+去重+路径中一直push到res中<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-built_in\">dfs</span>():<br>    res.<span class=\"hljs-built_in\">push_back</span>(path);<br>    <span class=\"hljs-keyword\">if</span>(index&gt;=size)&#123;<br>        <span class=\"hljs-keyword\">return</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=index;i&lt;size;i++)&#123;<br>        <span class=\"hljs-keyword\">if</span>(i!=index&amp;&amp;nums[i]==nums[i<span class=\"hljs-number\">-1</span>])&#123; <span class=\"hljs-comment\">//去重方式和四数之和一样</span><br>            <span class=\"hljs-keyword\">continue</span>;<br>        &#125;<br>        path.<span class=\"hljs-built_in\">push_back</span>(nums[i]);<br>        <span class=\"hljs-built_in\">dfs</span>(i+<span class=\"hljs-number\">1</span>, nums, path);<br>        path.<span class=\"hljs-built_in\">pop_back</span>();<br>    &#125;<br></code></pre></td></tr></table></figure></li>\n</ul>\n<ol start=\"9\">\n<li><p>01矩阵 <font color=\"blue\">多源BFS</font><br>找到1距离0的距离是从0开始进行bfs，而不是从1开始<br>解法：</p>\n<ul>\n<li>广度优先搜索+记忆数组（将为0的点放入队列中，然后一层层向外扩散，记得访问过的点记得标记为visit, 或者用matrix !=-1来判定该点时候被访问过）</li>\n<li>左上到右下；再从右下到左上</li>\n</ul>\n</li>\n<li><p>大礼包。注意这道题可以学习的是状态的记忆过程，使用map&lt;vector<int>, int&gt;, 当然这道题直接用dfs搜索每一个状态也是可以的<br>注意这道题在dfs的时候，除了要循环选择每个大礼包，退出循环后，还要判断当前计算值和==全部不用大礼包==谁更小！！！<br>无法使用完全背包+dp解决，因为dp的内层循环无法枚举，因为是一个vector, 而不是一个简单的int</int></p>\n</li>\n</ol>\n<p><font color=\"red\">11. 划分为k个相同的子集：</font><br>这道题既可以使用状态压缩的dp也可以使用回溯+贪心<br>方法一：</p>\n<ul>\n<li>需要对数组排序，从大的数最开始进行匹配，贪心策略（这样压栈次数会更少）</li>\n<li>使用回溯的时候需要使用一个vis数组，如果当前值小于target 那么继续向前遍历；如果==target那么从头开始遍历，同时k-1;如果大于target,那么循环内部判断数组下一个数是否合适  (循环数组的时候多次dfs 判断是否都能凑出&lt;=target)<br><a href=\"https://zhuanlan.zhihu.com/p/78031844\">https://zhuanlan.zhihu.com/p/78031844</a></li>\n</ul>\n<p>方法二：</p>\n<ul>\n<li>建立n个桶，然后判断每个数应该放在哪个桶内(只用记录桶中总数，不用记录具体放到什么)；如果当前这个数放在哪个桶都不行，那么当前循环return false；仍然使用贪心减少遍历次数</li>\n<li><a href=\"https://leetcode-cn.com/problems/partition-to-k-equal-sum-subsets/solution/liang-chong-bu-tong-de-hui-su-si-lu-cong-5rnw/\">https://leetcode-cn.com/problems/partition-to-k-equal-sum-subsets/solution/liang-chong-bu-tong-de-hui-su-si-lu-cong-5rnw/</a></li>\n</ul>\n<p><font color=\"blue\">12. 地图分析，多源BFS的例题</font><br>和正向题目描述的思路反过来，从为1的陆地出发，而不是从每个海洋出发求最短距离。先将所有为1的节点的位置放在队列中，每访问一个节点，就修改节点位置的值，那么就不需要使用vis数组</p>\n<p>13.组合总数||<br>因为这个是要求具体的组合，用dfs,同时注意去重</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=index;i&lt;size;i++)&#123;<br>    <span class=\"hljs-keyword\">if</span>(i&gt;index&amp;&amp;candidates[i]==candidates[i<span class=\"hljs-number\">-1</span>])&#123;<span class=\"hljs-comment\">//去重</span><br>        <span class=\"hljs-keyword\">continue</span>;<br>    &#125;<br>    path.<span class=\"hljs-built_in\">push_back</span>(candidates[i]);<br>    <span class=\"hljs-built_in\">dfs</span>(candidates, target-candidates[i], i+<span class=\"hljs-number\">1</span>, path);<br>    path.<span class=\"hljs-built_in\">pop_back</span>();<br>    <span class=\"hljs-comment\">// dfs(candidates, target, i+1, path); //注意这个一定不能要</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n<ol start=\"14\">\n<li>面试题 16.22. 兰顿蚂蚁<br>类似于走地图的题目，是一个模拟题<br>因为x, y的坐标可能为负数，因此使用map&lt; pair&lt;int, int&gt;, char&gt; matrix; (使用unordered_map会报错)<br>同时在进行打印的时候，应该y在外层，x在内层；如果map中没有找到这个坐标，那么应该打印出“_”, 记录当前地图的左上和右下坐标</li>\n</ol>\n<ol start=\"15\">\n<li>双向BFS</li>\n</ol>\n<ul>\n<li>使用两个队列， 每次更新一个size比较小的队列里面的所有元素，同时使用两个unordered_map记录走到某个字符串/位置，走的步数（同时有vis数组的功能）。 如果当前更新的字符串，在另外一个队列的map中也能找到记录说明两个队列相遇了， 返回step + 1 + other[copy];</li>\n</ul>\n<p><font color=\"red\">16. 逃脱迷宫需要移除的最少砖头数量</font></p>\n<ul>\n<li> 使用BFS+优先队列+vis， 队列里面存放到x, y, 和到每个节点的最少要移除的砖头数量， 循环在nextx nexty=n-1的时候返回结果， 具体代码实现看模板代码/逃脱迷宫</li>\n<li> 不能使用dfs+记忆化数组+vis，因为到达当前节点的时候，前面vis 路径不一定是最优的，导致计算出来d不一定是最佳的，从而之后的计算都出现错误； 记忆化数组可以使用场景就是，之前的选择不会对之后的选择造成影响， 或者需要另外用一个状态位运算来记录之前走的路径到底是怎样的（见lc980, 下面有分析）</li>\n<li>这道题的思路和lc752: 打开转盘锁一样，不能走回头路，lc752可以使用双端BFS，感觉这个不适合双堆队列，因为map里面的数据并不都是同一层，同时两个队列size感觉都是一样的，从两个对角线出发；这道题使用优先队列更佳</li>\n<li> 不一样的是这个每走一步不一定+1， 队列数据不一定在同一层（因此需要使用优先队列）， 但是逃脱迷宫是每走一步都+1， 队列里面的数据都在同一层，使用普通队列</li>\n<li>总结，使用bfs查找从源到目的节点的最短路径<ol>\n<li>将源节点压入队列中，同时设置为vis</li>\n<li>如果一层的cost一样，那么每层进行遍历（否则需要压入的时候，记录压入节点的cost）,计算当前节点的下一个节点，判断下一个节点的合理性（vis和index边缘）</li>\n<li>如果合理，那么判断下一个节点是否是目标节点，如果是直接返回step+1,否则向队列中压入下一个节点</li>\n<li>重复上述过程，知道队列为空</li>\n<li>如果队列空都没有找到，说明源节点无法到达目标节点</li>\n</ol>\n</li>\n</ul>\n<p>15， 克隆图</p>\n<ul>\n<li>使用BFS</li>\n<li>这个题类似于 剑指 Offer 35. 复杂链表的复制，需要建立原始node和新node之间的映射, 同时这个hash也能充当vis数组，判断当前节点是否被访问过；复杂链表复制那道题只需要顺序两次遍历链表就可以了，不需要vis或者bfs</li>\n</ul>\n<p><font color=\"red\">16. 给表达式添加运算符（hard）</font><br>使用回溯<br>易错点：<br>    1. 乘法是有优先级的，因此之前计算dfs计算的结果有可能是需要回退一个数组，然后再进行计算<br>    2. 每次压入的数字可能是包含多个位的<br>    3. 不能包含前导0，但是这个数又不是0的情况<br>    <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">if</span>(i!=index&amp;&amp;num[index]==<span class=\"hljs-string\">&#x27;0&#x27;</span>)&#123;<br>    <span class=\"hljs-keyword\">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>    4. 回溯是时候一定要记得将符号pop_back!!!!</p>\n<ol start=\"17\">\n<li>lc980. 不同路径 III</li>\n</ol>\n<ul>\n<li>求从起点到终点，经过二维矩阵的每个空方格（注意是每个都要走一次，而且不能重复），的不同路径总数</li>\n<li>使用记忆化的dfs 因为到达每个点前面的路径是不一定相同的，因此需要使用dp[i][j][i*C+j^之前的路径] 表示到达当前的状态之前走过的路径是怎样的<br>注意题目表示1 &lt;= grid.length * grid[0].length &lt;= 20，才能使用这种位运算来记录矩阵的状态（状态压缩的条件）</li>\n</ul>\n<ol start=\"18\">\n<li>单词拆分II</li>\n</ol>\n<ul>\n<li>需要找到所有拆分的具体方案</li>\n<li>为了减少回溯的重复，使用一个hash&lt;int, vector<string>&gt; 将以i下标为开始后面形成的所有可能都存储下来，这样之后寻找的时候就不用重复判断 （类似二叉搜索树的所有可能那种题目）， 记忆化dfs</string></li>\n</ul>\n<ol start=\"19\">\n<li>lc741. 摘樱桃(hard)</li>\n</ol>\n<ul>\n<li>这道题用dp理解起来比较困难，所以使用记忆化dfs</li>\n<li>易错点：贪心，第一次选最大+第二次选剩下的最大不一定是最优解</li>\n<li>正确方法，需要dfs，然后需要有两条路径，就相当于同时对<strong>两个点进行dfs</strong>, 这两个点x1+y1=x2+y2 (有关系)然后需要判断这两个是不是同一个点，如果是，那么+grid[x1][y1]， 否则+grid[x1][y1]+grid[x2][y2]</li>\n</ul>\n<ol start=\"20\">\n<li>lc934. Shortest Bridge 最短的桥梁</li>\n</ol>\n<ul>\n<li>使用多源最短路径，两个技巧：先dfs找到岛屿上的所有点，并将将访问过的岛屿转为2；2. BFS使用层次bfs, 因为修改了访问的点为2，所以不用使用vis数组</li>\n</ul>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>ok ok</p>\n<ol>\n<li><p>注意dfs和回溯还是有区别的，dfs，遇到不合适的条件可以直接退出，但是回溯，退出前要将之前的状态修改； BFS常用于求最短路径，或者最少xxxx(结合优先队列)</p>\n</li>\n<li><p>dfs和记忆化搜索和dp都有联系，有时候一道题这两种方法都可以用<br>例如：</p>\n</li>\n</ol>\n<ul>\n<li>分汤(因为都是25的倍数，所以n可以直接/25+1(如果余数不为0), 分配操作同样变为-4、-2、-1<br>dfs如果状态比较多，可以使用记忆化数组，同时如果状态都是某一个数的倍数，那么可以对数据进行归一化后再进行dfs<br>这样的话记忆化搜索的状态数量就会减少<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">double</span> ans = <span class=\"hljs-number\">0.0</span>;<br>               <span class=\"hljs-keyword\">if</span> (i == <span class=\"hljs-number\">0</span>) ans = <span class=\"hljs-number\">1.0</span>;<br>               <span class=\"hljs-keyword\">if</span> (i == <span class=\"hljs-number\">0</span> &amp;&amp; j == <span class=\"hljs-number\">0</span>) ans = <span class=\"hljs-number\">0.5</span>;<br>               <span class=\"hljs-keyword\">if</span> (i &gt; <span class=\"hljs-number\">0</span> &amp;&amp; j &gt; <span class=\"hljs-number\">0</span>) &#123;<br>                   ans = <span class=\"hljs-number\">0.25</span> * (memo[<span class=\"hljs-built_in\">M</span>(i<span class=\"hljs-number\">-4</span>)][j] + memo[<span class=\"hljs-built_in\">M</span>(i<span class=\"hljs-number\">-3</span>)][<span class=\"hljs-built_in\">M</span>(j<span class=\"hljs-number\">-1</span>)] +<br>                                 memo[<span class=\"hljs-built_in\">M</span>(i<span class=\"hljs-number\">-2</span>)][<span class=\"hljs-built_in\">M</span>(j<span class=\"hljs-number\">-2</span>)] + memo[<span class=\"hljs-built_in\">M</span>(i<span class=\"hljs-number\">-1</span>)][<span class=\"hljs-built_in\">M</span>(j<span class=\"hljs-number\">-3</span>)]);<br>               &#125;<br></code></pre></td></tr></table></figure></li>\n<li>类似的概率转移dfs/dp有leet935. 马”在棋盘上的概率（可以最后/pow(8,N), 不用每次/8）</li>\n</ul>\n<ol start=\"3\">\n<li><p>如果要求岛屿的形状相同，那么可以将岛屿的位置使用string的形式存储下来，然后使用set<string>来存储，返回size就是形状不同的岛屿（忽略翻折和旋转）</string></p>\n</li>\n<li><p>递归转为非递归的方式，使用堆或者栈（lc100.相同的数（dfs/宽度优先遍历））</p>\n</li>\n<li><p>注意如果dfs中数据包含重复，一定要记得去重（如排列，组合）</p>\n</li>\n</ol>\n","site":{"data":{}},"wordcount":9084,"excerpt":"","more":"<h4 id=\"例题\"><a href=\"#例题\" class=\"headerlink\" title=\"例题\"></a>例题</h4><ol>\n<li><p>字符串的转换路径问题:<br> 单词接龙I:只返回最短转换序列的长度（使用BFS）<br> 单词接龙II：返回所有最短转换序列具体是什么<br> 标准答案是既用到了深度优先搜索，也用到了宽度优先搜索<br> （最短距离）<br> 首先判断endWord是否在字典中，不在的话直接返回空<br> 在进行单词找相邻，可以遍历单词每个字符，判断与当前是否只有一个不相等（O(mn)）；或者将当前单词的每一位替换成 26 个小写英文字母，查找是否在字典中（推荐）(O(26n));一定要注意改变了某一个位之后要记得还原该位！！！！！！<br> 方法1：</p>\n<ul>\n<li>使用BFS建立每个单词的前向节点，需要使用steps[nextWord] 记录每个单词到start的最短。<br>如果steps[nextWord]==step,那么from[nextWord].insert(currentWord), 然后判断nextWord是否被vis, 或者是否还在dict中，如果在，加入队列中，进行下列操作；如果不在(已经加入过队列中或者被访问过)，直接continue<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-comment\">// 如果从一个单词扩展出来的单词以前遍历过，距离一定更远，为了避免搜索到已经遍历到，且距离更远的单词，需要将它从 dict 中删除</span><br>dict.<span class=\"hljs-built_in\">erase</span>(nextWord); <span class=\"hljs-comment\">//删除或者设置vis</span><br><span class=\"hljs-comment\">// 这一层扩展出的单词进入队列</span><br>q.<span class=\"hljs-built_in\">push</span>(nextWord);<br><span class=\"hljs-comment\">// 记录 nextWord 从 currWord 而来</span><br>from[nextWord].<span class=\"hljs-built_in\">insert</span>(currWord);<br><span class=\"hljs-comment\">// 记录 nextWord 的 step</span><br>steps[nextWord] = step;<br></code></pre></td></tr></table></figure></li>\n<li>DFS （从endWord到startWord）反向求具体路径，同时在进入下层循环是需要判断，当前的距离是不是当前节点到start的最短距离，如果是进入循环，否则剪枝</li>\n</ul>\n<p> 方法2：</p>\n<ul>\n<li>使用BFS求最短路，同时建立每个单词的pre单词，因为同一层两个单词可能到一个单词的距离相等，因此需要每层元素遍历完了之后再vis, 以及再队列push next_element<br>next_ele.erase(unique(next_ele.begin(), next_ele.end()), next_ele.end()); //也可以直接用set来去重</li>\n<li>反向DFS求具体路径</li>\n</ul>\n</li>\n<li><p>单词转换<br><a href=\"https://leetcode-cn.com/problems/word-transformer-lcci/solution/c-python3-dfsbu-neng-hui-su-yin-wei-bu-s-u45m/\">leetcode链接</a><br>求其中一条路径使用DFS （因为没说要最短）<br>求所有的路径使用BFS+DFS 在一轮访问完之后再赋值vis以及去重/或者记录每个节点d, 然后dfs的时候判断到这个节点的d时候是当前的深度对应<br>求最短的路径，用BFS</p>\n</li>\n</ol>\n<p>PS: 其他解决字符串的相关问题的方案<br>使用动态规划+Trie树，或者暴力string find，或者转为数组（数字）等等，</p>\n<p>PS类似的题目： 单词接龙和最小基因变化， 最小基因变化的这道题在进行单词转换的时候，找相邻的两种方式：(1)对每个字符，4种情况 ACGT都进行测试（也就是每个字符需要验证4n次）， (2)在单词库中查找只有一个字符变化的</p>\n<p><font color=\"red\">3. 组合总数 ：一定要注意如果给出的列表中包含重复的数据的话，一定要记得去重，以及通过一些条件可以提前剪枝</font></p>\n<p>组合总数I， II, III, VI 在进行回溯的时候需要注意的几个点：</p>\n<ul>\n<li>每类的数据是否可以重复选择，如果可以重复选择，那么需要在递归到某一个类的时候，将这个类的所有的数据（一个或者target/candidate[i]个）都选择完</li>\n<li>是只求总数还是求所有的序列，如果只求总数可以使用动态规划（一定要注意if和else的状态转移情况都要考虑到），如果求序列需要使用递归回溯剪枝</li>\n<li>相同结果不用元素组合算一种还是多种（2，2，3）和（2，2，3） 原数据为（2，2，2，2，3）</li>\n<li>给的列表是否包含重复的数据，如果包含需要对数据进行排序后，再进行回溯</li>\n<li>给的列表是否可以重复取，如果可以那么 改为 dfs(candidates,target-k*candidates[i],i+1,count);其中count[i]=k<br>为了防止递归层数太深；同时一定要递归到最后pos==size&amp;&amp;target==0才代表找到了这样一个序列（以为count需要修改）</li>\n<li>如果每个数都只能取一次，而且取的个数一定要是相等的话，可以使用二进制位进行枚举具体的序列</li>\n</ul>\n<ol start=\"4\">\n<li>将数组拆分为斐波拉切数列  枚举最开始的a b，求出c判断后面的字符是不是c</li>\n</ol>\n<ul>\n<li><p>可以使用stoi将字符串转为整数（一定要注意stoi字符溢出的问题， 以及stol溢出可能性）</p>\n<p>long long tmp=stoi(a)+stoi(b) 如果整数相加超过了INT_MAX还是会报错，所以左边的写法是错误的，应该写为 long long tmp=stol(a)+stol(b)</p>\n</li>\n<li><p>也可以使用 回溯一个字符一个字符的累加，如果size&gt;2的情况下计算当前数+pre是否能够达到target,如果小于那么继续循环，如果大于那么退出循环 cur = cur*10 + S[i] - ‘0’;</p>\n</li>\n</ul>\n<ol start=\"5\">\n<li><p>求图长度，或者多叉树的树高</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-comment\">//注意开始遍历每个节点的时候，一定要记得将根节点设置为vis</span><br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">dfs</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> cur, vector&lt;vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&gt;&amp; graph, vector&lt;<span class=\"hljs-keyword\">int</span>&gt; &amp;vis)</span></span>&#123;<br>          <span class=\"hljs-keyword\">int</span> ans=<span class=\"hljs-number\">0</span>;<br>          <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;graph[cur].<span class=\"hljs-built_in\">size</span>();i++)&#123;<br>              <span class=\"hljs-keyword\">if</span>(!vis[graph[cur][i]])&#123;<br>                  vis[graph[cur][i]]=<span class=\"hljs-number\">1</span>;<br>                  ans= <span class=\"hljs-built_in\">max</span>(ans, <span class=\"hljs-built_in\">dfs</span>(graph[cur][i], graph, vis));<br>              &#125;<br>          &#125;<br>          <span class=\"hljs-keyword\">return</span> ans+<span class=\"hljs-number\">1</span>;<br>      &#125;<br><br></code></pre></td></tr></table></figure></li>\n<li><p>最小高度树（有两个类似的题目）<br>让根节点是排序数组的中点<br>使用的是拓扑排序，如果求以每个节点为根节点的树，会导致超出时间限制，因此需要使用拓扑排序，每次删除叶节点（degrees[i] ），求到最中间的几个点</p>\n</li>\n</ol>\n<ol start=\"7\">\n<li>水壶问题，使用深度优先搜索，或者数学推导<br>深度优先搜索，因为超过了系统的搜索的层数，所以需要自己模拟压栈和出栈， 同时需要知道当前状态可以转化为其他状态，其他状态包括，将X倒满，将Y倒满，将X倒空，将Y倒空，将x的水导入Y中，将Y的水倒数X中 6种撞他<br>或者使用数学方式解决，每次水的变化量（X+Y）一定是X或者Y, 那么有不等式 ax+by=z; 那么z一定x和y最小公因数的倍数</li>\n</ol>\n<p><font color=\"red\">8. 字典序 或者 全排列使用深度优先搜索</font><br>字典序返回[1-n]所有整数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">dfs</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> n, <span class=\"hljs-keyword\">int</span> cur, vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&amp; res)</span></span>&#123;<br>      <span class=\"hljs-keyword\">if</span>(cur&gt;n)&#123;<br>          <span class=\"hljs-keyword\">return</span>;<br>      &#125;<br>      res.<span class=\"hljs-built_in\">push_back</span>(cur);<span class=\"hljs-comment\">//在dfs的同时push</span><br>      <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;=<span class=\"hljs-number\">9</span>;i++)&#123;<br>          <span class=\"hljs-built_in\">dfs</span>(n, cur*<span class=\"hljs-number\">10</span>+i, res);<br>      &#125;<br>  &#125;<br>  <span class=\"hljs-function\">vector&lt;<span class=\"hljs-keyword\">int</span>&gt; <span class=\"hljs-title\">lexicalOrder</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> n)</span> </span>&#123;<br>      vector&lt;<span class=\"hljs-keyword\">int</span>&gt; res;<br>      <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;=<span class=\"hljs-number\">9</span>;i++)&#123;<br>          <span class=\"hljs-built_in\">dfs</span>(n, i, res);<br>      &#125;<br>      <span class=\"hljs-keyword\">return</span> res;<br>  &#125;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><figcaption><span>无重复数字的全排列</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">方法<span class=\"hljs-number\">1</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">all_permute</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&amp; nums,vector&lt;vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&gt; &amp;result,<span class=\"hljs-keyword\">int</span> cur )</span> </span>&#123;<br>    <span class=\"hljs-keyword\">int</span> size=nums.<span class=\"hljs-built_in\">size</span>();<br>    <span class=\"hljs-keyword\">if</span>(cur==size<span class=\"hljs-number\">-1</span>)&#123;<br>        result.<span class=\"hljs-built_in\">push_back</span>(nums);<br>        <span class=\"hljs-keyword\">return</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=cur;i&lt;size;i++)&#123;<br>        <span class=\"hljs-built_in\">swap</span>(nums[cur], nums[i]);<br>        <span class=\"hljs-built_in\">all_permute</span>(nums, result, cur+<span class=\"hljs-number\">1</span>);<br>        <span class=\"hljs-built_in\">swap</span>(nums[cur], nums[i]);<br>    &#125;<br>&#125;<br><span class=\"hljs-comment\">//方法2：</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">dfs</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> index, string &amp;S, string &amp;path, vector&lt;<span class=\"hljs-keyword\">int</span>&gt; &amp;used)</span></span>&#123;<br>    <span class=\"hljs-keyword\">int</span> size=S.<span class=\"hljs-built_in\">size</span>();<br>        <span class=\"hljs-keyword\">if</span>(index==size)&#123;<br>        res.<span class=\"hljs-built_in\">push_back</span>(path);<br>        <span class=\"hljs-keyword\">return</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;size;i++)&#123;<br>        <span class=\"hljs-keyword\">if</span>(used[i])&#123; <span class=\"hljs-comment\">//最重要的两个if判断</span><br>            <span class=\"hljs-keyword\">continue</span>;<br>        &#125;<br>        path.<span class=\"hljs-built_in\">push_back</span>(S[i]);<br>        used[i]=<span class=\"hljs-literal\">true</span>;<br>        <span class=\"hljs-built_in\">dfs</span>(index+<span class=\"hljs-number\">1</span>, S, path, used);<br>        used[i]=<span class=\"hljs-literal\">false</span>;<br>        path.<span class=\"hljs-built_in\">pop_back</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<p><font color=\"red\"> 有重复数字的全排列</font><br>答案解析：lc:全排列II</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-built_in\">sort</span>(S.<span class=\"hljs-built_in\">begin</span>(), S.<span class=\"hljs-built_in\">end</span>()); <span class=\"hljs-comment\">//在主函数进行排序， 同时使用used数组，判断S中的某个字符是否被用过， 用一个string path，表示现在拼起来的字符</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">dfs</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> index, string &amp;S, string &amp;path, vector&lt;<span class=\"hljs-keyword\">int</span>&gt; &amp;used)</span></span>&#123;<br>    <span class=\"hljs-keyword\">int</span> size=S.<span class=\"hljs-built_in\">size</span>();<br>     <span class=\"hljs-keyword\">if</span>(index==size)&#123;<br>        res.<span class=\"hljs-built_in\">push_back</span>(path);<br>        <span class=\"hljs-keyword\">return</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;size;i++)&#123;<br>        <span class=\"hljs-keyword\">if</span>(used[i])&#123; <span class=\"hljs-comment\">//最重要的两个if判断</span><br>            <span class=\"hljs-keyword\">continue</span>;<br>        &#125;<br>        <span class=\"hljs-keyword\">if</span>(i!=<span class=\"hljs-number\">0</span>&amp;&amp;S[i]==S[i<span class=\"hljs-number\">-1</span>]&amp;&amp;!used[i<span class=\"hljs-number\">-1</span>])&#123; <span class=\"hljs-comment\">//注意这一层的判断</span><br>            <span class=\"hljs-keyword\">continue</span>;<br>        &#125;<br>        path.<span class=\"hljs-built_in\">push_back</span>(S[i]);<br>        used[i]=<span class=\"hljs-literal\">true</span>;<br>        <span class=\"hljs-built_in\">dfs</span>(index+<span class=\"hljs-number\">1</span>, S, path, used);<br>        used[i]=<span class=\"hljs-literal\">false</span>;<br>        path.<span class=\"hljs-built_in\">pop_back</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>扩展：排列中的下一个排列</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">//先找一个一个顺序相邻， 然后交换当前数和为后面第一个大于它的数，然后让后面的数递增；注意特殊情况，如果当前数已经是全排雷的最后一个，那么直接返回第一个排列</span><br>    <span class=\"hljs-keyword\">int</span> i=nums.<span class=\"hljs-built_in\">size</span>()<span class=\"hljs-number\">-2</span>;<br>    <span class=\"hljs-keyword\">while</span>(i&gt;=<span class=\"hljs-number\">0</span>&amp;&amp;nums[i]&gt;=nums[i+<span class=\"hljs-number\">1</span>])&#123;<br>        i--;<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span>(i&gt;=<span class=\"hljs-number\">0</span>)&#123;<br>        <span class=\"hljs-keyword\">int</span> j=nums.<span class=\"hljs-built_in\">size</span>()<span class=\"hljs-number\">-1</span>;<br>        <span class=\"hljs-keyword\">while</span>(nums[i]&gt;=nums[j])&#123;<br>            j--;<br>        &#125;<br>        <span class=\"hljs-built_in\">swap</span>(nums[i],nums[j]);<br>        <span class=\"hljs-built_in\">reverse</span>(nums.<span class=\"hljs-built_in\">begin</span>()+i+<span class=\"hljs-number\">1</span>,nums.<span class=\"hljs-built_in\">end</span>());<br>    &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>        <span class=\"hljs-built_in\">reverse</span>(nums.<span class=\"hljs-built_in\">begin</span>()+i+<span class=\"hljs-number\">1</span>,nums.<span class=\"hljs-built_in\">end</span>());<br>    &#125;<br></code></pre></td></tr></table></figure>\n<p>lc60. 排列序列 （hard）<br>求全排列的第k个排列<br>易错点：需要最开始使用k–;因为第k个排列前面有k-1个排列<br>然后计算当前每一位应该放哪个第一位 前面的数为num = k/(n-1)! ，固定了第一个位, 之后更新k=k%(n-1)!<br>第二个位，前面的数 num = k/(n-2)! ，固定了第一个位, 之后更新k=k%(n-2)!，同时使用了一个数，需要标记为访问<br>重复这样的过程</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">string res;<br>k--; <span class=\"hljs-comment\">//非常重要</span><br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">1</span>;j&lt;=n;j++)&#123;<br>    <span class=\"hljs-keyword\">int</span> num=k/frac[n-j]; <span class=\"hljs-comment\">//前面的数</span><br>    num++; <span class=\"hljs-comment\">//当前应该选择的数</span><br>    <span class=\"hljs-comment\">// cout&lt;&lt;num&lt;&lt;endl;</span><br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;=n;i++)&#123;<br>        <span class=\"hljs-keyword\">if</span>(!vis[i])&#123;<br>            num--;<br>            <span class=\"hljs-keyword\">if</span>(num==<span class=\"hljs-number\">0</span>)&#123;<br>                vis[i]=<span class=\"hljs-number\">1</span>;<br>                res+=i+<span class=\"hljs-string\">&#x27;0&#x27;</span>;<br>            &#125;<br>        &#125;<br>        <br>    &#125;<br>    k=k%frac[n-j];<br>&#125;<br><span class=\"hljs-keyword\">return</span> res;<br></code></pre></td></tr></table></figure>\n\n<p>lc90, 子集II</p>\n<ul>\n<li>题意：求有重复数据数列的所有子集</li>\n<li>使用dfs+去重+路径中一直push到res中<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-built_in\">dfs</span>():<br>    res.<span class=\"hljs-built_in\">push_back</span>(path);<br>    <span class=\"hljs-keyword\">if</span>(index&gt;=size)&#123;<br>        <span class=\"hljs-keyword\">return</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=index;i&lt;size;i++)&#123;<br>        <span class=\"hljs-keyword\">if</span>(i!=index&amp;&amp;nums[i]==nums[i<span class=\"hljs-number\">-1</span>])&#123; <span class=\"hljs-comment\">//去重方式和四数之和一样</span><br>            <span class=\"hljs-keyword\">continue</span>;<br>        &#125;<br>        path.<span class=\"hljs-built_in\">push_back</span>(nums[i]);<br>        <span class=\"hljs-built_in\">dfs</span>(i+<span class=\"hljs-number\">1</span>, nums, path);<br>        path.<span class=\"hljs-built_in\">pop_back</span>();<br>    &#125;<br></code></pre></td></tr></table></figure></li>\n</ul>\n<ol start=\"9\">\n<li><p>01矩阵 <font color=\"blue\">多源BFS</font><br>找到1距离0的距离是从0开始进行bfs，而不是从1开始<br>解法：</p>\n<ul>\n<li>广度优先搜索+记忆数组（将为0的点放入队列中，然后一层层向外扩散，记得访问过的点记得标记为visit, 或者用matrix !=-1来判定该点时候被访问过）</li>\n<li>左上到右下；再从右下到左上</li>\n</ul>\n</li>\n<li><p>大礼包。注意这道题可以学习的是状态的记忆过程，使用map&lt;vector<int>, int&gt;, 当然这道题直接用dfs搜索每一个状态也是可以的<br>注意这道题在dfs的时候，除了要循环选择每个大礼包，退出循环后，还要判断当前计算值和==全部不用大礼包==谁更小！！！<br>无法使用完全背包+dp解决，因为dp的内层循环无法枚举，因为是一个vector, 而不是一个简单的int</int></p>\n</li>\n</ol>\n<p><font color=\"red\">11. 划分为k个相同的子集：</font><br>这道题既可以使用状态压缩的dp也可以使用回溯+贪心<br>方法一：</p>\n<ul>\n<li>需要对数组排序，从大的数最开始进行匹配，贪心策略（这样压栈次数会更少）</li>\n<li>使用回溯的时候需要使用一个vis数组，如果当前值小于target 那么继续向前遍历；如果==target那么从头开始遍历，同时k-1;如果大于target,那么循环内部判断数组下一个数是否合适  (循环数组的时候多次dfs 判断是否都能凑出&lt;=target)<br><a href=\"https://zhuanlan.zhihu.com/p/78031844\">https://zhuanlan.zhihu.com/p/78031844</a></li>\n</ul>\n<p>方法二：</p>\n<ul>\n<li>建立n个桶，然后判断每个数应该放在哪个桶内(只用记录桶中总数，不用记录具体放到什么)；如果当前这个数放在哪个桶都不行，那么当前循环return false；仍然使用贪心减少遍历次数</li>\n<li><a href=\"https://leetcode-cn.com/problems/partition-to-k-equal-sum-subsets/solution/liang-chong-bu-tong-de-hui-su-si-lu-cong-5rnw/\">https://leetcode-cn.com/problems/partition-to-k-equal-sum-subsets/solution/liang-chong-bu-tong-de-hui-su-si-lu-cong-5rnw/</a></li>\n</ul>\n<p><font color=\"blue\">12. 地图分析，多源BFS的例题</font><br>和正向题目描述的思路反过来，从为1的陆地出发，而不是从每个海洋出发求最短距离。先将所有为1的节点的位置放在队列中，每访问一个节点，就修改节点位置的值，那么就不需要使用vis数组</p>\n<p>13.组合总数||<br>因为这个是要求具体的组合，用dfs,同时注意去重</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=index;i&lt;size;i++)&#123;<br>    <span class=\"hljs-keyword\">if</span>(i&gt;index&amp;&amp;candidates[i]==candidates[i<span class=\"hljs-number\">-1</span>])&#123;<span class=\"hljs-comment\">//去重</span><br>        <span class=\"hljs-keyword\">continue</span>;<br>    &#125;<br>    path.<span class=\"hljs-built_in\">push_back</span>(candidates[i]);<br>    <span class=\"hljs-built_in\">dfs</span>(candidates, target-candidates[i], i+<span class=\"hljs-number\">1</span>, path);<br>    path.<span class=\"hljs-built_in\">pop_back</span>();<br>    <span class=\"hljs-comment\">// dfs(candidates, target, i+1, path); //注意这个一定不能要</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n<ol start=\"14\">\n<li>面试题 16.22. 兰顿蚂蚁<br>类似于走地图的题目，是一个模拟题<br>因为x, y的坐标可能为负数，因此使用map&lt; pair&lt;int, int&gt;, char&gt; matrix; (使用unordered_map会报错)<br>同时在进行打印的时候，应该y在外层，x在内层；如果map中没有找到这个坐标，那么应该打印出“_”, 记录当前地图的左上和右下坐标</li>\n</ol>\n<ol start=\"15\">\n<li>双向BFS</li>\n</ol>\n<ul>\n<li>使用两个队列， 每次更新一个size比较小的队列里面的所有元素，同时使用两个unordered_map记录走到某个字符串/位置，走的步数（同时有vis数组的功能）。 如果当前更新的字符串，在另外一个队列的map中也能找到记录说明两个队列相遇了， 返回step + 1 + other[copy];</li>\n</ul>\n<p><font color=\"red\">16. 逃脱迷宫需要移除的最少砖头数量</font></p>\n<ul>\n<li> 使用BFS+优先队列+vis， 队列里面存放到x, y, 和到每个节点的最少要移除的砖头数量， 循环在nextx nexty=n-1的时候返回结果， 具体代码实现看模板代码/逃脱迷宫</li>\n<li> 不能使用dfs+记忆化数组+vis，因为到达当前节点的时候，前面vis 路径不一定是最优的，导致计算出来d不一定是最佳的，从而之后的计算都出现错误； 记忆化数组可以使用场景就是，之前的选择不会对之后的选择造成影响， 或者需要另外用一个状态位运算来记录之前走的路径到底是怎样的（见lc980, 下面有分析）</li>\n<li>这道题的思路和lc752: 打开转盘锁一样，不能走回头路，lc752可以使用双端BFS，感觉这个不适合双堆队列，因为map里面的数据并不都是同一层，同时两个队列size感觉都是一样的，从两个对角线出发；这道题使用优先队列更佳</li>\n<li> 不一样的是这个每走一步不一定+1， 队列数据不一定在同一层（因此需要使用优先队列）， 但是逃脱迷宫是每走一步都+1， 队列里面的数据都在同一层，使用普通队列</li>\n<li>总结，使用bfs查找从源到目的节点的最短路径<ol>\n<li>将源节点压入队列中，同时设置为vis</li>\n<li>如果一层的cost一样，那么每层进行遍历（否则需要压入的时候，记录压入节点的cost）,计算当前节点的下一个节点，判断下一个节点的合理性（vis和index边缘）</li>\n<li>如果合理，那么判断下一个节点是否是目标节点，如果是直接返回step+1,否则向队列中压入下一个节点</li>\n<li>重复上述过程，知道队列为空</li>\n<li>如果队列空都没有找到，说明源节点无法到达目标节点</li>\n</ol>\n</li>\n</ul>\n<p>15， 克隆图</p>\n<ul>\n<li>使用BFS</li>\n<li>这个题类似于 剑指 Offer 35. 复杂链表的复制，需要建立原始node和新node之间的映射, 同时这个hash也能充当vis数组，判断当前节点是否被访问过；复杂链表复制那道题只需要顺序两次遍历链表就可以了，不需要vis或者bfs</li>\n</ul>\n<p><font color=\"red\">16. 给表达式添加运算符（hard）</font><br>使用回溯<br>易错点：<br>    1. 乘法是有优先级的，因此之前计算dfs计算的结果有可能是需要回退一个数组，然后再进行计算<br>    2. 每次压入的数字可能是包含多个位的<br>    3. 不能包含前导0，但是这个数又不是0的情况<br>    <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">if</span>(i!=index&amp;&amp;num[index]==<span class=\"hljs-string\">&#x27;0&#x27;</span>)&#123;<br>    <span class=\"hljs-keyword\">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>    4. 回溯是时候一定要记得将符号pop_back!!!!</p>\n<ol start=\"17\">\n<li>lc980. 不同路径 III</li>\n</ol>\n<ul>\n<li>求从起点到终点，经过二维矩阵的每个空方格（注意是每个都要走一次，而且不能重复），的不同路径总数</li>\n<li>使用记忆化的dfs 因为到达每个点前面的路径是不一定相同的，因此需要使用dp[i][j][i*C+j^之前的路径] 表示到达当前的状态之前走过的路径是怎样的<br>注意题目表示1 &lt;= grid.length * grid[0].length &lt;= 20，才能使用这种位运算来记录矩阵的状态（状态压缩的条件）</li>\n</ul>\n<ol start=\"18\">\n<li>单词拆分II</li>\n</ol>\n<ul>\n<li>需要找到所有拆分的具体方案</li>\n<li>为了减少回溯的重复，使用一个hash&lt;int, vector<string>&gt; 将以i下标为开始后面形成的所有可能都存储下来，这样之后寻找的时候就不用重复判断 （类似二叉搜索树的所有可能那种题目）， 记忆化dfs</string></li>\n</ul>\n<ol start=\"19\">\n<li>lc741. 摘樱桃(hard)</li>\n</ol>\n<ul>\n<li>这道题用dp理解起来比较困难，所以使用记忆化dfs</li>\n<li>易错点：贪心，第一次选最大+第二次选剩下的最大不一定是最优解</li>\n<li>正确方法，需要dfs，然后需要有两条路径，就相当于同时对<strong>两个点进行dfs</strong>, 这两个点x1+y1=x2+y2 (有关系)然后需要判断这两个是不是同一个点，如果是，那么+grid[x1][y1]， 否则+grid[x1][y1]+grid[x2][y2]</li>\n</ul>\n<ol start=\"20\">\n<li>lc934. Shortest Bridge 最短的桥梁</li>\n</ol>\n<ul>\n<li>使用多源最短路径，两个技巧：先dfs找到岛屿上的所有点，并将将访问过的岛屿转为2；2. BFS使用层次bfs, 因为修改了访问的点为2，所以不用使用vis数组</li>\n</ul>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>ok ok</p>\n<ol>\n<li><p>注意dfs和回溯还是有区别的，dfs，遇到不合适的条件可以直接退出，但是回溯，退出前要将之前的状态修改； BFS常用于求最短路径，或者最少xxxx(结合优先队列)</p>\n</li>\n<li><p>dfs和记忆化搜索和dp都有联系，有时候一道题这两种方法都可以用<br>例如：</p>\n</li>\n</ol>\n<ul>\n<li>分汤(因为都是25的倍数，所以n可以直接/25+1(如果余数不为0), 分配操作同样变为-4、-2、-1<br>dfs如果状态比较多，可以使用记忆化数组，同时如果状态都是某一个数的倍数，那么可以对数据进行归一化后再进行dfs<br>这样的话记忆化搜索的状态数量就会减少<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">double</span> ans = <span class=\"hljs-number\">0.0</span>;<br>               <span class=\"hljs-keyword\">if</span> (i == <span class=\"hljs-number\">0</span>) ans = <span class=\"hljs-number\">1.0</span>;<br>               <span class=\"hljs-keyword\">if</span> (i == <span class=\"hljs-number\">0</span> &amp;&amp; j == <span class=\"hljs-number\">0</span>) ans = <span class=\"hljs-number\">0.5</span>;<br>               <span class=\"hljs-keyword\">if</span> (i &gt; <span class=\"hljs-number\">0</span> &amp;&amp; j &gt; <span class=\"hljs-number\">0</span>) &#123;<br>                   ans = <span class=\"hljs-number\">0.25</span> * (memo[<span class=\"hljs-built_in\">M</span>(i<span class=\"hljs-number\">-4</span>)][j] + memo[<span class=\"hljs-built_in\">M</span>(i<span class=\"hljs-number\">-3</span>)][<span class=\"hljs-built_in\">M</span>(j<span class=\"hljs-number\">-1</span>)] +<br>                                 memo[<span class=\"hljs-built_in\">M</span>(i<span class=\"hljs-number\">-2</span>)][<span class=\"hljs-built_in\">M</span>(j<span class=\"hljs-number\">-2</span>)] + memo[<span class=\"hljs-built_in\">M</span>(i<span class=\"hljs-number\">-1</span>)][<span class=\"hljs-built_in\">M</span>(j<span class=\"hljs-number\">-3</span>)]);<br>               &#125;<br></code></pre></td></tr></table></figure></li>\n<li>类似的概率转移dfs/dp有leet935. 马”在棋盘上的概率（可以最后/pow(8,N), 不用每次/8）</li>\n</ul>\n<ol start=\"3\">\n<li><p>如果要求岛屿的形状相同，那么可以将岛屿的位置使用string的形式存储下来，然后使用set<string>来存储，返回size就是形状不同的岛屿（忽略翻折和旋转）</string></p>\n</li>\n<li><p>递归转为非递归的方式，使用堆或者栈（lc100.相同的数（dfs/宽度优先遍历））</p>\n</li>\n<li><p>注意如果dfs中数据包含重复，一定要记得去重（如排列，组合）</p>\n</li>\n</ol>\n"},{"title":"多线程","date":"2022-01-26T04:19:28.000Z","_content":"\n\n### semaphore 信号量\n```\n#include <semaphore.h>\nsem_t sem1;//进行变量申明\n\nsem_init(&sem1, 1, 0); \n第一个参数：指向的信号对象\n第二个参数：控制信号量的类型，如果其值为0，就表示信号量是当前进程的局部信号量，否则信号量就可以在多个进程间共享\n第三个参数：信号量sem的初始值\n\nsem_post(&sem1) 信号量值加1\n\nsem_wait(&sem1) 信号量值减1\n\nsem_destroy(&sem1) 信号量销毁\n```\n\n###  互斥锁和条件变量（可以实现一个进程打印5次，另外一个进程打印1次的场景）\nC++： condition_variable C: pthread_cond_t\n条件变量的一个例子，讲得很详细：https://blog.csdn.net/jinking01/article/details/110362483\n\n讲述conditon_variable的一个例子：https://segmentfault.com/a/1190000006679917 \n```C++\n伪代码\ncondition_variable cond;\nmutex p_lock;\nint count=0;\nvoid* process1(void *args){\n  while(1){\n    p_lock.lock();\n    count++;\n    if(count%5==0){\n      cond.cond_signal(&cond);\n    }else{\n      printFunction(\"this is process 1\");\n    }\n    p_lock.unlock();\n\n  }\n}\nvoid* process2(void *args){\n  while(1){\n        p_lock.lock();\n        cond_wait(&cond);//锁内部\n        printFunction(\"this is process 2\");\n        p_lock.unlock();t\n  }\n\n}\n```\n生产者-消费者问题\n读者-写者问题\n```C++\nsem_t full;\nsem_t empty;\nsem_t mutex;\nvoid Producer(){\n  while(true){\n      down(&empty);\n      down(&mutex);\n      produce_item();\n      up(&mutex);\n      up(&full);\n  }\n}\nvoid Consumer(){\n  while(true){\n      down(&full);\n      down(&mutex);\n      produce_item();\n      up(&mutex);\n      up(&empty);\n  }\n}\n```\n读者-写者问题\n```C++\nsem_t data_mutex;\nsem_t count_mutex;\nvoid Reader(){\n  while(true){\n      down(&count_mutex);\n      count++;\n      if(count==1){\n        down(&data_mutex);\n      }\n      up(&count_mutex);\n\n      read();//没有单独加数据锁\n\n      down(&count_mutex);\n      count--;\n      if(count==0){\n        up(&data_mutex);\n      }\n      up(&count_mutex);\n  }\n}\nvoid riter(){\n  while(true){\n      down(&data_mutex);\n      produce_item();\n      up(&data_mutex);\n  }\n}\n```\n1.\n引入条件变量一个就是为了避免为了查看条件是否成立而不断轮询的情况\n总结：互斥锁实现的是线程之间的互斥，条件变量实现的是线程之间的同步。\n初始化条件变量\npthread_cond_t cond = PTHREAD_COND_INITIALIZER;\n\n该函数用来在一个ConditionVariable上阻塞等待，做以下三步操作：①释放Mutex；②阻塞等待；③当被唤醒时，重新获得Mutex并返回。\nint pthread_cond_wait(pthread_cond_t &cond_name, pthread_mutex_t &mutex_name);\n\n唤醒等待线程\npthread_cond_signal()：用于唤醒在该条件变量下等待的一个线程，至于哪个被唤醒，取决于线程的优先级和调度策略。\npthread_cond_broadcast()：用于唤醒在某个ConditionVariable 上等待的所有线程。使用这种方法时，瞬间唤醒的线程数过多，资源请求过大，容易导致系统不稳定。\nint pthread_cond_signal(pthread_cond_t &cond_name);\nint pthread_cond_broadcast(pthread_cond_t &cond_name);\n\n\n\n2. 和信号量的区别：\n条件变量的提出是为了解决互斥锁中的循环等待问题，其希望引入一种挂起、唤醒的机制来实现cpu的高效利用\n（1）使用条件变量可以一次唤醒所有等待者，而这个信号量没有的功能，感觉是最大区别。 \n（2）信号量是有一个值（状态的），而条件变量是没有的，没有地方记录唤醒（发送信号）过多少次，也没有地方记录唤醒线程（wait返回）过多少次。\n\n\n3. 注意！！！！\n条件变量被通知后，挂起的线程就被唤醒，但是唤醒也有可能是假唤醒，或者是因为超时等异常情况，所以被唤醒的线程仍要检查条件是否满足，所以 wait 是放在条件循环里面。cv.wait(lock, [] { return ready; }); 相当于：while (!ready) { cv.wait(lock); }。\n\n### 例题\n1. 为了实现两个函数的交替打印，可以使用信号量，也可以使用交替锁\n1115. 交替打印 FooBar\n\nsolution 1:\n```C++\nfunc1:\nsem_wait(&sem_foo);\nprintFoo();\nsem_post(&sem_bar);\n\nfunc2\nsem_wait(&sem_bar);\nprintBar();\nsem_post(&sem_foo);\n```\n\nsolution 2 互斥锁（不建议用这种解法，在不同线程加锁解锁确实会出问题）\n```C++\nfunc1:\nmutex lock1, lock2; //这里锁类似条件变量\n\nlock1.lock();\nprintFoo();\nlock2.unlock();\n\nfunc2\nlock2.lock();\nprintBar();\nlock1.unlock();\n```\n\n\n2. 实现一个线程安全的队列\n在多个线程进行push的时候需要加锁，在push的时候通知pop的线程可以pop \n使用trypop，如果加锁，判断队列为空，那么直接返回，否则调用pop //不用try pop那么可能出现阻塞\npop函数使用使用条件锁 m_cond, 在pop的时候也需要加锁 //在多进程需要使用条件变量，虽然判断了是否为empty再进入的pop，因为可能时间片被其他线程占用导致当前没有元素pop\nempty(), 加锁判断队列里面是否有元素\n\n使用条件变量判断队列里面是否有元素，才能pop\n\n#### 总结\nok\n生成者-消费者需要两个信号量用于同步，一个用于给数据加锁\n条件变量主要是用于达到了某个条件通知另外的进程可以做某件事（5对1，或者队列pop push）\n读者-写者，写者加数据锁（信号量），读者只需要加count锁，因为多个读者可以同时读\n队列这种，pop先判断是否为空，为空直接返回；不为空还需要等待条件变量，放置pop的时候被其他pop抢占，或者多个同时判断不为空，但是只有一个元素情况","source":"_posts/leetcode/多线程编程.md","raw":"---\ntitle: 多线程\ntags: 多线程并发， 信号量， 互斥锁\ncategories:\n  - leetcode\ndate: 2022-01-26 12:19:28\n---\n\n\n### semaphore 信号量\n```\n#include <semaphore.h>\nsem_t sem1;//进行变量申明\n\nsem_init(&sem1, 1, 0); \n第一个参数：指向的信号对象\n第二个参数：控制信号量的类型，如果其值为0，就表示信号量是当前进程的局部信号量，否则信号量就可以在多个进程间共享\n第三个参数：信号量sem的初始值\n\nsem_post(&sem1) 信号量值加1\n\nsem_wait(&sem1) 信号量值减1\n\nsem_destroy(&sem1) 信号量销毁\n```\n\n###  互斥锁和条件变量（可以实现一个进程打印5次，另外一个进程打印1次的场景）\nC++： condition_variable C: pthread_cond_t\n条件变量的一个例子，讲得很详细：https://blog.csdn.net/jinking01/article/details/110362483\n\n讲述conditon_variable的一个例子：https://segmentfault.com/a/1190000006679917 \n```C++\n伪代码\ncondition_variable cond;\nmutex p_lock;\nint count=0;\nvoid* process1(void *args){\n  while(1){\n    p_lock.lock();\n    count++;\n    if(count%5==0){\n      cond.cond_signal(&cond);\n    }else{\n      printFunction(\"this is process 1\");\n    }\n    p_lock.unlock();\n\n  }\n}\nvoid* process2(void *args){\n  while(1){\n        p_lock.lock();\n        cond_wait(&cond);//锁内部\n        printFunction(\"this is process 2\");\n        p_lock.unlock();t\n  }\n\n}\n```\n生产者-消费者问题\n读者-写者问题\n```C++\nsem_t full;\nsem_t empty;\nsem_t mutex;\nvoid Producer(){\n  while(true){\n      down(&empty);\n      down(&mutex);\n      produce_item();\n      up(&mutex);\n      up(&full);\n  }\n}\nvoid Consumer(){\n  while(true){\n      down(&full);\n      down(&mutex);\n      produce_item();\n      up(&mutex);\n      up(&empty);\n  }\n}\n```\n读者-写者问题\n```C++\nsem_t data_mutex;\nsem_t count_mutex;\nvoid Reader(){\n  while(true){\n      down(&count_mutex);\n      count++;\n      if(count==1){\n        down(&data_mutex);\n      }\n      up(&count_mutex);\n\n      read();//没有单独加数据锁\n\n      down(&count_mutex);\n      count--;\n      if(count==0){\n        up(&data_mutex);\n      }\n      up(&count_mutex);\n  }\n}\nvoid riter(){\n  while(true){\n      down(&data_mutex);\n      produce_item();\n      up(&data_mutex);\n  }\n}\n```\n1.\n引入条件变量一个就是为了避免为了查看条件是否成立而不断轮询的情况\n总结：互斥锁实现的是线程之间的互斥，条件变量实现的是线程之间的同步。\n初始化条件变量\npthread_cond_t cond = PTHREAD_COND_INITIALIZER;\n\n该函数用来在一个ConditionVariable上阻塞等待，做以下三步操作：①释放Mutex；②阻塞等待；③当被唤醒时，重新获得Mutex并返回。\nint pthread_cond_wait(pthread_cond_t &cond_name, pthread_mutex_t &mutex_name);\n\n唤醒等待线程\npthread_cond_signal()：用于唤醒在该条件变量下等待的一个线程，至于哪个被唤醒，取决于线程的优先级和调度策略。\npthread_cond_broadcast()：用于唤醒在某个ConditionVariable 上等待的所有线程。使用这种方法时，瞬间唤醒的线程数过多，资源请求过大，容易导致系统不稳定。\nint pthread_cond_signal(pthread_cond_t &cond_name);\nint pthread_cond_broadcast(pthread_cond_t &cond_name);\n\n\n\n2. 和信号量的区别：\n条件变量的提出是为了解决互斥锁中的循环等待问题，其希望引入一种挂起、唤醒的机制来实现cpu的高效利用\n（1）使用条件变量可以一次唤醒所有等待者，而这个信号量没有的功能，感觉是最大区别。 \n（2）信号量是有一个值（状态的），而条件变量是没有的，没有地方记录唤醒（发送信号）过多少次，也没有地方记录唤醒线程（wait返回）过多少次。\n\n\n3. 注意！！！！\n条件变量被通知后，挂起的线程就被唤醒，但是唤醒也有可能是假唤醒，或者是因为超时等异常情况，所以被唤醒的线程仍要检查条件是否满足，所以 wait 是放在条件循环里面。cv.wait(lock, [] { return ready; }); 相当于：while (!ready) { cv.wait(lock); }。\n\n### 例题\n1. 为了实现两个函数的交替打印，可以使用信号量，也可以使用交替锁\n1115. 交替打印 FooBar\n\nsolution 1:\n```C++\nfunc1:\nsem_wait(&sem_foo);\nprintFoo();\nsem_post(&sem_bar);\n\nfunc2\nsem_wait(&sem_bar);\nprintBar();\nsem_post(&sem_foo);\n```\n\nsolution 2 互斥锁（不建议用这种解法，在不同线程加锁解锁确实会出问题）\n```C++\nfunc1:\nmutex lock1, lock2; //这里锁类似条件变量\n\nlock1.lock();\nprintFoo();\nlock2.unlock();\n\nfunc2\nlock2.lock();\nprintBar();\nlock1.unlock();\n```\n\n\n2. 实现一个线程安全的队列\n在多个线程进行push的时候需要加锁，在push的时候通知pop的线程可以pop \n使用trypop，如果加锁，判断队列为空，那么直接返回，否则调用pop //不用try pop那么可能出现阻塞\npop函数使用使用条件锁 m_cond, 在pop的时候也需要加锁 //在多进程需要使用条件变量，虽然判断了是否为empty再进入的pop，因为可能时间片被其他线程占用导致当前没有元素pop\nempty(), 加锁判断队列里面是否有元素\n\n使用条件变量判断队列里面是否有元素，才能pop\n\n#### 总结\nok\n生成者-消费者需要两个信号量用于同步，一个用于给数据加锁\n条件变量主要是用于达到了某个条件通知另外的进程可以做某件事（5对1，或者队列pop push）\n读者-写者，写者加数据锁（信号量），读者只需要加count锁，因为多个读者可以同时读\n队列这种，pop先判断是否为空，为空直接返回；不为空还需要等待条件变量，放置pop的时候被其他pop抢占，或者多个同时判断不为空，但是只有一个元素情况","slug":"leetcode/多线程编程","published":1,"updated":"2022-03-02T03:53:22.049Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clk5ceinp000qjpjb9tvgej5j","content":"<h3 id=\"semaphore-信号量\"><a href=\"#semaphore-信号量\" class=\"headerlink\" title=\"semaphore 信号量\"></a>semaphore 信号量</h3><figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs reasonml\">#<span class=\"hljs-keyword\">include</span> &lt;semaphore.h&gt;<br>sem_t sem1;<span class=\"hljs-comment\">//进行变量申明</span><br><br>sem<span class=\"hljs-constructor\">_init(&amp;<span class=\"hljs-params\">sem1</span>, 1, 0)</span>; <br>第一个参数：指向的信号对象<br>第二个参数：控制信号量的类型，如果其值为<span class=\"hljs-number\">0</span>，就表示信号量是当前进程的局部信号量，否则信号量就可以在多个进程间共享<br>第三个参数：信号量sem的初始值<br><br>sem<span class=\"hljs-constructor\">_post(&amp;<span class=\"hljs-params\">sem1</span>)</span> 信号量值加<span class=\"hljs-number\">1</span><br><br>sem<span class=\"hljs-constructor\">_wait(&amp;<span class=\"hljs-params\">sem1</span>)</span> 信号量值减<span class=\"hljs-number\">1</span><br><br>sem<span class=\"hljs-constructor\">_destroy(&amp;<span class=\"hljs-params\">sem1</span>)</span> 信号量销毁<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"互斥锁和条件变量（可以实现一个进程打印5次，另外一个进程打印1次的场景）\"><a href=\"#互斥锁和条件变量（可以实现一个进程打印5次，另外一个进程打印1次的场景）\" class=\"headerlink\" title=\"互斥锁和条件变量（可以实现一个进程打印5次，另外一个进程打印1次的场景）\"></a>互斥锁和条件变量（可以实现一个进程打印5次，另外一个进程打印1次的场景）</h3><p>C++： condition_variable C: pthread_cond_t<br>条件变量的一个例子，讲得很详细：<a href=\"https://blog.csdn.net/jinking01/article/details/110362483\">https://blog.csdn.net/jinking01/article/details/110362483</a></p>\n<p>讲述conditon_variable的一个例子：<a href=\"https://segmentfault.com/a/1190000006679917\">https://segmentfault.com/a/1190000006679917</a> </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">伪代码<br>condition_variable cond;<br>mutex p_lock;<br><span class=\"hljs-keyword\">int</span> count=<span class=\"hljs-number\">0</span>;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span>* <span class=\"hljs-title\">process1</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">void</span> *args)</span></span>&#123;<br>  <span class=\"hljs-keyword\">while</span>(<span class=\"hljs-number\">1</span>)&#123;<br>    p_lock.<span class=\"hljs-built_in\">lock</span>();<br>    count++;<br>    <span class=\"hljs-keyword\">if</span>(count%<span class=\"hljs-number\">5</span>==<span class=\"hljs-number\">0</span>)&#123;<br>      cond.<span class=\"hljs-built_in\">cond_signal</span>(&amp;cond);<br>    &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>      <span class=\"hljs-built_in\">printFunction</span>(<span class=\"hljs-string\">&quot;this is process 1&quot;</span>);<br>    &#125;<br>    p_lock.<span class=\"hljs-built_in\">unlock</span>();<br><br>  &#125;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span>* <span class=\"hljs-title\">process2</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">void</span> *args)</span></span>&#123;<br>  <span class=\"hljs-keyword\">while</span>(<span class=\"hljs-number\">1</span>)&#123;<br>        p_lock.<span class=\"hljs-built_in\">lock</span>();<br>        <span class=\"hljs-built_in\">cond_wait</span>(&amp;cond);<span class=\"hljs-comment\">//锁内部</span><br>        <span class=\"hljs-built_in\">printFunction</span>(<span class=\"hljs-string\">&quot;this is process 2&quot;</span>);<br>        p_lock.<span class=\"hljs-built_in\">unlock</span>();t<br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>生产者-消费者问题<br>读者-写者问题</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">sem_t</span> full;<br><span class=\"hljs-keyword\">sem_t</span> empty;<br><span class=\"hljs-keyword\">sem_t</span> mutex;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Producer</span><span class=\"hljs-params\">()</span></span>&#123;<br>  <span class=\"hljs-keyword\">while</span>(<span class=\"hljs-literal\">true</span>)&#123;<br>      <span class=\"hljs-built_in\">down</span>(&amp;empty);<br>      <span class=\"hljs-built_in\">down</span>(&amp;mutex);<br>      <span class=\"hljs-built_in\">produce_item</span>();<br>      <span class=\"hljs-built_in\">up</span>(&amp;mutex);<br>      <span class=\"hljs-built_in\">up</span>(&amp;full);<br>  &#125;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Consumer</span><span class=\"hljs-params\">()</span></span>&#123;<br>  <span class=\"hljs-keyword\">while</span>(<span class=\"hljs-literal\">true</span>)&#123;<br>      <span class=\"hljs-built_in\">down</span>(&amp;full);<br>      <span class=\"hljs-built_in\">down</span>(&amp;mutex);<br>      <span class=\"hljs-built_in\">produce_item</span>();<br>      <span class=\"hljs-built_in\">up</span>(&amp;mutex);<br>      <span class=\"hljs-built_in\">up</span>(&amp;empty);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>读者-写者问题</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">sem_t</span> data_mutex;<br><span class=\"hljs-keyword\">sem_t</span> count_mutex;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Reader</span><span class=\"hljs-params\">()</span></span>&#123;<br>  <span class=\"hljs-keyword\">while</span>(<span class=\"hljs-literal\">true</span>)&#123;<br>      <span class=\"hljs-built_in\">down</span>(&amp;count_mutex);<br>      count++;<br>      <span class=\"hljs-keyword\">if</span>(count==<span class=\"hljs-number\">1</span>)&#123;<br>        <span class=\"hljs-built_in\">down</span>(&amp;data_mutex);<br>      &#125;<br>      <span class=\"hljs-built_in\">up</span>(&amp;count_mutex);<br><br>      <span class=\"hljs-built_in\">read</span>();<span class=\"hljs-comment\">//没有单独加数据锁</span><br><br>      <span class=\"hljs-built_in\">down</span>(&amp;count_mutex);<br>      count--;<br>      <span class=\"hljs-keyword\">if</span>(count==<span class=\"hljs-number\">0</span>)&#123;<br>        <span class=\"hljs-built_in\">up</span>(&amp;data_mutex);<br>      &#125;<br>      <span class=\"hljs-built_in\">up</span>(&amp;count_mutex);<br>  &#125;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">riter</span><span class=\"hljs-params\">()</span></span>&#123;<br>  <span class=\"hljs-keyword\">while</span>(<span class=\"hljs-literal\">true</span>)&#123;<br>      <span class=\"hljs-built_in\">down</span>(&amp;data_mutex);<br>      <span class=\"hljs-built_in\">produce_item</span>();<br>      <span class=\"hljs-built_in\">up</span>(&amp;data_mutex);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>1.<br>引入条件变量一个就是为了避免为了查看条件是否成立而不断轮询的情况<br>总结：互斥锁实现的是线程之间的互斥，条件变量实现的是线程之间的同步。<br>初始化条件变量<br>pthread_cond_t cond = PTHREAD_COND_INITIALIZER;</p>\n<p>该函数用来在一个ConditionVariable上阻塞等待，做以下三步操作：①释放Mutex；②阻塞等待；③当被唤醒时，重新获得Mutex并返回。<br>int pthread_cond_wait(pthread_cond_t &amp;cond_name, pthread_mutex_t &amp;mutex_name);</p>\n<p>唤醒等待线程<br>pthread_cond_signal()：用于唤醒在该条件变量下等待的一个线程，至于哪个被唤醒，取决于线程的优先级和调度策略。<br>pthread_cond_broadcast()：用于唤醒在某个ConditionVariable 上等待的所有线程。使用这种方法时，瞬间唤醒的线程数过多，资源请求过大，容易导致系统不稳定。<br>int pthread_cond_signal(pthread_cond_t &amp;cond_name);<br>int pthread_cond_broadcast(pthread_cond_t &amp;cond_name);</p>\n<ol start=\"2\">\n<li>和信号量的区别：<br>条件变量的提出是为了解决互斥锁中的循环等待问题，其希望引入一种挂起、唤醒的机制来实现cpu的高效利用<br>（1）使用条件变量可以一次唤醒所有等待者，而这个信号量没有的功能，感觉是最大区别。<br>（2）信号量是有一个值（状态的），而条件变量是没有的，没有地方记录唤醒（发送信号）过多少次，也没有地方记录唤醒线程（wait返回）过多少次。</li>\n</ol>\n<ol start=\"3\">\n<li>注意！！！！<br>条件变量被通知后，挂起的线程就被唤醒，但是唤醒也有可能是假唤醒，或者是因为超时等异常情况，所以被唤醒的线程仍要检查条件是否满足，所以 wait 是放在条件循环里面。cv.wait(lock, [] { return ready; }); 相当于：while (!ready) { cv.wait(lock); }。</li>\n</ol>\n<h3 id=\"例题\"><a href=\"#例题\" class=\"headerlink\" title=\"例题\"></a>例题</h3><ol>\n<li>为了实现两个函数的交替打印，可以使用信号量，也可以使用交替锁</li>\n<li>交替打印 FooBar</li>\n</ol>\n<p>solution 1:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">func1:<br><span class=\"hljs-built_in\">sem_wait</span>(&amp;sem_foo);<br><span class=\"hljs-built_in\">printFoo</span>();<br><span class=\"hljs-built_in\">sem_post</span>(&amp;sem_bar);<br><br><span class=\"hljs-function\">func2</span><br><span class=\"hljs-function\"><span class=\"hljs-title\">sem_wait</span><span class=\"hljs-params\">(&amp;sem_bar)</span></span>;<br><span class=\"hljs-built_in\">printBar</span>();<br><span class=\"hljs-built_in\">sem_post</span>(&amp;sem_foo);<br></code></pre></td></tr></table></figure>\n\n<p>solution 2 互斥锁（不建议用这种解法，在不同线程加锁解锁确实会出问题）</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">func1:<br>mutex lock1, lock2; <span class=\"hljs-comment\">//这里锁类似条件变量</span><br><br>lock1.<span class=\"hljs-built_in\">lock</span>();<br><span class=\"hljs-built_in\">printFoo</span>();<br>lock2.<span class=\"hljs-built_in\">unlock</span>();<br><br>func2<br>lock2.<span class=\"hljs-built_in\">lock</span>();<br><span class=\"hljs-built_in\">printBar</span>();<br>lock1.<span class=\"hljs-built_in\">unlock</span>();<br></code></pre></td></tr></table></figure>\n\n\n<ol start=\"2\">\n<li>实现一个线程安全的队列<br>在多个线程进行push的时候需要加锁，在push的时候通知pop的线程可以pop<br>使用trypop，如果加锁，判断队列为空，那么直接返回，否则调用pop //不用try pop那么可能出现阻塞<br>pop函数使用使用条件锁 m_cond, 在pop的时候也需要加锁 //在多进程需要使用条件变量，虽然判断了是否为empty再进入的pop，因为可能时间片被其他线程占用导致当前没有元素pop<br>empty(), 加锁判断队列里面是否有元素</li>\n</ol>\n<p>使用条件变量判断队列里面是否有元素，才能pop</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>ok<br>生成者-消费者需要两个信号量用于同步，一个用于给数据加锁<br>条件变量主要是用于达到了某个条件通知另外的进程可以做某件事（5对1，或者队列pop push）<br>读者-写者，写者加数据锁（信号量），读者只需要加count锁，因为多个读者可以同时读<br>队列这种，pop先判断是否为空，为空直接返回；不为空还需要等待条件变量，放置pop的时候被其他pop抢占，或者多个同时判断不为空，但是只有一个元素情况</p>\n","site":{"data":{}},"wordcount":3368,"excerpt":"","more":"<h3 id=\"semaphore-信号量\"><a href=\"#semaphore-信号量\" class=\"headerlink\" title=\"semaphore 信号量\"></a>semaphore 信号量</h3><figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs reasonml\">#<span class=\"hljs-keyword\">include</span> &lt;semaphore.h&gt;<br>sem_t sem1;<span class=\"hljs-comment\">//进行变量申明</span><br><br>sem<span class=\"hljs-constructor\">_init(&amp;<span class=\"hljs-params\">sem1</span>, 1, 0)</span>; <br>第一个参数：指向的信号对象<br>第二个参数：控制信号量的类型，如果其值为<span class=\"hljs-number\">0</span>，就表示信号量是当前进程的局部信号量，否则信号量就可以在多个进程间共享<br>第三个参数：信号量sem的初始值<br><br>sem<span class=\"hljs-constructor\">_post(&amp;<span class=\"hljs-params\">sem1</span>)</span> 信号量值加<span class=\"hljs-number\">1</span><br><br>sem<span class=\"hljs-constructor\">_wait(&amp;<span class=\"hljs-params\">sem1</span>)</span> 信号量值减<span class=\"hljs-number\">1</span><br><br>sem<span class=\"hljs-constructor\">_destroy(&amp;<span class=\"hljs-params\">sem1</span>)</span> 信号量销毁<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"互斥锁和条件变量（可以实现一个进程打印5次，另外一个进程打印1次的场景）\"><a href=\"#互斥锁和条件变量（可以实现一个进程打印5次，另外一个进程打印1次的场景）\" class=\"headerlink\" title=\"互斥锁和条件变量（可以实现一个进程打印5次，另外一个进程打印1次的场景）\"></a>互斥锁和条件变量（可以实现一个进程打印5次，另外一个进程打印1次的场景）</h3><p>C++： condition_variable C: pthread_cond_t<br>条件变量的一个例子，讲得很详细：<a href=\"https://blog.csdn.net/jinking01/article/details/110362483\">https://blog.csdn.net/jinking01/article/details/110362483</a></p>\n<p>讲述conditon_variable的一个例子：<a href=\"https://segmentfault.com/a/1190000006679917\">https://segmentfault.com/a/1190000006679917</a> </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">伪代码<br>condition_variable cond;<br>mutex p_lock;<br><span class=\"hljs-keyword\">int</span> count=<span class=\"hljs-number\">0</span>;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span>* <span class=\"hljs-title\">process1</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">void</span> *args)</span></span>&#123;<br>  <span class=\"hljs-keyword\">while</span>(<span class=\"hljs-number\">1</span>)&#123;<br>    p_lock.<span class=\"hljs-built_in\">lock</span>();<br>    count++;<br>    <span class=\"hljs-keyword\">if</span>(count%<span class=\"hljs-number\">5</span>==<span class=\"hljs-number\">0</span>)&#123;<br>      cond.<span class=\"hljs-built_in\">cond_signal</span>(&amp;cond);<br>    &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>      <span class=\"hljs-built_in\">printFunction</span>(<span class=\"hljs-string\">&quot;this is process 1&quot;</span>);<br>    &#125;<br>    p_lock.<span class=\"hljs-built_in\">unlock</span>();<br><br>  &#125;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span>* <span class=\"hljs-title\">process2</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">void</span> *args)</span></span>&#123;<br>  <span class=\"hljs-keyword\">while</span>(<span class=\"hljs-number\">1</span>)&#123;<br>        p_lock.<span class=\"hljs-built_in\">lock</span>();<br>        <span class=\"hljs-built_in\">cond_wait</span>(&amp;cond);<span class=\"hljs-comment\">//锁内部</span><br>        <span class=\"hljs-built_in\">printFunction</span>(<span class=\"hljs-string\">&quot;this is process 2&quot;</span>);<br>        p_lock.<span class=\"hljs-built_in\">unlock</span>();t<br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>生产者-消费者问题<br>读者-写者问题</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">sem_t</span> full;<br><span class=\"hljs-keyword\">sem_t</span> empty;<br><span class=\"hljs-keyword\">sem_t</span> mutex;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Producer</span><span class=\"hljs-params\">()</span></span>&#123;<br>  <span class=\"hljs-keyword\">while</span>(<span class=\"hljs-literal\">true</span>)&#123;<br>      <span class=\"hljs-built_in\">down</span>(&amp;empty);<br>      <span class=\"hljs-built_in\">down</span>(&amp;mutex);<br>      <span class=\"hljs-built_in\">produce_item</span>();<br>      <span class=\"hljs-built_in\">up</span>(&amp;mutex);<br>      <span class=\"hljs-built_in\">up</span>(&amp;full);<br>  &#125;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Consumer</span><span class=\"hljs-params\">()</span></span>&#123;<br>  <span class=\"hljs-keyword\">while</span>(<span class=\"hljs-literal\">true</span>)&#123;<br>      <span class=\"hljs-built_in\">down</span>(&amp;full);<br>      <span class=\"hljs-built_in\">down</span>(&amp;mutex);<br>      <span class=\"hljs-built_in\">produce_item</span>();<br>      <span class=\"hljs-built_in\">up</span>(&amp;mutex);<br>      <span class=\"hljs-built_in\">up</span>(&amp;empty);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>读者-写者问题</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">sem_t</span> data_mutex;<br><span class=\"hljs-keyword\">sem_t</span> count_mutex;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Reader</span><span class=\"hljs-params\">()</span></span>&#123;<br>  <span class=\"hljs-keyword\">while</span>(<span class=\"hljs-literal\">true</span>)&#123;<br>      <span class=\"hljs-built_in\">down</span>(&amp;count_mutex);<br>      count++;<br>      <span class=\"hljs-keyword\">if</span>(count==<span class=\"hljs-number\">1</span>)&#123;<br>        <span class=\"hljs-built_in\">down</span>(&amp;data_mutex);<br>      &#125;<br>      <span class=\"hljs-built_in\">up</span>(&amp;count_mutex);<br><br>      <span class=\"hljs-built_in\">read</span>();<span class=\"hljs-comment\">//没有单独加数据锁</span><br><br>      <span class=\"hljs-built_in\">down</span>(&amp;count_mutex);<br>      count--;<br>      <span class=\"hljs-keyword\">if</span>(count==<span class=\"hljs-number\">0</span>)&#123;<br>        <span class=\"hljs-built_in\">up</span>(&amp;data_mutex);<br>      &#125;<br>      <span class=\"hljs-built_in\">up</span>(&amp;count_mutex);<br>  &#125;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">riter</span><span class=\"hljs-params\">()</span></span>&#123;<br>  <span class=\"hljs-keyword\">while</span>(<span class=\"hljs-literal\">true</span>)&#123;<br>      <span class=\"hljs-built_in\">down</span>(&amp;data_mutex);<br>      <span class=\"hljs-built_in\">produce_item</span>();<br>      <span class=\"hljs-built_in\">up</span>(&amp;data_mutex);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>1.<br>引入条件变量一个就是为了避免为了查看条件是否成立而不断轮询的情况<br>总结：互斥锁实现的是线程之间的互斥，条件变量实现的是线程之间的同步。<br>初始化条件变量<br>pthread_cond_t cond = PTHREAD_COND_INITIALIZER;</p>\n<p>该函数用来在一个ConditionVariable上阻塞等待，做以下三步操作：①释放Mutex；②阻塞等待；③当被唤醒时，重新获得Mutex并返回。<br>int pthread_cond_wait(pthread_cond_t &amp;cond_name, pthread_mutex_t &amp;mutex_name);</p>\n<p>唤醒等待线程<br>pthread_cond_signal()：用于唤醒在该条件变量下等待的一个线程，至于哪个被唤醒，取决于线程的优先级和调度策略。<br>pthread_cond_broadcast()：用于唤醒在某个ConditionVariable 上等待的所有线程。使用这种方法时，瞬间唤醒的线程数过多，资源请求过大，容易导致系统不稳定。<br>int pthread_cond_signal(pthread_cond_t &amp;cond_name);<br>int pthread_cond_broadcast(pthread_cond_t &amp;cond_name);</p>\n<ol start=\"2\">\n<li>和信号量的区别：<br>条件变量的提出是为了解决互斥锁中的循环等待问题，其希望引入一种挂起、唤醒的机制来实现cpu的高效利用<br>（1）使用条件变量可以一次唤醒所有等待者，而这个信号量没有的功能，感觉是最大区别。<br>（2）信号量是有一个值（状态的），而条件变量是没有的，没有地方记录唤醒（发送信号）过多少次，也没有地方记录唤醒线程（wait返回）过多少次。</li>\n</ol>\n<ol start=\"3\">\n<li>注意！！！！<br>条件变量被通知后，挂起的线程就被唤醒，但是唤醒也有可能是假唤醒，或者是因为超时等异常情况，所以被唤醒的线程仍要检查条件是否满足，所以 wait 是放在条件循环里面。cv.wait(lock, [] { return ready; }); 相当于：while (!ready) { cv.wait(lock); }。</li>\n</ol>\n<h3 id=\"例题\"><a href=\"#例题\" class=\"headerlink\" title=\"例题\"></a>例题</h3><ol>\n<li>为了实现两个函数的交替打印，可以使用信号量，也可以使用交替锁</li>\n<li>交替打印 FooBar</li>\n</ol>\n<p>solution 1:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">func1:<br><span class=\"hljs-built_in\">sem_wait</span>(&amp;sem_foo);<br><span class=\"hljs-built_in\">printFoo</span>();<br><span class=\"hljs-built_in\">sem_post</span>(&amp;sem_bar);<br><br><span class=\"hljs-function\">func2</span><br><span class=\"hljs-function\"><span class=\"hljs-title\">sem_wait</span><span class=\"hljs-params\">(&amp;sem_bar)</span></span>;<br><span class=\"hljs-built_in\">printBar</span>();<br><span class=\"hljs-built_in\">sem_post</span>(&amp;sem_foo);<br></code></pre></td></tr></table></figure>\n\n<p>solution 2 互斥锁（不建议用这种解法，在不同线程加锁解锁确实会出问题）</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">func1:<br>mutex lock1, lock2; <span class=\"hljs-comment\">//这里锁类似条件变量</span><br><br>lock1.<span class=\"hljs-built_in\">lock</span>();<br><span class=\"hljs-built_in\">printFoo</span>();<br>lock2.<span class=\"hljs-built_in\">unlock</span>();<br><br>func2<br>lock2.<span class=\"hljs-built_in\">lock</span>();<br><span class=\"hljs-built_in\">printBar</span>();<br>lock1.<span class=\"hljs-built_in\">unlock</span>();<br></code></pre></td></tr></table></figure>\n\n\n<ol start=\"2\">\n<li>实现一个线程安全的队列<br>在多个线程进行push的时候需要加锁，在push的时候通知pop的线程可以pop<br>使用trypop，如果加锁，判断队列为空，那么直接返回，否则调用pop //不用try pop那么可能出现阻塞<br>pop函数使用使用条件锁 m_cond, 在pop的时候也需要加锁 //在多进程需要使用条件变量，虽然判断了是否为empty再进入的pop，因为可能时间片被其他线程占用导致当前没有元素pop<br>empty(), 加锁判断队列里面是否有元素</li>\n</ol>\n<p>使用条件变量判断队列里面是否有元素，才能pop</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>ok<br>生成者-消费者需要两个信号量用于同步，一个用于给数据加锁<br>条件变量主要是用于达到了某个条件通知另外的进程可以做某件事（5对1，或者队列pop push）<br>读者-写者，写者加数据锁（信号量），读者只需要加count锁，因为多个读者可以同时读<br>队列这种，pop先判断是否为空，为空直接返回；不为空还需要等待条件变量，放置pop的时候被其他pop抢占，或者多个同时判断不为空，但是只有一个元素情况</p>\n"},{"title":"排序算法","catogory":["leetcode 题目汇总"],"date":"2021-11-13T09:22:15.000Z","_content":"\n#### 堆排序\n##### 堆排序的基本思路\n（每个内部节点，和左右节点对比，往上浮；之后根分别与最后，倒数第二个交换往下沉）\na.先所有的内部节点的每个，从下到上进行往上浮的操作heap_build\nb.然后根节点和最后一个节点交换，然后从根节点向下沉（0,n-1），然后根节点和倒数第二个节点交换，然后往下沉(0,n-2)然后重复上述的过程\n\n也就是先build最大堆，然后逐渐交换，然后重复build\n\n优先队列默认是从大到小进行排序；multiset 基于红黑树实现，默认是从小到大进行排序\npriority<int, vector<int>, greater<int> > q;//最小堆\nmultiset<int, greater<int> > //最大堆\n\n使用归并排序可以求逆序对的数量以及“计算数组的小和”问题: \n特征，如果一个数组中两个元素，nums[i]<nums[j]或者nums[i]>nums[j]再执行某个操作，而且数组元素之间的连续性等没有其他要求，那么使用归并排序计算\n\n```C++\nmerge函数\nwhile (p1 <= mid && p2 <= right)\n    {\n        res += arr[p1] <= arr[p2] ? arr[p1]*(right-p2+1) : 0;\n        help[i++] = arr[p1] <= arr[p2] ? arr[p1++] : arr[p2++];\n    }\n    while (p1 <= mid) help[i++] = arr[p1++];\n    while (p2 <= right) help[i++] = arr[p2++];\n```\n\n\n##### 堆排序的相关例题：\n\n1.打印N个数组的最大TopK (topk类似题使用堆)\n\n用N个最后的元素建立一个最大堆，然后移去堆顶元素，然后用移去元素的下一个元素放在堆顶调整堆，重复上面的过程；\n如果被移去元素数组中没有下一个元素，那么用堆的最后一个元素移到堆顶，让堆的size-1\n\n注意堆排序都是下沉的过程，但是如果向堆中一个一个插入元素，是插入到最后一个位置，heapsize++, 然后上浮过程\n同时也可以先全部放入数组中，然后从内部节点倒叙下沉\n\n*****在进行代码编写的时候，可以不直接实现堆，而是用STL的priority_queue（默认最大堆） ******\n```C++\nstruct node\n{\n    int row;\n    int val; //因为是pop_back所以不用记录下标\n    node(int _r,int _v)\n    {\n        row=_r;\n        val=_v;\n    }\n    bool operator<(const node& b)const\n    {\n        return this->val<b.val;\n    }\n   \n};\npriority_queue<node,vector<node>> heap；\n\n因此这道题的解答方案\n//首先初始化 n个末尾各自的最大元素入堆\n    for(int i=0;i<n;i++)\n    {\n        if(arr[i].size()==0)\n            continue;\n        heap.push(node(i,arr[i][arr[i].size()-1]));\n        arr[i].pop_back();//最后一个元素入堆\n    }\n    //开始从末尾遍历\n   for(int i=0;i<k;i++)  //从堆中选举k个最大的元素\n   {\n       cout<<heap.top().val<<\" \";//打印出最大的那个元素\n       int row=heap.top().row;//那个元素所在行\n       heap.pop();\n       if(arr[row].size()>0) //最大的那个元素弹出后 用所在行的下一个元素顶上（因为第二大元素一定在已有的元素 + 下一个顶上的元素 中产生）\n       {\n           heap.push(node(row,arr[row][arr[row].size()-1]));//下一个接替的node\n           arr[row].pop_back();\n       }\n   }\n```\n\nPS:类似的一个题：两个有序数组的整体中位数（或者第K位数）\n1.使用归并排序，但是只需要记录一个pre cur O(n/2)\n2.使用类似二分的删除的方法，先求出中位数的位置k\n然后比较两个数组nums1[k/2] nums2[k/2]，较小的那个数组，直接跳过k/2个数 index_next=before_index + k/2\n\n\n##### 补充知识：\npriority_queue的自定义排序函数：\nhttps://www.cnblogs.com/shona/p/12163381.html 记住priority_queue排序大小和排序函数都是和正常反着的\n建议使用struct cmp方式，重载operator < 会报错，如果是在solution 类中重载的话\n\n```C++\nstruct cmp{\n\n    bool operator()(const node &a, const node &b){\n        return a.val>b.val; //从小到大排序\n    }\n};//一定要注意结构体后面添加;\n```\n\n2. 查找和最小的K对数字，使用最大堆，以及每个数组最大循环k次\n\n#### 基数排序和桶排序\n\n时间复杂度为O(n)的排序算法：基数排序和桶排序\n例题：最大间距问题\n桶排序：需要确定桶的数量，然后遍历每一个数，求当前数应该放的桶的位置，有点时候并不一定要明确每个桶里面有哪些数据，只需要知道桶\n里面是否有数据（bucket[i]），以及每个桶里面的最大最小值(max_bucket[i], min_bucket[i])，那么就不需要用二维数组记录每个桶里面的具体数据（如例题），然后遍历桶里面的元素，用当前桶的最小值，减去上一个有数据的桶的最大值\n\n##### 基数排序的主要思想：\n1.每次排序都是从最低位到最高位进行排序，因此求最大数的位数，作为基数排序循环的次数\n2.在每次循环，求当前基数位的count\n3.将count进行累加，求在整个count数组中排列的具体位置\n4.从大到小重复计算count数组的过程，将data数据排好后放入tmp数组 count[k]--\n5.将tmp数组赋值为data数组 基数*10，重复上面的步骤\n```C++\nint maxbit(int data[], int n) //辅助函数，求数据的最大位数\n{\n    int maxData = data[0];              ///< 最大数\n    /// 先求出最大数，再求其位数，这样有原先依次每个数判断其位数，稍微优化点。\n    for (int i = 1; i < n; ++i)\n    {\n        if (maxData < data[i])\n            maxData = data[i];\n    }\n    int d = 1;\n    int p = 10;\n    while (maxData >= p)\n    {\n        //p *= 10; // Maybe overflow\n        maxData /= 10;\n        ++d;\n    }\n    return d;\n}\nvoid radixsort(int data[], int n) //基数排序\n{\n    int d = maxbit(data, n);\n    int *tmp = new int[n];\n    int *count = new int[10]; //计数器\n    int i, j, k;\n    int radix = 1;\n    for(i = 1; i <= d; i++) //进行d次排序\n    {\n        for(j = 0; j < 10; j++)\n            count[j] = 0; //每次分配前清空计数器\n        for(j = 0; j < n; j++)\n        {\n            k = (data[j] / radix) % 10; //统计每个桶中的记录数\n            count[k]++;\n        }\n        for(j = 1; j < 10; j++)\n            count[j] = count[j - 1] + count[j]; //将tmp中的位置依次分配给每个桶\n        for(j = n - 1; j >= 0; j--) //将所有桶中记录依次收集到tmp中\n        {\n            k = (data[j] / radix) % 10;\n            tmp[count[k] - 1] = data[j];\n            count[k]--;\n        }\n        for(j = 0; j < n; j++) //将临时数组的内容复制到data中\n            data[j] = tmp[j];\n        radix = radix * 10;\n    }\n    delete []tmp;\n    delete []count;\n}\n```\n\n\n##### 乱序数据使用多进程进行排序\n每个进程进行各种的快速排序，然后将所有进程排序好的结果进行两两归并\n使用pthread_t 和pthread_create\n``` C++\n struct node s[10];\n    for(int i=0;i<10;i++)\n    {\n        s[i].id = i;\n        s[i].l = i*10;\n        s[i].r = i*10+9;\n    }\n \n    pthread_t t[10];\n    for(int i=0;i<10;i++)\n        pthread_create(&t[i],NULL,__sort,(void *)&s[i]);\n \n    for(int i=0;i<10;i++)\n        pthread_join(t[i],NULL);\n\n[完整代码参考链接](https://blog.csdn.net/Return_nellen/article/details/79937320)\n\n```\n\n##### 桶排序例题\n<font color=red>存在重复元素 III</font>\n使用二分查找（set.lower_bound）和滑动窗口，或者桶排序和滑动窗口，比较经典 \n主要思路：查找当窗口元素中是否存在大于等于nums[i]-t的元素，如果存在，判断这个元素是否是小于等于 nums[i]+t 如果存在返回true;\n如果是桶排序解决，就设定每个桶的大小为t+1 计算每个nums[i]应该在的桶的编号，判断这个桶是否有数据，如果有数据直接返回true； 如果没有，那么判断左右两边桶的数据之间的abs差是否 <=t，同时在\n循环向前的时候记得删除范围大于k的桶里面的数据\n\n感觉使用滑动窗口更好理解，就是查找窗口为k的，是否能够找到当前加入的元素x, [x-t, x+t]范围内的数，而且不是当前的数x,如果能,那么返回true\n\n易错点：\n1.滑动窗口记得删除窗口之外的数据\n2. nums[i]-t可能超出了整数的范围，一定要记得判断范围\n\n\n#### 归并排序\n归并排序一般是求逆序对个数，或者其他规则的逆序对\n比如例题lc493. 翻转对 求i<j, 且nums[i]>2*nums[j]\n- 易错点: 有负数+是大于，因此在求解的时候/2 向上还是向下取整会不同\n- 题解是将求res这个过程单调拎出来计算，之后再进行归并\n```C++\n while(i<=mid){\n    while(j<=right&&(long long)nums[i]>(long long)2*nums[j]) j++; //最好不要转为nums[i]/2> nums[j] 因为负数在取整的时候和正数向上和向下不一样\n    res+=(j-mid-1);\n    i++;\n}\n```\n\n- 方法二：使用树状数组，但是因为数据的范围太大，因此使用hash对数据进行离散化， 对x 2*x 一些列数据排序后，递增给予他们idx 1....\n\n\n\n\n#### 其他排序例题\n1. 寻找两个正序数组的中位数 (寻找两个正序数组的第k个数)\n\n注意k表示的第k个数，而不是下标为k\n同时注意算法是一边在进行移动，而不是两边都移动\n\n```C++\n//时间复杂度log(m+n) 空间复杂度O(1)\nclass Solution {\npublic:\n    double getKthElement(vector<int>& nums1, vector<int>& nums2, int k){\n        int size1 = nums1.size();\n        int size2 = nums2.size();\n        int index1 = 0, index2 = 0; \n        while (true)\n        {\n            if(index1==size1){\n                return nums2[index2 + k - 1];\n            }\n            if(index2==size2){\n                return nums1[index1 + k - 1];\n            }\n            if(k==1){\n                return min(nums1[index1], nums2[index2]);\n            }\n            int newIndex1 = min(index1 + k / 2 - 1, size1 - 1);\n            int newIndex2 = min(index2 + k / 2 - 1, size2 - 1);\n            int pivot1 = nums1[newIndex1];\n            int pivot2 = nums2[newIndex2];\n            \n            if(pivot1<=pivot2){\n                \n                k = k - (newIndex1 - index1 + 1);\n                index1 = newIndex1 + 1;\n            }else{\n                \n                k = k - (newIndex2 - index2 + 1);\n                index2 = newIndex2 + 1;\n            }\n            cout<<pivot1<<\" \"<<pivot2<<endl;\n            \n        }\n        \n    }\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        int size1 = nums1.size();\n        int size2 = nums2.size();\n        int sum = size1 + size2;\n        if(sum%2==0){\n            return (getKthElement(nums1, nums2, sum / 2) + getKthElement(nums1, nums2, sum / 2 +1)) / 2;\n        }else{\n            cout<<sum/2+1<<endl;\n            return getKthElement(nums1, nums2, sum / 2+1);\n        }\n    }\n};\n\n ```\n\n 2. 排序和优先队列结合！！\n两个最好的不重叠活动\n步骤：\n- 先将活动按起始时间从小到大进行排序\n- 维护一个最小堆，堆内元素代表活动的结束时间和对应价值(结束时间越早的越先弹出)\n- 遍历所有活动，如果堆内的活动结束时间小于当前活动的起始时间，又因为活动时间是从小到大进行排序的，所以当前堆内的活动是可以与后面任意活动一起参与的，因此我们可以维护maxVal记录下当前活动开始前，我们可以选择的最大价值\n\n\n#### 快速排序\n快速排序模板题\n```C++\n void quickSort(vector<int>&  nums, int left, int right){\n        while(left>=right){\n            return;\n        }\n        int rand_num= rand()%(right-left+1)+left;\n        int pivot=nums[rand_num];\n        swap(nums[rand_num],nums[left]);\n        int l=left;\n        int r=right;\n        while(l<r){\n            while(l<r&&nums[r]>=pivot){\n                r--;\n            }\n            while(l<r&&nums[l]<=pivot){\n                l++;\n            }\n            if(l<r){\n                swap(nums[l], nums[r]);\n            }\n\n        }\n        swap(nums[left], nums[l]);\n        quickSort(nums, left, l-1);\n        quickSort(nums, l+1, right);\n    }\n    vector<int> sortArray(vector<int>& nums) {\n        int num_len=nums.size();\n        quickSort(nums, 0, num_len-1);\n        return nums;\n    }\n```\n\n快速排序找出第k个数的代码模板，类似于二分\n```C++\nclass Solution {\n    public int minMoves2(int[] nums) {\n        int mid = nums.length / 2;\n        int mid_num = quickSort(nums, mid); //这道题中k为mid\n        int ret = 0;\n        for (int num : nums) {\n            ret += Math.abs(mid_num - num);\n        }\n        return ret;\n    }\n\n    public int quickSort(int[] nums, int k) {\n        int l = 0;\n        int h = nums.length - 1;\n        while (l < h) {\n            int ret = partion(nums, l, h);\n            if (ret == k) {\n                break;\n            }\n            if (ret < k) {\n                l = ret + 1;\n            } else {\n                h = ret - 1; \n            }\n        }\n        return nums[k];\n    }\n\n    public int partion(int[] nums, int l, int h) {\n        int p = new Random().nextInt(h - l + 1) + l; //记住pivot是随机产生\n        int temp = nums[p];\n        nums[p] = nums[l];\n        nums[l] = temp;//交换left和pivot的值\n        \n        //可以如下方式写，也可以，l和r每次交换，最后l和pivot所在的位置交换\n        while (l < h) {\n            while (l < h && nums[h] >= temp) { //注意等于也要走，因为如果不，就可能导致在中间出现死循环\n                h--;\n            }\n            nums[l] = nums[h];\n            while (l < h && nums[l] <= temp) {\n                l++;\n            }\n            nums[h] = nums[l];\n        }\n        nums[l] = temp;\n        return l;\n    }\n}\n```\n使用快速排序找到第k个数， 同时考虑结构体(在进行比较的时候使用second, 同时pivot也是second的值)的这种情况， 注意比较value, 但是交换的时候使用index\n```C++\n    void qsort(vector<pair<int, int>>& v, int start, int end, vector<int>& ret, int k) {\n        int picked = rand() % (end - start + 1) + start;\n        swap(v[picked], v[start]);\n\n        int pivot = v[start].second;\n        int index = start;\n        for (int i = start + 1; i <= end; i++) {\n            if (v[i].second >= pivot) {\n                swap(v[index + 1], v[i]);\n                index++;\n            }\n        }\n        swap(v[start], v[index]);\n\n        if (k <= index - start) {\n            qsort(v, start, index - 1, ret, k);\n        } else {\n            for (int i = start; i <= index; i++) {\n                ret.push_back(v[i].first);\n            }\n            if (k > index - start + 1) {\n                qsort(v, index + 1, end, ret, k - (index - start + 1));\n            }\n        }\n    }\n\n```\n\n#### 各种排序算法的总结链接：\nhttps://www.runoob.com/w3cnote/ten-sorting-algorithm.html\n快速排序的额外空间复杂度是O(logn)， 因为每次递归只使用运用了常数时间的额外空间\n\n\n1. 常见算法的稳定性（要记住）\n\n不稳定排序算法： 堆排序、快速排序、希尔排序、选择排序 （快选西堆）\n\n稳定排序算法： 基数排序、冒泡排序、插入排序、归并排序 （极差归帽（0））\n\n\n计数排序的时间复杂度是O(n+k), 空间复杂度为O(k) \n桶排序 O(n+k) 先分桶再快排 O(n+k)//count+tmp数组\n基数排序  O(nxk) O(n+k)\n\n\n2. 比较各种数据结构\n数组 插入慢，删除慢，查找慢（通过下标获取快）， 空间连续且固定\n链表 插入快，删除快， 查找慢， 物理空间不连续，同时方便扩容\n二叉树： 查找、插入、删除都快（如果树保持平衡）。缺点是删除算法复杂。\n堆： 堆是一种特殊的完全二叉树\n栈：后进先出，存取和查找其他项非常缓慢\n队列： 先进先出，存取和查找其他项非常缓慢\n散列表（hash）： 则存取极快，插入快。缺点是删除慢，对存储空间使用不充分, 需要解决可能产生的hash冲突。\n图：邻接矩阵或者邻接链表，复杂，不同的存储方式导致查找比较缓慢\n\n\n3. 外部排序方法\n外排序的一个例子是外归并排序（External merge sort），它读入一些能放在内存内的数据量，在内存中排序后输出为一个顺串（即是内部数据有序的临时文件），处理完所有的数据后再进行归并。[1][2]比如，要对900 MB的数据进行排序，但机器上只有100 MB的可用内存时，外归并排序按如下方法操作：\n\n    1. 读入100 MB的数据至内存中，用某种常规方式（如快速排序、堆排序、归并排序等方法）在内存中完成排序。\n    2. 将排序完成的数据写入磁盘。\n    3. 读入每个临时文件（顺串）的前10 MB（ = 100 MB / (9块 + 1)）的数据放入内存中的输入缓冲区，最后的10 MB作为输出缓冲区。（实践中，将输入缓冲适当调小，而适当增大输出缓冲区能获得更好的效果。）\n    4. 执行九路归并算法，将结果输出到输出缓冲区。一旦输出缓冲区满，将缓冲区中的数据写出至目标文件，清空缓冲区。一旦9个输入缓冲区中的一个变空，就从这个缓冲区关联的文件，读入下一个10M数据，除非这个文件已读完。这是“外归并排序”能在主存外完成排序的关键步骤 -- 因为“归并算法”(merge algorithm)对每一个大块只是顺序地做一轮访问(进行归并)，每个大块不用完全载入主存。\n\n为了增加每一个有序的临时文件的长度，可以采用置换选择排序（Replacement selection sorting）。它可以产生大于内存大小的顺串。具体方法是在内存中使用一个最小堆进行排序，设该最小堆的大小为{\\displaystyle M}M。算法描述如下：\n\n    1. 初始时将输入文件读入内存，建立最小堆。\n    2. 将堆顶元素输出至输出缓冲区。然后读入下一个记录：\n        a. 若该元素的关键码值不小于刚输出的关键码值，将其作为堆顶元素并调整堆，使之满足堆的性质；\n        b. 否则将新元素放入堆底位置，将堆的大小减1。\n    3. 重复第2步，直至堆大小变为0。\n    此时一个顺串已经产生。将堆中的所有元素建堆，开始生成下一个顺串。[3]\n    此方法能生成平均长度为{\\displaystyle 2M}2M的顺串，可以进一步减少访问外部存储器的次数，节约时间，提高算法效率。\n\n总结：顺串产生可以用1）小顶堆或者2）划分为多个小文件+各自快速排序产生\n\n\n4. 向数组中追加 K 个整数（lc6017）\n题意，向数组中插入k个数组都没出现过的正整数，如果是插入的和最小\n解决方案：排序数组，然后填充数组的空隙， 使用高斯求和公式得到结果会更快\n易错点：注意的是需要在数组前面和后面加两个哨兵\n\n\n5.lc1539. 第 k 个缺失的正整数 (easy)\n- 一个排序正整数数组，找到缺失的第k个正整数\n- 算法1：为了减少分类讨论，直接在数组前面+一个哨兵节点0， 然后k依次减去相邻两个数中间包含数的个数\n- 算法2：缺失的正整数一定 >= k；数组中每出现一个 <= k 的数字, 意味着少了一个缺失的数字, 此时k+1\n```C++\nfor (int i = 0; i < arr.size(); i++) {\n    if (arr[i] <= k) {\n        k++;\n    }\n}\nreturn k;\n```\n\n6. 414. 第三大的数（easy）\n- 题意：返回第k大的数，相同的数同一level, 如果每个第k大的数，返回第一大\n- 注意数据中可能包含INT_MIN\n- 思路：可以使用排序，可以O(n)， 用三个数a, b, c, 初始化为long INT_MIN\n- 定要注意等于的情况是不更新的，比如等于b, 不会更新c的！！！！\n\n\n7. lc870. 优势洗牌\n- 题意：将nums1和nums2如何进行配对，使得在i, nums1[i]>nums2[i]的对数最大\n- 田忌赛马的思想\n- 使用优先队列，将每个nums2的下标和数据入队\n- 每次弹出nums2的最大的一个，如果当前nums1的最大不能打败当前的数，那么就将nums1的最小和nums2的最大匹配（nums1 index left++）, 否则right-- （更易理解）\n- 或者每次弹出nums2的最小的一个，如果当前nums1的最小不能打败当前的数，那么就将nums1的最小和nums2的最大匹配(此时用优先队列好像不行，可以直接对结构体nums2进行排序), 否则right--\n- “滑动窗口的最大值”，也是使用了优先队列\n\n8. 奇偶稳定排序\n- 将数组的奇数全部排在偶数前面，同时不交换奇数和偶数原本的相对顺序\n- 用一个k来记录前面以及排好序的奇数的个数， 然后每遇到一个奇数，就使用冒泡排序的方法，一个一个的交换到前面去\n```python\ndef reOrderArray(arr):\n    m = len(arr)\n    k = 0 # 记录当前已经排序好的奇数个数\n    for i in range(m):\n        if arr[i] % 2 == 1:\n            j = i\n            while j > k:  # 将奇数移到最前面\n                temp = arr[j]\n                arr[j] = arr[j-1]\n                arr[j-1] = temp\n                j -= 1\n            k += 1 \n    print(arr)\nif __name__ == '__main__':\n    arr = [1,2,5,4,7,6,12]\n    reOrderArray(arr)\n```\n\n\n#### 总结\nok\n\n主要是针对大文件或者多线程情况的下排序，或者数据结构本身的考察\n\n\n\n","source":"_posts/leetcode/排序题.md","raw":"---\ntitle: 排序算法\ncatogory:\n  - leetcode 题目汇总\ncategories:\n  - leetcode\ndate: 2021-11-13 17:22:15\ntags:\n---\n\n#### 堆排序\n##### 堆排序的基本思路\n（每个内部节点，和左右节点对比，往上浮；之后根分别与最后，倒数第二个交换往下沉）\na.先所有的内部节点的每个，从下到上进行往上浮的操作heap_build\nb.然后根节点和最后一个节点交换，然后从根节点向下沉（0,n-1），然后根节点和倒数第二个节点交换，然后往下沉(0,n-2)然后重复上述的过程\n\n也就是先build最大堆，然后逐渐交换，然后重复build\n\n优先队列默认是从大到小进行排序；multiset 基于红黑树实现，默认是从小到大进行排序\npriority<int, vector<int>, greater<int> > q;//最小堆\nmultiset<int, greater<int> > //最大堆\n\n使用归并排序可以求逆序对的数量以及“计算数组的小和”问题: \n特征，如果一个数组中两个元素，nums[i]<nums[j]或者nums[i]>nums[j]再执行某个操作，而且数组元素之间的连续性等没有其他要求，那么使用归并排序计算\n\n```C++\nmerge函数\nwhile (p1 <= mid && p2 <= right)\n    {\n        res += arr[p1] <= arr[p2] ? arr[p1]*(right-p2+1) : 0;\n        help[i++] = arr[p1] <= arr[p2] ? arr[p1++] : arr[p2++];\n    }\n    while (p1 <= mid) help[i++] = arr[p1++];\n    while (p2 <= right) help[i++] = arr[p2++];\n```\n\n\n##### 堆排序的相关例题：\n\n1.打印N个数组的最大TopK (topk类似题使用堆)\n\n用N个最后的元素建立一个最大堆，然后移去堆顶元素，然后用移去元素的下一个元素放在堆顶调整堆，重复上面的过程；\n如果被移去元素数组中没有下一个元素，那么用堆的最后一个元素移到堆顶，让堆的size-1\n\n注意堆排序都是下沉的过程，但是如果向堆中一个一个插入元素，是插入到最后一个位置，heapsize++, 然后上浮过程\n同时也可以先全部放入数组中，然后从内部节点倒叙下沉\n\n*****在进行代码编写的时候，可以不直接实现堆，而是用STL的priority_queue（默认最大堆） ******\n```C++\nstruct node\n{\n    int row;\n    int val; //因为是pop_back所以不用记录下标\n    node(int _r,int _v)\n    {\n        row=_r;\n        val=_v;\n    }\n    bool operator<(const node& b)const\n    {\n        return this->val<b.val;\n    }\n   \n};\npriority_queue<node,vector<node>> heap；\n\n因此这道题的解答方案\n//首先初始化 n个末尾各自的最大元素入堆\n    for(int i=0;i<n;i++)\n    {\n        if(arr[i].size()==0)\n            continue;\n        heap.push(node(i,arr[i][arr[i].size()-1]));\n        arr[i].pop_back();//最后一个元素入堆\n    }\n    //开始从末尾遍历\n   for(int i=0;i<k;i++)  //从堆中选举k个最大的元素\n   {\n       cout<<heap.top().val<<\" \";//打印出最大的那个元素\n       int row=heap.top().row;//那个元素所在行\n       heap.pop();\n       if(arr[row].size()>0) //最大的那个元素弹出后 用所在行的下一个元素顶上（因为第二大元素一定在已有的元素 + 下一个顶上的元素 中产生）\n       {\n           heap.push(node(row,arr[row][arr[row].size()-1]));//下一个接替的node\n           arr[row].pop_back();\n       }\n   }\n```\n\nPS:类似的一个题：两个有序数组的整体中位数（或者第K位数）\n1.使用归并排序，但是只需要记录一个pre cur O(n/2)\n2.使用类似二分的删除的方法，先求出中位数的位置k\n然后比较两个数组nums1[k/2] nums2[k/2]，较小的那个数组，直接跳过k/2个数 index_next=before_index + k/2\n\n\n##### 补充知识：\npriority_queue的自定义排序函数：\nhttps://www.cnblogs.com/shona/p/12163381.html 记住priority_queue排序大小和排序函数都是和正常反着的\n建议使用struct cmp方式，重载operator < 会报错，如果是在solution 类中重载的话\n\n```C++\nstruct cmp{\n\n    bool operator()(const node &a, const node &b){\n        return a.val>b.val; //从小到大排序\n    }\n};//一定要注意结构体后面添加;\n```\n\n2. 查找和最小的K对数字，使用最大堆，以及每个数组最大循环k次\n\n#### 基数排序和桶排序\n\n时间复杂度为O(n)的排序算法：基数排序和桶排序\n例题：最大间距问题\n桶排序：需要确定桶的数量，然后遍历每一个数，求当前数应该放的桶的位置，有点时候并不一定要明确每个桶里面有哪些数据，只需要知道桶\n里面是否有数据（bucket[i]），以及每个桶里面的最大最小值(max_bucket[i], min_bucket[i])，那么就不需要用二维数组记录每个桶里面的具体数据（如例题），然后遍历桶里面的元素，用当前桶的最小值，减去上一个有数据的桶的最大值\n\n##### 基数排序的主要思想：\n1.每次排序都是从最低位到最高位进行排序，因此求最大数的位数，作为基数排序循环的次数\n2.在每次循环，求当前基数位的count\n3.将count进行累加，求在整个count数组中排列的具体位置\n4.从大到小重复计算count数组的过程，将data数据排好后放入tmp数组 count[k]--\n5.将tmp数组赋值为data数组 基数*10，重复上面的步骤\n```C++\nint maxbit(int data[], int n) //辅助函数，求数据的最大位数\n{\n    int maxData = data[0];              ///< 最大数\n    /// 先求出最大数，再求其位数，这样有原先依次每个数判断其位数，稍微优化点。\n    for (int i = 1; i < n; ++i)\n    {\n        if (maxData < data[i])\n            maxData = data[i];\n    }\n    int d = 1;\n    int p = 10;\n    while (maxData >= p)\n    {\n        //p *= 10; // Maybe overflow\n        maxData /= 10;\n        ++d;\n    }\n    return d;\n}\nvoid radixsort(int data[], int n) //基数排序\n{\n    int d = maxbit(data, n);\n    int *tmp = new int[n];\n    int *count = new int[10]; //计数器\n    int i, j, k;\n    int radix = 1;\n    for(i = 1; i <= d; i++) //进行d次排序\n    {\n        for(j = 0; j < 10; j++)\n            count[j] = 0; //每次分配前清空计数器\n        for(j = 0; j < n; j++)\n        {\n            k = (data[j] / radix) % 10; //统计每个桶中的记录数\n            count[k]++;\n        }\n        for(j = 1; j < 10; j++)\n            count[j] = count[j - 1] + count[j]; //将tmp中的位置依次分配给每个桶\n        for(j = n - 1; j >= 0; j--) //将所有桶中记录依次收集到tmp中\n        {\n            k = (data[j] / radix) % 10;\n            tmp[count[k] - 1] = data[j];\n            count[k]--;\n        }\n        for(j = 0; j < n; j++) //将临时数组的内容复制到data中\n            data[j] = tmp[j];\n        radix = radix * 10;\n    }\n    delete []tmp;\n    delete []count;\n}\n```\n\n\n##### 乱序数据使用多进程进行排序\n每个进程进行各种的快速排序，然后将所有进程排序好的结果进行两两归并\n使用pthread_t 和pthread_create\n``` C++\n struct node s[10];\n    for(int i=0;i<10;i++)\n    {\n        s[i].id = i;\n        s[i].l = i*10;\n        s[i].r = i*10+9;\n    }\n \n    pthread_t t[10];\n    for(int i=0;i<10;i++)\n        pthread_create(&t[i],NULL,__sort,(void *)&s[i]);\n \n    for(int i=0;i<10;i++)\n        pthread_join(t[i],NULL);\n\n[完整代码参考链接](https://blog.csdn.net/Return_nellen/article/details/79937320)\n\n```\n\n##### 桶排序例题\n<font color=red>存在重复元素 III</font>\n使用二分查找（set.lower_bound）和滑动窗口，或者桶排序和滑动窗口，比较经典 \n主要思路：查找当窗口元素中是否存在大于等于nums[i]-t的元素，如果存在，判断这个元素是否是小于等于 nums[i]+t 如果存在返回true;\n如果是桶排序解决，就设定每个桶的大小为t+1 计算每个nums[i]应该在的桶的编号，判断这个桶是否有数据，如果有数据直接返回true； 如果没有，那么判断左右两边桶的数据之间的abs差是否 <=t，同时在\n循环向前的时候记得删除范围大于k的桶里面的数据\n\n感觉使用滑动窗口更好理解，就是查找窗口为k的，是否能够找到当前加入的元素x, [x-t, x+t]范围内的数，而且不是当前的数x,如果能,那么返回true\n\n易错点：\n1.滑动窗口记得删除窗口之外的数据\n2. nums[i]-t可能超出了整数的范围，一定要记得判断范围\n\n\n#### 归并排序\n归并排序一般是求逆序对个数，或者其他规则的逆序对\n比如例题lc493. 翻转对 求i<j, 且nums[i]>2*nums[j]\n- 易错点: 有负数+是大于，因此在求解的时候/2 向上还是向下取整会不同\n- 题解是将求res这个过程单调拎出来计算，之后再进行归并\n```C++\n while(i<=mid){\n    while(j<=right&&(long long)nums[i]>(long long)2*nums[j]) j++; //最好不要转为nums[i]/2> nums[j] 因为负数在取整的时候和正数向上和向下不一样\n    res+=(j-mid-1);\n    i++;\n}\n```\n\n- 方法二：使用树状数组，但是因为数据的范围太大，因此使用hash对数据进行离散化， 对x 2*x 一些列数据排序后，递增给予他们idx 1....\n\n\n\n\n#### 其他排序例题\n1. 寻找两个正序数组的中位数 (寻找两个正序数组的第k个数)\n\n注意k表示的第k个数，而不是下标为k\n同时注意算法是一边在进行移动，而不是两边都移动\n\n```C++\n//时间复杂度log(m+n) 空间复杂度O(1)\nclass Solution {\npublic:\n    double getKthElement(vector<int>& nums1, vector<int>& nums2, int k){\n        int size1 = nums1.size();\n        int size2 = nums2.size();\n        int index1 = 0, index2 = 0; \n        while (true)\n        {\n            if(index1==size1){\n                return nums2[index2 + k - 1];\n            }\n            if(index2==size2){\n                return nums1[index1 + k - 1];\n            }\n            if(k==1){\n                return min(nums1[index1], nums2[index2]);\n            }\n            int newIndex1 = min(index1 + k / 2 - 1, size1 - 1);\n            int newIndex2 = min(index2 + k / 2 - 1, size2 - 1);\n            int pivot1 = nums1[newIndex1];\n            int pivot2 = nums2[newIndex2];\n            \n            if(pivot1<=pivot2){\n                \n                k = k - (newIndex1 - index1 + 1);\n                index1 = newIndex1 + 1;\n            }else{\n                \n                k = k - (newIndex2 - index2 + 1);\n                index2 = newIndex2 + 1;\n            }\n            cout<<pivot1<<\" \"<<pivot2<<endl;\n            \n        }\n        \n    }\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        int size1 = nums1.size();\n        int size2 = nums2.size();\n        int sum = size1 + size2;\n        if(sum%2==0){\n            return (getKthElement(nums1, nums2, sum / 2) + getKthElement(nums1, nums2, sum / 2 +1)) / 2;\n        }else{\n            cout<<sum/2+1<<endl;\n            return getKthElement(nums1, nums2, sum / 2+1);\n        }\n    }\n};\n\n ```\n\n 2. 排序和优先队列结合！！\n两个最好的不重叠活动\n步骤：\n- 先将活动按起始时间从小到大进行排序\n- 维护一个最小堆，堆内元素代表活动的结束时间和对应价值(结束时间越早的越先弹出)\n- 遍历所有活动，如果堆内的活动结束时间小于当前活动的起始时间，又因为活动时间是从小到大进行排序的，所以当前堆内的活动是可以与后面任意活动一起参与的，因此我们可以维护maxVal记录下当前活动开始前，我们可以选择的最大价值\n\n\n#### 快速排序\n快速排序模板题\n```C++\n void quickSort(vector<int>&  nums, int left, int right){\n        while(left>=right){\n            return;\n        }\n        int rand_num= rand()%(right-left+1)+left;\n        int pivot=nums[rand_num];\n        swap(nums[rand_num],nums[left]);\n        int l=left;\n        int r=right;\n        while(l<r){\n            while(l<r&&nums[r]>=pivot){\n                r--;\n            }\n            while(l<r&&nums[l]<=pivot){\n                l++;\n            }\n            if(l<r){\n                swap(nums[l], nums[r]);\n            }\n\n        }\n        swap(nums[left], nums[l]);\n        quickSort(nums, left, l-1);\n        quickSort(nums, l+1, right);\n    }\n    vector<int> sortArray(vector<int>& nums) {\n        int num_len=nums.size();\n        quickSort(nums, 0, num_len-1);\n        return nums;\n    }\n```\n\n快速排序找出第k个数的代码模板，类似于二分\n```C++\nclass Solution {\n    public int minMoves2(int[] nums) {\n        int mid = nums.length / 2;\n        int mid_num = quickSort(nums, mid); //这道题中k为mid\n        int ret = 0;\n        for (int num : nums) {\n            ret += Math.abs(mid_num - num);\n        }\n        return ret;\n    }\n\n    public int quickSort(int[] nums, int k) {\n        int l = 0;\n        int h = nums.length - 1;\n        while (l < h) {\n            int ret = partion(nums, l, h);\n            if (ret == k) {\n                break;\n            }\n            if (ret < k) {\n                l = ret + 1;\n            } else {\n                h = ret - 1; \n            }\n        }\n        return nums[k];\n    }\n\n    public int partion(int[] nums, int l, int h) {\n        int p = new Random().nextInt(h - l + 1) + l; //记住pivot是随机产生\n        int temp = nums[p];\n        nums[p] = nums[l];\n        nums[l] = temp;//交换left和pivot的值\n        \n        //可以如下方式写，也可以，l和r每次交换，最后l和pivot所在的位置交换\n        while (l < h) {\n            while (l < h && nums[h] >= temp) { //注意等于也要走，因为如果不，就可能导致在中间出现死循环\n                h--;\n            }\n            nums[l] = nums[h];\n            while (l < h && nums[l] <= temp) {\n                l++;\n            }\n            nums[h] = nums[l];\n        }\n        nums[l] = temp;\n        return l;\n    }\n}\n```\n使用快速排序找到第k个数， 同时考虑结构体(在进行比较的时候使用second, 同时pivot也是second的值)的这种情况， 注意比较value, 但是交换的时候使用index\n```C++\n    void qsort(vector<pair<int, int>>& v, int start, int end, vector<int>& ret, int k) {\n        int picked = rand() % (end - start + 1) + start;\n        swap(v[picked], v[start]);\n\n        int pivot = v[start].second;\n        int index = start;\n        for (int i = start + 1; i <= end; i++) {\n            if (v[i].second >= pivot) {\n                swap(v[index + 1], v[i]);\n                index++;\n            }\n        }\n        swap(v[start], v[index]);\n\n        if (k <= index - start) {\n            qsort(v, start, index - 1, ret, k);\n        } else {\n            for (int i = start; i <= index; i++) {\n                ret.push_back(v[i].first);\n            }\n            if (k > index - start + 1) {\n                qsort(v, index + 1, end, ret, k - (index - start + 1));\n            }\n        }\n    }\n\n```\n\n#### 各种排序算法的总结链接：\nhttps://www.runoob.com/w3cnote/ten-sorting-algorithm.html\n快速排序的额外空间复杂度是O(logn)， 因为每次递归只使用运用了常数时间的额外空间\n\n\n1. 常见算法的稳定性（要记住）\n\n不稳定排序算法： 堆排序、快速排序、希尔排序、选择排序 （快选西堆）\n\n稳定排序算法： 基数排序、冒泡排序、插入排序、归并排序 （极差归帽（0））\n\n\n计数排序的时间复杂度是O(n+k), 空间复杂度为O(k) \n桶排序 O(n+k) 先分桶再快排 O(n+k)//count+tmp数组\n基数排序  O(nxk) O(n+k)\n\n\n2. 比较各种数据结构\n数组 插入慢，删除慢，查找慢（通过下标获取快）， 空间连续且固定\n链表 插入快，删除快， 查找慢， 物理空间不连续，同时方便扩容\n二叉树： 查找、插入、删除都快（如果树保持平衡）。缺点是删除算法复杂。\n堆： 堆是一种特殊的完全二叉树\n栈：后进先出，存取和查找其他项非常缓慢\n队列： 先进先出，存取和查找其他项非常缓慢\n散列表（hash）： 则存取极快，插入快。缺点是删除慢，对存储空间使用不充分, 需要解决可能产生的hash冲突。\n图：邻接矩阵或者邻接链表，复杂，不同的存储方式导致查找比较缓慢\n\n\n3. 外部排序方法\n外排序的一个例子是外归并排序（External merge sort），它读入一些能放在内存内的数据量，在内存中排序后输出为一个顺串（即是内部数据有序的临时文件），处理完所有的数据后再进行归并。[1][2]比如，要对900 MB的数据进行排序，但机器上只有100 MB的可用内存时，外归并排序按如下方法操作：\n\n    1. 读入100 MB的数据至内存中，用某种常规方式（如快速排序、堆排序、归并排序等方法）在内存中完成排序。\n    2. 将排序完成的数据写入磁盘。\n    3. 读入每个临时文件（顺串）的前10 MB（ = 100 MB / (9块 + 1)）的数据放入内存中的输入缓冲区，最后的10 MB作为输出缓冲区。（实践中，将输入缓冲适当调小，而适当增大输出缓冲区能获得更好的效果。）\n    4. 执行九路归并算法，将结果输出到输出缓冲区。一旦输出缓冲区满，将缓冲区中的数据写出至目标文件，清空缓冲区。一旦9个输入缓冲区中的一个变空，就从这个缓冲区关联的文件，读入下一个10M数据，除非这个文件已读完。这是“外归并排序”能在主存外完成排序的关键步骤 -- 因为“归并算法”(merge algorithm)对每一个大块只是顺序地做一轮访问(进行归并)，每个大块不用完全载入主存。\n\n为了增加每一个有序的临时文件的长度，可以采用置换选择排序（Replacement selection sorting）。它可以产生大于内存大小的顺串。具体方法是在内存中使用一个最小堆进行排序，设该最小堆的大小为{\\displaystyle M}M。算法描述如下：\n\n    1. 初始时将输入文件读入内存，建立最小堆。\n    2. 将堆顶元素输出至输出缓冲区。然后读入下一个记录：\n        a. 若该元素的关键码值不小于刚输出的关键码值，将其作为堆顶元素并调整堆，使之满足堆的性质；\n        b. 否则将新元素放入堆底位置，将堆的大小减1。\n    3. 重复第2步，直至堆大小变为0。\n    此时一个顺串已经产生。将堆中的所有元素建堆，开始生成下一个顺串。[3]\n    此方法能生成平均长度为{\\displaystyle 2M}2M的顺串，可以进一步减少访问外部存储器的次数，节约时间，提高算法效率。\n\n总结：顺串产生可以用1）小顶堆或者2）划分为多个小文件+各自快速排序产生\n\n\n4. 向数组中追加 K 个整数（lc6017）\n题意，向数组中插入k个数组都没出现过的正整数，如果是插入的和最小\n解决方案：排序数组，然后填充数组的空隙， 使用高斯求和公式得到结果会更快\n易错点：注意的是需要在数组前面和后面加两个哨兵\n\n\n5.lc1539. 第 k 个缺失的正整数 (easy)\n- 一个排序正整数数组，找到缺失的第k个正整数\n- 算法1：为了减少分类讨论，直接在数组前面+一个哨兵节点0， 然后k依次减去相邻两个数中间包含数的个数\n- 算法2：缺失的正整数一定 >= k；数组中每出现一个 <= k 的数字, 意味着少了一个缺失的数字, 此时k+1\n```C++\nfor (int i = 0; i < arr.size(); i++) {\n    if (arr[i] <= k) {\n        k++;\n    }\n}\nreturn k;\n```\n\n6. 414. 第三大的数（easy）\n- 题意：返回第k大的数，相同的数同一level, 如果每个第k大的数，返回第一大\n- 注意数据中可能包含INT_MIN\n- 思路：可以使用排序，可以O(n)， 用三个数a, b, c, 初始化为long INT_MIN\n- 定要注意等于的情况是不更新的，比如等于b, 不会更新c的！！！！\n\n\n7. lc870. 优势洗牌\n- 题意：将nums1和nums2如何进行配对，使得在i, nums1[i]>nums2[i]的对数最大\n- 田忌赛马的思想\n- 使用优先队列，将每个nums2的下标和数据入队\n- 每次弹出nums2的最大的一个，如果当前nums1的最大不能打败当前的数，那么就将nums1的最小和nums2的最大匹配（nums1 index left++）, 否则right-- （更易理解）\n- 或者每次弹出nums2的最小的一个，如果当前nums1的最小不能打败当前的数，那么就将nums1的最小和nums2的最大匹配(此时用优先队列好像不行，可以直接对结构体nums2进行排序), 否则right--\n- “滑动窗口的最大值”，也是使用了优先队列\n\n8. 奇偶稳定排序\n- 将数组的奇数全部排在偶数前面，同时不交换奇数和偶数原本的相对顺序\n- 用一个k来记录前面以及排好序的奇数的个数， 然后每遇到一个奇数，就使用冒泡排序的方法，一个一个的交换到前面去\n```python\ndef reOrderArray(arr):\n    m = len(arr)\n    k = 0 # 记录当前已经排序好的奇数个数\n    for i in range(m):\n        if arr[i] % 2 == 1:\n            j = i\n            while j > k:  # 将奇数移到最前面\n                temp = arr[j]\n                arr[j] = arr[j-1]\n                arr[j-1] = temp\n                j -= 1\n            k += 1 \n    print(arr)\nif __name__ == '__main__':\n    arr = [1,2,5,4,7,6,12]\n    reOrderArray(arr)\n```\n\n\n#### 总结\nok\n\n主要是针对大文件或者多线程情况的下排序，或者数据结构本身的考察\n\n\n\n","slug":"leetcode/排序题","published":1,"updated":"2023-07-10T10:36:19.573Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clk5ceinq000tjpjb0rjx1cja","content":"<h4 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h4><h5 id=\"堆排序的基本思路\"><a href=\"#堆排序的基本思路\" class=\"headerlink\" title=\"堆排序的基本思路\"></a>堆排序的基本思路</h5><p>（每个内部节点，和左右节点对比，往上浮；之后根分别与最后，倒数第二个交换往下沉）<br>a.先所有的内部节点的每个，从下到上进行往上浮的操作heap_build<br>b.然后根节点和最后一个节点交换，然后从根节点向下沉（0,n-1），然后根节点和倒数第二个节点交换，然后往下沉(0,n-2)然后重复上述的过程</p>\n<p>也就是先build最大堆，然后逐渐交换，然后重复build</p>\n<p>优先队列默认是从大到小进行排序；multiset 基于红黑树实现，默认是从小到大进行排序<br>priority&lt;int, vector<int>, greater<int> &gt; q;//最小堆<br>multiset&lt;int, greater<int> &gt; //最大堆</int></int></int></p>\n<p>使用归并排序可以求逆序对的数量以及“计算数组的小和”问题:<br>特征，如果一个数组中两个元素，nums[i]&lt;nums[j]或者nums[i]&gt;nums[j]再执行某个操作，而且数组元素之间的连续性等没有其他要求，那么使用归并排序计算</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">merge函数<br><span class=\"hljs-keyword\">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= right)<br>    &#123;<br>        res += arr[p1] &lt;= arr[p2] ? arr[p1]*(right-p2+<span class=\"hljs-number\">1</span>) : <span class=\"hljs-number\">0</span>;<br>        help[i++] = arr[p1] &lt;= arr[p2] ? arr[p1++] : arr[p2++];<br>    &#125;<br>    <span class=\"hljs-keyword\">while</span> (p1 &lt;= mid) help[i++] = arr[p1++];<br>    <span class=\"hljs-keyword\">while</span> (p2 &lt;= right) help[i++] = arr[p2++];<br></code></pre></td></tr></table></figure>\n\n\n<h5 id=\"堆排序的相关例题：\"><a href=\"#堆排序的相关例题：\" class=\"headerlink\" title=\"堆排序的相关例题：\"></a>堆排序的相关例题：</h5><p>1.打印N个数组的最大TopK (topk类似题使用堆)</p>\n<p>用N个最后的元素建立一个最大堆，然后移去堆顶元素，然后用移去元素的下一个元素放在堆顶调整堆，重复上面的过程；<br>如果被移去元素数组中没有下一个元素，那么用堆的最后一个元素移到堆顶，让堆的size-1</p>\n<p>注意堆排序都是下沉的过程，但是如果向堆中一个一个插入元素，是插入到最后一个位置，heapsize++, 然后上浮过程<br>同时也可以先全部放入数组中，然后从内部节点倒叙下沉</p>\n<p>*****在进行代码编写的时候，可以不直接实现堆，而是用STL的priority_queue（默认最大堆） ******</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">node</span></span><br><span class=\"hljs-class\">&#123;</span><br>    <span class=\"hljs-keyword\">int</span> row;<br>    <span class=\"hljs-keyword\">int</span> val; <span class=\"hljs-comment\">//因为是pop_back所以不用记录下标</span><br>    <span class=\"hljs-built_in\">node</span>(<span class=\"hljs-keyword\">int</span> _r,<span class=\"hljs-keyword\">int</span> _v)<br>    &#123;<br>        row=_r;<br>        val=_v;<br>    &#125;<br>    <span class=\"hljs-keyword\">bool</span> <span class=\"hljs-keyword\">operator</span>&lt;(<span class=\"hljs-keyword\">const</span> node&amp; b)<span class=\"hljs-keyword\">const</span><br>    &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>-&gt;val&lt;b.val;<br>    &#125;<br>   <br>&#125;;<br>priority_queue&lt;node,vector&lt;node&gt;&gt; heap；<br><br>因此这道题的解答方案<br><span class=\"hljs-comment\">//首先初始化 n个末尾各自的最大元素入堆</span><br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;n;i++)<br>    &#123;<br>        <span class=\"hljs-keyword\">if</span>(arr[i].<span class=\"hljs-built_in\">size</span>()==<span class=\"hljs-number\">0</span>)<br>            <span class=\"hljs-keyword\">continue</span>;<br>        heap.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-built_in\">node</span>(i,arr[i][arr[i].<span class=\"hljs-built_in\">size</span>()<span class=\"hljs-number\">-1</span>]));<br>        arr[i].<span class=\"hljs-built_in\">pop_back</span>();<span class=\"hljs-comment\">//最后一个元素入堆</span><br>    &#125;<br>    <span class=\"hljs-comment\">//开始从末尾遍历</span><br>   <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;k;i++)  <span class=\"hljs-comment\">//从堆中选举k个最大的元素</span><br>   &#123;<br>       cout&lt;&lt;heap.<span class=\"hljs-built_in\">top</span>().val&lt;&lt;<span class=\"hljs-string\">&quot; &quot;</span>;<span class=\"hljs-comment\">//打印出最大的那个元素</span><br>       <span class=\"hljs-keyword\">int</span> row=heap.<span class=\"hljs-built_in\">top</span>().row;<span class=\"hljs-comment\">//那个元素所在行</span><br>       heap.<span class=\"hljs-built_in\">pop</span>();<br>       <span class=\"hljs-keyword\">if</span>(arr[row].<span class=\"hljs-built_in\">size</span>()&gt;<span class=\"hljs-number\">0</span>) <span class=\"hljs-comment\">//最大的那个元素弹出后 用所在行的下一个元素顶上（因为第二大元素一定在已有的元素 + 下一个顶上的元素 中产生）</span><br>       &#123;<br>           heap.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-built_in\">node</span>(row,arr[row][arr[row].<span class=\"hljs-built_in\">size</span>()<span class=\"hljs-number\">-1</span>]));<span class=\"hljs-comment\">//下一个接替的node</span><br>           arr[row].<span class=\"hljs-built_in\">pop_back</span>();<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>\n\n<p>PS:类似的一个题：两个有序数组的整体中位数（或者第K位数）<br>1.使用归并排序，但是只需要记录一个pre cur O(n/2)<br>2.使用类似二分的删除的方法，先求出中位数的位置k<br>然后比较两个数组nums1[k/2] nums2[k/2]，较小的那个数组，直接跳过k/2个数 index_next=before_index + k/2</p>\n<h5 id=\"补充知识：\"><a href=\"#补充知识：\" class=\"headerlink\" title=\"补充知识：\"></a>补充知识：</h5><p>priority_queue的自定义排序函数：<br><a href=\"https://www.cnblogs.com/shona/p/12163381.html\">https://www.cnblogs.com/shona/p/12163381.html</a> 记住priority_queue排序大小和排序函数都是和正常反着的<br>建议使用struct cmp方式，重载operator &lt; 会报错，如果是在solution 类中重载的话</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">cmp</span>&#123;</span><br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">bool</span> <span class=\"hljs-title\">operator</span><span class=\"hljs-params\">()</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> node &amp;a, <span class=\"hljs-keyword\">const</span> node &amp;b)</span></span>&#123;<br>        <span class=\"hljs-keyword\">return</span> a.val&gt;b.val; <span class=\"hljs-comment\">//从小到大排序</span><br>    &#125;<br>&#125;;<span class=\"hljs-comment\">//一定要注意结构体后面添加;</span><br></code></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>查找和最小的K对数字，使用最大堆，以及每个数组最大循环k次</li>\n</ol>\n<h4 id=\"基数排序和桶排序\"><a href=\"#基数排序和桶排序\" class=\"headerlink\" title=\"基数排序和桶排序\"></a>基数排序和桶排序</h4><p>时间复杂度为O(n)的排序算法：基数排序和桶排序<br>例题：最大间距问题<br>桶排序：需要确定桶的数量，然后遍历每一个数，求当前数应该放的桶的位置，有点时候并不一定要明确每个桶里面有哪些数据，只需要知道桶<br>里面是否有数据（bucket[i]），以及每个桶里面的最大最小值(max_bucket[i], min_bucket[i])，那么就不需要用二维数组记录每个桶里面的具体数据（如例题），然后遍历桶里面的元素，用当前桶的最小值，减去上一个有数据的桶的最大值</p>\n<h5 id=\"基数排序的主要思想：\"><a href=\"#基数排序的主要思想：\" class=\"headerlink\" title=\"基数排序的主要思想：\"></a>基数排序的主要思想：</h5><p>1.每次排序都是从最低位到最高位进行排序，因此求最大数的位数，作为基数排序循环的次数<br>2.在每次循环，求当前基数位的count<br>3.将count进行累加，求在整个count数组中排列的具体位置<br>4.从大到小重复计算count数组的过程，将data数据排好后放入tmp数组 count[k]–<br>5.将tmp数组赋值为data数组 基数*10，重复上面的步骤</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">maxbit</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> data[], <span class=\"hljs-keyword\">int</span> n)</span> <span class=\"hljs-comment\">//辅助函数，求数据的最大位数</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">int</span> maxData = data[<span class=\"hljs-number\">0</span>];              <span class=\"hljs-comment\">///&lt; 最大数</span><br>    <span class=\"hljs-comment\">/// 先求出最大数，再求其位数，这样有原先依次每个数判断其位数，稍微优化点。</span><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt; n; ++i)<br>    &#123;<br>        <span class=\"hljs-keyword\">if</span> (maxData &lt; data[i])<br>            maxData = data[i];<br>    &#125;<br>    <span class=\"hljs-keyword\">int</span> d = <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">int</span> p = <span class=\"hljs-number\">10</span>;<br>    <span class=\"hljs-keyword\">while</span> (maxData &gt;= p)<br>    &#123;<br>        <span class=\"hljs-comment\">//p *= 10; // Maybe overflow</span><br>        maxData /= <span class=\"hljs-number\">10</span>;<br>        ++d;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> d;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">radixsort</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> data[], <span class=\"hljs-keyword\">int</span> n)</span> <span class=\"hljs-comment\">//基数排序</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">int</span> d = <span class=\"hljs-built_in\">maxbit</span>(data, n);<br>    <span class=\"hljs-keyword\">int</span> *tmp = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[n];<br>    <span class=\"hljs-keyword\">int</span> *count = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[<span class=\"hljs-number\">10</span>]; <span class=\"hljs-comment\">//计数器</span><br>    <span class=\"hljs-keyword\">int</span> i, j, k;<br>    <span class=\"hljs-keyword\">int</span> radix = <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">for</span>(i = <span class=\"hljs-number\">1</span>; i &lt;= d; i++) <span class=\"hljs-comment\">//进行d次排序</span><br>    &#123;<br>        <span class=\"hljs-keyword\">for</span>(j = <span class=\"hljs-number\">0</span>; j &lt; <span class=\"hljs-number\">10</span>; j++)<br>            count[j] = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">//每次分配前清空计数器</span><br>        <span class=\"hljs-keyword\">for</span>(j = <span class=\"hljs-number\">0</span>; j &lt; n; j++)<br>        &#123;<br>            k = (data[j] / radix) % <span class=\"hljs-number\">10</span>; <span class=\"hljs-comment\">//统计每个桶中的记录数</span><br>            count[k]++;<br>        &#125;<br>        <span class=\"hljs-keyword\">for</span>(j = <span class=\"hljs-number\">1</span>; j &lt; <span class=\"hljs-number\">10</span>; j++)<br>            count[j] = count[j - <span class=\"hljs-number\">1</span>] + count[j]; <span class=\"hljs-comment\">//将tmp中的位置依次分配给每个桶</span><br>        <span class=\"hljs-keyword\">for</span>(j = n - <span class=\"hljs-number\">1</span>; j &gt;= <span class=\"hljs-number\">0</span>; j--) <span class=\"hljs-comment\">//将所有桶中记录依次收集到tmp中</span><br>        &#123;<br>            k = (data[j] / radix) % <span class=\"hljs-number\">10</span>;<br>            tmp[count[k] - <span class=\"hljs-number\">1</span>] = data[j];<br>            count[k]--;<br>        &#125;<br>        <span class=\"hljs-keyword\">for</span>(j = <span class=\"hljs-number\">0</span>; j &lt; n; j++) <span class=\"hljs-comment\">//将临时数组的内容复制到data中</span><br>            data[j] = tmp[j];<br>        radix = radix * <span class=\"hljs-number\">10</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">delete</span> []tmp;<br>    <span class=\"hljs-keyword\">delete</span> []count;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n<h5 id=\"乱序数据使用多进程进行排序\"><a href=\"#乱序数据使用多进程进行排序\" class=\"headerlink\" title=\"乱序数据使用多进程进行排序\"></a>乱序数据使用多进程进行排序</h5><p>每个进程进行各种的快速排序，然后将所有进程排序好的结果进行两两归并<br>使用pthread_t 和pthread_create</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">node</span> <span class=\"hljs-title\">s</span>[10];</span><br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;<span class=\"hljs-number\">10</span>;i++)<br>    &#123;<br>        s[i].id = i;<br>        s[i].l = i*<span class=\"hljs-number\">10</span>;<br>        s[i].r = i*<span class=\"hljs-number\">10</span>+<span class=\"hljs-number\">9</span>;<br>    &#125;<br> <br>    <span class=\"hljs-keyword\">pthread_t</span> t[<span class=\"hljs-number\">10</span>];<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;<span class=\"hljs-number\">10</span>;i++)<br>        <span class=\"hljs-built_in\">pthread_create</span>(&amp;t[i],<span class=\"hljs-literal\">NULL</span>,__sort,(<span class=\"hljs-keyword\">void</span> *)&amp;s[i]);<br> <br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;<span class=\"hljs-number\">10</span>;i++)<br>        <span class=\"hljs-built_in\">pthread_join</span>(t[i],<span class=\"hljs-literal\">NULL</span>);<br><br>[完整代码参考链接](https:<span class=\"hljs-comment\">//blog.csdn.net/Return_nellen/article/details/79937320)</span><br><br></code></pre></td></tr></table></figure>\n\n<h5 id=\"桶排序例题\"><a href=\"#桶排序例题\" class=\"headerlink\" title=\"桶排序例题\"></a>桶排序例题</h5><p><font color=\"red\">存在重复元素 III</font><br>使用二分查找（set.lower_bound）和滑动窗口，或者桶排序和滑动窗口，比较经典<br>主要思路：查找当窗口元素中是否存在大于等于nums[i]-t的元素，如果存在，判断这个元素是否是小于等于 nums[i]+t 如果存在返回true;<br>如果是桶排序解决，就设定每个桶的大小为t+1 计算每个nums[i]应该在的桶的编号，判断这个桶是否有数据，如果有数据直接返回true； 如果没有，那么判断左右两边桶的数据之间的abs差是否 &lt;=t，同时在<br>循环向前的时候记得删除范围大于k的桶里面的数据</p>\n<p>感觉使用滑动窗口更好理解，就是查找窗口为k的，是否能够找到当前加入的元素x, [x-t, x+t]范围内的数，而且不是当前的数x,如果能,那么返回true</p>\n<p>易错点：<br>1.滑动窗口记得删除窗口之外的数据<br>2. nums[i]-t可能超出了整数的范围，一定要记得判断范围</p>\n<h4 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h4><p>归并排序一般是求逆序对个数，或者其他规则的逆序对<br>比如例题lc493. 翻转对 求i&lt;j, 且nums[i]&gt;2*nums[j]</p>\n<ul>\n<li><p>易错点: 有负数+是大于，因此在求解的时候/2 向上还是向下取整会不同</p>\n</li>\n<li><p>题解是将求res这个过程单调拎出来计算，之后再进行归并</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"> <span class=\"hljs-keyword\">while</span>(i&lt;=mid)&#123;<br>    <span class=\"hljs-keyword\">while</span>(j&lt;=right&amp;&amp;(<span class=\"hljs-keyword\">long</span> <span class=\"hljs-keyword\">long</span>)nums[i]&gt;(<span class=\"hljs-keyword\">long</span> <span class=\"hljs-keyword\">long</span>)<span class=\"hljs-number\">2</span>*nums[j]) j++; <span class=\"hljs-comment\">//最好不要转为nums[i]/2&gt; nums[j] 因为负数在取整的时候和正数向上和向下不一样</span><br>    res+=(j-mid<span class=\"hljs-number\">-1</span>);<br>    i++;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li><p>方法二：使用树状数组，但是因为数据的范围太大，因此使用hash对数据进行离散化， 对x 2*x 一些列数据排序后，递增给予他们idx 1….</p>\n</li>\n</ul>\n<h4 id=\"其他排序例题\"><a href=\"#其他排序例题\" class=\"headerlink\" title=\"其他排序例题\"></a>其他排序例题</h4><ol>\n<li>寻找两个正序数组的中位数 (寻找两个正序数组的第k个数)</li>\n</ol>\n<p>注意k表示的第k个数，而不是下标为k<br>同时注意算法是一边在进行移动，而不是两边都移动</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-comment\">//时间复杂度log(m+n) 空间复杂度O(1)</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> &#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">double</span> <span class=\"hljs-title\">getKthElement</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&amp; nums1, vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&amp; nums2, <span class=\"hljs-keyword\">int</span> k)</span></span>&#123;<br>        <span class=\"hljs-keyword\">int</span> size1 = nums1.<span class=\"hljs-built_in\">size</span>();<br>        <span class=\"hljs-keyword\">int</span> size2 = nums2.<span class=\"hljs-built_in\">size</span>();<br>        <span class=\"hljs-keyword\">int</span> index1 = <span class=\"hljs-number\">0</span>, index2 = <span class=\"hljs-number\">0</span>; <br>        <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>)<br>        &#123;<br>            <span class=\"hljs-keyword\">if</span>(index1==size1)&#123;<br>                <span class=\"hljs-keyword\">return</span> nums2[index2 + k - <span class=\"hljs-number\">1</span>];<br>            &#125;<br>            <span class=\"hljs-keyword\">if</span>(index2==size2)&#123;<br>                <span class=\"hljs-keyword\">return</span> nums1[index1 + k - <span class=\"hljs-number\">1</span>];<br>            &#125;<br>            <span class=\"hljs-keyword\">if</span>(k==<span class=\"hljs-number\">1</span>)&#123;<br>                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">min</span>(nums1[index1], nums2[index2]);<br>            &#125;<br>            <span class=\"hljs-keyword\">int</span> newIndex1 = <span class=\"hljs-built_in\">min</span>(index1 + k / <span class=\"hljs-number\">2</span> - <span class=\"hljs-number\">1</span>, size1 - <span class=\"hljs-number\">1</span>);<br>            <span class=\"hljs-keyword\">int</span> newIndex2 = <span class=\"hljs-built_in\">min</span>(index2 + k / <span class=\"hljs-number\">2</span> - <span class=\"hljs-number\">1</span>, size2 - <span class=\"hljs-number\">1</span>);<br>            <span class=\"hljs-keyword\">int</span> pivot1 = nums1[newIndex1];<br>            <span class=\"hljs-keyword\">int</span> pivot2 = nums2[newIndex2];<br>            <br>            <span class=\"hljs-keyword\">if</span>(pivot1&lt;=pivot2)&#123;<br>                <br>                k = k - (newIndex1 - index1 + <span class=\"hljs-number\">1</span>);<br>                index1 = newIndex1 + <span class=\"hljs-number\">1</span>;<br>            &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>                <br>                k = k - (newIndex2 - index2 + <span class=\"hljs-number\">1</span>);<br>                index2 = newIndex2 + <span class=\"hljs-number\">1</span>;<br>            &#125;<br>            cout&lt;&lt;pivot1&lt;&lt;<span class=\"hljs-string\">&quot; &quot;</span>&lt;&lt;pivot2&lt;&lt;endl;<br>            <br>        &#125;<br>        <br>    &#125;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">double</span> <span class=\"hljs-title\">findMedianSortedArrays</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&amp; nums1, vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        <span class=\"hljs-keyword\">int</span> size1 = nums1.<span class=\"hljs-built_in\">size</span>();<br>        <span class=\"hljs-keyword\">int</span> size2 = nums2.<span class=\"hljs-built_in\">size</span>();<br>        <span class=\"hljs-keyword\">int</span> sum = size1 + size2;<br>        <span class=\"hljs-keyword\">if</span>(sum%<span class=\"hljs-number\">2</span>==<span class=\"hljs-number\">0</span>)&#123;<br>            <span class=\"hljs-keyword\">return</span> (<span class=\"hljs-built_in\">getKthElement</span>(nums1, nums2, sum / <span class=\"hljs-number\">2</span>) + <span class=\"hljs-built_in\">getKthElement</span>(nums1, nums2, sum / <span class=\"hljs-number\">2</span> +<span class=\"hljs-number\">1</span>)) / <span class=\"hljs-number\">2</span>;<br>        &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>            cout&lt;&lt;sum/<span class=\"hljs-number\">2</span>+<span class=\"hljs-number\">1</span>&lt;&lt;endl;<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">getKthElement</span>(nums1, nums2, sum / <span class=\"hljs-number\">2</span>+<span class=\"hljs-number\">1</span>);<br>        &#125;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>排序和优先队列结合！！<br>两个最好的不重叠活动<br>步骤：</li>\n</ol>\n<ul>\n<li>先将活动按起始时间从小到大进行排序</li>\n<li>维护一个最小堆，堆内元素代表活动的结束时间和对应价值(结束时间越早的越先弹出)</li>\n<li>遍历所有活动，如果堆内的活动结束时间小于当前活动的起始时间，又因为活动时间是从小到大进行排序的，所以当前堆内的活动是可以与后面任意活动一起参与的，因此我们可以维护maxVal记录下当前活动开始前，我们可以选择的最大价值</li>\n</ul>\n<h4 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h4><p>快速排序模板题</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">quickSort</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&amp;  nums, <span class=\"hljs-keyword\">int</span> left, <span class=\"hljs-keyword\">int</span> right)</span></span>&#123;<br>       <span class=\"hljs-keyword\">while</span>(left&gt;=right)&#123;<br>           <span class=\"hljs-keyword\">return</span>;<br>       &#125;<br>       <span class=\"hljs-keyword\">int</span> rand_num= <span class=\"hljs-built_in\">rand</span>()%(right-left+<span class=\"hljs-number\">1</span>)+left;<br>       <span class=\"hljs-keyword\">int</span> pivot=nums[rand_num];<br>       <span class=\"hljs-built_in\">swap</span>(nums[rand_num],nums[left]);<br>       <span class=\"hljs-keyword\">int</span> l=left;<br>       <span class=\"hljs-keyword\">int</span> r=right;<br>       <span class=\"hljs-keyword\">while</span>(l&lt;r)&#123;<br>           <span class=\"hljs-keyword\">while</span>(l&lt;r&amp;&amp;nums[r]&gt;=pivot)&#123;<br>               r--;<br>           &#125;<br>           <span class=\"hljs-keyword\">while</span>(l&lt;r&amp;&amp;nums[l]&lt;=pivot)&#123;<br>               l++;<br>           &#125;<br>           <span class=\"hljs-keyword\">if</span>(l&lt;r)&#123;<br>               <span class=\"hljs-built_in\">swap</span>(nums[l], nums[r]);<br>           &#125;<br><br>       &#125;<br>       <span class=\"hljs-built_in\">swap</span>(nums[left], nums[l]);<br>       <span class=\"hljs-built_in\">quickSort</span>(nums, left, l<span class=\"hljs-number\">-1</span>);<br>       <span class=\"hljs-built_in\">quickSort</span>(nums, l+<span class=\"hljs-number\">1</span>, right);<br>   &#125;<br>   <span class=\"hljs-function\">vector&lt;<span class=\"hljs-keyword\">int</span>&gt; <span class=\"hljs-title\">sortArray</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;<br>       <span class=\"hljs-keyword\">int</span> num_len=nums.<span class=\"hljs-built_in\">size</span>();<br>       <span class=\"hljs-built_in\">quickSort</span>(nums, <span class=\"hljs-number\">0</span>, num_len<span class=\"hljs-number\">-1</span>);<br>       <span class=\"hljs-keyword\">return</span> nums;<br>   &#125;<br></code></pre></td></tr></table></figure>\n\n<p>快速排序找出第k个数的代码模板，类似于二分</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> &#123;</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">minMoves2</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] nums)</span> </span>&#123;<br>        <span class=\"hljs-keyword\">int</span> mid = nums.length / <span class=\"hljs-number\">2</span>;<br>        <span class=\"hljs-keyword\">int</span> mid_num = <span class=\"hljs-built_in\">quickSort</span>(nums, mid); <span class=\"hljs-comment\">//这道题中k为mid</span><br>        <span class=\"hljs-keyword\">int</span> ret = <span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> num : nums) &#123;<br>            ret += Math.<span class=\"hljs-built_in\">abs</span>(mid_num - num);<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> ret;<br>    &#125;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">quickSort</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] nums, <span class=\"hljs-keyword\">int</span> k)</span> </span>&#123;<br>        <span class=\"hljs-keyword\">int</span> l = <span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-keyword\">int</span> h = nums.length - <span class=\"hljs-number\">1</span>;<br>        <span class=\"hljs-keyword\">while</span> (l &lt; h) &#123;<br>            <span class=\"hljs-keyword\">int</span> ret = <span class=\"hljs-built_in\">partion</span>(nums, l, h);<br>            <span class=\"hljs-keyword\">if</span> (ret == k) &#123;<br>                <span class=\"hljs-keyword\">break</span>;<br>            &#125;<br>            <span class=\"hljs-keyword\">if</span> (ret &lt; k) &#123;<br>                l = ret + <span class=\"hljs-number\">1</span>;<br>            &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>                h = ret - <span class=\"hljs-number\">1</span>; <br>            &#125;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> nums[k];<br>    &#125;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">partion</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] nums, <span class=\"hljs-keyword\">int</span> l, <span class=\"hljs-keyword\">int</span> h)</span> </span>&#123;<br>        <span class=\"hljs-keyword\">int</span> p = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Random</span>().<span class=\"hljs-built_in\">nextInt</span>(h - l + <span class=\"hljs-number\">1</span>) + l; <span class=\"hljs-comment\">//记住pivot是随机产生</span><br>        <span class=\"hljs-keyword\">int</span> temp = nums[p];<br>        nums[p] = nums[l];<br>        nums[l] = temp;<span class=\"hljs-comment\">//交换left和pivot的值</span><br>        <br>        <span class=\"hljs-comment\">//可以如下方式写，也可以，l和r每次交换，最后l和pivot所在的位置交换</span><br>        <span class=\"hljs-keyword\">while</span> (l &lt; h) &#123;<br>            <span class=\"hljs-keyword\">while</span> (l &lt; h &amp;&amp; nums[h] &gt;= temp) &#123; <span class=\"hljs-comment\">//注意等于也要走，因为如果不，就可能导致在中间出现死循环</span><br>                h--;<br>            &#125;<br>            nums[l] = nums[h];<br>            <span class=\"hljs-keyword\">while</span> (l &lt; h &amp;&amp; nums[l] &lt;= temp) &#123;<br>                l++;<br>            &#125;<br>            nums[h] = nums[l];<br>        &#125;<br>        nums[l] = temp;<br>        <span class=\"hljs-keyword\">return</span> l;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>使用快速排序找到第k个数， 同时考虑结构体(在进行比较的时候使用second, 同时pivot也是second的值)的这种情况， 注意比较value, 但是交换的时候使用index</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">qsort</span><span class=\"hljs-params\">(vector&lt;pair&lt;<span class=\"hljs-keyword\">int</span>, <span class=\"hljs-keyword\">int</span>&gt;&gt;&amp; v, <span class=\"hljs-keyword\">int</span> start, <span class=\"hljs-keyword\">int</span> end, vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&amp; ret, <span class=\"hljs-keyword\">int</span> k)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">int</span> picked = <span class=\"hljs-built_in\">rand</span>() % (end - start + <span class=\"hljs-number\">1</span>) + start;<br>    <span class=\"hljs-built_in\">swap</span>(v[picked], v[start]);<br><br>    <span class=\"hljs-keyword\">int</span> pivot = v[start].second;<br>    <span class=\"hljs-keyword\">int</span> index = start;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = start + <span class=\"hljs-number\">1</span>; i &lt;= end; i++) &#123;<br>        <span class=\"hljs-keyword\">if</span> (v[i].second &gt;= pivot) &#123;<br>            <span class=\"hljs-built_in\">swap</span>(v[index + <span class=\"hljs-number\">1</span>], v[i]);<br>            index++;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-built_in\">swap</span>(v[start], v[index]);<br><br>    <span class=\"hljs-keyword\">if</span> (k &lt;= index - start) &#123;<br>        <span class=\"hljs-built_in\">qsort</span>(v, start, index - <span class=\"hljs-number\">1</span>, ret, k);<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = start; i &lt;= index; i++) &#123;<br>            ret.<span class=\"hljs-built_in\">push_back</span>(v[i].first);<br>        &#125;<br>        <span class=\"hljs-keyword\">if</span> (k &gt; index - start + <span class=\"hljs-number\">1</span>) &#123;<br>            <span class=\"hljs-built_in\">qsort</span>(v, index + <span class=\"hljs-number\">1</span>, end, ret, k - (index - start + <span class=\"hljs-number\">1</span>));<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"各种排序算法的总结链接：\"><a href=\"#各种排序算法的总结链接：\" class=\"headerlink\" title=\"各种排序算法的总结链接：\"></a>各种排序算法的总结链接：</h4><p><a href=\"https://www.runoob.com/w3cnote/ten-sorting-algorithm.html\">https://www.runoob.com/w3cnote/ten-sorting-algorithm.html</a><br>快速排序的额外空间复杂度是O(logn)， 因为每次递归只使用运用了常数时间的额外空间</p>\n<ol>\n<li>常见算法的稳定性（要记住）</li>\n</ol>\n<p>不稳定排序算法： 堆排序、快速排序、希尔排序、选择排序 （快选西堆）</p>\n<p>稳定排序算法： 基数排序、冒泡排序、插入排序、归并排序 （极差归帽（0））</p>\n<p>计数排序的时间复杂度是O(n+k), 空间复杂度为O(k)<br>桶排序 O(n+k) 先分桶再快排 O(n+k)//count+tmp数组<br>基数排序  O(nxk) O(n+k)</p>\n<ol start=\"2\">\n<li>比较各种数据结构<br>数组 插入慢，删除慢，查找慢（通过下标获取快）， 空间连续且固定<br>链表 插入快，删除快， 查找慢， 物理空间不连续，同时方便扩容<br>二叉树： 查找、插入、删除都快（如果树保持平衡）。缺点是删除算法复杂。<br>堆： 堆是一种特殊的完全二叉树<br>栈：后进先出，存取和查找其他项非常缓慢<br>队列： 先进先出，存取和查找其他项非常缓慢<br>散列表（hash）： 则存取极快，插入快。缺点是删除慢，对存储空间使用不充分, 需要解决可能产生的hash冲突。<br>图：邻接矩阵或者邻接链表，复杂，不同的存储方式导致查找比较缓慢</li>\n</ol>\n<ol start=\"3\">\n<li><p>外部排序方法<br>外排序的一个例子是外归并排序（External merge sort），它读入一些能放在内存内的数据量，在内存中排序后输出为一个顺串（即是内部数据有序的临时文件），处理完所有的数据后再进行归并。[1][2]比如，要对900 MB的数据进行排序，但机器上只有100 MB的可用内存时，外归并排序按如下方法操作：</p>\n<ol>\n<li>读入100 MB的数据至内存中，用某种常规方式（如快速排序、堆排序、归并排序等方法）在内存中完成排序。</li>\n<li>将排序完成的数据写入磁盘。</li>\n<li>读入每个临时文件（顺串）的前10 MB（ = 100 MB / (9块 + 1)）的数据放入内存中的输入缓冲区，最后的10 MB作为输出缓冲区。（实践中，将输入缓冲适当调小，而适当增大输出缓冲区能获得更好的效果。）</li>\n<li>执行九路归并算法，将结果输出到输出缓冲区。一旦输出缓冲区满，将缓冲区中的数据写出至目标文件，清空缓冲区。一旦9个输入缓冲区中的一个变空，就从这个缓冲区关联的文件，读入下一个10M数据，除非这个文件已读完。这是“外归并排序”能在主存外完成排序的关键步骤 – 因为“归并算法”(merge algorithm)对每一个大块只是顺序地做一轮访问(进行归并)，每个大块不用完全载入主存。</li>\n</ol>\n</li>\n</ol>\n<p>为了增加每一个有序的临时文件的长度，可以采用置换选择排序（Replacement selection sorting）。它可以产生大于内存大小的顺串。具体方法是在内存中使用一个最小堆进行排序，设该最小堆的大小为{\\displaystyle M}M。算法描述如下：</p>\n<pre><code>1. 初始时将输入文件读入内存，建立最小堆。\n2. 将堆顶元素输出至输出缓冲区。然后读入下一个记录：\n    a. 若该元素的关键码值不小于刚输出的关键码值，将其作为堆顶元素并调整堆，使之满足堆的性质；\n    b. 否则将新元素放入堆底位置，将堆的大小减1。\n3. 重复第2步，直至堆大小变为0。\n此时一个顺串已经产生。将堆中的所有元素建堆，开始生成下一个顺串。[3]\n此方法能生成平均长度为&#123;\\displaystyle 2M&#125;2M的顺串，可以进一步减少访问外部存储器的次数，节约时间，提高算法效率。\n</code></pre>\n<p>总结：顺串产生可以用1）小顶堆或者2）划分为多个小文件+各自快速排序产生</p>\n<ol start=\"4\">\n<li>向数组中追加 K 个整数（lc6017）<br>题意，向数组中插入k个数组都没出现过的正整数，如果是插入的和最小<br>解决方案：排序数组，然后填充数组的空隙， 使用高斯求和公式得到结果会更快<br>易错点：注意的是需要在数组前面和后面加两个哨兵</li>\n</ol>\n<p>5.lc1539. 第 k 个缺失的正整数 (easy)</p>\n<ul>\n<li>一个排序正整数数组，找到缺失的第k个正整数</li>\n<li>算法1：为了减少分类讨论，直接在数组前面+一个哨兵节点0， 然后k依次减去相邻两个数中间包含数的个数</li>\n<li>算法2：缺失的正整数一定 &gt;= k；数组中每出现一个 &lt;= k 的数字, 意味着少了一个缺失的数字, 此时k+1<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; arr.<span class=\"hljs-built_in\">size</span>(); i++) &#123;<br>    <span class=\"hljs-keyword\">if</span> (arr[i] &lt;= k) &#123;<br>        k++;<br>    &#125;<br>&#125;<br><span class=\"hljs-keyword\">return</span> k;<br></code></pre></td></tr></table></figure></li>\n</ul>\n<ol start=\"6\">\n<li><ol start=\"414\">\n<li>第三大的数（easy）</li>\n</ol>\n</li>\n</ol>\n<ul>\n<li>题意：返回第k大的数，相同的数同一level, 如果每个第k大的数，返回第一大</li>\n<li>注意数据中可能包含INT_MIN</li>\n<li>思路：可以使用排序，可以O(n)， 用三个数a, b, c, 初始化为long INT_MIN</li>\n<li>定要注意等于的情况是不更新的，比如等于b, 不会更新c的！！！！</li>\n</ul>\n<ol start=\"7\">\n<li>lc870. 优势洗牌</li>\n</ol>\n<ul>\n<li>题意：将nums1和nums2如何进行配对，使得在i, nums1[i]&gt;nums2[i]的对数最大</li>\n<li>田忌赛马的思想</li>\n<li>使用优先队列，将每个nums2的下标和数据入队</li>\n<li>每次弹出nums2的最大的一个，如果当前nums1的最大不能打败当前的数，那么就将nums1的最小和nums2的最大匹配（nums1 index left++）, 否则right– （更易理解）</li>\n<li>或者每次弹出nums2的最小的一个，如果当前nums1的最小不能打败当前的数，那么就将nums1的最小和nums2的最大匹配(此时用优先队列好像不行，可以直接对结构体nums2进行排序), 否则right–</li>\n<li>“滑动窗口的最大值”，也是使用了优先队列</li>\n</ul>\n<ol start=\"8\">\n<li>奇偶稳定排序</li>\n</ol>\n<ul>\n<li>将数组的奇数全部排在偶数前面，同时不交换奇数和偶数原本的相对顺序</li>\n<li>用一个k来记录前面以及排好序的奇数的个数， 然后每遇到一个奇数，就使用冒泡排序的方法，一个一个的交换到前面去<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">reOrderArray</span>(<span class=\"hljs-params\">arr</span>):</span><br>    m = <span class=\"hljs-built_in\">len</span>(arr)<br>    k = <span class=\"hljs-number\">0</span> <span class=\"hljs-comment\"># 记录当前已经排序好的奇数个数</span><br>    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(m):<br>        <span class=\"hljs-keyword\">if</span> arr[i] % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">1</span>:<br>            j = i<br>            <span class=\"hljs-keyword\">while</span> j &gt; k:  <span class=\"hljs-comment\"># 将奇数移到最前面</span><br>                temp = arr[j]<br>                arr[j] = arr[j-<span class=\"hljs-number\">1</span>]<br>                arr[j-<span class=\"hljs-number\">1</span>] = temp<br>                j -= <span class=\"hljs-number\">1</span><br>            k += <span class=\"hljs-number\">1</span> <br>    <span class=\"hljs-built_in\">print</span>(arr)<br><span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&#x27;__main__&#x27;</span>:<br>    arr = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">7</span>,<span class=\"hljs-number\">6</span>,<span class=\"hljs-number\">12</span>]<br>    reOrderArray(arr)<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>ok</p>\n<p>主要是针对大文件或者多线程情况的下排序，或者数据结构本身的考察</p>\n","site":{"data":{}},"wordcount":11035,"excerpt":"","more":"<h4 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h4><h5 id=\"堆排序的基本思路\"><a href=\"#堆排序的基本思路\" class=\"headerlink\" title=\"堆排序的基本思路\"></a>堆排序的基本思路</h5><p>（每个内部节点，和左右节点对比，往上浮；之后根分别与最后，倒数第二个交换往下沉）<br>a.先所有的内部节点的每个，从下到上进行往上浮的操作heap_build<br>b.然后根节点和最后一个节点交换，然后从根节点向下沉（0,n-1），然后根节点和倒数第二个节点交换，然后往下沉(0,n-2)然后重复上述的过程</p>\n<p>也就是先build最大堆，然后逐渐交换，然后重复build</p>\n<p>优先队列默认是从大到小进行排序；multiset 基于红黑树实现，默认是从小到大进行排序<br>priority&lt;int, vector<int>, greater<int> &gt; q;//最小堆<br>multiset&lt;int, greater<int> &gt; //最大堆</int></int></int></p>\n<p>使用归并排序可以求逆序对的数量以及“计算数组的小和”问题:<br>特征，如果一个数组中两个元素，nums[i]&lt;nums[j]或者nums[i]&gt;nums[j]再执行某个操作，而且数组元素之间的连续性等没有其他要求，那么使用归并排序计算</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">merge函数<br><span class=\"hljs-keyword\">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= right)<br>    &#123;<br>        res += arr[p1] &lt;= arr[p2] ? arr[p1]*(right-p2+<span class=\"hljs-number\">1</span>) : <span class=\"hljs-number\">0</span>;<br>        help[i++] = arr[p1] &lt;= arr[p2] ? arr[p1++] : arr[p2++];<br>    &#125;<br>    <span class=\"hljs-keyword\">while</span> (p1 &lt;= mid) help[i++] = arr[p1++];<br>    <span class=\"hljs-keyword\">while</span> (p2 &lt;= right) help[i++] = arr[p2++];<br></code></pre></td></tr></table></figure>\n\n\n<h5 id=\"堆排序的相关例题：\"><a href=\"#堆排序的相关例题：\" class=\"headerlink\" title=\"堆排序的相关例题：\"></a>堆排序的相关例题：</h5><p>1.打印N个数组的最大TopK (topk类似题使用堆)</p>\n<p>用N个最后的元素建立一个最大堆，然后移去堆顶元素，然后用移去元素的下一个元素放在堆顶调整堆，重复上面的过程；<br>如果被移去元素数组中没有下一个元素，那么用堆的最后一个元素移到堆顶，让堆的size-1</p>\n<p>注意堆排序都是下沉的过程，但是如果向堆中一个一个插入元素，是插入到最后一个位置，heapsize++, 然后上浮过程<br>同时也可以先全部放入数组中，然后从内部节点倒叙下沉</p>\n<p>*****在进行代码编写的时候，可以不直接实现堆，而是用STL的priority_queue（默认最大堆） ******</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">node</span></span><br><span class=\"hljs-class\">&#123;</span><br>    <span class=\"hljs-keyword\">int</span> row;<br>    <span class=\"hljs-keyword\">int</span> val; <span class=\"hljs-comment\">//因为是pop_back所以不用记录下标</span><br>    <span class=\"hljs-built_in\">node</span>(<span class=\"hljs-keyword\">int</span> _r,<span class=\"hljs-keyword\">int</span> _v)<br>    &#123;<br>        row=_r;<br>        val=_v;<br>    &#125;<br>    <span class=\"hljs-keyword\">bool</span> <span class=\"hljs-keyword\">operator</span>&lt;(<span class=\"hljs-keyword\">const</span> node&amp; b)<span class=\"hljs-keyword\">const</span><br>    &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>-&gt;val&lt;b.val;<br>    &#125;<br>   <br>&#125;;<br>priority_queue&lt;node,vector&lt;node&gt;&gt; heap；<br><br>因此这道题的解答方案<br><span class=\"hljs-comment\">//首先初始化 n个末尾各自的最大元素入堆</span><br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;n;i++)<br>    &#123;<br>        <span class=\"hljs-keyword\">if</span>(arr[i].<span class=\"hljs-built_in\">size</span>()==<span class=\"hljs-number\">0</span>)<br>            <span class=\"hljs-keyword\">continue</span>;<br>        heap.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-built_in\">node</span>(i,arr[i][arr[i].<span class=\"hljs-built_in\">size</span>()<span class=\"hljs-number\">-1</span>]));<br>        arr[i].<span class=\"hljs-built_in\">pop_back</span>();<span class=\"hljs-comment\">//最后一个元素入堆</span><br>    &#125;<br>    <span class=\"hljs-comment\">//开始从末尾遍历</span><br>   <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;k;i++)  <span class=\"hljs-comment\">//从堆中选举k个最大的元素</span><br>   &#123;<br>       cout&lt;&lt;heap.<span class=\"hljs-built_in\">top</span>().val&lt;&lt;<span class=\"hljs-string\">&quot; &quot;</span>;<span class=\"hljs-comment\">//打印出最大的那个元素</span><br>       <span class=\"hljs-keyword\">int</span> row=heap.<span class=\"hljs-built_in\">top</span>().row;<span class=\"hljs-comment\">//那个元素所在行</span><br>       heap.<span class=\"hljs-built_in\">pop</span>();<br>       <span class=\"hljs-keyword\">if</span>(arr[row].<span class=\"hljs-built_in\">size</span>()&gt;<span class=\"hljs-number\">0</span>) <span class=\"hljs-comment\">//最大的那个元素弹出后 用所在行的下一个元素顶上（因为第二大元素一定在已有的元素 + 下一个顶上的元素 中产生）</span><br>       &#123;<br>           heap.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-built_in\">node</span>(row,arr[row][arr[row].<span class=\"hljs-built_in\">size</span>()<span class=\"hljs-number\">-1</span>]));<span class=\"hljs-comment\">//下一个接替的node</span><br>           arr[row].<span class=\"hljs-built_in\">pop_back</span>();<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>\n\n<p>PS:类似的一个题：两个有序数组的整体中位数（或者第K位数）<br>1.使用归并排序，但是只需要记录一个pre cur O(n/2)<br>2.使用类似二分的删除的方法，先求出中位数的位置k<br>然后比较两个数组nums1[k/2] nums2[k/2]，较小的那个数组，直接跳过k/2个数 index_next=before_index + k/2</p>\n<h5 id=\"补充知识：\"><a href=\"#补充知识：\" class=\"headerlink\" title=\"补充知识：\"></a>补充知识：</h5><p>priority_queue的自定义排序函数：<br><a href=\"https://www.cnblogs.com/shona/p/12163381.html\">https://www.cnblogs.com/shona/p/12163381.html</a> 记住priority_queue排序大小和排序函数都是和正常反着的<br>建议使用struct cmp方式，重载operator &lt; 会报错，如果是在solution 类中重载的话</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">cmp</span>&#123;</span><br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">bool</span> <span class=\"hljs-title\">operator</span><span class=\"hljs-params\">()</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> node &amp;a, <span class=\"hljs-keyword\">const</span> node &amp;b)</span></span>&#123;<br>        <span class=\"hljs-keyword\">return</span> a.val&gt;b.val; <span class=\"hljs-comment\">//从小到大排序</span><br>    &#125;<br>&#125;;<span class=\"hljs-comment\">//一定要注意结构体后面添加;</span><br></code></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>查找和最小的K对数字，使用最大堆，以及每个数组最大循环k次</li>\n</ol>\n<h4 id=\"基数排序和桶排序\"><a href=\"#基数排序和桶排序\" class=\"headerlink\" title=\"基数排序和桶排序\"></a>基数排序和桶排序</h4><p>时间复杂度为O(n)的排序算法：基数排序和桶排序<br>例题：最大间距问题<br>桶排序：需要确定桶的数量，然后遍历每一个数，求当前数应该放的桶的位置，有点时候并不一定要明确每个桶里面有哪些数据，只需要知道桶<br>里面是否有数据（bucket[i]），以及每个桶里面的最大最小值(max_bucket[i], min_bucket[i])，那么就不需要用二维数组记录每个桶里面的具体数据（如例题），然后遍历桶里面的元素，用当前桶的最小值，减去上一个有数据的桶的最大值</p>\n<h5 id=\"基数排序的主要思想：\"><a href=\"#基数排序的主要思想：\" class=\"headerlink\" title=\"基数排序的主要思想：\"></a>基数排序的主要思想：</h5><p>1.每次排序都是从最低位到最高位进行排序，因此求最大数的位数，作为基数排序循环的次数<br>2.在每次循环，求当前基数位的count<br>3.将count进行累加，求在整个count数组中排列的具体位置<br>4.从大到小重复计算count数组的过程，将data数据排好后放入tmp数组 count[k]–<br>5.将tmp数组赋值为data数组 基数*10，重复上面的步骤</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">maxbit</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> data[], <span class=\"hljs-keyword\">int</span> n)</span> <span class=\"hljs-comment\">//辅助函数，求数据的最大位数</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">int</span> maxData = data[<span class=\"hljs-number\">0</span>];              <span class=\"hljs-comment\">///&lt; 最大数</span><br>    <span class=\"hljs-comment\">/// 先求出最大数，再求其位数，这样有原先依次每个数判断其位数，稍微优化点。</span><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt; n; ++i)<br>    &#123;<br>        <span class=\"hljs-keyword\">if</span> (maxData &lt; data[i])<br>            maxData = data[i];<br>    &#125;<br>    <span class=\"hljs-keyword\">int</span> d = <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">int</span> p = <span class=\"hljs-number\">10</span>;<br>    <span class=\"hljs-keyword\">while</span> (maxData &gt;= p)<br>    &#123;<br>        <span class=\"hljs-comment\">//p *= 10; // Maybe overflow</span><br>        maxData /= <span class=\"hljs-number\">10</span>;<br>        ++d;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> d;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">radixsort</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> data[], <span class=\"hljs-keyword\">int</span> n)</span> <span class=\"hljs-comment\">//基数排序</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">int</span> d = <span class=\"hljs-built_in\">maxbit</span>(data, n);<br>    <span class=\"hljs-keyword\">int</span> *tmp = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[n];<br>    <span class=\"hljs-keyword\">int</span> *count = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[<span class=\"hljs-number\">10</span>]; <span class=\"hljs-comment\">//计数器</span><br>    <span class=\"hljs-keyword\">int</span> i, j, k;<br>    <span class=\"hljs-keyword\">int</span> radix = <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">for</span>(i = <span class=\"hljs-number\">1</span>; i &lt;= d; i++) <span class=\"hljs-comment\">//进行d次排序</span><br>    &#123;<br>        <span class=\"hljs-keyword\">for</span>(j = <span class=\"hljs-number\">0</span>; j &lt; <span class=\"hljs-number\">10</span>; j++)<br>            count[j] = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">//每次分配前清空计数器</span><br>        <span class=\"hljs-keyword\">for</span>(j = <span class=\"hljs-number\">0</span>; j &lt; n; j++)<br>        &#123;<br>            k = (data[j] / radix) % <span class=\"hljs-number\">10</span>; <span class=\"hljs-comment\">//统计每个桶中的记录数</span><br>            count[k]++;<br>        &#125;<br>        <span class=\"hljs-keyword\">for</span>(j = <span class=\"hljs-number\">1</span>; j &lt; <span class=\"hljs-number\">10</span>; j++)<br>            count[j] = count[j - <span class=\"hljs-number\">1</span>] + count[j]; <span class=\"hljs-comment\">//将tmp中的位置依次分配给每个桶</span><br>        <span class=\"hljs-keyword\">for</span>(j = n - <span class=\"hljs-number\">1</span>; j &gt;= <span class=\"hljs-number\">0</span>; j--) <span class=\"hljs-comment\">//将所有桶中记录依次收集到tmp中</span><br>        &#123;<br>            k = (data[j] / radix) % <span class=\"hljs-number\">10</span>;<br>            tmp[count[k] - <span class=\"hljs-number\">1</span>] = data[j];<br>            count[k]--;<br>        &#125;<br>        <span class=\"hljs-keyword\">for</span>(j = <span class=\"hljs-number\">0</span>; j &lt; n; j++) <span class=\"hljs-comment\">//将临时数组的内容复制到data中</span><br>            data[j] = tmp[j];<br>        radix = radix * <span class=\"hljs-number\">10</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">delete</span> []tmp;<br>    <span class=\"hljs-keyword\">delete</span> []count;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n<h5 id=\"乱序数据使用多进程进行排序\"><a href=\"#乱序数据使用多进程进行排序\" class=\"headerlink\" title=\"乱序数据使用多进程进行排序\"></a>乱序数据使用多进程进行排序</h5><p>每个进程进行各种的快速排序，然后将所有进程排序好的结果进行两两归并<br>使用pthread_t 和pthread_create</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">node</span> <span class=\"hljs-title\">s</span>[10];</span><br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;<span class=\"hljs-number\">10</span>;i++)<br>    &#123;<br>        s[i].id = i;<br>        s[i].l = i*<span class=\"hljs-number\">10</span>;<br>        s[i].r = i*<span class=\"hljs-number\">10</span>+<span class=\"hljs-number\">9</span>;<br>    &#125;<br> <br>    <span class=\"hljs-keyword\">pthread_t</span> t[<span class=\"hljs-number\">10</span>];<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;<span class=\"hljs-number\">10</span>;i++)<br>        <span class=\"hljs-built_in\">pthread_create</span>(&amp;t[i],<span class=\"hljs-literal\">NULL</span>,__sort,(<span class=\"hljs-keyword\">void</span> *)&amp;s[i]);<br> <br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;<span class=\"hljs-number\">10</span>;i++)<br>        <span class=\"hljs-built_in\">pthread_join</span>(t[i],<span class=\"hljs-literal\">NULL</span>);<br><br>[完整代码参考链接](https:<span class=\"hljs-comment\">//blog.csdn.net/Return_nellen/article/details/79937320)</span><br><br></code></pre></td></tr></table></figure>\n\n<h5 id=\"桶排序例题\"><a href=\"#桶排序例题\" class=\"headerlink\" title=\"桶排序例题\"></a>桶排序例题</h5><p><font color=\"red\">存在重复元素 III</font><br>使用二分查找（set.lower_bound）和滑动窗口，或者桶排序和滑动窗口，比较经典<br>主要思路：查找当窗口元素中是否存在大于等于nums[i]-t的元素，如果存在，判断这个元素是否是小于等于 nums[i]+t 如果存在返回true;<br>如果是桶排序解决，就设定每个桶的大小为t+1 计算每个nums[i]应该在的桶的编号，判断这个桶是否有数据，如果有数据直接返回true； 如果没有，那么判断左右两边桶的数据之间的abs差是否 &lt;=t，同时在<br>循环向前的时候记得删除范围大于k的桶里面的数据</p>\n<p>感觉使用滑动窗口更好理解，就是查找窗口为k的，是否能够找到当前加入的元素x, [x-t, x+t]范围内的数，而且不是当前的数x,如果能,那么返回true</p>\n<p>易错点：<br>1.滑动窗口记得删除窗口之外的数据<br>2. nums[i]-t可能超出了整数的范围，一定要记得判断范围</p>\n<h4 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h4><p>归并排序一般是求逆序对个数，或者其他规则的逆序对<br>比如例题lc493. 翻转对 求i&lt;j, 且nums[i]&gt;2*nums[j]</p>\n<ul>\n<li><p>易错点: 有负数+是大于，因此在求解的时候/2 向上还是向下取整会不同</p>\n</li>\n<li><p>题解是将求res这个过程单调拎出来计算，之后再进行归并</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"> <span class=\"hljs-keyword\">while</span>(i&lt;=mid)&#123;<br>    <span class=\"hljs-keyword\">while</span>(j&lt;=right&amp;&amp;(<span class=\"hljs-keyword\">long</span> <span class=\"hljs-keyword\">long</span>)nums[i]&gt;(<span class=\"hljs-keyword\">long</span> <span class=\"hljs-keyword\">long</span>)<span class=\"hljs-number\">2</span>*nums[j]) j++; <span class=\"hljs-comment\">//最好不要转为nums[i]/2&gt; nums[j] 因为负数在取整的时候和正数向上和向下不一样</span><br>    res+=(j-mid<span class=\"hljs-number\">-1</span>);<br>    i++;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li><p>方法二：使用树状数组，但是因为数据的范围太大，因此使用hash对数据进行离散化， 对x 2*x 一些列数据排序后，递增给予他们idx 1….</p>\n</li>\n</ul>\n<h4 id=\"其他排序例题\"><a href=\"#其他排序例题\" class=\"headerlink\" title=\"其他排序例题\"></a>其他排序例题</h4><ol>\n<li>寻找两个正序数组的中位数 (寻找两个正序数组的第k个数)</li>\n</ol>\n<p>注意k表示的第k个数，而不是下标为k<br>同时注意算法是一边在进行移动，而不是两边都移动</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-comment\">//时间复杂度log(m+n) 空间复杂度O(1)</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> &#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">double</span> <span class=\"hljs-title\">getKthElement</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&amp; nums1, vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&amp; nums2, <span class=\"hljs-keyword\">int</span> k)</span></span>&#123;<br>        <span class=\"hljs-keyword\">int</span> size1 = nums1.<span class=\"hljs-built_in\">size</span>();<br>        <span class=\"hljs-keyword\">int</span> size2 = nums2.<span class=\"hljs-built_in\">size</span>();<br>        <span class=\"hljs-keyword\">int</span> index1 = <span class=\"hljs-number\">0</span>, index2 = <span class=\"hljs-number\">0</span>; <br>        <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>)<br>        &#123;<br>            <span class=\"hljs-keyword\">if</span>(index1==size1)&#123;<br>                <span class=\"hljs-keyword\">return</span> nums2[index2 + k - <span class=\"hljs-number\">1</span>];<br>            &#125;<br>            <span class=\"hljs-keyword\">if</span>(index2==size2)&#123;<br>                <span class=\"hljs-keyword\">return</span> nums1[index1 + k - <span class=\"hljs-number\">1</span>];<br>            &#125;<br>            <span class=\"hljs-keyword\">if</span>(k==<span class=\"hljs-number\">1</span>)&#123;<br>                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">min</span>(nums1[index1], nums2[index2]);<br>            &#125;<br>            <span class=\"hljs-keyword\">int</span> newIndex1 = <span class=\"hljs-built_in\">min</span>(index1 + k / <span class=\"hljs-number\">2</span> - <span class=\"hljs-number\">1</span>, size1 - <span class=\"hljs-number\">1</span>);<br>            <span class=\"hljs-keyword\">int</span> newIndex2 = <span class=\"hljs-built_in\">min</span>(index2 + k / <span class=\"hljs-number\">2</span> - <span class=\"hljs-number\">1</span>, size2 - <span class=\"hljs-number\">1</span>);<br>            <span class=\"hljs-keyword\">int</span> pivot1 = nums1[newIndex1];<br>            <span class=\"hljs-keyword\">int</span> pivot2 = nums2[newIndex2];<br>            <br>            <span class=\"hljs-keyword\">if</span>(pivot1&lt;=pivot2)&#123;<br>                <br>                k = k - (newIndex1 - index1 + <span class=\"hljs-number\">1</span>);<br>                index1 = newIndex1 + <span class=\"hljs-number\">1</span>;<br>            &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>                <br>                k = k - (newIndex2 - index2 + <span class=\"hljs-number\">1</span>);<br>                index2 = newIndex2 + <span class=\"hljs-number\">1</span>;<br>            &#125;<br>            cout&lt;&lt;pivot1&lt;&lt;<span class=\"hljs-string\">&quot; &quot;</span>&lt;&lt;pivot2&lt;&lt;endl;<br>            <br>        &#125;<br>        <br>    &#125;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">double</span> <span class=\"hljs-title\">findMedianSortedArrays</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&amp; nums1, vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        <span class=\"hljs-keyword\">int</span> size1 = nums1.<span class=\"hljs-built_in\">size</span>();<br>        <span class=\"hljs-keyword\">int</span> size2 = nums2.<span class=\"hljs-built_in\">size</span>();<br>        <span class=\"hljs-keyword\">int</span> sum = size1 + size2;<br>        <span class=\"hljs-keyword\">if</span>(sum%<span class=\"hljs-number\">2</span>==<span class=\"hljs-number\">0</span>)&#123;<br>            <span class=\"hljs-keyword\">return</span> (<span class=\"hljs-built_in\">getKthElement</span>(nums1, nums2, sum / <span class=\"hljs-number\">2</span>) + <span class=\"hljs-built_in\">getKthElement</span>(nums1, nums2, sum / <span class=\"hljs-number\">2</span> +<span class=\"hljs-number\">1</span>)) / <span class=\"hljs-number\">2</span>;<br>        &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>            cout&lt;&lt;sum/<span class=\"hljs-number\">2</span>+<span class=\"hljs-number\">1</span>&lt;&lt;endl;<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">getKthElement</span>(nums1, nums2, sum / <span class=\"hljs-number\">2</span>+<span class=\"hljs-number\">1</span>);<br>        &#125;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>排序和优先队列结合！！<br>两个最好的不重叠活动<br>步骤：</li>\n</ol>\n<ul>\n<li>先将活动按起始时间从小到大进行排序</li>\n<li>维护一个最小堆，堆内元素代表活动的结束时间和对应价值(结束时间越早的越先弹出)</li>\n<li>遍历所有活动，如果堆内的活动结束时间小于当前活动的起始时间，又因为活动时间是从小到大进行排序的，所以当前堆内的活动是可以与后面任意活动一起参与的，因此我们可以维护maxVal记录下当前活动开始前，我们可以选择的最大价值</li>\n</ul>\n<h4 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h4><p>快速排序模板题</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">quickSort</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&amp;  nums, <span class=\"hljs-keyword\">int</span> left, <span class=\"hljs-keyword\">int</span> right)</span></span>&#123;<br>       <span class=\"hljs-keyword\">while</span>(left&gt;=right)&#123;<br>           <span class=\"hljs-keyword\">return</span>;<br>       &#125;<br>       <span class=\"hljs-keyword\">int</span> rand_num= <span class=\"hljs-built_in\">rand</span>()%(right-left+<span class=\"hljs-number\">1</span>)+left;<br>       <span class=\"hljs-keyword\">int</span> pivot=nums[rand_num];<br>       <span class=\"hljs-built_in\">swap</span>(nums[rand_num],nums[left]);<br>       <span class=\"hljs-keyword\">int</span> l=left;<br>       <span class=\"hljs-keyword\">int</span> r=right;<br>       <span class=\"hljs-keyword\">while</span>(l&lt;r)&#123;<br>           <span class=\"hljs-keyword\">while</span>(l&lt;r&amp;&amp;nums[r]&gt;=pivot)&#123;<br>               r--;<br>           &#125;<br>           <span class=\"hljs-keyword\">while</span>(l&lt;r&amp;&amp;nums[l]&lt;=pivot)&#123;<br>               l++;<br>           &#125;<br>           <span class=\"hljs-keyword\">if</span>(l&lt;r)&#123;<br>               <span class=\"hljs-built_in\">swap</span>(nums[l], nums[r]);<br>           &#125;<br><br>       &#125;<br>       <span class=\"hljs-built_in\">swap</span>(nums[left], nums[l]);<br>       <span class=\"hljs-built_in\">quickSort</span>(nums, left, l<span class=\"hljs-number\">-1</span>);<br>       <span class=\"hljs-built_in\">quickSort</span>(nums, l+<span class=\"hljs-number\">1</span>, right);<br>   &#125;<br>   <span class=\"hljs-function\">vector&lt;<span class=\"hljs-keyword\">int</span>&gt; <span class=\"hljs-title\">sortArray</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&amp; nums)</span> </span>&#123;<br>       <span class=\"hljs-keyword\">int</span> num_len=nums.<span class=\"hljs-built_in\">size</span>();<br>       <span class=\"hljs-built_in\">quickSort</span>(nums, <span class=\"hljs-number\">0</span>, num_len<span class=\"hljs-number\">-1</span>);<br>       <span class=\"hljs-keyword\">return</span> nums;<br>   &#125;<br></code></pre></td></tr></table></figure>\n\n<p>快速排序找出第k个数的代码模板，类似于二分</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> &#123;</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">minMoves2</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] nums)</span> </span>&#123;<br>        <span class=\"hljs-keyword\">int</span> mid = nums.length / <span class=\"hljs-number\">2</span>;<br>        <span class=\"hljs-keyword\">int</span> mid_num = <span class=\"hljs-built_in\">quickSort</span>(nums, mid); <span class=\"hljs-comment\">//这道题中k为mid</span><br>        <span class=\"hljs-keyword\">int</span> ret = <span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> num : nums) &#123;<br>            ret += Math.<span class=\"hljs-built_in\">abs</span>(mid_num - num);<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> ret;<br>    &#125;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">quickSort</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] nums, <span class=\"hljs-keyword\">int</span> k)</span> </span>&#123;<br>        <span class=\"hljs-keyword\">int</span> l = <span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-keyword\">int</span> h = nums.length - <span class=\"hljs-number\">1</span>;<br>        <span class=\"hljs-keyword\">while</span> (l &lt; h) &#123;<br>            <span class=\"hljs-keyword\">int</span> ret = <span class=\"hljs-built_in\">partion</span>(nums, l, h);<br>            <span class=\"hljs-keyword\">if</span> (ret == k) &#123;<br>                <span class=\"hljs-keyword\">break</span>;<br>            &#125;<br>            <span class=\"hljs-keyword\">if</span> (ret &lt; k) &#123;<br>                l = ret + <span class=\"hljs-number\">1</span>;<br>            &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>                h = ret - <span class=\"hljs-number\">1</span>; <br>            &#125;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> nums[k];<br>    &#125;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">partion</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>[] nums, <span class=\"hljs-keyword\">int</span> l, <span class=\"hljs-keyword\">int</span> h)</span> </span>&#123;<br>        <span class=\"hljs-keyword\">int</span> p = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Random</span>().<span class=\"hljs-built_in\">nextInt</span>(h - l + <span class=\"hljs-number\">1</span>) + l; <span class=\"hljs-comment\">//记住pivot是随机产生</span><br>        <span class=\"hljs-keyword\">int</span> temp = nums[p];<br>        nums[p] = nums[l];<br>        nums[l] = temp;<span class=\"hljs-comment\">//交换left和pivot的值</span><br>        <br>        <span class=\"hljs-comment\">//可以如下方式写，也可以，l和r每次交换，最后l和pivot所在的位置交换</span><br>        <span class=\"hljs-keyword\">while</span> (l &lt; h) &#123;<br>            <span class=\"hljs-keyword\">while</span> (l &lt; h &amp;&amp; nums[h] &gt;= temp) &#123; <span class=\"hljs-comment\">//注意等于也要走，因为如果不，就可能导致在中间出现死循环</span><br>                h--;<br>            &#125;<br>            nums[l] = nums[h];<br>            <span class=\"hljs-keyword\">while</span> (l &lt; h &amp;&amp; nums[l] &lt;= temp) &#123;<br>                l++;<br>            &#125;<br>            nums[h] = nums[l];<br>        &#125;<br>        nums[l] = temp;<br>        <span class=\"hljs-keyword\">return</span> l;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>使用快速排序找到第k个数， 同时考虑结构体(在进行比较的时候使用second, 同时pivot也是second的值)的这种情况， 注意比较value, 但是交换的时候使用index</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">qsort</span><span class=\"hljs-params\">(vector&lt;pair&lt;<span class=\"hljs-keyword\">int</span>, <span class=\"hljs-keyword\">int</span>&gt;&gt;&amp; v, <span class=\"hljs-keyword\">int</span> start, <span class=\"hljs-keyword\">int</span> end, vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&amp; ret, <span class=\"hljs-keyword\">int</span> k)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">int</span> picked = <span class=\"hljs-built_in\">rand</span>() % (end - start + <span class=\"hljs-number\">1</span>) + start;<br>    <span class=\"hljs-built_in\">swap</span>(v[picked], v[start]);<br><br>    <span class=\"hljs-keyword\">int</span> pivot = v[start].second;<br>    <span class=\"hljs-keyword\">int</span> index = start;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = start + <span class=\"hljs-number\">1</span>; i &lt;= end; i++) &#123;<br>        <span class=\"hljs-keyword\">if</span> (v[i].second &gt;= pivot) &#123;<br>            <span class=\"hljs-built_in\">swap</span>(v[index + <span class=\"hljs-number\">1</span>], v[i]);<br>            index++;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-built_in\">swap</span>(v[start], v[index]);<br><br>    <span class=\"hljs-keyword\">if</span> (k &lt;= index - start) &#123;<br>        <span class=\"hljs-built_in\">qsort</span>(v, start, index - <span class=\"hljs-number\">1</span>, ret, k);<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = start; i &lt;= index; i++) &#123;<br>            ret.<span class=\"hljs-built_in\">push_back</span>(v[i].first);<br>        &#125;<br>        <span class=\"hljs-keyword\">if</span> (k &gt; index - start + <span class=\"hljs-number\">1</span>) &#123;<br>            <span class=\"hljs-built_in\">qsort</span>(v, index + <span class=\"hljs-number\">1</span>, end, ret, k - (index - start + <span class=\"hljs-number\">1</span>));<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"各种排序算法的总结链接：\"><a href=\"#各种排序算法的总结链接：\" class=\"headerlink\" title=\"各种排序算法的总结链接：\"></a>各种排序算法的总结链接：</h4><p><a href=\"https://www.runoob.com/w3cnote/ten-sorting-algorithm.html\">https://www.runoob.com/w3cnote/ten-sorting-algorithm.html</a><br>快速排序的额外空间复杂度是O(logn)， 因为每次递归只使用运用了常数时间的额外空间</p>\n<ol>\n<li>常见算法的稳定性（要记住）</li>\n</ol>\n<p>不稳定排序算法： 堆排序、快速排序、希尔排序、选择排序 （快选西堆）</p>\n<p>稳定排序算法： 基数排序、冒泡排序、插入排序、归并排序 （极差归帽（0））</p>\n<p>计数排序的时间复杂度是O(n+k), 空间复杂度为O(k)<br>桶排序 O(n+k) 先分桶再快排 O(n+k)//count+tmp数组<br>基数排序  O(nxk) O(n+k)</p>\n<ol start=\"2\">\n<li>比较各种数据结构<br>数组 插入慢，删除慢，查找慢（通过下标获取快）， 空间连续且固定<br>链表 插入快，删除快， 查找慢， 物理空间不连续，同时方便扩容<br>二叉树： 查找、插入、删除都快（如果树保持平衡）。缺点是删除算法复杂。<br>堆： 堆是一种特殊的完全二叉树<br>栈：后进先出，存取和查找其他项非常缓慢<br>队列： 先进先出，存取和查找其他项非常缓慢<br>散列表（hash）： 则存取极快，插入快。缺点是删除慢，对存储空间使用不充分, 需要解决可能产生的hash冲突。<br>图：邻接矩阵或者邻接链表，复杂，不同的存储方式导致查找比较缓慢</li>\n</ol>\n<ol start=\"3\">\n<li><p>外部排序方法<br>外排序的一个例子是外归并排序（External merge sort），它读入一些能放在内存内的数据量，在内存中排序后输出为一个顺串（即是内部数据有序的临时文件），处理完所有的数据后再进行归并。[1][2]比如，要对900 MB的数据进行排序，但机器上只有100 MB的可用内存时，外归并排序按如下方法操作：</p>\n<ol>\n<li>读入100 MB的数据至内存中，用某种常规方式（如快速排序、堆排序、归并排序等方法）在内存中完成排序。</li>\n<li>将排序完成的数据写入磁盘。</li>\n<li>读入每个临时文件（顺串）的前10 MB（ = 100 MB / (9块 + 1)）的数据放入内存中的输入缓冲区，最后的10 MB作为输出缓冲区。（实践中，将输入缓冲适当调小，而适当增大输出缓冲区能获得更好的效果。）</li>\n<li>执行九路归并算法，将结果输出到输出缓冲区。一旦输出缓冲区满，将缓冲区中的数据写出至目标文件，清空缓冲区。一旦9个输入缓冲区中的一个变空，就从这个缓冲区关联的文件，读入下一个10M数据，除非这个文件已读完。这是“外归并排序”能在主存外完成排序的关键步骤 – 因为“归并算法”(merge algorithm)对每一个大块只是顺序地做一轮访问(进行归并)，每个大块不用完全载入主存。</li>\n</ol>\n</li>\n</ol>\n<p>为了增加每一个有序的临时文件的长度，可以采用置换选择排序（Replacement selection sorting）。它可以产生大于内存大小的顺串。具体方法是在内存中使用一个最小堆进行排序，设该最小堆的大小为{\\displaystyle M}M。算法描述如下：</p>\n<pre><code>1. 初始时将输入文件读入内存，建立最小堆。\n2. 将堆顶元素输出至输出缓冲区。然后读入下一个记录：\n    a. 若该元素的关键码值不小于刚输出的关键码值，将其作为堆顶元素并调整堆，使之满足堆的性质；\n    b. 否则将新元素放入堆底位置，将堆的大小减1。\n3. 重复第2步，直至堆大小变为0。\n此时一个顺串已经产生。将堆中的所有元素建堆，开始生成下一个顺串。[3]\n此方法能生成平均长度为&#123;\\displaystyle 2M&#125;2M的顺串，可以进一步减少访问外部存储器的次数，节约时间，提高算法效率。\n</code></pre>\n<p>总结：顺串产生可以用1）小顶堆或者2）划分为多个小文件+各自快速排序产生</p>\n<ol start=\"4\">\n<li>向数组中追加 K 个整数（lc6017）<br>题意，向数组中插入k个数组都没出现过的正整数，如果是插入的和最小<br>解决方案：排序数组，然后填充数组的空隙， 使用高斯求和公式得到结果会更快<br>易错点：注意的是需要在数组前面和后面加两个哨兵</li>\n</ol>\n<p>5.lc1539. 第 k 个缺失的正整数 (easy)</p>\n<ul>\n<li>一个排序正整数数组，找到缺失的第k个正整数</li>\n<li>算法1：为了减少分类讨论，直接在数组前面+一个哨兵节点0， 然后k依次减去相邻两个数中间包含数的个数</li>\n<li>算法2：缺失的正整数一定 &gt;= k；数组中每出现一个 &lt;= k 的数字, 意味着少了一个缺失的数字, 此时k+1<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; arr.<span class=\"hljs-built_in\">size</span>(); i++) &#123;<br>    <span class=\"hljs-keyword\">if</span> (arr[i] &lt;= k) &#123;<br>        k++;<br>    &#125;<br>&#125;<br><span class=\"hljs-keyword\">return</span> k;<br></code></pre></td></tr></table></figure></li>\n</ul>\n<ol start=\"6\">\n<li><ol start=\"414\">\n<li>第三大的数（easy）</li>\n</ol>\n</li>\n</ol>\n<ul>\n<li>题意：返回第k大的数，相同的数同一level, 如果每个第k大的数，返回第一大</li>\n<li>注意数据中可能包含INT_MIN</li>\n<li>思路：可以使用排序，可以O(n)， 用三个数a, b, c, 初始化为long INT_MIN</li>\n<li>定要注意等于的情况是不更新的，比如等于b, 不会更新c的！！！！</li>\n</ul>\n<ol start=\"7\">\n<li>lc870. 优势洗牌</li>\n</ol>\n<ul>\n<li>题意：将nums1和nums2如何进行配对，使得在i, nums1[i]&gt;nums2[i]的对数最大</li>\n<li>田忌赛马的思想</li>\n<li>使用优先队列，将每个nums2的下标和数据入队</li>\n<li>每次弹出nums2的最大的一个，如果当前nums1的最大不能打败当前的数，那么就将nums1的最小和nums2的最大匹配（nums1 index left++）, 否则right– （更易理解）</li>\n<li>或者每次弹出nums2的最小的一个，如果当前nums1的最小不能打败当前的数，那么就将nums1的最小和nums2的最大匹配(此时用优先队列好像不行，可以直接对结构体nums2进行排序), 否则right–</li>\n<li>“滑动窗口的最大值”，也是使用了优先队列</li>\n</ul>\n<ol start=\"8\">\n<li>奇偶稳定排序</li>\n</ol>\n<ul>\n<li>将数组的奇数全部排在偶数前面，同时不交换奇数和偶数原本的相对顺序</li>\n<li>用一个k来记录前面以及排好序的奇数的个数， 然后每遇到一个奇数，就使用冒泡排序的方法，一个一个的交换到前面去<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">reOrderArray</span>(<span class=\"hljs-params\">arr</span>):</span><br>    m = <span class=\"hljs-built_in\">len</span>(arr)<br>    k = <span class=\"hljs-number\">0</span> <span class=\"hljs-comment\"># 记录当前已经排序好的奇数个数</span><br>    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(m):<br>        <span class=\"hljs-keyword\">if</span> arr[i] % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">1</span>:<br>            j = i<br>            <span class=\"hljs-keyword\">while</span> j &gt; k:  <span class=\"hljs-comment\"># 将奇数移到最前面</span><br>                temp = arr[j]<br>                arr[j] = arr[j-<span class=\"hljs-number\">1</span>]<br>                arr[j-<span class=\"hljs-number\">1</span>] = temp<br>                j -= <span class=\"hljs-number\">1</span><br>            k += <span class=\"hljs-number\">1</span> <br>    <span class=\"hljs-built_in\">print</span>(arr)<br><span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&#x27;__main__&#x27;</span>:<br>    arr = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">7</span>,<span class=\"hljs-number\">6</span>,<span class=\"hljs-number\">12</span>]<br>    reOrderArray(arr)<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>ok</p>\n<p>主要是针对大文件或者多线程情况的下排序，或者数据结构本身的考察</p>\n"},{"title":"字符串相关问题","catogory":["leetcode 题目汇总"],"date":"2021-11-13T09:23:32.000Z","_content":"\n#### 常见字符串解决套路\n1. [用动态规划求解](./动态规划题型.md)\n2.[用滑动窗口求解](./滑动窗口.md)\n3. [用双指针求解](./双指针.md)\n4. [使用DFS/BFS求一个字符串转为另外一个字符串的路径问题](./回溯_DFS_BFS.md)\n\n\n#### 扩展：字符串hash\nabcde\n转为为多项式\nf(5)= a* p^5 + b*p^4 +c *p^3 +d *p^2 +e *p^1\nf(3)= a* p^3 + b*p^2 +c *p^1\nf(4, 5)=f(5)-f(3)*p^(5-4+1)\n\nc++用unsigned long long 自然溢出，可以不用取模，如果使用取模方式可能会导致溢出\n```C++\np[0]=1;\nh[0]=0;\nfor(int i=1;i<size;i++){\n  h[i]=h[i-1]*p+s[i-1]; //0到i-1之间的hash值\n  p[i]=p[i-1]*p;  //不同长度字符串的p值\n}\n\nhash_val_m_n=h[m]-h[n-1]*p[m-n+1];\n```\n\n最长重复子串（hard）\n使用字符串hash+二分寻找长度，如果hash的key是字符串的话，时间复杂度为O(n*len))， 只有key为整数类型，时间复杂度才为 O(n))\n\n#### 例题\n\n1. 最大数：注意使用str.substr以及位移操作时候一定要记得赋值，否则结果是不会改变的 res=res.substr(start, len), 以及注意最后的结果包含首0的情况，一定要记得去除首零\n\n2. 最大单词长度乘积\n使用掩码判断字符串是否有相似的字符，然后掩码&\n\n3. 打开转盘锁\n使用bfs\n值得学习的地方：\n1. 使用unordered_set代替vector\n主要在判断一个字符之前是否在一个集合中, 使用unordered_set比vector更快 if(!set.count())  表示集合中没有这个元素\n2. 在查找当前字符变形后的字符，一定要及得保留当前的字符再做修改！！\n\n3. 匹配子序列的单词数\n查看多个字符串中，有几个是字符串s的子序列\n使用二分查找，先通过hash，将不同字符对应的下标值进行存储，然后遍历需要查询的每个字符串，分别从hash里面多个vector进行查找，同时下次查找的下标，应该比当前下标至少+1\n\n\n<font color=red>4. 反转每对括号间的子串 (华为机试)</font>\n**字符串+栈**\n注意这道题我最开始还没想出来\n- 解决方案：\n  str为最后的结果\n  遇到（ 那么将str的元素压入栈中，然后str转为“”\n  遇到）那么将str元素翻转，**如果栈不为空, 将栈顶元素弹出**, str=s.top()+str; s.pop()\n  其余的字符直接追加在str后面\n  最后返回str\n- 也就是拼接好的字符串直接放在str中，不需要再压入栈中, 多了一个 \"每次遇到]将当前字符串reverse 并加在栈顶元素的后面\" 的步骤\n\nPS：类似的一道题: 字符串解码 (2021年4399后端开发笔试原题)\n- 仍然使用栈, 思路和4相似，只不过多了一个数字 （左括号不会被压入栈中）\n- 另一种解法：数字存放在数字栈，字符串存放在字符串栈，遇到右括号时候弹出一个数字栈，字母栈弹到左括号为止。（左括号会压入栈中）\n\n\n<font color=red>5. lc2157字符串分组(hard)</font>\n- (lc49字符串异位词分组) 用string或者vector<int> 作为hash的key\n- 并查集对字符串进行分组和记录组数（带size的并查集，同时要考虑可能存在相同字符串的情况， size[x]>1 group--，同时合并的时候， group也会--），状态压缩+位运算实现字符串关联判断和查找\n- 如果直接枚举任意两个字符串并判断是否关联，并以此得到图上所有的边，时间复杂度至少为 O(n^2), 会超出时间限制。因此对每个字符串进行变换\n\n\n\n```C++\nint x = 0;\nfor (char ch: word) {\n    x |= 1 << (ch - 'a'); // 计算 word 的二进制表示\n}\n\nfor x := range fa { // 枚举所有字符串（二进制表示）\n\t\tfor i := 0; i < 26; i++ {\n\t\t\tmerge(x, x^1<<i) // 添加或删除字符 i  0变为1， 1变为0\n\t\t\tif x>>i&1 == 1 { //找到一个1， 0对 翻转\n\t\t\t\tfor j := 0; j < 26; j++ {\n\t\t\t\t\tif x>>j&1 == 0 {\n\t\t\t\t\t\tmerge(x, x^1<<i|1<<j) // 替换字符 i 为 j\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n```\n\n6. 最长的美好子字符串\n- 枚举，i， j, 表示字符串左右，两重循环\n- 然后使用两个二进制代替两个数组，判断是否大小写都有，如果有数量就不能使用两个数来代替，只有这种有或没有可以\n也是使用二进制对字符串进行压缩\n枚举/分治/枚举typenum(至少有K个重复字符的最长子串, 不建议用这种方法，因为比较难)\n\n7. 不同字符的最小子序列\n去除重复的字符串，使得子序列包含所有的字符，每个字符一次，同时字典序有最少\nsolution: \n需要有一个hash来记录一个字符的剩余出现次数\n如果栈中没找到，从栈中弹出剩余出现次数大于0，而且大于当前字符的字符，然后压入当前字符\n如果栈中找到，直接将num[当前字符]--, 不push进入栈中\n\n\n<font color=red>8.序列自动机</font>\n字符串dp\n在进行判断一个字符串a是否是另外一个字符串b的子序列的时候，可以使用双指针，判断a的指针是否能走到末尾\n也可以使用dp\ndp[i][j]=i  s[i]==j （表示s从i开始第一个等于字符j的下标）\ndp[i][j]=dp[i+1][j]  s[i]!=j\n从后往前更新\n```java\n Arrays.fill(f[m], m);\nfor (int i = m - 1; i >= 0; --i) {\n\tfor (int j = 0; j < 26; ++j) {//只包含小写字符\n\t\tif (s.charAt(i) == (char) ('a' + j)) {\n\t\t\tf[i][j] = i;\n\t\t} else {\n\t\t\tf[i][j] = f[i + 1][j];\n\t\t}\n\t}\n}\nString res = \"\";\nfor (String t : dictionary) {\n\tboolean match = true;\n\tint j = 0;\n\tfor (int i = 0; i < t.length(); ++i) {\n\t\tif (f[j][t.charAt(i) - 'a'] == m) {\n\t\t\tmatch = false;\n\t\t\tbreak;\n\t\t}\n\t\tj = f[j][t.charAt(i) - 'a'] + 1;\n\t}\n\tif (match) {\n\t\t\n\t}\n}\n```\n\n9. KMP算法的模板，主要是求next的数组，以及在循环退出之后判断字符是否相等，进行k的判断或者next数组的赋值\n```C++\n void findnext(string pattern, vector<int>& next){\n        int size = pattern.size();\n        int k = -1;\n        next[0] = -1;//代表已经匹配的下标\n        for (int i = 1; i < size; i++)\n        {\n            while(k!=-1&&pattern[i]!=pattern[k+1]){\n                    k = next[k];\n            }//因为跳出循环后还需要判断相等，因此将判断相等放在while的后面而不是前面\n            if(pattern[i]==pattern[k+1]){\n                k++;\n            }\n\n            next[i] = k;\n        }\n    }\n    int strStr(string haystack, string needle) {\n    // int KMP(string target, string pattern){\n        string target=haystack;\n        string pattern=needle;\n        int size = target.size();\n        int k = -1;\n        if(pattern==\"\"){\n            return 0;\n        }\n        vector<int> next(pattern.size());\n        findnext(pattern, next);\n        for (int i = 0; i < size; i++)\n        {\n            while(k!=-1&&target[i]!=pattern[k+1]){\n                    k = next[k];\n            }\n            if(target[i]==pattern[k+1]){\n                k++;\n                if(k==pattern.size()-1){\n                    return i - k ; //返回匹配字符串的头位置\n                }\n            }\n\n        }\n        return -1;\n    }\n```\n\n10. 字符串翻转\n“leetcode i\" --> \"i leetcode\"\n思路：1. 使用栈\n2. 先整个字符串翻转，去空格+原位翻转（双指针）+删除后面多余的字符 //空间复杂度O(1)\n\n11. 实现 atoi() 字符串转数字：注意这几个测试用例\n  a. 包含非法字符，返回 error 或者 0\n  b. 要考虑正负号\n  c. 要考虑溢出的情况。直接按照字典序，比较输入字符串和 TMin、TMax 的字符串就可以了，不需要在转换过程中判断是否溢出\n\n12. lc115. 不同的子序列(字符串匹配问题)\n-  这道题主要是求一个字符串s中可以找到多少个字符串t(只变了一个字符也是一种新的情况) (见8.序列自动机)\n-  使用dp[i][j]表示字符串s前i个，和字符串t前j个进行匹配的个数，那么状态转移方程为 （下面展示的是从前往后，从后往前也是可以的）\n```C++\n        for(int i=0;i<s1;i++){  //注意这里的初始化非常重要\n            dp[i][0]=1;\n        }\n        for(int i=1;i<s1;i++){\n            for(int j=1;j<s2;j++){\n                if(s[i]==t[j]){\n                    dp[i][j]=dp[i-1][j-1]+dp[i-1][j];   //相同可以与当前t匹配，也可以不匹配\n                }else{\n                    dp[i][j]=dp[i-1][j];\n                }\n                dp[i][j]=min(dp[i][j],1LL*1000000000000000); //这里是为了防止long long型超出范围\n            }\n        }\n```\n-  其他注意的地方：自左向右和从右到左都会爆 long long超出范围，使用记忆化搜索不会。同时一定要记得初始化，没有与模式字符串匹配的时候，都需要赋值为1 dp[i][0]=1\n\n\n\n13. Trie树的实现\n具体实现见系统设计中的Trie树专题\n\n14. 单词搜索\n- Trie树+回溯\n先将要字典中的单词建立一颗Trie树，然后枚举矩阵中的每个点，进行dfs, 在进行dfs的时候，只对Trie树中有的边进行dfs, 如果当前走到isEnd=True的情况，那么就直接压入结果，同时这个时候不能直接退出，还可以继续dfs,因为字典中的单词可能是存在相互包含的关系的（dfs剪枝）\n\n<font color=red>15. 最长回文前缀</font>\nlc214. 最短回文串\n求s的最长回文前缀，其实就是求str = s+\"#\"+rev_s的最长公共前后缀，使用KMP算法求next数组，然后返回next[str.size()-1]，就是最长的回文前缀\n\n一个字符串的最长前后缀为，这个字符串求next数组，返回next[size-1]\n\n马拉车算法：https://www.acwing.com/file_system/file/content/whole/index/content/446985/\n\n<font color=red>16. lc321. 拼接最大数 (hard)</font>\n- 题意：从两个数组中共选择k个数，是的数最大\n- 第一步是枚举每个数组中取数据的个数\n- 第二步分别从两个数组中得到指定长度的最大子序列\n- 第三步是将两个最大子序列合并。（一定要注意合并！！！！ 可能会遇到相同的情况，不是随便选一个，而是要找到他们后面第一个不相等的进行比较）\n```C++\n  bool flag=true; //第一个数组++\n  while(index1<m&&index2<n){\n      if(arr1[index1]>arr2[index2]){\n          flag==true;\n          break;\n      }else if(arr1[index1]<arr2[index2]){\n          flag=false;\n          break;\n      }\n      index1++;\n      index2++;\n  }\n  if(index1==m){\n      flag=false;\n  }\n```\n\n\n17. lc792. 匹配子序列的单词数\n- 判断字典里面的每个字符串是否是s的子序列，使用双指针会超时\n- 方法一：使用字符串dp, dp[i][j]表示s从index下标开始，找到的第一个字母j的下标\n- 方法二：使用map<int, vector<int>> 记录下每个字母在字符串中下标的位置，然后使用二分查找\n\n\n#### 总结\nok ok\n1. 在对字符串进行操作通常可以朝栈，递归， bfs等方向思考\n    尤其是左右括号对应的这种情况-> 栈和递归\n2. 状态压缩：如果字符串的每一个字符串都至多包含每个字母一次，并且字母的顺序无关紧要，因此我们可以使用一个 262的二进制数 mask 表示一个字符串。\n  同时如何两两判断两个字符串是否有关联的时间复杂度太高O(n^2^len(str)), 那么可以转为「枚举一个节点」+「枚举可能的相邻节点」+「使用哈希表判断相邻节点是否真正存在」的方法得到所有关联的边，（也就是猜测字符串的每个数的时间复杂度可能小于两层循环遍历+判断）\n\n3. 注意在进行字符串比较的时候是比较多次，但是在进行数字比较的时候是比较一次,所以hash的key存int比存string更高效\n\n4. char a可以使用a++，变为另外一个字符 'A'->'B'\n  但是string s类型，即使只有一个字符，也必须使用s[0]++, 不能使用s++\n\n5. 如果出现反复将一个字符串的子串和字典中的每个字符比对的题目，可以使用Trie树，或者使用动态规划（True/False类型），提前判断某一个子字符串是否在字典中 （PS: 动态规划中也有这句话的总结）\n\n6. Trie树，通常是将字典里面的字符串构建一个trie数，然后在进行查询的时候，就相当于直接在字典中（多个字符串同时）查找，而不是和字典中的每个字符串进行对比\n例题：lc: 面试题 17.17. 多次搜索(KMP/ Trie数)\n\n7. 字符串匹配问题:求个数，求是否匹配，求删除字符的最小数量，都是使用的动态规划，定义的dp[i][j]都是让s前i个字符和t前j个字符匹配的xxxx， 一般都是将s[i]和t[j]是否相等分成两种情况，并分别求对应的状态转移\n\n8. 有时候有字典的这种情况会考虑到建立前缀树，也可以考虑使用逆向思维，将字典树加密的所有字符串提前求出来，然后使用打表方法\nlc5302. 加密解密字符串（周赛hard）\n\n\n\n\n\n","source":"_posts/leetcode/字符串.md","raw":"---\ntitle: 字符串相关问题\ncatogory:\n  - leetcode 题目汇总\ncategories:\n  - leetcode\ndate: 2021-11-13 17:23:32\ntags:\n---\n\n#### 常见字符串解决套路\n1. [用动态规划求解](./动态规划题型.md)\n2.[用滑动窗口求解](./滑动窗口.md)\n3. [用双指针求解](./双指针.md)\n4. [使用DFS/BFS求一个字符串转为另外一个字符串的路径问题](./回溯_DFS_BFS.md)\n\n\n#### 扩展：字符串hash\nabcde\n转为为多项式\nf(5)= a* p^5 + b*p^4 +c *p^3 +d *p^2 +e *p^1\nf(3)= a* p^3 + b*p^2 +c *p^1\nf(4, 5)=f(5)-f(3)*p^(5-4+1)\n\nc++用unsigned long long 自然溢出，可以不用取模，如果使用取模方式可能会导致溢出\n```C++\np[0]=1;\nh[0]=0;\nfor(int i=1;i<size;i++){\n  h[i]=h[i-1]*p+s[i-1]; //0到i-1之间的hash值\n  p[i]=p[i-1]*p;  //不同长度字符串的p值\n}\n\nhash_val_m_n=h[m]-h[n-1]*p[m-n+1];\n```\n\n最长重复子串（hard）\n使用字符串hash+二分寻找长度，如果hash的key是字符串的话，时间复杂度为O(n*len))， 只有key为整数类型，时间复杂度才为 O(n))\n\n#### 例题\n\n1. 最大数：注意使用str.substr以及位移操作时候一定要记得赋值，否则结果是不会改变的 res=res.substr(start, len), 以及注意最后的结果包含首0的情况，一定要记得去除首零\n\n2. 最大单词长度乘积\n使用掩码判断字符串是否有相似的字符，然后掩码&\n\n3. 打开转盘锁\n使用bfs\n值得学习的地方：\n1. 使用unordered_set代替vector\n主要在判断一个字符之前是否在一个集合中, 使用unordered_set比vector更快 if(!set.count())  表示集合中没有这个元素\n2. 在查找当前字符变形后的字符，一定要及得保留当前的字符再做修改！！\n\n3. 匹配子序列的单词数\n查看多个字符串中，有几个是字符串s的子序列\n使用二分查找，先通过hash，将不同字符对应的下标值进行存储，然后遍历需要查询的每个字符串，分别从hash里面多个vector进行查找，同时下次查找的下标，应该比当前下标至少+1\n\n\n<font color=red>4. 反转每对括号间的子串 (华为机试)</font>\n**字符串+栈**\n注意这道题我最开始还没想出来\n- 解决方案：\n  str为最后的结果\n  遇到（ 那么将str的元素压入栈中，然后str转为“”\n  遇到）那么将str元素翻转，**如果栈不为空, 将栈顶元素弹出**, str=s.top()+str; s.pop()\n  其余的字符直接追加在str后面\n  最后返回str\n- 也就是拼接好的字符串直接放在str中，不需要再压入栈中, 多了一个 \"每次遇到]将当前字符串reverse 并加在栈顶元素的后面\" 的步骤\n\nPS：类似的一道题: 字符串解码 (2021年4399后端开发笔试原题)\n- 仍然使用栈, 思路和4相似，只不过多了一个数字 （左括号不会被压入栈中）\n- 另一种解法：数字存放在数字栈，字符串存放在字符串栈，遇到右括号时候弹出一个数字栈，字母栈弹到左括号为止。（左括号会压入栈中）\n\n\n<font color=red>5. lc2157字符串分组(hard)</font>\n- (lc49字符串异位词分组) 用string或者vector<int> 作为hash的key\n- 并查集对字符串进行分组和记录组数（带size的并查集，同时要考虑可能存在相同字符串的情况， size[x]>1 group--，同时合并的时候， group也会--），状态压缩+位运算实现字符串关联判断和查找\n- 如果直接枚举任意两个字符串并判断是否关联，并以此得到图上所有的边，时间复杂度至少为 O(n^2), 会超出时间限制。因此对每个字符串进行变换\n\n\n\n```C++\nint x = 0;\nfor (char ch: word) {\n    x |= 1 << (ch - 'a'); // 计算 word 的二进制表示\n}\n\nfor x := range fa { // 枚举所有字符串（二进制表示）\n\t\tfor i := 0; i < 26; i++ {\n\t\t\tmerge(x, x^1<<i) // 添加或删除字符 i  0变为1， 1变为0\n\t\t\tif x>>i&1 == 1 { //找到一个1， 0对 翻转\n\t\t\t\tfor j := 0; j < 26; j++ {\n\t\t\t\t\tif x>>j&1 == 0 {\n\t\t\t\t\t\tmerge(x, x^1<<i|1<<j) // 替换字符 i 为 j\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n```\n\n6. 最长的美好子字符串\n- 枚举，i， j, 表示字符串左右，两重循环\n- 然后使用两个二进制代替两个数组，判断是否大小写都有，如果有数量就不能使用两个数来代替，只有这种有或没有可以\n也是使用二进制对字符串进行压缩\n枚举/分治/枚举typenum(至少有K个重复字符的最长子串, 不建议用这种方法，因为比较难)\n\n7. 不同字符的最小子序列\n去除重复的字符串，使得子序列包含所有的字符，每个字符一次，同时字典序有最少\nsolution: \n需要有一个hash来记录一个字符的剩余出现次数\n如果栈中没找到，从栈中弹出剩余出现次数大于0，而且大于当前字符的字符，然后压入当前字符\n如果栈中找到，直接将num[当前字符]--, 不push进入栈中\n\n\n<font color=red>8.序列自动机</font>\n字符串dp\n在进行判断一个字符串a是否是另外一个字符串b的子序列的时候，可以使用双指针，判断a的指针是否能走到末尾\n也可以使用dp\ndp[i][j]=i  s[i]==j （表示s从i开始第一个等于字符j的下标）\ndp[i][j]=dp[i+1][j]  s[i]!=j\n从后往前更新\n```java\n Arrays.fill(f[m], m);\nfor (int i = m - 1; i >= 0; --i) {\n\tfor (int j = 0; j < 26; ++j) {//只包含小写字符\n\t\tif (s.charAt(i) == (char) ('a' + j)) {\n\t\t\tf[i][j] = i;\n\t\t} else {\n\t\t\tf[i][j] = f[i + 1][j];\n\t\t}\n\t}\n}\nString res = \"\";\nfor (String t : dictionary) {\n\tboolean match = true;\n\tint j = 0;\n\tfor (int i = 0; i < t.length(); ++i) {\n\t\tif (f[j][t.charAt(i) - 'a'] == m) {\n\t\t\tmatch = false;\n\t\t\tbreak;\n\t\t}\n\t\tj = f[j][t.charAt(i) - 'a'] + 1;\n\t}\n\tif (match) {\n\t\t\n\t}\n}\n```\n\n9. KMP算法的模板，主要是求next的数组，以及在循环退出之后判断字符是否相等，进行k的判断或者next数组的赋值\n```C++\n void findnext(string pattern, vector<int>& next){\n        int size = pattern.size();\n        int k = -1;\n        next[0] = -1;//代表已经匹配的下标\n        for (int i = 1; i < size; i++)\n        {\n            while(k!=-1&&pattern[i]!=pattern[k+1]){\n                    k = next[k];\n            }//因为跳出循环后还需要判断相等，因此将判断相等放在while的后面而不是前面\n            if(pattern[i]==pattern[k+1]){\n                k++;\n            }\n\n            next[i] = k;\n        }\n    }\n    int strStr(string haystack, string needle) {\n    // int KMP(string target, string pattern){\n        string target=haystack;\n        string pattern=needle;\n        int size = target.size();\n        int k = -1;\n        if(pattern==\"\"){\n            return 0;\n        }\n        vector<int> next(pattern.size());\n        findnext(pattern, next);\n        for (int i = 0; i < size; i++)\n        {\n            while(k!=-1&&target[i]!=pattern[k+1]){\n                    k = next[k];\n            }\n            if(target[i]==pattern[k+1]){\n                k++;\n                if(k==pattern.size()-1){\n                    return i - k ; //返回匹配字符串的头位置\n                }\n            }\n\n        }\n        return -1;\n    }\n```\n\n10. 字符串翻转\n“leetcode i\" --> \"i leetcode\"\n思路：1. 使用栈\n2. 先整个字符串翻转，去空格+原位翻转（双指针）+删除后面多余的字符 //空间复杂度O(1)\n\n11. 实现 atoi() 字符串转数字：注意这几个测试用例\n  a. 包含非法字符，返回 error 或者 0\n  b. 要考虑正负号\n  c. 要考虑溢出的情况。直接按照字典序，比较输入字符串和 TMin、TMax 的字符串就可以了，不需要在转换过程中判断是否溢出\n\n12. lc115. 不同的子序列(字符串匹配问题)\n-  这道题主要是求一个字符串s中可以找到多少个字符串t(只变了一个字符也是一种新的情况) (见8.序列自动机)\n-  使用dp[i][j]表示字符串s前i个，和字符串t前j个进行匹配的个数，那么状态转移方程为 （下面展示的是从前往后，从后往前也是可以的）\n```C++\n        for(int i=0;i<s1;i++){  //注意这里的初始化非常重要\n            dp[i][0]=1;\n        }\n        for(int i=1;i<s1;i++){\n            for(int j=1;j<s2;j++){\n                if(s[i]==t[j]){\n                    dp[i][j]=dp[i-1][j-1]+dp[i-1][j];   //相同可以与当前t匹配，也可以不匹配\n                }else{\n                    dp[i][j]=dp[i-1][j];\n                }\n                dp[i][j]=min(dp[i][j],1LL*1000000000000000); //这里是为了防止long long型超出范围\n            }\n        }\n```\n-  其他注意的地方：自左向右和从右到左都会爆 long long超出范围，使用记忆化搜索不会。同时一定要记得初始化，没有与模式字符串匹配的时候，都需要赋值为1 dp[i][0]=1\n\n\n\n13. Trie树的实现\n具体实现见系统设计中的Trie树专题\n\n14. 单词搜索\n- Trie树+回溯\n先将要字典中的单词建立一颗Trie树，然后枚举矩阵中的每个点，进行dfs, 在进行dfs的时候，只对Trie树中有的边进行dfs, 如果当前走到isEnd=True的情况，那么就直接压入结果，同时这个时候不能直接退出，还可以继续dfs,因为字典中的单词可能是存在相互包含的关系的（dfs剪枝）\n\n<font color=red>15. 最长回文前缀</font>\nlc214. 最短回文串\n求s的最长回文前缀，其实就是求str = s+\"#\"+rev_s的最长公共前后缀，使用KMP算法求next数组，然后返回next[str.size()-1]，就是最长的回文前缀\n\n一个字符串的最长前后缀为，这个字符串求next数组，返回next[size-1]\n\n马拉车算法：https://www.acwing.com/file_system/file/content/whole/index/content/446985/\n\n<font color=red>16. lc321. 拼接最大数 (hard)</font>\n- 题意：从两个数组中共选择k个数，是的数最大\n- 第一步是枚举每个数组中取数据的个数\n- 第二步分别从两个数组中得到指定长度的最大子序列\n- 第三步是将两个最大子序列合并。（一定要注意合并！！！！ 可能会遇到相同的情况，不是随便选一个，而是要找到他们后面第一个不相等的进行比较）\n```C++\n  bool flag=true; //第一个数组++\n  while(index1<m&&index2<n){\n      if(arr1[index1]>arr2[index2]){\n          flag==true;\n          break;\n      }else if(arr1[index1]<arr2[index2]){\n          flag=false;\n          break;\n      }\n      index1++;\n      index2++;\n  }\n  if(index1==m){\n      flag=false;\n  }\n```\n\n\n17. lc792. 匹配子序列的单词数\n- 判断字典里面的每个字符串是否是s的子序列，使用双指针会超时\n- 方法一：使用字符串dp, dp[i][j]表示s从index下标开始，找到的第一个字母j的下标\n- 方法二：使用map<int, vector<int>> 记录下每个字母在字符串中下标的位置，然后使用二分查找\n\n\n#### 总结\nok ok\n1. 在对字符串进行操作通常可以朝栈，递归， bfs等方向思考\n    尤其是左右括号对应的这种情况-> 栈和递归\n2. 状态压缩：如果字符串的每一个字符串都至多包含每个字母一次，并且字母的顺序无关紧要，因此我们可以使用一个 262的二进制数 mask 表示一个字符串。\n  同时如何两两判断两个字符串是否有关联的时间复杂度太高O(n^2^len(str)), 那么可以转为「枚举一个节点」+「枚举可能的相邻节点」+「使用哈希表判断相邻节点是否真正存在」的方法得到所有关联的边，（也就是猜测字符串的每个数的时间复杂度可能小于两层循环遍历+判断）\n\n3. 注意在进行字符串比较的时候是比较多次，但是在进行数字比较的时候是比较一次,所以hash的key存int比存string更高效\n\n4. char a可以使用a++，变为另外一个字符 'A'->'B'\n  但是string s类型，即使只有一个字符，也必须使用s[0]++, 不能使用s++\n\n5. 如果出现反复将一个字符串的子串和字典中的每个字符比对的题目，可以使用Trie树，或者使用动态规划（True/False类型），提前判断某一个子字符串是否在字典中 （PS: 动态规划中也有这句话的总结）\n\n6. Trie树，通常是将字典里面的字符串构建一个trie数，然后在进行查询的时候，就相当于直接在字典中（多个字符串同时）查找，而不是和字典中的每个字符串进行对比\n例题：lc: 面试题 17.17. 多次搜索(KMP/ Trie数)\n\n7. 字符串匹配问题:求个数，求是否匹配，求删除字符的最小数量，都是使用的动态规划，定义的dp[i][j]都是让s前i个字符和t前j个字符匹配的xxxx， 一般都是将s[i]和t[j]是否相等分成两种情况，并分别求对应的状态转移\n\n8. 有时候有字典的这种情况会考虑到建立前缀树，也可以考虑使用逆向思维，将字典树加密的所有字符串提前求出来，然后使用打表方法\nlc5302. 加密解密字符串（周赛hard）\n\n\n\n\n\n","slug":"leetcode/字符串","published":1,"updated":"2023-07-10T10:36:19.573Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clk5ceinq000wjpjbf9xo2orz","content":"<h4 id=\"常见字符串解决套路\"><a href=\"#常见字符串解决套路\" class=\"headerlink\" title=\"常见字符串解决套路\"></a>常见字符串解决套路</h4><ol>\n<li><a href=\"./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%A2%98%E5%9E%8B.md\">用动态规划求解</a></li>\n<li><a href=\"./%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.md\">用滑动窗口求解</a></li>\n<li><a href=\"./%E5%8F%8C%E6%8C%87%E9%92%88.md\">用双指针求解</a></li>\n<li><a href=\"./%E5%9B%9E%E6%BA%AF_DFS_BFS.md\">使用DFS/BFS求一个字符串转为另外一个字符串的路径问题</a></li>\n</ol>\n<h4 id=\"扩展：字符串hash\"><a href=\"#扩展：字符串hash\" class=\"headerlink\" title=\"扩展：字符串hash\"></a>扩展：字符串hash</h4><p>abcde<br>转为为多项式<br>f(5)= a* p^5 + b*p^4 +c *p^3 +d <em>p^2 +e <em>p^1<br>f(3)= a</em> p^3 + b</em>p^2 +c *p^1<br>f(4, 5)=f(5)-f(3)*p^(5-4+1)</p>\n<p>c++用unsigned long long 自然溢出，可以不用取模，如果使用取模方式可能会导致溢出</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">p[<span class=\"hljs-number\">0</span>]=<span class=\"hljs-number\">1</span>;<br>h[<span class=\"hljs-number\">0</span>]=<span class=\"hljs-number\">0</span>;<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;size;i++)&#123;<br>  h[i]=h[i<span class=\"hljs-number\">-1</span>]*p+s[i<span class=\"hljs-number\">-1</span>]; <span class=\"hljs-comment\">//0到i-1之间的hash值</span><br>  p[i]=p[i<span class=\"hljs-number\">-1</span>]*p;  <span class=\"hljs-comment\">//不同长度字符串的p值</span><br>&#125;<br><br>hash_val_m_n=h[m]-h[n<span class=\"hljs-number\">-1</span>]*p[m-n+<span class=\"hljs-number\">1</span>];<br></code></pre></td></tr></table></figure>\n\n<p>最长重复子串（hard）<br>使用字符串hash+二分寻找长度，如果hash的key是字符串的话，时间复杂度为O(n*len))， 只有key为整数类型，时间复杂度才为 O(n))</p>\n<h4 id=\"例题\"><a href=\"#例题\" class=\"headerlink\" title=\"例题\"></a>例题</h4><ol>\n<li><p>最大数：注意使用str.substr以及位移操作时候一定要记得赋值，否则结果是不会改变的 res=res.substr(start, len), 以及注意最后的结果包含首0的情况，一定要记得去除首零</p>\n</li>\n<li><p>最大单词长度乘积<br>使用掩码判断字符串是否有相似的字符，然后掩码&amp;</p>\n</li>\n<li><p>打开转盘锁<br>使用bfs<br>值得学习的地方：</p>\n</li>\n<li><p>使用unordered_set代替vector<br>主要在判断一个字符之前是否在一个集合中, 使用unordered_set比vector更快 if(!set.count())  表示集合中没有这个元素</p>\n</li>\n<li><p>在查找当前字符变形后的字符，一定要及得保留当前的字符再做修改！！</p>\n</li>\n<li><p>匹配子序列的单词数<br>查看多个字符串中，有几个是字符串s的子序列<br>使用二分查找，先通过hash，将不同字符对应的下标值进行存储，然后遍历需要查询的每个字符串，分别从hash里面多个vector进行查找，同时下次查找的下标，应该比当前下标至少+1</p>\n</li>\n</ol>\n<p><font color=\"red\">4. 反转每对括号间的子串 (华为机试)</font><br><strong>字符串+栈</strong><br>注意这道题我最开始还没想出来</p>\n<ul>\n<li>解决方案：<br>str为最后的结果<br>遇到（ 那么将str的元素压入栈中，然后str转为“”<br>遇到）那么将str元素翻转，<strong>如果栈不为空, 将栈顶元素弹出</strong>, str=s.top()+str; s.pop()<br>其余的字符直接追加在str后面<br>最后返回str</li>\n<li>也就是拼接好的字符串直接放在str中，不需要再压入栈中, 多了一个 “每次遇到]将当前字符串reverse 并加在栈顶元素的后面” 的步骤</li>\n</ul>\n<p>PS：类似的一道题: 字符串解码 (2021年4399后端开发笔试原题)</p>\n<ul>\n<li>仍然使用栈, 思路和4相似，只不过多了一个数字 （左括号不会被压入栈中）</li>\n<li>另一种解法：数字存放在数字栈，字符串存放在字符串栈，遇到右括号时候弹出一个数字栈，字母栈弹到左括号为止。（左括号会压入栈中）</li>\n</ul>\n<p><font color=\"red\">5. lc2157字符串分组(hard)</font></p>\n<ul>\n<li>(lc49字符串异位词分组) 用string或者vector<int> 作为hash的key</int></li>\n<li>并查集对字符串进行分组和记录组数（带size的并查集，同时要考虑可能存在相同字符串的情况， size[x]&gt;1 group–，同时合并的时候， group也会–），状态压缩+位运算实现字符串关联判断和查找</li>\n<li>如果直接枚举任意两个字符串并判断是否关联，并以此得到图上所有的边，时间复杂度至少为 O(n^2), 会超出时间限制。因此对每个字符串进行变换</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">int</span> x = <span class=\"hljs-number\">0</span>;<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">char</span> ch: word) &#123;<br>    x |= <span class=\"hljs-number\">1</span> &lt;&lt; (ch - <span class=\"hljs-string\">&#x27;a&#x27;</span>); <span class=\"hljs-comment\">// 计算 word 的二进制表示</span><br>&#125;<br><br><span class=\"hljs-keyword\">for</span> x := range fa &#123; <span class=\"hljs-comment\">// 枚举所有字符串（二进制表示）</span><br>\t\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">26</span>; i++ &#123;<br>\t\t\t<span class=\"hljs-built_in\">merge</span>(x, x^<span class=\"hljs-number\">1</span>&lt;&lt;i) <span class=\"hljs-comment\">// 添加或删除字符 i  0变为1， 1变为0</span><br>\t\t\t<span class=\"hljs-keyword\">if</span> x&gt;&gt;i&amp;<span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">1</span> &#123; <span class=\"hljs-comment\">//找到一个1， 0对 翻转</span><br>\t\t\t\t<span class=\"hljs-keyword\">for</span> j := <span class=\"hljs-number\">0</span>; j &lt; <span class=\"hljs-number\">26</span>; j++ &#123;<br>\t\t\t\t\t<span class=\"hljs-keyword\">if</span> x&gt;&gt;j&amp;<span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">0</span> &#123;<br>\t\t\t\t\t\t<span class=\"hljs-built_in\">merge</span>(x, x^<span class=\"hljs-number\">1</span>&lt;&lt;i|<span class=\"hljs-number\">1</span>&lt;&lt;j) <span class=\"hljs-comment\">// 替换字符 i 为 j</span><br>\t\t\t\t\t&#125;<br>\t\t\t\t&#125;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t&#125;<br><br></code></pre></td></tr></table></figure>\n\n<ol start=\"6\">\n<li>最长的美好子字符串</li>\n</ol>\n<ul>\n<li>枚举，i， j, 表示字符串左右，两重循环</li>\n<li>然后使用两个二进制代替两个数组，判断是否大小写都有，如果有数量就不能使用两个数来代替，只有这种有或没有可以<br>也是使用二进制对字符串进行压缩<br>枚举/分治/枚举typenum(至少有K个重复字符的最长子串, 不建议用这种方法，因为比较难)</li>\n</ul>\n<ol start=\"7\">\n<li>不同字符的最小子序列<br>去除重复的字符串，使得子序列包含所有的字符，每个字符一次，同时字典序有最少<br>solution:<br>需要有一个hash来记录一个字符的剩余出现次数<br>如果栈中没找到，从栈中弹出剩余出现次数大于0，而且大于当前字符的字符，然后压入当前字符<br>如果栈中找到，直接将num[当前字符]–, 不push进入栈中</li>\n</ol>\n<p><font color=\"red\">8.序列自动机</font><br>字符串dp<br>在进行判断一个字符串a是否是另外一个字符串b的子序列的时候，可以使用双指针，判断a的指针是否能走到末尾<br>也可以使用dp<br>dp[i][j]=i  s[i]==j （表示s从i开始第一个等于字符j的下标）<br>dp[i][j]=dp[i+1][j]  s[i]!=j<br>从后往前更新</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"> Arrays.fill(f[m], m);<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = m - <span class=\"hljs-number\">1</span>; i &gt;= <span class=\"hljs-number\">0</span>; --i) &#123;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; <span class=\"hljs-number\">26</span>; ++j) &#123;<span class=\"hljs-comment\">//只包含小写字符</span><br>\t\t<span class=\"hljs-keyword\">if</span> (s.charAt(i) == (<span class=\"hljs-keyword\">char</span>) (<span class=\"hljs-string\">&#x27;a&#x27;</span> + j)) &#123;<br>\t\t\tf[i][j] = i;<br>\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\tf[i][j] = f[i + <span class=\"hljs-number\">1</span>][j];<br>\t\t&#125;<br>\t&#125;<br>&#125;<br>String res = <span class=\"hljs-string\">&quot;&quot;</span>;<br><span class=\"hljs-keyword\">for</span> (String t : dictionary) &#123;<br>\t<span class=\"hljs-keyword\">boolean</span> match = <span class=\"hljs-keyword\">true</span>;<br>\t<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; t.length(); ++i) &#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (f[j][t.charAt(i) - <span class=\"hljs-string\">&#x27;a&#x27;</span>] == m) &#123;<br>\t\t\tmatch = <span class=\"hljs-keyword\">false</span>;<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t&#125;<br>\t\tj = f[j][t.charAt(i) - <span class=\"hljs-string\">&#x27;a&#x27;</span>] + <span class=\"hljs-number\">1</span>;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span> (match) &#123;<br>\t\t<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ol start=\"9\">\n<li><p>KMP算法的模板，主要是求next的数组，以及在循环退出之后判断字符是否相等，进行k的判断或者next数组的赋值</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">findnext</span><span class=\"hljs-params\">(string pattern, vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&amp; next)</span></span>&#123;<br>       <span class=\"hljs-keyword\">int</span> size = pattern.<span class=\"hljs-built_in\">size</span>();<br>       <span class=\"hljs-keyword\">int</span> k = <span class=\"hljs-number\">-1</span>;<br>       next[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">-1</span>;<span class=\"hljs-comment\">//代表已经匹配的下标</span><br>       <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt; size; i++)<br>       &#123;<br>           <span class=\"hljs-keyword\">while</span>(k!=<span class=\"hljs-number\">-1</span>&amp;&amp;pattern[i]!=pattern[k+<span class=\"hljs-number\">1</span>])&#123;<br>                   k = next[k];<br>           &#125;<span class=\"hljs-comment\">//因为跳出循环后还需要判断相等，因此将判断相等放在while的后面而不是前面</span><br>           <span class=\"hljs-keyword\">if</span>(pattern[i]==pattern[k+<span class=\"hljs-number\">1</span>])&#123;<br>               k++;<br>           &#125;<br><br>           next[i] = k;<br>       &#125;<br>   &#125;<br>   <span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">strStr</span><span class=\"hljs-params\">(string haystack, string needle)</span> </span>&#123;<br>   <span class=\"hljs-comment\">// int KMP(string target, string pattern)&#123;</span><br>       string target=haystack;<br>       string pattern=needle;<br>       <span class=\"hljs-keyword\">int</span> size = target.<span class=\"hljs-built_in\">size</span>();<br>       <span class=\"hljs-keyword\">int</span> k = <span class=\"hljs-number\">-1</span>;<br>       <span class=\"hljs-keyword\">if</span>(pattern==<span class=\"hljs-string\">&quot;&quot;</span>)&#123;<br>           <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>       &#125;<br>       <span class=\"hljs-function\">vector&lt;<span class=\"hljs-keyword\">int</span>&gt; <span class=\"hljs-title\">next</span><span class=\"hljs-params\">(pattern.size())</span></span>;<br>       <span class=\"hljs-built_in\">findnext</span>(pattern, next);<br>       <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; size; i++)<br>       &#123;<br>           <span class=\"hljs-keyword\">while</span>(k!=<span class=\"hljs-number\">-1</span>&amp;&amp;target[i]!=pattern[k+<span class=\"hljs-number\">1</span>])&#123;<br>                   k = next[k];<br>           &#125;<br>           <span class=\"hljs-keyword\">if</span>(target[i]==pattern[k+<span class=\"hljs-number\">1</span>])&#123;<br>               k++;<br>               <span class=\"hljs-keyword\">if</span>(k==pattern.<span class=\"hljs-built_in\">size</span>()<span class=\"hljs-number\">-1</span>)&#123;<br>                   <span class=\"hljs-keyword\">return</span> i - k ; <span class=\"hljs-comment\">//返回匹配字符串的头位置</span><br>               &#125;<br>           &#125;<br><br>       &#125;<br>       <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>   &#125;<br></code></pre></td></tr></table></figure></li>\n<li><p>字符串翻转<br>“leetcode i” –&gt; “i leetcode”<br>思路：1. 使用栈</p>\n</li>\n<li><p>先整个字符串翻转，去空格+原位翻转（双指针）+删除后面多余的字符 //空间复杂度O(1)</p>\n</li>\n<li><p>实现 atoi() 字符串转数字：注意这几个测试用例<br>a. 包含非法字符，返回 error 或者 0<br>b. 要考虑正负号<br>c. 要考虑溢出的情况。直接按照字典序，比较输入字符串和 TMin、TMax 的字符串就可以了，不需要在转换过程中判断是否溢出</p>\n</li>\n<li><p>lc115. 不同的子序列(字符串匹配问题)</p>\n</li>\n</ol>\n<ul>\n<li> 这道题主要是求一个字符串s中可以找到多少个字符串t(只变了一个字符也是一种新的情况) (见8.序列自动机)</li>\n<li> 使用dp[i][j]表示字符串s前i个，和字符串t前j个进行匹配的个数，那么状态转移方程为 （下面展示的是从前往后，从后往前也是可以的）<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;s1;i++)&#123;  <span class=\"hljs-comment\">//注意这里的初始化非常重要</span><br>    dp[i][<span class=\"hljs-number\">0</span>]=<span class=\"hljs-number\">1</span>;<br>&#125;<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;s1;i++)&#123;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">1</span>;j&lt;s2;j++)&#123;<br>        <span class=\"hljs-keyword\">if</span>(s[i]==t[j])&#123;<br>            dp[i][j]=dp[i<span class=\"hljs-number\">-1</span>][j<span class=\"hljs-number\">-1</span>]+dp[i<span class=\"hljs-number\">-1</span>][j];   <span class=\"hljs-comment\">//相同可以与当前t匹配，也可以不匹配</span><br>        &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>            dp[i][j]=dp[i<span class=\"hljs-number\">-1</span>][j];<br>        &#125;<br>        dp[i][j]=<span class=\"hljs-built_in\">min</span>(dp[i][j],<span class=\"hljs-number\">1LL</span>*<span class=\"hljs-number\">1000000000000000</span>); <span class=\"hljs-comment\">//这里是为了防止long long型超出范围</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li> 其他注意的地方：自左向右和从右到左都会爆 long long超出范围，使用记忆化搜索不会。同时一定要记得初始化，没有与模式字符串匹配的时候，都需要赋值为1 dp[i][0]=1</li>\n</ul>\n<ol start=\"13\">\n<li><p>Trie树的实现<br>具体实现见系统设计中的Trie树专题</p>\n</li>\n<li><p>单词搜索</p>\n</li>\n</ol>\n<ul>\n<li>Trie树+回溯<br>先将要字典中的单词建立一颗Trie树，然后枚举矩阵中的每个点，进行dfs, 在进行dfs的时候，只对Trie树中有的边进行dfs, 如果当前走到isEnd=True的情况，那么就直接压入结果，同时这个时候不能直接退出，还可以继续dfs,因为字典中的单词可能是存在相互包含的关系的（dfs剪枝）</li>\n</ul>\n<p><font color=\"red\">15. 最长回文前缀</font><br>lc214. 最短回文串<br>求s的最长回文前缀，其实就是求str = s+”#”+rev_s的最长公共前后缀，使用KMP算法求next数组，然后返回next[str.size()-1]，就是最长的回文前缀</p>\n<p>一个字符串的最长前后缀为，这个字符串求next数组，返回next[size-1]</p>\n<p>马拉车算法：<a href=\"https://www.acwing.com/file_system/file/content/whole/index/content/446985/\">https://www.acwing.com/file_system/file/content/whole/index/content/446985/</a></p>\n<p><font color=\"red\">16. lc321. 拼接最大数 (hard)</font></p>\n<ul>\n<li>题意：从两个数组中共选择k个数，是的数最大</li>\n<li>第一步是枚举每个数组中取数据的个数</li>\n<li>第二步分别从两个数组中得到指定长度的最大子序列</li>\n<li>第三步是将两个最大子序列合并。（一定要注意合并！！！！ 可能会遇到相同的情况，不是随便选一个，而是要找到他们后面第一个不相等的进行比较）<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">bool</span> flag=<span class=\"hljs-literal\">true</span>; <span class=\"hljs-comment\">//第一个数组++</span><br><span class=\"hljs-keyword\">while</span>(index1&lt;m&amp;&amp;index2&lt;n)&#123;<br>    <span class=\"hljs-keyword\">if</span>(arr1[index1]&gt;arr2[index2])&#123;<br>        flag==<span class=\"hljs-literal\">true</span>;<br>        <span class=\"hljs-keyword\">break</span>;<br>    &#125;<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(arr1[index1]&lt;arr2[index2])&#123;<br>        flag=<span class=\"hljs-literal\">false</span>;<br>        <span class=\"hljs-keyword\">break</span>;<br>    &#125;<br>    index1++;<br>    index2++;<br>&#125;<br><span class=\"hljs-keyword\">if</span>(index1==m)&#123;<br>    flag=<span class=\"hljs-literal\">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n</ul>\n<ol start=\"17\">\n<li>lc792. 匹配子序列的单词数</li>\n</ol>\n<ul>\n<li>判断字典里面的每个字符串是否是s的子序列，使用双指针会超时</li>\n<li>方法一：使用字符串dp, dp[i][j]表示s从index下标开始，找到的第一个字母j的下标</li>\n<li>方法二：使用map&lt;int, vector<int>&gt; 记录下每个字母在字符串中下标的位置，然后使用二分查找</int></li>\n</ul>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>ok ok</p>\n<ol>\n<li><p>在对字符串进行操作通常可以朝栈，递归， bfs等方向思考<br> 尤其是左右括号对应的这种情况-&gt; 栈和递归</p>\n</li>\n<li><p>状态压缩：如果字符串的每一个字符串都至多包含每个字母一次，并且字母的顺序无关紧要，因此我们可以使用一个 262的二进制数 mask 表示一个字符串。<br>同时如何两两判断两个字符串是否有关联的时间复杂度太高O(n^2^len(str)), 那么可以转为「枚举一个节点」+「枚举可能的相邻节点」+「使用哈希表判断相邻节点是否真正存在」的方法得到所有关联的边，（也就是猜测字符串的每个数的时间复杂度可能小于两层循环遍历+判断）</p>\n</li>\n<li><p>注意在进行字符串比较的时候是比较多次，但是在进行数字比较的时候是比较一次,所以hash的key存int比存string更高效</p>\n</li>\n<li><p>char a可以使用a++，变为另外一个字符 ‘A’-&gt;’B’<br>但是string s类型，即使只有一个字符，也必须使用s[0]++, 不能使用s++</p>\n</li>\n<li><p>如果出现反复将一个字符串的子串和字典中的每个字符比对的题目，可以使用Trie树，或者使用动态规划（True/False类型），提前判断某一个子字符串是否在字典中 （PS: 动态规划中也有这句话的总结）</p>\n</li>\n<li><p>Trie树，通常是将字典里面的字符串构建一个trie数，然后在进行查询的时候，就相当于直接在字典中（多个字符串同时）查找，而不是和字典中的每个字符串进行对比<br>例题：lc: 面试题 17.17. 多次搜索(KMP/ Trie数)</p>\n</li>\n<li><p>字符串匹配问题:求个数，求是否匹配，求删除字符的最小数量，都是使用的动态规划，定义的dp[i][j]都是让s前i个字符和t前j个字符匹配的xxxx， 一般都是将s[i]和t[j]是否相等分成两种情况，并分别求对应的状态转移</p>\n</li>\n<li><p>有时候有字典的这种情况会考虑到建立前缀树，也可以考虑使用逆向思维，将字典树加密的所有字符串提前求出来，然后使用打表方法<br>lc5302. 加密解密字符串（周赛hard）</p>\n</li>\n</ol>\n","site":{"data":{}},"wordcount":6150,"excerpt":"","more":"<h4 id=\"常见字符串解决套路\"><a href=\"#常见字符串解决套路\" class=\"headerlink\" title=\"常见字符串解决套路\"></a>常见字符串解决套路</h4><ol>\n<li><a href=\"./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%A2%98%E5%9E%8B.md\">用动态规划求解</a></li>\n<li><a href=\"./%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.md\">用滑动窗口求解</a></li>\n<li><a href=\"./%E5%8F%8C%E6%8C%87%E9%92%88.md\">用双指针求解</a></li>\n<li><a href=\"./%E5%9B%9E%E6%BA%AF_DFS_BFS.md\">使用DFS/BFS求一个字符串转为另外一个字符串的路径问题</a></li>\n</ol>\n<h4 id=\"扩展：字符串hash\"><a href=\"#扩展：字符串hash\" class=\"headerlink\" title=\"扩展：字符串hash\"></a>扩展：字符串hash</h4><p>abcde<br>转为为多项式<br>f(5)= a* p^5 + b*p^4 +c *p^3 +d <em>p^2 +e <em>p^1<br>f(3)= a</em> p^3 + b</em>p^2 +c *p^1<br>f(4, 5)=f(5)-f(3)*p^(5-4+1)</p>\n<p>c++用unsigned long long 自然溢出，可以不用取模，如果使用取模方式可能会导致溢出</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">p[<span class=\"hljs-number\">0</span>]=<span class=\"hljs-number\">1</span>;<br>h[<span class=\"hljs-number\">0</span>]=<span class=\"hljs-number\">0</span>;<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;size;i++)&#123;<br>  h[i]=h[i<span class=\"hljs-number\">-1</span>]*p+s[i<span class=\"hljs-number\">-1</span>]; <span class=\"hljs-comment\">//0到i-1之间的hash值</span><br>  p[i]=p[i<span class=\"hljs-number\">-1</span>]*p;  <span class=\"hljs-comment\">//不同长度字符串的p值</span><br>&#125;<br><br>hash_val_m_n=h[m]-h[n<span class=\"hljs-number\">-1</span>]*p[m-n+<span class=\"hljs-number\">1</span>];<br></code></pre></td></tr></table></figure>\n\n<p>最长重复子串（hard）<br>使用字符串hash+二分寻找长度，如果hash的key是字符串的话，时间复杂度为O(n*len))， 只有key为整数类型，时间复杂度才为 O(n))</p>\n<h4 id=\"例题\"><a href=\"#例题\" class=\"headerlink\" title=\"例题\"></a>例题</h4><ol>\n<li><p>最大数：注意使用str.substr以及位移操作时候一定要记得赋值，否则结果是不会改变的 res=res.substr(start, len), 以及注意最后的结果包含首0的情况，一定要记得去除首零</p>\n</li>\n<li><p>最大单词长度乘积<br>使用掩码判断字符串是否有相似的字符，然后掩码&amp;</p>\n</li>\n<li><p>打开转盘锁<br>使用bfs<br>值得学习的地方：</p>\n</li>\n<li><p>使用unordered_set代替vector<br>主要在判断一个字符之前是否在一个集合中, 使用unordered_set比vector更快 if(!set.count())  表示集合中没有这个元素</p>\n</li>\n<li><p>在查找当前字符变形后的字符，一定要及得保留当前的字符再做修改！！</p>\n</li>\n<li><p>匹配子序列的单词数<br>查看多个字符串中，有几个是字符串s的子序列<br>使用二分查找，先通过hash，将不同字符对应的下标值进行存储，然后遍历需要查询的每个字符串，分别从hash里面多个vector进行查找，同时下次查找的下标，应该比当前下标至少+1</p>\n</li>\n</ol>\n<p><font color=\"red\">4. 反转每对括号间的子串 (华为机试)</font><br><strong>字符串+栈</strong><br>注意这道题我最开始还没想出来</p>\n<ul>\n<li>解决方案：<br>str为最后的结果<br>遇到（ 那么将str的元素压入栈中，然后str转为“”<br>遇到）那么将str元素翻转，<strong>如果栈不为空, 将栈顶元素弹出</strong>, str=s.top()+str; s.pop()<br>其余的字符直接追加在str后面<br>最后返回str</li>\n<li>也就是拼接好的字符串直接放在str中，不需要再压入栈中, 多了一个 “每次遇到]将当前字符串reverse 并加在栈顶元素的后面” 的步骤</li>\n</ul>\n<p>PS：类似的一道题: 字符串解码 (2021年4399后端开发笔试原题)</p>\n<ul>\n<li>仍然使用栈, 思路和4相似，只不过多了一个数字 （左括号不会被压入栈中）</li>\n<li>另一种解法：数字存放在数字栈，字符串存放在字符串栈，遇到右括号时候弹出一个数字栈，字母栈弹到左括号为止。（左括号会压入栈中）</li>\n</ul>\n<p><font color=\"red\">5. lc2157字符串分组(hard)</font></p>\n<ul>\n<li>(lc49字符串异位词分组) 用string或者vector<int> 作为hash的key</int></li>\n<li>并查集对字符串进行分组和记录组数（带size的并查集，同时要考虑可能存在相同字符串的情况， size[x]&gt;1 group–，同时合并的时候， group也会–），状态压缩+位运算实现字符串关联判断和查找</li>\n<li>如果直接枚举任意两个字符串并判断是否关联，并以此得到图上所有的边，时间复杂度至少为 O(n^2), 会超出时间限制。因此对每个字符串进行变换</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">int</span> x = <span class=\"hljs-number\">0</span>;<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">char</span> ch: word) &#123;<br>    x |= <span class=\"hljs-number\">1</span> &lt;&lt; (ch - <span class=\"hljs-string\">&#x27;a&#x27;</span>); <span class=\"hljs-comment\">// 计算 word 的二进制表示</span><br>&#125;<br><br><span class=\"hljs-keyword\">for</span> x := range fa &#123; <span class=\"hljs-comment\">// 枚举所有字符串（二进制表示）</span><br>\t\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">26</span>; i++ &#123;<br>\t\t\t<span class=\"hljs-built_in\">merge</span>(x, x^<span class=\"hljs-number\">1</span>&lt;&lt;i) <span class=\"hljs-comment\">// 添加或删除字符 i  0变为1， 1变为0</span><br>\t\t\t<span class=\"hljs-keyword\">if</span> x&gt;&gt;i&amp;<span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">1</span> &#123; <span class=\"hljs-comment\">//找到一个1， 0对 翻转</span><br>\t\t\t\t<span class=\"hljs-keyword\">for</span> j := <span class=\"hljs-number\">0</span>; j &lt; <span class=\"hljs-number\">26</span>; j++ &#123;<br>\t\t\t\t\t<span class=\"hljs-keyword\">if</span> x&gt;&gt;j&amp;<span class=\"hljs-number\">1</span> == <span class=\"hljs-number\">0</span> &#123;<br>\t\t\t\t\t\t<span class=\"hljs-built_in\">merge</span>(x, x^<span class=\"hljs-number\">1</span>&lt;&lt;i|<span class=\"hljs-number\">1</span>&lt;&lt;j) <span class=\"hljs-comment\">// 替换字符 i 为 j</span><br>\t\t\t\t\t&#125;<br>\t\t\t\t&#125;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t&#125;<br><br></code></pre></td></tr></table></figure>\n\n<ol start=\"6\">\n<li>最长的美好子字符串</li>\n</ol>\n<ul>\n<li>枚举，i， j, 表示字符串左右，两重循环</li>\n<li>然后使用两个二进制代替两个数组，判断是否大小写都有，如果有数量就不能使用两个数来代替，只有这种有或没有可以<br>也是使用二进制对字符串进行压缩<br>枚举/分治/枚举typenum(至少有K个重复字符的最长子串, 不建议用这种方法，因为比较难)</li>\n</ul>\n<ol start=\"7\">\n<li>不同字符的最小子序列<br>去除重复的字符串，使得子序列包含所有的字符，每个字符一次，同时字典序有最少<br>solution:<br>需要有一个hash来记录一个字符的剩余出现次数<br>如果栈中没找到，从栈中弹出剩余出现次数大于0，而且大于当前字符的字符，然后压入当前字符<br>如果栈中找到，直接将num[当前字符]–, 不push进入栈中</li>\n</ol>\n<p><font color=\"red\">8.序列自动机</font><br>字符串dp<br>在进行判断一个字符串a是否是另外一个字符串b的子序列的时候，可以使用双指针，判断a的指针是否能走到末尾<br>也可以使用dp<br>dp[i][j]=i  s[i]==j （表示s从i开始第一个等于字符j的下标）<br>dp[i][j]=dp[i+1][j]  s[i]!=j<br>从后往前更新</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"> Arrays.fill(f[m], m);<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = m - <span class=\"hljs-number\">1</span>; i &gt;= <span class=\"hljs-number\">0</span>; --i) &#123;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; <span class=\"hljs-number\">26</span>; ++j) &#123;<span class=\"hljs-comment\">//只包含小写字符</span><br>\t\t<span class=\"hljs-keyword\">if</span> (s.charAt(i) == (<span class=\"hljs-keyword\">char</span>) (<span class=\"hljs-string\">&#x27;a&#x27;</span> + j)) &#123;<br>\t\t\tf[i][j] = i;<br>\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\tf[i][j] = f[i + <span class=\"hljs-number\">1</span>][j];<br>\t\t&#125;<br>\t&#125;<br>&#125;<br>String res = <span class=\"hljs-string\">&quot;&quot;</span>;<br><span class=\"hljs-keyword\">for</span> (String t : dictionary) &#123;<br>\t<span class=\"hljs-keyword\">boolean</span> match = <span class=\"hljs-keyword\">true</span>;<br>\t<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; t.length(); ++i) &#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (f[j][t.charAt(i) - <span class=\"hljs-string\">&#x27;a&#x27;</span>] == m) &#123;<br>\t\t\tmatch = <span class=\"hljs-keyword\">false</span>;<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t&#125;<br>\t\tj = f[j][t.charAt(i) - <span class=\"hljs-string\">&#x27;a&#x27;</span>] + <span class=\"hljs-number\">1</span>;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span> (match) &#123;<br>\t\t<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ol start=\"9\">\n<li><p>KMP算法的模板，主要是求next的数组，以及在循环退出之后判断字符是否相等，进行k的判断或者next数组的赋值</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">findnext</span><span class=\"hljs-params\">(string pattern, vector&lt;<span class=\"hljs-keyword\">int</span>&gt;&amp; next)</span></span>&#123;<br>       <span class=\"hljs-keyword\">int</span> size = pattern.<span class=\"hljs-built_in\">size</span>();<br>       <span class=\"hljs-keyword\">int</span> k = <span class=\"hljs-number\">-1</span>;<br>       next[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">-1</span>;<span class=\"hljs-comment\">//代表已经匹配的下标</span><br>       <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt; size; i++)<br>       &#123;<br>           <span class=\"hljs-keyword\">while</span>(k!=<span class=\"hljs-number\">-1</span>&amp;&amp;pattern[i]!=pattern[k+<span class=\"hljs-number\">1</span>])&#123;<br>                   k = next[k];<br>           &#125;<span class=\"hljs-comment\">//因为跳出循环后还需要判断相等，因此将判断相等放在while的后面而不是前面</span><br>           <span class=\"hljs-keyword\">if</span>(pattern[i]==pattern[k+<span class=\"hljs-number\">1</span>])&#123;<br>               k++;<br>           &#125;<br><br>           next[i] = k;<br>       &#125;<br>   &#125;<br>   <span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">strStr</span><span class=\"hljs-params\">(string haystack, string needle)</span> </span>&#123;<br>   <span class=\"hljs-comment\">// int KMP(string target, string pattern)&#123;</span><br>       string target=haystack;<br>       string pattern=needle;<br>       <span class=\"hljs-keyword\">int</span> size = target.<span class=\"hljs-built_in\">size</span>();<br>       <span class=\"hljs-keyword\">int</span> k = <span class=\"hljs-number\">-1</span>;<br>       <span class=\"hljs-keyword\">if</span>(pattern==<span class=\"hljs-string\">&quot;&quot;</span>)&#123;<br>           <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>       &#125;<br>       <span class=\"hljs-function\">vector&lt;<span class=\"hljs-keyword\">int</span>&gt; <span class=\"hljs-title\">next</span><span class=\"hljs-params\">(pattern.size())</span></span>;<br>       <span class=\"hljs-built_in\">findnext</span>(pattern, next);<br>       <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; size; i++)<br>       &#123;<br>           <span class=\"hljs-keyword\">while</span>(k!=<span class=\"hljs-number\">-1</span>&amp;&amp;target[i]!=pattern[k+<span class=\"hljs-number\">1</span>])&#123;<br>                   k = next[k];<br>           &#125;<br>           <span class=\"hljs-keyword\">if</span>(target[i]==pattern[k+<span class=\"hljs-number\">1</span>])&#123;<br>               k++;<br>               <span class=\"hljs-keyword\">if</span>(k==pattern.<span class=\"hljs-built_in\">size</span>()<span class=\"hljs-number\">-1</span>)&#123;<br>                   <span class=\"hljs-keyword\">return</span> i - k ; <span class=\"hljs-comment\">//返回匹配字符串的头位置</span><br>               &#125;<br>           &#125;<br><br>       &#125;<br>       <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>   &#125;<br></code></pre></td></tr></table></figure></li>\n<li><p>字符串翻转<br>“leetcode i” –&gt; “i leetcode”<br>思路：1. 使用栈</p>\n</li>\n<li><p>先整个字符串翻转，去空格+原位翻转（双指针）+删除后面多余的字符 //空间复杂度O(1)</p>\n</li>\n<li><p>实现 atoi() 字符串转数字：注意这几个测试用例<br>a. 包含非法字符，返回 error 或者 0<br>b. 要考虑正负号<br>c. 要考虑溢出的情况。直接按照字典序，比较输入字符串和 TMin、TMax 的字符串就可以了，不需要在转换过程中判断是否溢出</p>\n</li>\n<li><p>lc115. 不同的子序列(字符串匹配问题)</p>\n</li>\n</ol>\n<ul>\n<li> 这道题主要是求一个字符串s中可以找到多少个字符串t(只变了一个字符也是一种新的情况) (见8.序列自动机)</li>\n<li> 使用dp[i][j]表示字符串s前i个，和字符串t前j个进行匹配的个数，那么状态转移方程为 （下面展示的是从前往后，从后往前也是可以的）<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;s1;i++)&#123;  <span class=\"hljs-comment\">//注意这里的初始化非常重要</span><br>    dp[i][<span class=\"hljs-number\">0</span>]=<span class=\"hljs-number\">1</span>;<br>&#125;<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;s1;i++)&#123;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">1</span>;j&lt;s2;j++)&#123;<br>        <span class=\"hljs-keyword\">if</span>(s[i]==t[j])&#123;<br>            dp[i][j]=dp[i<span class=\"hljs-number\">-1</span>][j<span class=\"hljs-number\">-1</span>]+dp[i<span class=\"hljs-number\">-1</span>][j];   <span class=\"hljs-comment\">//相同可以与当前t匹配，也可以不匹配</span><br>        &#125;<span class=\"hljs-keyword\">else</span>&#123;<br>            dp[i][j]=dp[i<span class=\"hljs-number\">-1</span>][j];<br>        &#125;<br>        dp[i][j]=<span class=\"hljs-built_in\">min</span>(dp[i][j],<span class=\"hljs-number\">1LL</span>*<span class=\"hljs-number\">1000000000000000</span>); <span class=\"hljs-comment\">//这里是为了防止long long型超出范围</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li> 其他注意的地方：自左向右和从右到左都会爆 long long超出范围，使用记忆化搜索不会。同时一定要记得初始化，没有与模式字符串匹配的时候，都需要赋值为1 dp[i][0]=1</li>\n</ul>\n<ol start=\"13\">\n<li><p>Trie树的实现<br>具体实现见系统设计中的Trie树专题</p>\n</li>\n<li><p>单词搜索</p>\n</li>\n</ol>\n<ul>\n<li>Trie树+回溯<br>先将要字典中的单词建立一颗Trie树，然后枚举矩阵中的每个点，进行dfs, 在进行dfs的时候，只对Trie树中有的边进行dfs, 如果当前走到isEnd=True的情况，那么就直接压入结果，同时这个时候不能直接退出，还可以继续dfs,因为字典中的单词可能是存在相互包含的关系的（dfs剪枝）</li>\n</ul>\n<p><font color=\"red\">15. 最长回文前缀</font><br>lc214. 最短回文串<br>求s的最长回文前缀，其实就是求str = s+”#”+rev_s的最长公共前后缀，使用KMP算法求next数组，然后返回next[str.size()-1]，就是最长的回文前缀</p>\n<p>一个字符串的最长前后缀为，这个字符串求next数组，返回next[size-1]</p>\n<p>马拉车算法：<a href=\"https://www.acwing.com/file_system/file/content/whole/index/content/446985/\">https://www.acwing.com/file_system/file/content/whole/index/content/446985/</a></p>\n<p><font color=\"red\">16. lc321. 拼接最大数 (hard)</font></p>\n<ul>\n<li>题意：从两个数组中共选择k个数，是的数最大</li>\n<li>第一步是枚举每个数组中取数据的个数</li>\n<li>第二步分别从两个数组中得到指定长度的最大子序列</li>\n<li>第三步是将两个最大子序列合并。（一定要注意合并！！！！ 可能会遇到相同的情况，不是随便选一个，而是要找到他们后面第一个不相等的进行比较）<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">bool</span> flag=<span class=\"hljs-literal\">true</span>; <span class=\"hljs-comment\">//第一个数组++</span><br><span class=\"hljs-keyword\">while</span>(index1&lt;m&amp;&amp;index2&lt;n)&#123;<br>    <span class=\"hljs-keyword\">if</span>(arr1[index1]&gt;arr2[index2])&#123;<br>        flag==<span class=\"hljs-literal\">true</span>;<br>        <span class=\"hljs-keyword\">break</span>;<br>    &#125;<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(arr1[index1]&lt;arr2[index2])&#123;<br>        flag=<span class=\"hljs-literal\">false</span>;<br>        <span class=\"hljs-keyword\">break</span>;<br>    &#125;<br>    index1++;<br>    index2++;<br>&#125;<br><span class=\"hljs-keyword\">if</span>(index1==m)&#123;<br>    flag=<span class=\"hljs-literal\">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n</ul>\n<ol start=\"17\">\n<li>lc792. 匹配子序列的单词数</li>\n</ol>\n<ul>\n<li>判断字典里面的每个字符串是否是s的子序列，使用双指针会超时</li>\n<li>方法一：使用字符串dp, dp[i][j]表示s从index下标开始，找到的第一个字母j的下标</li>\n<li>方法二：使用map&lt;int, vector<int>&gt; 记录下每个字母在字符串中下标的位置，然后使用二分查找</int></li>\n</ul>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>ok ok</p>\n<ol>\n<li><p>在对字符串进行操作通常可以朝栈，递归， bfs等方向思考<br> 尤其是左右括号对应的这种情况-&gt; 栈和递归</p>\n</li>\n<li><p>状态压缩：如果字符串的每一个字符串都至多包含每个字母一次，并且字母的顺序无关紧要，因此我们可以使用一个 262的二进制数 mask 表示一个字符串。<br>同时如何两两判断两个字符串是否有关联的时间复杂度太高O(n^2^len(str)), 那么可以转为「枚举一个节点」+「枚举可能的相邻节点」+「使用哈希表判断相邻节点是否真正存在」的方法得到所有关联的边，（也就是猜测字符串的每个数的时间复杂度可能小于两层循环遍历+判断）</p>\n</li>\n<li><p>注意在进行字符串比较的时候是比较多次，但是在进行数字比较的时候是比较一次,所以hash的key存int比存string更高效</p>\n</li>\n<li><p>char a可以使用a++，变为另外一个字符 ‘A’-&gt;’B’<br>但是string s类型，即使只有一个字符，也必须使用s[0]++, 不能使用s++</p>\n</li>\n<li><p>如果出现反复将一个字符串的子串和字典中的每个字符比对的题目，可以使用Trie树，或者使用动态规划（True/False类型），提前判断某一个子字符串是否在字典中 （PS: 动态规划中也有这句话的总结）</p>\n</li>\n<li><p>Trie树，通常是将字典里面的字符串构建一个trie数，然后在进行查询的时候，就相当于直接在字典中（多个字符串同时）查找，而不是和字典中的每个字符串进行对比<br>例题：lc: 面试题 17.17. 多次搜索(KMP/ Trie数)</p>\n</li>\n<li><p>字符串匹配问题:求个数，求是否匹配，求删除字符的最小数量，都是使用的动态规划，定义的dp[i][j]都是让s前i个字符和t前j个字符匹配的xxxx， 一般都是将s[i]和t[j]是否相等分成两种情况，并分别求对应的状态转移</p>\n</li>\n<li><p>有时候有字典的这种情况会考虑到建立前缀树，也可以考虑使用逆向思维，将字典树加密的所有字符串提前求出来，然后使用打表方法<br>lc5302. 加密解密字符串（周赛hard）</p>\n</li>\n</ol>\n"},{"title":"暂时未看","catogory":["leetcode 题目汇总"],"date":"2021-11-13T09:23:20.000Z","_content":"\n1. 堆排序和其他排序内容，面试前过一次\n\n堆排序已经看，主要思路：\n先对每个内部节点进行heap_build,然后每次将0交换到i位置（n-1 到0），然后对0~i-1进行heap_build；\nheap_build：先对左右排序，在对root排序，如果当前root没有交换，那么退出递归程序，否则递归root=flag, heap_build\n\n\n2. 字典树\n前缀树也不一定要有value字段，当value的数字的时候，也可以直接用下标代表value，而不用记录value这个字段\n前缀树经典例题： \n- lc648. 单词替换(前缀单词查找，注意类函数需要申明为public, 26个字符（如果申请小于26个会报错），而且最初建立的对象是指针 Trie *t=new Trie()， t->search, t->findPrefix)\n- 1268. 搜索推荐系统\n- 字典树变形:在字典树中加入一个set<string> bags 来存储前缀包含该路径的前3个字符串，在每将字典里面的字符串插入这棵数的时候，将经过路径的所有字符的bags都插入这个字符串， 如果大于size, 就删除最后一个元素，bags.erase(--bags.end());\nvector<string> tmp(cur->bags.begin(), cur->bags.end());//set元素赋值给vec, vec反过来赋值一样的\n易错点：在收缩的时候，如果发现字典树都找不到这个字符了，那么直接break, 然后s.size()-res.size()大小全部push为 空的vec<string>\n\n\n\n   例题：子数组的最大异或和：\n- 方法一：可以求前缀异或和，然后遍历每个下标j前面的i XOR(i,j)=XOR(o,j)^XOR(0,j) 时间复杂度O(N^2)\n- 方法二：建立XOR的前缀树，然后计算每个以j结尾的数组能够获得的最大异或值，使用，遍历当前j值的二进制位（从31-0），比如j=00111, 那么走过的路径最好为01000，也就是符号相同，其余位置相反最好，\n如果之前值没有这个路径那么就取有的唯一那条路径（因为每个节点只有0 1两种情况\n\n3. 布隆过滤器，判断一个值是否在集合中：\n使用多个hash函数将输入映射到布隆过滤器 bitMap的多个位置，那么在进行判断一个输入是否存在的时候，可以根据如果计算出位置有一个位置没有被标记，说明这个数一定不在集合中，如果都被标记，那么说明可能在集合中。\n何根据失误率 p 和样本数 n 来确定布隆过滤器大小 m\n\n\n4. Dijstra算法，单源和多源最短路径\n\n\n5. 查找无序数组的最小k个数，使用BFPRT算法，相当于快速排序，但是在寻找pivot上进行了修改，将数组按照5\n个一组，找到每个组内的中位数，然后重复上述过程（也就是找中位数的中位数，直到最后只有一个数）\n\n\n6. skyline问i\nP446\n\n7. 位运算相关：下一个数\n\n\n8. 大数运算的相关题目，运用字符串进行加减乘除\n\n9. 面试题 16.09. 运算 只使用加法，不使用位运算实现减法，乘法，除法\n因为不使用位运算，因此只能累加，不能使用幂积法，因此需要将count对应value值存在vector之中，然后计算的时候，倒着计算，因为无法计算当前count/2是多少，不能正着加\n因此只能倒着减\n\n- 易错点：1.注意特殊情况，可以直接返回结果；2.注意数据可能有正负，因此需要都转为正数，然后最后结果判断是否需要加上符号\nif(neg%2!=0){\n    return -res;\n} 可以用计数法判断正负号\n\n","source":"_posts/leetcode/暂时没看内容.md","raw":"---\ntitle: 暂时未看\ncatogory:\n  - leetcode 题目汇总\ncategories:\n  - leetcode\ndate: 2021-11-13 17:23:20\ntags:\n---\n\n1. 堆排序和其他排序内容，面试前过一次\n\n堆排序已经看，主要思路：\n先对每个内部节点进行heap_build,然后每次将0交换到i位置（n-1 到0），然后对0~i-1进行heap_build；\nheap_build：先对左右排序，在对root排序，如果当前root没有交换，那么退出递归程序，否则递归root=flag, heap_build\n\n\n2. 字典树\n前缀树也不一定要有value字段，当value的数字的时候，也可以直接用下标代表value，而不用记录value这个字段\n前缀树经典例题： \n- lc648. 单词替换(前缀单词查找，注意类函数需要申明为public, 26个字符（如果申请小于26个会报错），而且最初建立的对象是指针 Trie *t=new Trie()， t->search, t->findPrefix)\n- 1268. 搜索推荐系统\n- 字典树变形:在字典树中加入一个set<string> bags 来存储前缀包含该路径的前3个字符串，在每将字典里面的字符串插入这棵数的时候，将经过路径的所有字符的bags都插入这个字符串， 如果大于size, 就删除最后一个元素，bags.erase(--bags.end());\nvector<string> tmp(cur->bags.begin(), cur->bags.end());//set元素赋值给vec, vec反过来赋值一样的\n易错点：在收缩的时候，如果发现字典树都找不到这个字符了，那么直接break, 然后s.size()-res.size()大小全部push为 空的vec<string>\n\n\n\n   例题：子数组的最大异或和：\n- 方法一：可以求前缀异或和，然后遍历每个下标j前面的i XOR(i,j)=XOR(o,j)^XOR(0,j) 时间复杂度O(N^2)\n- 方法二：建立XOR的前缀树，然后计算每个以j结尾的数组能够获得的最大异或值，使用，遍历当前j值的二进制位（从31-0），比如j=00111, 那么走过的路径最好为01000，也就是符号相同，其余位置相反最好，\n如果之前值没有这个路径那么就取有的唯一那条路径（因为每个节点只有0 1两种情况\n\n3. 布隆过滤器，判断一个值是否在集合中：\n使用多个hash函数将输入映射到布隆过滤器 bitMap的多个位置，那么在进行判断一个输入是否存在的时候，可以根据如果计算出位置有一个位置没有被标记，说明这个数一定不在集合中，如果都被标记，那么说明可能在集合中。\n何根据失误率 p 和样本数 n 来确定布隆过滤器大小 m\n\n\n4. Dijstra算法，单源和多源最短路径\n\n\n5. 查找无序数组的最小k个数，使用BFPRT算法，相当于快速排序，但是在寻找pivot上进行了修改，将数组按照5\n个一组，找到每个组内的中位数，然后重复上述过程（也就是找中位数的中位数，直到最后只有一个数）\n\n\n6. skyline问i\nP446\n\n7. 位运算相关：下一个数\n\n\n8. 大数运算的相关题目，运用字符串进行加减乘除\n\n9. 面试题 16.09. 运算 只使用加法，不使用位运算实现减法，乘法，除法\n因为不使用位运算，因此只能累加，不能使用幂积法，因此需要将count对应value值存在vector之中，然后计算的时候，倒着计算，因为无法计算当前count/2是多少，不能正着加\n因此只能倒着减\n\n- 易错点：1.注意特殊情况，可以直接返回结果；2.注意数据可能有正负，因此需要都转为正数，然后最后结果判断是否需要加上符号\nif(neg%2!=0){\n    return -res;\n} 可以用计数法判断正负号\n\n","slug":"leetcode/暂时没看内容","published":1,"updated":"2023-07-10T10:36:19.574Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clk5ceinr000zjpjbc0mqgx23","content":"<ol>\n<li>堆排序和其他排序内容，面试前过一次</li>\n</ol>\n<p>堆排序已经看，主要思路：<br>先对每个内部节点进行heap_build,然后每次将0交换到i位置（n-1 到0），然后对0~i-1进行heap_build；<br>heap_build：先对左右排序，在对root排序，如果当前root没有交换，那么退出递归程序，否则递归root=flag, heap_build</p>\n<ol start=\"2\">\n<li>字典树<br>前缀树也不一定要有value字段，当value的数字的时候，也可以直接用下标代表value，而不用记录value这个字段<br>前缀树经典例题： </li>\n</ol>\n<ul>\n<li>lc648. 单词替换(前缀单词查找，注意类函数需要申明为public, 26个字符（如果申请小于26个会报错），而且最初建立的对象是指针 Trie *t=new Trie()， t-&gt;search, t-&gt;findPrefix)</li>\n<li><ol start=\"1268\">\n<li>搜索推荐系统</li>\n</ol>\n</li>\n<li>字典树变形:在字典树中加入一个set<string> bags 来存储前缀包含该路径的前3个字符串，在每将字典里面的字符串插入这棵数的时候，将经过路径的所有字符的bags都插入这个字符串， 如果大于size, 就删除最后一个元素，bags.erase(–bags.end());<br>vector<string> tmp(cur-&gt;bags.begin(), cur-&gt;bags.end());//set元素赋值给vec, vec反过来赋值一样的<br>易错点：在收缩的时候，如果发现字典树都找不到这个字符了，那么直接break, 然后s.size()-res.size()大小全部push为 空的vec<string></string></string></string></li>\n</ul>\n<p>   例题：子数组的最大异或和：</p>\n<ul>\n<li>方法一：可以求前缀异或和，然后遍历每个下标j前面的i XOR(i,j)=XOR(o,j)^XOR(0,j) 时间复杂度O(N^2)</li>\n<li>方法二：建立XOR的前缀树，然后计算每个以j结尾的数组能够获得的最大异或值，使用，遍历当前j值的二进制位（从31-0），比如j=00111, 那么走过的路径最好为01000，也就是符号相同，其余位置相反最好，<br>如果之前值没有这个路径那么就取有的唯一那条路径（因为每个节点只有0 1两种情况</li>\n</ul>\n<ol start=\"3\">\n<li>布隆过滤器，判断一个值是否在集合中：<br>使用多个hash函数将输入映射到布隆过滤器 bitMap的多个位置，那么在进行判断一个输入是否存在的时候，可以根据如果计算出位置有一个位置没有被标记，说明这个数一定不在集合中，如果都被标记，那么说明可能在集合中。<br>何根据失误率 p 和样本数 n 来确定布隆过滤器大小 m</li>\n</ol>\n<ol start=\"4\">\n<li>Dijstra算法，单源和多源最短路径</li>\n</ol>\n<ol start=\"5\">\n<li>查找无序数组的最小k个数，使用BFPRT算法，相当于快速排序，但是在寻找pivot上进行了修改，将数组按照5<br>个一组，找到每个组内的中位数，然后重复上述过程（也就是找中位数的中位数，直到最后只有一个数）</li>\n</ol>\n<ol start=\"6\">\n<li><p>skyline问i<br>P446</p>\n</li>\n<li><p>位运算相关：下一个数</p>\n</li>\n</ol>\n<ol start=\"8\">\n<li><p>大数运算的相关题目，运用字符串进行加减乘除</p>\n</li>\n<li><p>面试题 16.09. 运算 只使用加法，不使用位运算实现减法，乘法，除法<br>因为不使用位运算，因此只能累加，不能使用幂积法，因此需要将count对应value值存在vector之中，然后计算的时候，倒着计算，因为无法计算当前count/2是多少，不能正着加<br>因此只能倒着减</p>\n</li>\n</ol>\n<ul>\n<li>易错点：1.注意特殊情况，可以直接返回结果；2.注意数据可能有正负，因此需要都转为正数，然后最后结果判断是否需要加上符号<br>if(neg%2!=0){<br>  return -res;<br>} 可以用计数法判断正负号</li>\n</ul>\n","site":{"data":{}},"wordcount":1383,"excerpt":"","more":"<ol>\n<li>堆排序和其他排序内容，面试前过一次</li>\n</ol>\n<p>堆排序已经看，主要思路：<br>先对每个内部节点进行heap_build,然后每次将0交换到i位置（n-1 到0），然后对0~i-1进行heap_build；<br>heap_build：先对左右排序，在对root排序，如果当前root没有交换，那么退出递归程序，否则递归root=flag, heap_build</p>\n<ol start=\"2\">\n<li>字典树<br>前缀树也不一定要有value字段，当value的数字的时候，也可以直接用下标代表value，而不用记录value这个字段<br>前缀树经典例题： </li>\n</ol>\n<ul>\n<li>lc648. 单词替换(前缀单词查找，注意类函数需要申明为public, 26个字符（如果申请小于26个会报错），而且最初建立的对象是指针 Trie *t=new Trie()， t-&gt;search, t-&gt;findPrefix)</li>\n<li><ol start=\"1268\">\n<li>搜索推荐系统</li>\n</ol>\n</li>\n<li>字典树变形:在字典树中加入一个set<string> bags 来存储前缀包含该路径的前3个字符串，在每将字典里面的字符串插入这棵数的时候，将经过路径的所有字符的bags都插入这个字符串， 如果大于size, 就删除最后一个元素，bags.erase(–bags.end());<br>vector<string> tmp(cur-&gt;bags.begin(), cur-&gt;bags.end());//set元素赋值给vec, vec反过来赋值一样的<br>易错点：在收缩的时候，如果发现字典树都找不到这个字符了，那么直接break, 然后s.size()-res.size()大小全部push为 空的vec<string></string></string></string></li>\n</ul>\n<p>   例题：子数组的最大异或和：</p>\n<ul>\n<li>方法一：可以求前缀异或和，然后遍历每个下标j前面的i XOR(i,j)=XOR(o,j)^XOR(0,j) 时间复杂度O(N^2)</li>\n<li>方法二：建立XOR的前缀树，然后计算每个以j结尾的数组能够获得的最大异或值，使用，遍历当前j值的二进制位（从31-0），比如j=00111, 那么走过的路径最好为01000，也就是符号相同，其余位置相反最好，<br>如果之前值没有这个路径那么就取有的唯一那条路径（因为每个节点只有0 1两种情况</li>\n</ul>\n<ol start=\"3\">\n<li>布隆过滤器，判断一个值是否在集合中：<br>使用多个hash函数将输入映射到布隆过滤器 bitMap的多个位置，那么在进行判断一个输入是否存在的时候，可以根据如果计算出位置有一个位置没有被标记，说明这个数一定不在集合中，如果都被标记，那么说明可能在集合中。<br>何根据失误率 p 和样本数 n 来确定布隆过滤器大小 m</li>\n</ol>\n<ol start=\"4\">\n<li>Dijstra算法，单源和多源最短路径</li>\n</ol>\n<ol start=\"5\">\n<li>查找无序数组的最小k个数，使用BFPRT算法，相当于快速排序，但是在寻找pivot上进行了修改，将数组按照5<br>个一组，找到每个组内的中位数，然后重复上述过程（也就是找中位数的中位数，直到最后只有一个数）</li>\n</ol>\n<ol start=\"6\">\n<li><p>skyline问i<br>P446</p>\n</li>\n<li><p>位运算相关：下一个数</p>\n</li>\n</ol>\n<ol start=\"8\">\n<li><p>大数运算的相关题目，运用字符串进行加减乘除</p>\n</li>\n<li><p>面试题 16.09. 运算 只使用加法，不使用位运算实现减法，乘法，除法<br>因为不使用位运算，因此只能累加，不能使用幂积法，因此需要将count对应value值存在vector之中，然后计算的时候，倒着计算，因为无法计算当前count/2是多少，不能正着加<br>因此只能倒着减</p>\n</li>\n</ol>\n<ul>\n<li>易错点：1.注意特殊情况，可以直接返回结果；2.注意数据可能有正负，因此需要都转为正数，然后最后结果判断是否需要加上符号<br>if(neg%2!=0){<br>  return -res;<br>} 可以用计数法判断正负号</li>\n</ul>\n"},{"title":"滑动窗口","catogory":["leetcode 题目汇总"],"date":"2021-11-13T09:22:03.000Z","_content":"\n#### 例题\n1. 最小覆盖子串（两个字符串）\n2. 不同字符的最小子序列（一个字符串）\n  需要有一个hash来记录一个字符的剩余出现次数\n  如果栈中没找到，从栈中弹出剩余出现次数大于0，而且大于当前字符的字符，然后压入当前字符\n  否则直接将num[当前字符]--\n3. 窗口内的最大值，使用的是单调栈\n4. 未排序数组中，累加和为给定值的最长子数组\n- 方法一： 滑动窗口 （使用了条件，数据全部为正数，如果没有这个条件就不能使用滑动窗口）\n- 方法二： 使用hash记录一个sum出现的最早index,同时要记得压入hash[0]=-1 \n  (PS: 累加和为给定值的子数组个数->hash)\n\n- 补充问题1，正数和负数个数相等的最长子数组\n    将正数转为1，负数转为0，求累加和为0最长子数组\n- 补充问题2： 元素只有0和1的情况下，求0 和 1个数相等的最长子数组\n    将0转为-1，1不变，求累加和为0的最长子数组\n\n5. 未排序数组中，累加和小于等于给定值的最长子数组\n\n6. 和小于等于K的最长子数组  以及 和不小于k的最短子数组leetcode 862\n<font color=red>862. 和至少为 K 的最短子数组(hard)</font>\n因为带有负数，所以收缩窗口不一定sum变小，和还有可能变大,所以滑动窗口不行\n解决方案：使用前缀和+双端队列\n  - 题目说明K一定是大于0的数\n  - 如果当前的值比队尾小，那么循环弹出队尾部的值；\n  - 如果队尾的值减去队首前缀和大于等于target，那么循环弹出首部的值（下标）,同时更新minlen (先pop前面再pop后面，或者先pop后面再pop前面都是可以的)\n  - 易错点：一定要注意先push_back(0), 因为要处理只有一个元素的情况  [1] k=1\n\n<font color=blue> 这道题可以和连续和大于0的最长序列（lc-1124:表现良好的最长时间段）一起看：\n  - 求最长大于k使用前缀和+单调栈，求最短大于等于k使用前缀和+双端队列； \n  - 如果是求最长小于k（和小于k的最长序列），那么使用先遍历一次前缀和数组（小压栈，否则continue），得到底部到顶单增的栈，然后逆序遍历，求小于k的最长序列\n  - 如果是求最长大于k（和大于0的最长序列），那么使用先遍历一次前缀和数组（小压栈，否则continue），得到底部到顶单减的栈，然后逆序遍历，求小于k的最长序列\n  - 如果是求最短小于k（一般无这种问法）\n</font>\n\n\n<font color=red>7. 至少有 K 个重复字符的最长子串</font>\n题意：子串中每个字符都需要重复k次\n解决方案： \n- 滑动窗口，枚举窗口内包含的字符的总数，如果字符总数大于（1-26个字符26种情况下，每个字符至少k个）的最大长度，当当前窗口包含的字符数大于遍历的这种情况的话，收缩窗口， 末尾如果typecnt=k_num那么就更新答案\n\n- 分治算法，先统计当前字符串，每个字符的频率，然后以小于k 的字符的任意一个作为划分点（感觉也可以放在一个集合，判断字符是否在集合内），将当前字符分为多个段，然后递归求解\n\n\n8. 等差数列的划分，求个数问题 每个窗口包含的等差数列的个数=左右指针差-1（滑动窗口内包含子数组的个数计算）\n\n9. 找到字符串的所有异位词，注意这个是两个指针之间只能包含这个词\n\n  - 解法1：类似于needle数组，只有count==0判断right-left+1是否等于p.size() 然后收缩窗口，每次收缩的时候都需要重新判断 len是否相等\n  - 解法2：维护一个和p 一样长度的窗口，如果当前字符频率数组==p的字符频率数组（vec1==vecb），那么说明找到一个异位词\n  - 解法3：也可以使用一个count vector，表示两个字符串各个字符的差值，和一个diff变量，如果diff变量==0说明两个字符串相等。减左边1之后，如果count[i]==0，那么diff--,如果count[i]==-1, diff++；同理加右边1之后\n\nPS:类似的题 最小覆盖子串（可以包含其他字符）， 至少有k个无重复字符的最长子串, lc 面试题 17.18. 最短超串(big字符串里面包含small字符串里面每个字符的最短串)\n  - <font color=red>易错点：注意一定是needle[big[left]]++/--不是needle[left] or needle[right]</font>\n\n模板 needle+count来判断\n```C++\n总结：count == 0的时候，先收缩不必要的字符再进行判断！！！！\nint left=0, right=0;\n        //right最好是包含这个字符\nwhile(right<len1){\n\n    if(needle[s[right]]>0){\n        count--; \n    }\n    needle[s[right]]--; //先减再判断\n    if(count==0){\n        //收缩字符\n        while(needle[s[left]]<0){\n            needle[s[left]]++;\n            left++;\n        }\n        if(right-left+1<min_len){\n            min_len = right - left+1;\n            start = left;\n        }\n            needle[s[left]]++;\n            count++;\n            left++;\n        }\n        \n        right++;\n  }\n```\n\n<font color=red>10. 最少交换次数来组合所有的 1 II</font>\n  先计算出有多少个1，假设为k个\n  然后用一个固定大小为k的窗口，遍历数组，记录窗口内0的最小个数即为答案\n  II和I的区别在于II是环形数组，因此需要遍历每一个start(包括==size, 此时end通过求余得到),但是I只需要遍历end<size\n\n11. 水果成篮\n题意是包含两种数据类型的最长子数组;使用typecnt， hash_cnt 和left right指针；当typecnt<=2对窗口进行扩， 否则进行收缩\n用滑动窗口\n注意是hash[fruit[left]]++/--不是hash[left]++/--\n\n\n12. 最大连续1的个数III\n滑动窗口，当当前的0的个数比k大，就收缩窗口，否则扩展窗口\n\n\n13. 爱生气的书店老板\n先将满意时的数据加起来，然后这些位置的值置为0，剩下的就是求滑动窗口的最大值\n\n14. 尽可能使字符串相等\n这道题转化的题意是，使得子数组（连续的数,开销都为正数）的和小于maxCost的最长子数组的长度\n使用滑动窗口\n```C++\n while(right<size){\n      sum+=dist[right];\n      while(sum>maxCost&&left<=right){\n          sum-=dist[left];\n          left++;\n      }\n      res=max(res, right-left+1);\n      right++;\n  }\n```\n\n另外一种方法是前缀和+二分，对于每个index, 二分找到前缀和大于等于presum[index]-maxCost的最小下标（lower_bound）\n\n\n13. 可获得的最大点数\n题意：只能从两端取数据，取得k个数据的最大值\nsolution: 滑动窗口size-k内元素之和的最小值, 其实也可以用区间dp解决，但是因为为造成三维dp[left][right][k]，因此会超出内存\n\n<font color=red>14. 最高频元素的频数</font>\n- 将整个数组进行排序，使用滑动窗口，枚举将窗口内所有的数转为右边界这个数的最长长度， l只会递增不会减少， r就是当前遍历的下标，因为之前的元素都已经转为num[r-1]，因此还需要消耗的数据只有(nums[r]-nums[r-1])*(r-l), 如果比给定的k大，那么收缩窗口\n- 具有滑动窗口单增特性，r向右滑动，需要的数越来越大，l向右滑动需要的越来越小\n\n15. 查找给定哈希值的子串\n这个就是 字符串hash的一个例子，但是和常规的字符串hash不一样的是，字符串hash计算方式为\nhash(s, p, m) = (val(s[0]) * p0 + val(s[1]) * p1 + ... + val(s[k-1]) * pk-1) mod m.\n\n但是因为除法不满足取余的恒等性质，如果正序的话就会导致需要减去第一个数然后/power+最后一个数的值，会发生错误\n因此需要倒序，减去当前的值，乘以power再加上新元素的值。（乘法满足取余恒等）\nsolution: 从右到左，滑动窗口计算k字符串里面的hashvalue （求后缀和，中间的那段的hash/滑动窗口从右到左，和从左到右的计算方式不同\n\n另一种解法，适用于任何长度的字符串，仍然需要反向计算\n与标准的不同之处：sum[i] 从sum[i-1]变为从sum[i+1], 计算hash由hash[right]-hash[left]变为hash[left]-hash[right]\nhttps://leetcode-cn.com/problems/find-substring-with-given-hash-value/solution/zi-fu-chuan-ha-xi-zi-fu-chuan-chu-li-cha-v809/\n\nPS:取模和乘法同一优先级：乘法都要在后面加一个%运算符， 减了一个元素，需要在取模前加上这个modulo；这道题也不能直接套用以前封装的的字符串哈希类，因为POWER 与 MOD 要互质(存在逆元) 才能调RK算法\n\n16. lc713. 乘积小于K的子数组\n- 求乘积小于K的连续子数组的个数\n- 滑动窗口：具有增大窗口，值递增，减少窗口值减少，求所有满足条件子集的个数；如果增大窗口，值并不出现单调趋势，就不能使用滑窗\n\n\n17. lc632. 最小区间\n- 每个区间的数至少包含一个，其实就是1 3 2都要包含的最短区间问题，使用滑动窗口\n- 使用最小覆盖子串解决\n\n\n18. lc295. 数据流的中位数\n- 使用两个优先队列/multiset来维护一个大顶堆和小顶堆\n- 为了保证大顶堆和小顶堆数据量的平衡，可以使用偶数插入大顶堆， 并移除最大元素到小顶堆， 以及奇数插入小顶堆， 并移除最大元素到大顶堆的方法\n```C++\nset1.insert(num);\nint tmp=*set1.begin();\nset1.erase(set1.begin());\nset2.insert(tmp);\n```\n\n19. lc480. 滑动窗口中位数\n\n- 方法一：需要使用一个map来记录需要删除的数，进行延迟删除 mp[l]++; 这种方法，为了保证左右两边数据的平衡，可以用一个变量balance来记录，（small加一个数，balance++， 减一个数balance--） 使得balance维持0就行了\n- 方法二：可以使用multiset来删除特定的数\n- 因为large（小顶堆）应该始终比 small(大顶堆)的size 大于等于1, 因此可以通过这个来判断之后的数应该是插入大顶堆还是小顶堆\n\n20.  lc424: 替换后的最长重复字符-这道题和和其他滑动窗口都不一样；主要是由于窗口内最多的字符是未知的，因为窗口即使收缩，长度也不会变小，不能以右边指针的字符代表整个窗口最后选定的字符！！！！！\n```C++\n       while(right<size){\n            nums[s[right]-'A']++;\n            maxn=max(maxn, nums[s[right]-'A']);//这个可以求到曾经滑动窗口中出现最多的字符数目，但是具体是哪个字符不知道\n            if(right-left+1>maxn+k){\n                nums[s[left]-'A']--;\n                left++;\n            }\n            right++;\n        }\n        return right-left;\n```\n\n\n21. lc1438. 绝对差不超过限制的最长连续子数组\n- 如何维护滑动窗口的最大值和最小值？\n- 方法1：使用multiset的方法，使用*s.rbegin()- *s.begin()来找到最小和最大的差值，使用s.erase(s.find(nums[left]))来删除最左边的元素\n- 方法2: 使用两个双端队列，分别维护滑动窗口的最大值和最小值，其中最大值q，存储元素类似一个单调递减的栈（当一个更大的值出现后，前面更小的元素都不可能成为窗口的最大值了，因此弹出，成为单调减队列；最前面最大值弹出后，后面下的一个数可能为窗口最大值）; 最小值q,存储元素的时候类似一个单调递增的栈；然后判断两个队列的差值是否在limit之内，如果不在就判断q_min和q_max的front是否是当前的nums[left], 如果是就弹出，否则就说明有可能之前就已经被弹出了。\n\n\n#### 总结\nok \n1. 涉及连续子数组的两种方法：\n  a.滑动窗口 \n  b.前缀和+hash+二分\n    - 如果是小于等于K的最长，那么使用二分查找，查找大于等于sums[i]-target的第一个下标index（向前查找）i-index+1  lower_bound 最后返回时候判断一下是否>=target\n    - 如果是大于等于K的最短，那么使用二分查找，查找大于等于sums[i]+target的第一个下标index（向后查找）index-i+1\n  (hash适用于==target, 滑动窗口适用于至多至少target，最长连续，最短连续这种情况)\n\n3. 滑动串口count==0 先收缩再判断\n\n4. 求子数组的个数，以及最长子数组， 可能使用滑动窗口(右边固定，左边每个都可以，子数组的所有个数)，可能使用hash+前缀和（和为k， 右边固定，左边部分可，部分不行），也可能两种都可以，注意区别。\n如果固定了left到right之间的间距，一般用滑动窗口\n而且区分子序列（不连续）， 子数组（连续）\n\n5. 滑动窗口适合字符串/数组是连续场景，滑动窗口里面的字符是可能都需要，也能只需要子序列满足条件就可以\n\n6. 如果字符串连续+长度固定，使用滑动窗口 （lc1423. 可获得的最大点数, 拿的点数是固定的，所以没必要使用动态规划， 使用动态规划三维数组，反而会导致错误）\n\n7. 求滑动窗口的适合没有负数的场景，对于负数这种情况，不满足扩充窗口和变大，减小窗口和变小的规律（不满足单调性质），因此不使用于滑动窗口这种场景\n对于包含负数的这种情况：求最短大于使用前缀和+双端队列，求最长大于或者小于k使用前缀和+单调栈，见例题6详细说明\n\n8.滑动窗口使用与某一段连续只包含k中字符，只允许翻转k个数类似的题目， 同时也可以转为前缀和+二分来进行查找\n\n9. 两端k个元素和最大的问题可以转为中间size-k个元素和最小的问题\n\n\n10. 一种是right每次往右走，只要不满足条件，left就一直收敛。 另一种是，right每次往右走，如果不满足条件，left最多收敛一次（进阶）lc424:替换后的最长重复字符\n\n11.如果遇到环形数组，那么将数组拉直解决，就是并列两个相同的数组aa\n\n\n\n\n\n\n","source":"_posts/leetcode/滑动窗口.md","raw":"---\ntitle: 滑动窗口\ncatogory:\n  - leetcode 题目汇总\ncategories:\n  - leetcode\ndate: 2021-11-13 17:22:03\ntags:\n---\n\n#### 例题\n1. 最小覆盖子串（两个字符串）\n2. 不同字符的最小子序列（一个字符串）\n  需要有一个hash来记录一个字符的剩余出现次数\n  如果栈中没找到，从栈中弹出剩余出现次数大于0，而且大于当前字符的字符，然后压入当前字符\n  否则直接将num[当前字符]--\n3. 窗口内的最大值，使用的是单调栈\n4. 未排序数组中，累加和为给定值的最长子数组\n- 方法一： 滑动窗口 （使用了条件，数据全部为正数，如果没有这个条件就不能使用滑动窗口）\n- 方法二： 使用hash记录一个sum出现的最早index,同时要记得压入hash[0]=-1 \n  (PS: 累加和为给定值的子数组个数->hash)\n\n- 补充问题1，正数和负数个数相等的最长子数组\n    将正数转为1，负数转为0，求累加和为0最长子数组\n- 补充问题2： 元素只有0和1的情况下，求0 和 1个数相等的最长子数组\n    将0转为-1，1不变，求累加和为0的最长子数组\n\n5. 未排序数组中，累加和小于等于给定值的最长子数组\n\n6. 和小于等于K的最长子数组  以及 和不小于k的最短子数组leetcode 862\n<font color=red>862. 和至少为 K 的最短子数组(hard)</font>\n因为带有负数，所以收缩窗口不一定sum变小，和还有可能变大,所以滑动窗口不行\n解决方案：使用前缀和+双端队列\n  - 题目说明K一定是大于0的数\n  - 如果当前的值比队尾小，那么循环弹出队尾部的值；\n  - 如果队尾的值减去队首前缀和大于等于target，那么循环弹出首部的值（下标）,同时更新minlen (先pop前面再pop后面，或者先pop后面再pop前面都是可以的)\n  - 易错点：一定要注意先push_back(0), 因为要处理只有一个元素的情况  [1] k=1\n\n<font color=blue> 这道题可以和连续和大于0的最长序列（lc-1124:表现良好的最长时间段）一起看：\n  - 求最长大于k使用前缀和+单调栈，求最短大于等于k使用前缀和+双端队列； \n  - 如果是求最长小于k（和小于k的最长序列），那么使用先遍历一次前缀和数组（小压栈，否则continue），得到底部到顶单增的栈，然后逆序遍历，求小于k的最长序列\n  - 如果是求最长大于k（和大于0的最长序列），那么使用先遍历一次前缀和数组（小压栈，否则continue），得到底部到顶单减的栈，然后逆序遍历，求小于k的最长序列\n  - 如果是求最短小于k（一般无这种问法）\n</font>\n\n\n<font color=red>7. 至少有 K 个重复字符的最长子串</font>\n题意：子串中每个字符都需要重复k次\n解决方案： \n- 滑动窗口，枚举窗口内包含的字符的总数，如果字符总数大于（1-26个字符26种情况下，每个字符至少k个）的最大长度，当当前窗口包含的字符数大于遍历的这种情况的话，收缩窗口， 末尾如果typecnt=k_num那么就更新答案\n\n- 分治算法，先统计当前字符串，每个字符的频率，然后以小于k 的字符的任意一个作为划分点（感觉也可以放在一个集合，判断字符是否在集合内），将当前字符分为多个段，然后递归求解\n\n\n8. 等差数列的划分，求个数问题 每个窗口包含的等差数列的个数=左右指针差-1（滑动窗口内包含子数组的个数计算）\n\n9. 找到字符串的所有异位词，注意这个是两个指针之间只能包含这个词\n\n  - 解法1：类似于needle数组，只有count==0判断right-left+1是否等于p.size() 然后收缩窗口，每次收缩的时候都需要重新判断 len是否相等\n  - 解法2：维护一个和p 一样长度的窗口，如果当前字符频率数组==p的字符频率数组（vec1==vecb），那么说明找到一个异位词\n  - 解法3：也可以使用一个count vector，表示两个字符串各个字符的差值，和一个diff变量，如果diff变量==0说明两个字符串相等。减左边1之后，如果count[i]==0，那么diff--,如果count[i]==-1, diff++；同理加右边1之后\n\nPS:类似的题 最小覆盖子串（可以包含其他字符）， 至少有k个无重复字符的最长子串, lc 面试题 17.18. 最短超串(big字符串里面包含small字符串里面每个字符的最短串)\n  - <font color=red>易错点：注意一定是needle[big[left]]++/--不是needle[left] or needle[right]</font>\n\n模板 needle+count来判断\n```C++\n总结：count == 0的时候，先收缩不必要的字符再进行判断！！！！\nint left=0, right=0;\n        //right最好是包含这个字符\nwhile(right<len1){\n\n    if(needle[s[right]]>0){\n        count--; \n    }\n    needle[s[right]]--; //先减再判断\n    if(count==0){\n        //收缩字符\n        while(needle[s[left]]<0){\n            needle[s[left]]++;\n            left++;\n        }\n        if(right-left+1<min_len){\n            min_len = right - left+1;\n            start = left;\n        }\n            needle[s[left]]++;\n            count++;\n            left++;\n        }\n        \n        right++;\n  }\n```\n\n<font color=red>10. 最少交换次数来组合所有的 1 II</font>\n  先计算出有多少个1，假设为k个\n  然后用一个固定大小为k的窗口，遍历数组，记录窗口内0的最小个数即为答案\n  II和I的区别在于II是环形数组，因此需要遍历每一个start(包括==size, 此时end通过求余得到),但是I只需要遍历end<size\n\n11. 水果成篮\n题意是包含两种数据类型的最长子数组;使用typecnt， hash_cnt 和left right指针；当typecnt<=2对窗口进行扩， 否则进行收缩\n用滑动窗口\n注意是hash[fruit[left]]++/--不是hash[left]++/--\n\n\n12. 最大连续1的个数III\n滑动窗口，当当前的0的个数比k大，就收缩窗口，否则扩展窗口\n\n\n13. 爱生气的书店老板\n先将满意时的数据加起来，然后这些位置的值置为0，剩下的就是求滑动窗口的最大值\n\n14. 尽可能使字符串相等\n这道题转化的题意是，使得子数组（连续的数,开销都为正数）的和小于maxCost的最长子数组的长度\n使用滑动窗口\n```C++\n while(right<size){\n      sum+=dist[right];\n      while(sum>maxCost&&left<=right){\n          sum-=dist[left];\n          left++;\n      }\n      res=max(res, right-left+1);\n      right++;\n  }\n```\n\n另外一种方法是前缀和+二分，对于每个index, 二分找到前缀和大于等于presum[index]-maxCost的最小下标（lower_bound）\n\n\n13. 可获得的最大点数\n题意：只能从两端取数据，取得k个数据的最大值\nsolution: 滑动窗口size-k内元素之和的最小值, 其实也可以用区间dp解决，但是因为为造成三维dp[left][right][k]，因此会超出内存\n\n<font color=red>14. 最高频元素的频数</font>\n- 将整个数组进行排序，使用滑动窗口，枚举将窗口内所有的数转为右边界这个数的最长长度， l只会递增不会减少， r就是当前遍历的下标，因为之前的元素都已经转为num[r-1]，因此还需要消耗的数据只有(nums[r]-nums[r-1])*(r-l), 如果比给定的k大，那么收缩窗口\n- 具有滑动窗口单增特性，r向右滑动，需要的数越来越大，l向右滑动需要的越来越小\n\n15. 查找给定哈希值的子串\n这个就是 字符串hash的一个例子，但是和常规的字符串hash不一样的是，字符串hash计算方式为\nhash(s, p, m) = (val(s[0]) * p0 + val(s[1]) * p1 + ... + val(s[k-1]) * pk-1) mod m.\n\n但是因为除法不满足取余的恒等性质，如果正序的话就会导致需要减去第一个数然后/power+最后一个数的值，会发生错误\n因此需要倒序，减去当前的值，乘以power再加上新元素的值。（乘法满足取余恒等）\nsolution: 从右到左，滑动窗口计算k字符串里面的hashvalue （求后缀和，中间的那段的hash/滑动窗口从右到左，和从左到右的计算方式不同\n\n另一种解法，适用于任何长度的字符串，仍然需要反向计算\n与标准的不同之处：sum[i] 从sum[i-1]变为从sum[i+1], 计算hash由hash[right]-hash[left]变为hash[left]-hash[right]\nhttps://leetcode-cn.com/problems/find-substring-with-given-hash-value/solution/zi-fu-chuan-ha-xi-zi-fu-chuan-chu-li-cha-v809/\n\nPS:取模和乘法同一优先级：乘法都要在后面加一个%运算符， 减了一个元素，需要在取模前加上这个modulo；这道题也不能直接套用以前封装的的字符串哈希类，因为POWER 与 MOD 要互质(存在逆元) 才能调RK算法\n\n16. lc713. 乘积小于K的子数组\n- 求乘积小于K的连续子数组的个数\n- 滑动窗口：具有增大窗口，值递增，减少窗口值减少，求所有满足条件子集的个数；如果增大窗口，值并不出现单调趋势，就不能使用滑窗\n\n\n17. lc632. 最小区间\n- 每个区间的数至少包含一个，其实就是1 3 2都要包含的最短区间问题，使用滑动窗口\n- 使用最小覆盖子串解决\n\n\n18. lc295. 数据流的中位数\n- 使用两个优先队列/multiset来维护一个大顶堆和小顶堆\n- 为了保证大顶堆和小顶堆数据量的平衡，可以使用偶数插入大顶堆， 并移除最大元素到小顶堆， 以及奇数插入小顶堆， 并移除最大元素到大顶堆的方法\n```C++\nset1.insert(num);\nint tmp=*set1.begin();\nset1.erase(set1.begin());\nset2.insert(tmp);\n```\n\n19. lc480. 滑动窗口中位数\n\n- 方法一：需要使用一个map来记录需要删除的数，进行延迟删除 mp[l]++; 这种方法，为了保证左右两边数据的平衡，可以用一个变量balance来记录，（small加一个数，balance++， 减一个数balance--） 使得balance维持0就行了\n- 方法二：可以使用multiset来删除特定的数\n- 因为large（小顶堆）应该始终比 small(大顶堆)的size 大于等于1, 因此可以通过这个来判断之后的数应该是插入大顶堆还是小顶堆\n\n20.  lc424: 替换后的最长重复字符-这道题和和其他滑动窗口都不一样；主要是由于窗口内最多的字符是未知的，因为窗口即使收缩，长度也不会变小，不能以右边指针的字符代表整个窗口最后选定的字符！！！！！\n```C++\n       while(right<size){\n            nums[s[right]-'A']++;\n            maxn=max(maxn, nums[s[right]-'A']);//这个可以求到曾经滑动窗口中出现最多的字符数目，但是具体是哪个字符不知道\n            if(right-left+1>maxn+k){\n                nums[s[left]-'A']--;\n                left++;\n            }\n            right++;\n        }\n        return right-left;\n```\n\n\n21. lc1438. 绝对差不超过限制的最长连续子数组\n- 如何维护滑动窗口的最大值和最小值？\n- 方法1：使用multiset的方法，使用*s.rbegin()- *s.begin()来找到最小和最大的差值，使用s.erase(s.find(nums[left]))来删除最左边的元素\n- 方法2: 使用两个双端队列，分别维护滑动窗口的最大值和最小值，其中最大值q，存储元素类似一个单调递减的栈（当一个更大的值出现后，前面更小的元素都不可能成为窗口的最大值了，因此弹出，成为单调减队列；最前面最大值弹出后，后面下的一个数可能为窗口最大值）; 最小值q,存储元素的时候类似一个单调递增的栈；然后判断两个队列的差值是否在limit之内，如果不在就判断q_min和q_max的front是否是当前的nums[left], 如果是就弹出，否则就说明有可能之前就已经被弹出了。\n\n\n#### 总结\nok \n1. 涉及连续子数组的两种方法：\n  a.滑动窗口 \n  b.前缀和+hash+二分\n    - 如果是小于等于K的最长，那么使用二分查找，查找大于等于sums[i]-target的第一个下标index（向前查找）i-index+1  lower_bound 最后返回时候判断一下是否>=target\n    - 如果是大于等于K的最短，那么使用二分查找，查找大于等于sums[i]+target的第一个下标index（向后查找）index-i+1\n  (hash适用于==target, 滑动窗口适用于至多至少target，最长连续，最短连续这种情况)\n\n3. 滑动串口count==0 先收缩再判断\n\n4. 求子数组的个数，以及最长子数组， 可能使用滑动窗口(右边固定，左边每个都可以，子数组的所有个数)，可能使用hash+前缀和（和为k， 右边固定，左边部分可，部分不行），也可能两种都可以，注意区别。\n如果固定了left到right之间的间距，一般用滑动窗口\n而且区分子序列（不连续）， 子数组（连续）\n\n5. 滑动窗口适合字符串/数组是连续场景，滑动窗口里面的字符是可能都需要，也能只需要子序列满足条件就可以\n\n6. 如果字符串连续+长度固定，使用滑动窗口 （lc1423. 可获得的最大点数, 拿的点数是固定的，所以没必要使用动态规划， 使用动态规划三维数组，反而会导致错误）\n\n7. 求滑动窗口的适合没有负数的场景，对于负数这种情况，不满足扩充窗口和变大，减小窗口和变小的规律（不满足单调性质），因此不使用于滑动窗口这种场景\n对于包含负数的这种情况：求最短大于使用前缀和+双端队列，求最长大于或者小于k使用前缀和+单调栈，见例题6详细说明\n\n8.滑动窗口使用与某一段连续只包含k中字符，只允许翻转k个数类似的题目， 同时也可以转为前缀和+二分来进行查找\n\n9. 两端k个元素和最大的问题可以转为中间size-k个元素和最小的问题\n\n\n10. 一种是right每次往右走，只要不满足条件，left就一直收敛。 另一种是，right每次往右走，如果不满足条件，left最多收敛一次（进阶）lc424:替换后的最长重复字符\n\n11.如果遇到环形数组，那么将数组拉直解决，就是并列两个相同的数组aa\n\n\n\n\n\n\n","slug":"leetcode/滑动窗口","published":1,"updated":"2023-07-10T10:36:19.575Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clk5ceins0012jpjb9b91e836","content":"<h4 id=\"例题\"><a href=\"#例题\" class=\"headerlink\" title=\"例题\"></a>例题</h4><ol>\n<li>最小覆盖子串（两个字符串）</li>\n<li>不同字符的最小子序列（一个字符串）<br>需要有一个hash来记录一个字符的剩余出现次数<br>如果栈中没找到，从栈中弹出剩余出现次数大于0，而且大于当前字符的字符，然后压入当前字符<br>否则直接将num[当前字符]–</li>\n<li>窗口内的最大值，使用的是单调栈</li>\n<li>未排序数组中，累加和为给定值的最长子数组</li>\n</ol>\n<ul>\n<li><p>方法一： 滑动窗口 （使用了条件，数据全部为正数，如果没有这个条件就不能使用滑动窗口）</p>\n</li>\n<li><p>方法二： 使用hash记录一个sum出现的最早index,同时要记得压入hash[0]=-1<br>(PS: 累加和为给定值的子数组个数-&gt;hash)</p>\n</li>\n<li><p>补充问题1，正数和负数个数相等的最长子数组<br>  将正数转为1，负数转为0，求累加和为0最长子数组</p>\n</li>\n<li><p>补充问题2： 元素只有0和1的情况下，求0 和 1个数相等的最长子数组<br>  将0转为-1，1不变，求累加和为0的最长子数组</p>\n</li>\n</ul>\n<ol start=\"5\">\n<li><p>未排序数组中，累加和小于等于给定值的最长子数组</p>\n</li>\n<li><p>和小于等于K的最长子数组  以及 和不小于k的最短子数组leetcode 862<br><font color=\"red\">862. 和至少为 K 的最短子数组(hard)</font><br>因为带有负数，所以收缩窗口不一定sum变小，和还有可能变大,所以滑动窗口不行<br>解决方案：使用前缀和+双端队列</p>\n</li>\n</ol>\n<ul>\n<li>题目说明K一定是大于0的数</li>\n<li>如果当前的值比队尾小，那么循环弹出队尾部的值；</li>\n<li>如果队尾的值减去队首前缀和大于等于target，那么循环弹出首部的值（下标）,同时更新minlen (先pop前面再pop后面，或者先pop后面再pop前面都是可以的)</li>\n<li>易错点：一定要注意先push_back(0), 因为要处理只有一个元素的情况  [1] k=1</li>\n</ul>\n<p><font color=\"blue\"> 这道题可以和连续和大于0的最长序列（lc-1124:表现良好的最长时间段）一起看：</font></p>\n<ul>\n<li>求最长大于k使用前缀和+单调栈，求最短大于等于k使用前缀和+双端队列； </li>\n<li>如果是求最长小于k（和小于k的最长序列），那么使用先遍历一次前缀和数组（小压栈，否则continue），得到底部到顶单增的栈，然后逆序遍历，求小于k的最长序列</li>\n<li>如果是求最长大于k（和大于0的最长序列），那么使用先遍历一次前缀和数组（小压栈，否则continue），得到底部到顶单减的栈，然后逆序遍历，求小于k的最长序列</li>\n<li>如果是求最短小于k（一般无这种问法）</li>\n</ul>\n<p><font color=\"red\">7. 至少有 K 个重复字符的最长子串</font><br>题意：子串中每个字符都需要重复k次<br>解决方案： </p>\n<ul>\n<li><p>滑动窗口，枚举窗口内包含的字符的总数，如果字符总数大于（1-26个字符26种情况下，每个字符至少k个）的最大长度，当当前窗口包含的字符数大于遍历的这种情况的话，收缩窗口， 末尾如果typecnt=k_num那么就更新答案</p>\n</li>\n<li><p>分治算法，先统计当前字符串，每个字符的频率，然后以小于k 的字符的任意一个作为划分点（感觉也可以放在一个集合，判断字符是否在集合内），将当前字符分为多个段，然后递归求解</p>\n</li>\n</ul>\n<ol start=\"8\">\n<li><p>等差数列的划分，求个数问题 每个窗口包含的等差数列的个数=左右指针差-1（滑动窗口内包含子数组的个数计算）</p>\n</li>\n<li><p>找到字符串的所有异位词，注意这个是两个指针之间只能包含这个词</p>\n</li>\n</ol>\n<ul>\n<li>解法1：类似于needle数组，只有count==0判断right-left+1是否等于p.size() 然后收缩窗口，每次收缩的时候都需要重新判断 len是否相等</li>\n<li>解法2：维护一个和p 一样长度的窗口，如果当前字符频率数组==p的字符频率数组（vec1==vecb），那么说明找到一个异位词</li>\n<li>解法3：也可以使用一个count vector，表示两个字符串各个字符的差值，和一个diff变量，如果diff变量==0说明两个字符串相等。减左边1之后，如果count[i]==0，那么diff–,如果count[i]==-1, diff++；同理加右边1之后</li>\n</ul>\n<p>PS:类似的题 最小覆盖子串（可以包含其他字符）， 至少有k个无重复字符的最长子串, lc 面试题 17.18. 最短超串(big字符串里面包含small字符串里面每个字符的最短串)</p>\n<ul>\n<li><font color=\"red\">易错点：注意一定是needle[big[left]]++/–不是needle[left] or needle[right]</font></li>\n</ul>\n<p>模板 needle+count来判断</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">总结：count == <span class=\"hljs-number\">0</span>的时候，先收缩不必要的字符再进行判断！！！！<br><span class=\"hljs-keyword\">int</span> left=<span class=\"hljs-number\">0</span>, right=<span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-comment\">//right最好是包含这个字符</span><br><span class=\"hljs-keyword\">while</span>(right&lt;len1)&#123;<br><br>    <span class=\"hljs-keyword\">if</span>(needle[s[right]]&gt;<span class=\"hljs-number\">0</span>)&#123;<br>        count--; <br>    &#125;<br>    needle[s[right]]--; <span class=\"hljs-comment\">//先减再判断</span><br>    <span class=\"hljs-keyword\">if</span>(count==<span class=\"hljs-number\">0</span>)&#123;<br>        <span class=\"hljs-comment\">//收缩字符</span><br>        <span class=\"hljs-keyword\">while</span>(needle[s[left]]&lt;<span class=\"hljs-number\">0</span>)&#123;<br>            needle[s[left]]++;<br>            left++;<br>        &#125;<br>        <span class=\"hljs-keyword\">if</span>(right-left+<span class=\"hljs-number\">1</span>&lt;min_len)&#123;<br>            min_len = right - left+<span class=\"hljs-number\">1</span>;<br>            start = left;<br>        &#125;<br>            needle[s[left]]++;<br>            count++;<br>            left++;<br>        &#125;<br>        <br>        right++;<br>  &#125;<br></code></pre></td></tr></table></figure>\n\n<p><font color=\"red\">10. 最少交换次数来组合所有的 1 II</font><br>  先计算出有多少个1，假设为k个<br>  然后用一个固定大小为k的窗口，遍历数组，记录窗口内0的最小个数即为答案<br>  II和I的区别在于II是环形数组，因此需要遍历每一个start(包括==size, 此时end通过求余得到),但是I只需要遍历end&lt;size</p>\n<ol start=\"11\">\n<li>水果成篮<br>题意是包含两种数据类型的最长子数组;使用typecnt， hash_cnt 和left right指针；当typecnt&lt;=2对窗口进行扩， 否则进行收缩<br>用滑动窗口<br>注意是hash[fruit[left]]++/–不是hash[left]++/–</li>\n</ol>\n<ol start=\"12\">\n<li>最大连续1的个数III<br>滑动窗口，当当前的0的个数比k大，就收缩窗口，否则扩展窗口</li>\n</ol>\n<ol start=\"13\">\n<li><p>爱生气的书店老板<br>先将满意时的数据加起来，然后这些位置的值置为0，剩下的就是求滑动窗口的最大值</p>\n</li>\n<li><p>尽可能使字符串相等<br>这道题转化的题意是，使得子数组（连续的数,开销都为正数）的和小于maxCost的最长子数组的长度<br>使用滑动窗口</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">while</span>(right&lt;size)&#123;<br>     sum+=dist[right];<br>     <span class=\"hljs-keyword\">while</span>(sum&gt;maxCost&amp;&amp;left&lt;=right)&#123;<br>         sum-=dist[left];<br>         left++;<br>     &#125;<br>     res=<span class=\"hljs-built_in\">max</span>(res, right-left+<span class=\"hljs-number\">1</span>);<br>     right++;<br> &#125;<br></code></pre></td></tr></table></figure></li>\n</ol>\n<p>另外一种方法是前缀和+二分，对于每个index, 二分找到前缀和大于等于presum[index]-maxCost的最小下标（lower_bound）</p>\n<ol start=\"13\">\n<li>可获得的最大点数<br>题意：只能从两端取数据，取得k个数据的最大值<br>solution: 滑动窗口size-k内元素之和的最小值, 其实也可以用区间dp解决，但是因为为造成三维dp[left][right][k]，因此会超出内存</li>\n</ol>\n<p><font color=\"red\">14. 最高频元素的频数</font></p>\n<ul>\n<li>将整个数组进行排序，使用滑动窗口，枚举将窗口内所有的数转为右边界这个数的最长长度， l只会递增不会减少， r就是当前遍历的下标，因为之前的元素都已经转为num[r-1]，因此还需要消耗的数据只有(nums[r]-nums[r-1])*(r-l), 如果比给定的k大，那么收缩窗口</li>\n<li>具有滑动窗口单增特性，r向右滑动，需要的数越来越大，l向右滑动需要的越来越小</li>\n</ul>\n<ol start=\"15\">\n<li>查找给定哈希值的子串<br>这个就是 字符串hash的一个例子，但是和常规的字符串hash不一样的是，字符串hash计算方式为<br>hash(s, p, m) = (val(s[0]) * p0 + val(s[1]) * p1 + … + val(s[k-1]) * pk-1) mod m.</li>\n</ol>\n<p>但是因为除法不满足取余的恒等性质，如果正序的话就会导致需要减去第一个数然后/power+最后一个数的值，会发生错误<br>因此需要倒序，减去当前的值，乘以power再加上新元素的值。（乘法满足取余恒等）<br>solution: 从右到左，滑动窗口计算k字符串里面的hashvalue （求后缀和，中间的那段的hash/滑动窗口从右到左，和从左到右的计算方式不同</p>\n<p>另一种解法，适用于任何长度的字符串，仍然需要反向计算<br>与标准的不同之处：sum[i] 从sum[i-1]变为从sum[i+1], 计算hash由hash[right]-hash[left]变为hash[left]-hash[right]<br><a href=\"https://leetcode-cn.com/problems/find-substring-with-given-hash-value/solution/zi-fu-chuan-ha-xi-zi-fu-chuan-chu-li-cha-v809/\">https://leetcode-cn.com/problems/find-substring-with-given-hash-value/solution/zi-fu-chuan-ha-xi-zi-fu-chuan-chu-li-cha-v809/</a></p>\n<p>PS:取模和乘法同一优先级：乘法都要在后面加一个%运算符， 减了一个元素，需要在取模前加上这个modulo；这道题也不能直接套用以前封装的的字符串哈希类，因为POWER 与 MOD 要互质(存在逆元) 才能调RK算法</p>\n<ol start=\"16\">\n<li>lc713. 乘积小于K的子数组</li>\n</ol>\n<ul>\n<li>求乘积小于K的连续子数组的个数</li>\n<li>滑动窗口：具有增大窗口，值递增，减少窗口值减少，求所有满足条件子集的个数；如果增大窗口，值并不出现单调趋势，就不能使用滑窗</li>\n</ul>\n<ol start=\"17\">\n<li>lc632. 最小区间</li>\n</ol>\n<ul>\n<li>每个区间的数至少包含一个，其实就是1 3 2都要包含的最短区间问题，使用滑动窗口</li>\n<li>使用最小覆盖子串解决</li>\n</ul>\n<ol start=\"18\">\n<li>lc295. 数据流的中位数</li>\n</ol>\n<ul>\n<li>使用两个优先队列/multiset来维护一个大顶堆和小顶堆</li>\n<li>为了保证大顶堆和小顶堆数据量的平衡，可以使用偶数插入大顶堆， 并移除最大元素到小顶堆， 以及奇数插入小顶堆， 并移除最大元素到大顶堆的方法<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">set1.<span class=\"hljs-built_in\">insert</span>(num);<br><span class=\"hljs-keyword\">int</span> tmp=*set1.<span class=\"hljs-built_in\">begin</span>();<br>set1.<span class=\"hljs-built_in\">erase</span>(set1.<span class=\"hljs-built_in\">begin</span>());<br>set2.<span class=\"hljs-built_in\">insert</span>(tmp);<br></code></pre></td></tr></table></figure></li>\n</ul>\n<ol start=\"19\">\n<li>lc480. 滑动窗口中位数</li>\n</ol>\n<ul>\n<li>方法一：需要使用一个map来记录需要删除的数，进行延迟删除 mp[l]++; 这种方法，为了保证左右两边数据的平衡，可以用一个变量balance来记录，（small加一个数，balance++， 减一个数balance–） 使得balance维持0就行了</li>\n<li>方法二：可以使用multiset来删除特定的数</li>\n<li>因为large（小顶堆）应该始终比 small(大顶堆)的size 大于等于1, 因此可以通过这个来判断之后的数应该是插入大顶堆还是小顶堆</li>\n</ul>\n<ol start=\"20\">\n<li> lc424: 替换后的最长重复字符-这道题和和其他滑动窗口都不一样；主要是由于窗口内最多的字符是未知的，因为窗口即使收缩，长度也不会变小，不能以右边指针的字符代表整个窗口最后选定的字符！！！！！<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">while</span>(right&lt;size)&#123;<br>     nums[s[right]-<span class=\"hljs-string\">&#x27;A&#x27;</span>]++;<br>     maxn=<span class=\"hljs-built_in\">max</span>(maxn, nums[s[right]-<span class=\"hljs-string\">&#x27;A&#x27;</span>]);<span class=\"hljs-comment\">//这个可以求到曾经滑动窗口中出现最多的字符数目，但是具体是哪个字符不知道</span><br>     <span class=\"hljs-keyword\">if</span>(right-left+<span class=\"hljs-number\">1</span>&gt;maxn+k)&#123;<br>         nums[s[left]-<span class=\"hljs-string\">&#x27;A&#x27;</span>]--;<br>         left++;<br>     &#125;<br>     right++;<br> &#125;<br> <span class=\"hljs-keyword\">return</span> right-left;<br></code></pre></td></tr></table></figure></li>\n</ol>\n<ol start=\"21\">\n<li>lc1438. 绝对差不超过限制的最长连续子数组</li>\n</ol>\n<ul>\n<li>如何维护滑动窗口的最大值和最小值？</li>\n<li>方法1：使用multiset的方法，使用*s.rbegin()- *s.begin()来找到最小和最大的差值，使用s.erase(s.find(nums[left]))来删除最左边的元素</li>\n<li>方法2: 使用两个双端队列，分别维护滑动窗口的最大值和最小值，其中最大值q，存储元素类似一个单调递减的栈（当一个更大的值出现后，前面更小的元素都不可能成为窗口的最大值了，因此弹出，成为单调减队列；最前面最大值弹出后，后面下的一个数可能为窗口最大值）; 最小值q,存储元素的时候类似一个单调递增的栈；然后判断两个队列的差值是否在limit之内，如果不在就判断q_min和q_max的front是否是当前的nums[left], 如果是就弹出，否则就说明有可能之前就已经被弹出了。</li>\n</ul>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>ok </p>\n<ol>\n<li><p>涉及连续子数组的两种方法：<br>a.滑动窗口<br>b.前缀和+hash+二分</p>\n<ul>\n<li>如果是小于等于K的最长，那么使用二分查找，查找大于等于sums[i]-target的第一个下标index（向前查找）i-index+1  lower_bound 最后返回时候判断一下是否&gt;=target</li>\n<li>如果是大于等于K的最短，那么使用二分查找，查找大于等于sums[i]+target的第一个下标index（向后查找）index-i+1<br>(hash适用于==target, 滑动窗口适用于至多至少target，最长连续，最短连续这种情况)</li>\n</ul>\n</li>\n<li><p>滑动串口count==0 先收缩再判断</p>\n</li>\n<li><p>求子数组的个数，以及最长子数组， 可能使用滑动窗口(右边固定，左边每个都可以，子数组的所有个数)，可能使用hash+前缀和（和为k， 右边固定，左边部分可，部分不行），也可能两种都可以，注意区别。<br>如果固定了left到right之间的间距，一般用滑动窗口<br>而且区分子序列（不连续）， 子数组（连续）</p>\n</li>\n<li><p>滑动窗口适合字符串/数组是连续场景，滑动窗口里面的字符是可能都需要，也能只需要子序列满足条件就可以</p>\n</li>\n<li><p>如果字符串连续+长度固定，使用滑动窗口 （lc1423. 可获得的最大点数, 拿的点数是固定的，所以没必要使用动态规划， 使用动态规划三维数组，反而会导致错误）</p>\n</li>\n<li><p>求滑动窗口的适合没有负数的场景，对于负数这种情况，不满足扩充窗口和变大，减小窗口和变小的规律（不满足单调性质），因此不使用于滑动窗口这种场景<br>对于包含负数的这种情况：求最短大于使用前缀和+双端队列，求最长大于或者小于k使用前缀和+单调栈，见例题6详细说明</p>\n</li>\n</ol>\n<p>8.滑动窗口使用与某一段连续只包含k中字符，只允许翻转k个数类似的题目， 同时也可以转为前缀和+二分来进行查找</p>\n<ol start=\"9\">\n<li>两端k个元素和最大的问题可以转为中间size-k个元素和最小的问题</li>\n</ol>\n<ol start=\"10\">\n<li>一种是right每次往右走，只要不满足条件，left就一直收敛。 另一种是，right每次往右走，如果不满足条件，left最多收敛一次（进阶）lc424:替换后的最长重复字符</li>\n</ol>\n<p>11.如果遇到环形数组，那么将数组拉直解决，就是并列两个相同的数组aa</p>\n","site":{"data":{}},"wordcount":5816,"excerpt":"","more":"<h4 id=\"例题\"><a href=\"#例题\" class=\"headerlink\" title=\"例题\"></a>例题</h4><ol>\n<li>最小覆盖子串（两个字符串）</li>\n<li>不同字符的最小子序列（一个字符串）<br>需要有一个hash来记录一个字符的剩余出现次数<br>如果栈中没找到，从栈中弹出剩余出现次数大于0，而且大于当前字符的字符，然后压入当前字符<br>否则直接将num[当前字符]–</li>\n<li>窗口内的最大值，使用的是单调栈</li>\n<li>未排序数组中，累加和为给定值的最长子数组</li>\n</ol>\n<ul>\n<li><p>方法一： 滑动窗口 （使用了条件，数据全部为正数，如果没有这个条件就不能使用滑动窗口）</p>\n</li>\n<li><p>方法二： 使用hash记录一个sum出现的最早index,同时要记得压入hash[0]=-1<br>(PS: 累加和为给定值的子数组个数-&gt;hash)</p>\n</li>\n<li><p>补充问题1，正数和负数个数相等的最长子数组<br>  将正数转为1，负数转为0，求累加和为0最长子数组</p>\n</li>\n<li><p>补充问题2： 元素只有0和1的情况下，求0 和 1个数相等的最长子数组<br>  将0转为-1，1不变，求累加和为0的最长子数组</p>\n</li>\n</ul>\n<ol start=\"5\">\n<li><p>未排序数组中，累加和小于等于给定值的最长子数组</p>\n</li>\n<li><p>和小于等于K的最长子数组  以及 和不小于k的最短子数组leetcode 862<br><font color=\"red\">862. 和至少为 K 的最短子数组(hard)</font><br>因为带有负数，所以收缩窗口不一定sum变小，和还有可能变大,所以滑动窗口不行<br>解决方案：使用前缀和+双端队列</p>\n</li>\n</ol>\n<ul>\n<li>题目说明K一定是大于0的数</li>\n<li>如果当前的值比队尾小，那么循环弹出队尾部的值；</li>\n<li>如果队尾的值减去队首前缀和大于等于target，那么循环弹出首部的值（下标）,同时更新minlen (先pop前面再pop后面，或者先pop后面再pop前面都是可以的)</li>\n<li>易错点：一定要注意先push_back(0), 因为要处理只有一个元素的情况  [1] k=1</li>\n</ul>\n<p><font color=\"blue\"> 这道题可以和连续和大于0的最长序列（lc-1124:表现良好的最长时间段）一起看：</font></p>\n<ul>\n<li>求最长大于k使用前缀和+单调栈，求最短大于等于k使用前缀和+双端队列； </li>\n<li>如果是求最长小于k（和小于k的最长序列），那么使用先遍历一次前缀和数组（小压栈，否则continue），得到底部到顶单增的栈，然后逆序遍历，求小于k的最长序列</li>\n<li>如果是求最长大于k（和大于0的最长序列），那么使用先遍历一次前缀和数组（小压栈，否则continue），得到底部到顶单减的栈，然后逆序遍历，求小于k的最长序列</li>\n<li>如果是求最短小于k（一般无这种问法）</li>\n</ul>\n<p><font color=\"red\">7. 至少有 K 个重复字符的最长子串</font><br>题意：子串中每个字符都需要重复k次<br>解决方案： </p>\n<ul>\n<li><p>滑动窗口，枚举窗口内包含的字符的总数，如果字符总数大于（1-26个字符26种情况下，每个字符至少k个）的最大长度，当当前窗口包含的字符数大于遍历的这种情况的话，收缩窗口， 末尾如果typecnt=k_num那么就更新答案</p>\n</li>\n<li><p>分治算法，先统计当前字符串，每个字符的频率，然后以小于k 的字符的任意一个作为划分点（感觉也可以放在一个集合，判断字符是否在集合内），将当前字符分为多个段，然后递归求解</p>\n</li>\n</ul>\n<ol start=\"8\">\n<li><p>等差数列的划分，求个数问题 每个窗口包含的等差数列的个数=左右指针差-1（滑动窗口内包含子数组的个数计算）</p>\n</li>\n<li><p>找到字符串的所有异位词，注意这个是两个指针之间只能包含这个词</p>\n</li>\n</ol>\n<ul>\n<li>解法1：类似于needle数组，只有count==0判断right-left+1是否等于p.size() 然后收缩窗口，每次收缩的时候都需要重新判断 len是否相等</li>\n<li>解法2：维护一个和p 一样长度的窗口，如果当前字符频率数组==p的字符频率数组（vec1==vecb），那么说明找到一个异位词</li>\n<li>解法3：也可以使用一个count vector，表示两个字符串各个字符的差值，和一个diff变量，如果diff变量==0说明两个字符串相等。减左边1之后，如果count[i]==0，那么diff–,如果count[i]==-1, diff++；同理加右边1之后</li>\n</ul>\n<p>PS:类似的题 最小覆盖子串（可以包含其他字符）， 至少有k个无重复字符的最长子串, lc 面试题 17.18. 最短超串(big字符串里面包含small字符串里面每个字符的最短串)</p>\n<ul>\n<li><font color=\"red\">易错点：注意一定是needle[big[left]]++/–不是needle[left] or needle[right]</font></li>\n</ul>\n<p>模板 needle+count来判断</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">总结：count == <span class=\"hljs-number\">0</span>的时候，先收缩不必要的字符再进行判断！！！！<br><span class=\"hljs-keyword\">int</span> left=<span class=\"hljs-number\">0</span>, right=<span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-comment\">//right最好是包含这个字符</span><br><span class=\"hljs-keyword\">while</span>(right&lt;len1)&#123;<br><br>    <span class=\"hljs-keyword\">if</span>(needle[s[right]]&gt;<span class=\"hljs-number\">0</span>)&#123;<br>        count--; <br>    &#125;<br>    needle[s[right]]--; <span class=\"hljs-comment\">//先减再判断</span><br>    <span class=\"hljs-keyword\">if</span>(count==<span class=\"hljs-number\">0</span>)&#123;<br>        <span class=\"hljs-comment\">//收缩字符</span><br>        <span class=\"hljs-keyword\">while</span>(needle[s[left]]&lt;<span class=\"hljs-number\">0</span>)&#123;<br>            needle[s[left]]++;<br>            left++;<br>        &#125;<br>        <span class=\"hljs-keyword\">if</span>(right-left+<span class=\"hljs-number\">1</span>&lt;min_len)&#123;<br>            min_len = right - left+<span class=\"hljs-number\">1</span>;<br>            start = left;<br>        &#125;<br>            needle[s[left]]++;<br>            count++;<br>            left++;<br>        &#125;<br>        <br>        right++;<br>  &#125;<br></code></pre></td></tr></table></figure>\n\n<p><font color=\"red\">10. 最少交换次数来组合所有的 1 II</font><br>  先计算出有多少个1，假设为k个<br>  然后用一个固定大小为k的窗口，遍历数组，记录窗口内0的最小个数即为答案<br>  II和I的区别在于II是环形数组，因此需要遍历每一个start(包括==size, 此时end通过求余得到),但是I只需要遍历end&lt;size</p>\n<ol start=\"11\">\n<li>水果成篮<br>题意是包含两种数据类型的最长子数组;使用typecnt， hash_cnt 和left right指针；当typecnt&lt;=2对窗口进行扩， 否则进行收缩<br>用滑动窗口<br>注意是hash[fruit[left]]++/–不是hash[left]++/–</li>\n</ol>\n<ol start=\"12\">\n<li>最大连续1的个数III<br>滑动窗口，当当前的0的个数比k大，就收缩窗口，否则扩展窗口</li>\n</ol>\n<ol start=\"13\">\n<li><p>爱生气的书店老板<br>先将满意时的数据加起来，然后这些位置的值置为0，剩下的就是求滑动窗口的最大值</p>\n</li>\n<li><p>尽可能使字符串相等<br>这道题转化的题意是，使得子数组（连续的数,开销都为正数）的和小于maxCost的最长子数组的长度<br>使用滑动窗口</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">while</span>(right&lt;size)&#123;<br>     sum+=dist[right];<br>     <span class=\"hljs-keyword\">while</span>(sum&gt;maxCost&amp;&amp;left&lt;=right)&#123;<br>         sum-=dist[left];<br>         left++;<br>     &#125;<br>     res=<span class=\"hljs-built_in\">max</span>(res, right-left+<span class=\"hljs-number\">1</span>);<br>     right++;<br> &#125;<br></code></pre></td></tr></table></figure></li>\n</ol>\n<p>另外一种方法是前缀和+二分，对于每个index, 二分找到前缀和大于等于presum[index]-maxCost的最小下标（lower_bound）</p>\n<ol start=\"13\">\n<li>可获得的最大点数<br>题意：只能从两端取数据，取得k个数据的最大值<br>solution: 滑动窗口size-k内元素之和的最小值, 其实也可以用区间dp解决，但是因为为造成三维dp[left][right][k]，因此会超出内存</li>\n</ol>\n<p><font color=\"red\">14. 最高频元素的频数</font></p>\n<ul>\n<li>将整个数组进行排序，使用滑动窗口，枚举将窗口内所有的数转为右边界这个数的最长长度， l只会递增不会减少， r就是当前遍历的下标，因为之前的元素都已经转为num[r-1]，因此还需要消耗的数据只有(nums[r]-nums[r-1])*(r-l), 如果比给定的k大，那么收缩窗口</li>\n<li>具有滑动窗口单增特性，r向右滑动，需要的数越来越大，l向右滑动需要的越来越小</li>\n</ul>\n<ol start=\"15\">\n<li>查找给定哈希值的子串<br>这个就是 字符串hash的一个例子，但是和常规的字符串hash不一样的是，字符串hash计算方式为<br>hash(s, p, m) = (val(s[0]) * p0 + val(s[1]) * p1 + … + val(s[k-1]) * pk-1) mod m.</li>\n</ol>\n<p>但是因为除法不满足取余的恒等性质，如果正序的话就会导致需要减去第一个数然后/power+最后一个数的值，会发生错误<br>因此需要倒序，减去当前的值，乘以power再加上新元素的值。（乘法满足取余恒等）<br>solution: 从右到左，滑动窗口计算k字符串里面的hashvalue （求后缀和，中间的那段的hash/滑动窗口从右到左，和从左到右的计算方式不同</p>\n<p>另一种解法，适用于任何长度的字符串，仍然需要反向计算<br>与标准的不同之处：sum[i] 从sum[i-1]变为从sum[i+1], 计算hash由hash[right]-hash[left]变为hash[left]-hash[right]<br><a href=\"https://leetcode-cn.com/problems/find-substring-with-given-hash-value/solution/zi-fu-chuan-ha-xi-zi-fu-chuan-chu-li-cha-v809/\">https://leetcode-cn.com/problems/find-substring-with-given-hash-value/solution/zi-fu-chuan-ha-xi-zi-fu-chuan-chu-li-cha-v809/</a></p>\n<p>PS:取模和乘法同一优先级：乘法都要在后面加一个%运算符， 减了一个元素，需要在取模前加上这个modulo；这道题也不能直接套用以前封装的的字符串哈希类，因为POWER 与 MOD 要互质(存在逆元) 才能调RK算法</p>\n<ol start=\"16\">\n<li>lc713. 乘积小于K的子数组</li>\n</ol>\n<ul>\n<li>求乘积小于K的连续子数组的个数</li>\n<li>滑动窗口：具有增大窗口，值递增，减少窗口值减少，求所有满足条件子集的个数；如果增大窗口，值并不出现单调趋势，就不能使用滑窗</li>\n</ul>\n<ol start=\"17\">\n<li>lc632. 最小区间</li>\n</ol>\n<ul>\n<li>每个区间的数至少包含一个，其实就是1 3 2都要包含的最短区间问题，使用滑动窗口</li>\n<li>使用最小覆盖子串解决</li>\n</ul>\n<ol start=\"18\">\n<li>lc295. 数据流的中位数</li>\n</ol>\n<ul>\n<li>使用两个优先队列/multiset来维护一个大顶堆和小顶堆</li>\n<li>为了保证大顶堆和小顶堆数据量的平衡，可以使用偶数插入大顶堆， 并移除最大元素到小顶堆， 以及奇数插入小顶堆， 并移除最大元素到大顶堆的方法<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">set1.<span class=\"hljs-built_in\">insert</span>(num);<br><span class=\"hljs-keyword\">int</span> tmp=*set1.<span class=\"hljs-built_in\">begin</span>();<br>set1.<span class=\"hljs-built_in\">erase</span>(set1.<span class=\"hljs-built_in\">begin</span>());<br>set2.<span class=\"hljs-built_in\">insert</span>(tmp);<br></code></pre></td></tr></table></figure></li>\n</ul>\n<ol start=\"19\">\n<li>lc480. 滑动窗口中位数</li>\n</ol>\n<ul>\n<li>方法一：需要使用一个map来记录需要删除的数，进行延迟删除 mp[l]++; 这种方法，为了保证左右两边数据的平衡，可以用一个变量balance来记录，（small加一个数，balance++， 减一个数balance–） 使得balance维持0就行了</li>\n<li>方法二：可以使用multiset来删除特定的数</li>\n<li>因为large（小顶堆）应该始终比 small(大顶堆)的size 大于等于1, 因此可以通过这个来判断之后的数应该是插入大顶堆还是小顶堆</li>\n</ul>\n<ol start=\"20\">\n<li> lc424: 替换后的最长重复字符-这道题和和其他滑动窗口都不一样；主要是由于窗口内最多的字符是未知的，因为窗口即使收缩，长度也不会变小，不能以右边指针的字符代表整个窗口最后选定的字符！！！！！<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">while</span>(right&lt;size)&#123;<br>     nums[s[right]-<span class=\"hljs-string\">&#x27;A&#x27;</span>]++;<br>     maxn=<span class=\"hljs-built_in\">max</span>(maxn, nums[s[right]-<span class=\"hljs-string\">&#x27;A&#x27;</span>]);<span class=\"hljs-comment\">//这个可以求到曾经滑动窗口中出现最多的字符数目，但是具体是哪个字符不知道</span><br>     <span class=\"hljs-keyword\">if</span>(right-left+<span class=\"hljs-number\">1</span>&gt;maxn+k)&#123;<br>         nums[s[left]-<span class=\"hljs-string\">&#x27;A&#x27;</span>]--;<br>         left++;<br>     &#125;<br>     right++;<br> &#125;<br> <span class=\"hljs-keyword\">return</span> right-left;<br></code></pre></td></tr></table></figure></li>\n</ol>\n<ol start=\"21\">\n<li>lc1438. 绝对差不超过限制的最长连续子数组</li>\n</ol>\n<ul>\n<li>如何维护滑动窗口的最大值和最小值？</li>\n<li>方法1：使用multiset的方法，使用*s.rbegin()- *s.begin()来找到最小和最大的差值，使用s.erase(s.find(nums[left]))来删除最左边的元素</li>\n<li>方法2: 使用两个双端队列，分别维护滑动窗口的最大值和最小值，其中最大值q，存储元素类似一个单调递减的栈（当一个更大的值出现后，前面更小的元素都不可能成为窗口的最大值了，因此弹出，成为单调减队列；最前面最大值弹出后，后面下的一个数可能为窗口最大值）; 最小值q,存储元素的时候类似一个单调递增的栈；然后判断两个队列的差值是否在limit之内，如果不在就判断q_min和q_max的front是否是当前的nums[left], 如果是就弹出，否则就说明有可能之前就已经被弹出了。</li>\n</ul>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>ok </p>\n<ol>\n<li><p>涉及连续子数组的两种方法：<br>a.滑动窗口<br>b.前缀和+hash+二分</p>\n<ul>\n<li>如果是小于等于K的最长，那么使用二分查找，查找大于等于sums[i]-target的第一个下标index（向前查找）i-index+1  lower_bound 最后返回时候判断一下是否&gt;=target</li>\n<li>如果是大于等于K的最短，那么使用二分查找，查找大于等于sums[i]+target的第一个下标index（向后查找）index-i+1<br>(hash适用于==target, 滑动窗口适用于至多至少target，最长连续，最短连续这种情况)</li>\n</ul>\n</li>\n<li><p>滑动串口count==0 先收缩再判断</p>\n</li>\n<li><p>求子数组的个数，以及最长子数组， 可能使用滑动窗口(右边固定，左边每个都可以，子数组的所有个数)，可能使用hash+前缀和（和为k， 右边固定，左边部分可，部分不行），也可能两种都可以，注意区别。<br>如果固定了left到right之间的间距，一般用滑动窗口<br>而且区分子序列（不连续）， 子数组（连续）</p>\n</li>\n<li><p>滑动窗口适合字符串/数组是连续场景，滑动窗口里面的字符是可能都需要，也能只需要子序列满足条件就可以</p>\n</li>\n<li><p>如果字符串连续+长度固定，使用滑动窗口 （lc1423. 可获得的最大点数, 拿的点数是固定的，所以没必要使用动态规划， 使用动态规划三维数组，反而会导致错误）</p>\n</li>\n<li><p>求滑动窗口的适合没有负数的场景，对于负数这种情况，不满足扩充窗口和变大，减小窗口和变小的规律（不满足单调性质），因此不使用于滑动窗口这种场景<br>对于包含负数的这种情况：求最短大于使用前缀和+双端队列，求最长大于或者小于k使用前缀和+单调栈，见例题6详细说明</p>\n</li>\n</ol>\n<p>8.滑动窗口使用与某一段连续只包含k中字符，只允许翻转k个数类似的题目， 同时也可以转为前缀和+二分来进行查找</p>\n<ol start=\"9\">\n<li>两端k个元素和最大的问题可以转为中间size-k个元素和最小的问题</li>\n</ol>\n<ol start=\"10\">\n<li>一种是right每次往右走，只要不满足条件，left就一直收敛。 另一种是，right每次往右走，如果不满足条件，left最多收敛一次（进阶）lc424:替换后的最长重复字符</li>\n</ol>\n<p>11.如果遇到环形数组，那么将数组拉直解决，就是并列两个相同的数组aa</p>\n"},{"title":"系统设计相关题目","date":"2022-01-19T06:09:24.000Z","_content":"####  链接\nhttps://github.com/donnemartin/system-design-primer\n\n#### 题型\n##### 1.标准布隆过滤器hash函数的设置\n```C++\nclass HashFunction {\nprivate:\n    int cap, seed;\npublic:\n    HashFunction(int cap, int seed) {\n        this->cap = cap;\n        this->seed = seed;\n    }\n\n    int hash(string& value) {\n        int ret = 0;\n        int n = value.size();\n        for (int i = 0; i < n; ++i) {\n            ret += seed * ret + value[i];\n            ret %= cap;\n        }\n        return ret;\n    }\n};\n\n\nclass StandardBloomFilter {\nprivate:\n    int k;\n    vector<HashFunction*> hashFunc;\n    bitset<200000> bits;\npublic:\n    StandardBloomFilter(int k) {\n        // initialize your data structure here\n        this->k = k;\n        for (int i = 0; i < k; ++i)\n            hashFunc.push_back(new HashFunction(100000 + i, 2 * i + 3));\n    }\n}\n```\n每个字符串通过这个hash函数可以得到一个值（position），然后将bit[200000]中该位置为1，多个函数，那么就会有多个位置为1;判断某一个字符串是否存在，就是判断多个函数计算出来值是否都在bit中位1，如果有一个不为1，说明该字符串不在\n\n##### 2. 序列化Trie树(Lintcode)\n 这个模板一定要记住，不要用自己的方法，用模板\n 同类型题目：二叉树的序列化和反序列化， n叉数的序列化和反序列化\n注意这道题\n- 在进行序列化：使用dfs, 在遍历完所有的chidren后，加上‘/'表示退出当前循环\n- 在进行反序列化时： 使用全局index, index在进入下一层循环和退出循环(注意这里和二叉树不同，有两处)之前都需要+1， 其余情况index保持不变\n- 注意:\n(1)在退出训练时候不是返回null, 而是返回一个Trie对象的指针！！！\n(2)因为一个节点有多个节点，而不是只有二叉树的left和right节点，因此需要使用while判断，如果data[index]=='/'的时候退出while循环\n(3)\n```C++  right\nTrieNode* tmp=new TrieNode(); //注意区分类和结构体\nmap<char, TrieNode*> &childs=tmp->children;\n```\n```C++  wrong\nTrieNode* tmp; //注意区分类和类指针，这里直接申明一个空指针是不对的, 即使是结构体也应该是student s;\nmap<char, TrieNode*> childs;\ntmp->children=childs;\n```\n\n官方题解使用的<data> 进行序列化+栈的方式进行反序列化：<将当前current入栈 >将栈顶出栈 其余：新建一个Trie对象(current)，将当前data[index]指向这个对象\n\n\n//下面模板代码可以用作n叉树的遍历或者trie树遍历，下面的这种方式会将空字符串用<>，如果想要空字符串没有，可以使用dfs2\n\n```C++\n/**\n * Definition of TrieNode:\n * class TrieNode {\n * public:\n *     TrieNode() {}\n *     map<char, TrieNode*> children;\n * };\n */\n //适用于n叉数的遍历， 但是这种方式在进行反序列化的时候，每次从栈中弹出一个元素前，需要将栈顶赋值给cur\n //<1<3<5><6>><2><4>> null节点无<>\n//  lc428 每个节点都被<>分开，即使是同一层\nstring dfs(Node* root){\n    if(root==NULL){\n        return \"\";\n    }\n    string data;\n    int size=root->children.size();\n    data+=to_string(root->val);\n    for(int i=0;i<size;i++){\n        data+=dfs(root->children[i]);\n    }\n    return \"<\"+data+\">\";\n}\n\n//<a<b<e<>>c<>d<f<>>>> 节点之间可能没有<>分开\nclass Solution {\npublic:\n    /**\n     * This method will be invoked first, you should design your own algorithm \n     * to serialize a trie which denote by a root node to a string which\n     * can be easily deserialized by your own \"deserialize\" method later.\n     */\n     \n    void dfs2(TrieNode* root){\n        string dfs(Node* root){\n        if(root==NULL){\n            return \"\";\n        }\n        string data;\n        int size=root->children.size();\n        data+=to_string(root->val);\n        for(int i=0;i<size;i++){\n            data+=dfs(root->children[i]);\n        }\n        return \"<\"+data+\">\";\n    }\n    \n    string serialize(TrieNode* root) {\n        // Write your code here\n        if (root == NULL)\n            return \"\";\n        string data;\n        for (map<char, TrieNode*>::iterator it = root->children.begin();\n             it != root->children.end(); ++it) {\n            data += it->first;\n            data += serialize(it->second);\n        }\n        return \"<\" + data + \">\";\n    }\n\n    /**\n     * This method will be invoked second, the argument data is what exactly\n     * you serialized at method \"serialize\", that means the data is not given by\n     * system, it's given by your own serialize method. So the format of data is\n     * designed by yourself, and deserialize it here as you serialize it in \n     * \"serialize\" method.\n     */\n    TrieNode* deserialize(string data) {\n        // Write your code here\n        if (data.size() == 0)\n            return NULL;\n\n        TrieNode* head = new TrieNode();\n        TrieNode* current = head;\n        stack<TrieNode*> path;\n        int len = data.size();\n        for (int i = 0; i < len; ++i) {\n            switch (data[i]) {\n                case '<':\n                    path.push(current);\n                    break;\n                case '>':\n                    //如果是null节点无<>情况，那么需要在这里赋值cur=path.top()\n                    path.pop();\n                    \n                    break;\n                default:\n                    current = new TrieNode();\n                    path.top()->children[data[i]] = current;\n            }\n        }\n        return head;\n    }\n};\n```\n\n\n3. Trie树专题\n```C++\nclass Trie(){\n    vector<Trie*> children;\n    bool isEnd;\n    Trie(){\n        this->child = vector<Trie*>(26,nullptr); //一定要记得初始化26个节点，而且都为null\n        this->isEnd = false;\n    }\n    search(string s){\n        Trie* root=this;\n        for(int i=0;i<s.size();i++){\n            if(root->children[s[i]-'a']==NULL){\n                return false;\n            }\n            root= root->children[s[i]-'a'];\n        }\n        return root->isEnd;\n    }\n    insert(string s){\n        Trie* root=this;\n        for(int i=0;i<s.size();i++){\n            if(root->children[s[i]-'a']==NULL){\n                root->children[s[i]-'a']=new Trie();\n            }\n            root= root->children[s[i]-'a'];\n        }\n        root->isEnd=true;\n    }\n}\n\n```\n\n二叉树的序列化和反序列可以使用前序遍历实现\n\n4. lc355. 设计推特\n- 需要实现4个功能: 关注， 取消关注， 发表博客， 列出userid和userid最近发表的10条博客\n- 实现关注和取消关注使用unordered_map<int, unordered_set<int>> hash\n- 发表博客使用unordered_map<int, node*> , 其中node记录\nnode{\n    tuiteid, //充当时间戳\n    userid, //发表用户\n    node* next; //指向下一个node, 类似于LRU，方便使用头插入方法\n}\n-  列出userid和userid最近发表的10条博客， 使用K个链表的合并，找出前M个数\n- 为什么使用链表，这样的话扩展非常方便，如果不使用，那么在删除博客的时候就比较麻烦\n\n\n5. 单词自动补全系统\n- 题意：1. 初始化系统，包括一些句子和句子最初始的频率，一个句子之间可能小写字符或者空格 2. 每次input一个字符应该接着上一个字符，同时输出‘#’表示输出的末尾，这时候需要初始化data=\"\", cur=root（全局变量）, 更新句子的频率\n- 解决方案：\n- 1. 使用前缀树+hash(存储句子+频率) 前缀树的每个节点，应该存储一个vector<string> 表示走到这个节点的下面所有字符\n- 2. 注意字符串在进行查找如果cur==null, 那么直接返回空，否则一直在cur的基础上走一步 cur=cur->children[c]//unordered_map<char, TrieNode*> children;\n- 3. 如果走到‘#’，表示走到了末尾，这时候需要初始化data=\"\", cur=root, 同时更新句子的频率 +1（句子频率会更新）\n- 参考答案: https://aaronice.gitbook.io/lintcode/data_structure/design-search-autocomplete-system\nhttps://zhuanlan.zhihu.com/p/99499171 (有点问题，不应该在每个节点里面记录节点的频率，因为这个随时更新，之后就不准确，应该用一个单独的hashmap来记录)\n\n\n#### 总结\n一般是有关于系统， 多个函数的整体设计题目\n比如：GeoHash, GFS, 布隆过滤器， 心跳设计， 缓存系统， LRU cache设计，二叉树的序列化和反序列化等\n还有新定义一种数据结构，嵌套返回list leetcode-扁平化嵌套列表迭代器 使用递归方式分解\n\n为了在vector里面删除元素更快，可以再配合使用一个dict (map)映射特定值对应的index;注意在进行删除元素的时候，除了交换vector中最后一个元素和当前元素，还需要修改hash最后一个元素映射的下标为当前index+从hash中删除key\n\n\n\n","source":"_posts/leetcode/系统设计.md","raw":"---\ntitle: 系统设计相关题目\ncategories:\n  - leetcode\ndate: 2022-01-19 14:09:24\ntags:\n---\n####  链接\nhttps://github.com/donnemartin/system-design-primer\n\n#### 题型\n##### 1.标准布隆过滤器hash函数的设置\n```C++\nclass HashFunction {\nprivate:\n    int cap, seed;\npublic:\n    HashFunction(int cap, int seed) {\n        this->cap = cap;\n        this->seed = seed;\n    }\n\n    int hash(string& value) {\n        int ret = 0;\n        int n = value.size();\n        for (int i = 0; i < n; ++i) {\n            ret += seed * ret + value[i];\n            ret %= cap;\n        }\n        return ret;\n    }\n};\n\n\nclass StandardBloomFilter {\nprivate:\n    int k;\n    vector<HashFunction*> hashFunc;\n    bitset<200000> bits;\npublic:\n    StandardBloomFilter(int k) {\n        // initialize your data structure here\n        this->k = k;\n        for (int i = 0; i < k; ++i)\n            hashFunc.push_back(new HashFunction(100000 + i, 2 * i + 3));\n    }\n}\n```\n每个字符串通过这个hash函数可以得到一个值（position），然后将bit[200000]中该位置为1，多个函数，那么就会有多个位置为1;判断某一个字符串是否存在，就是判断多个函数计算出来值是否都在bit中位1，如果有一个不为1，说明该字符串不在\n\n##### 2. 序列化Trie树(Lintcode)\n 这个模板一定要记住，不要用自己的方法，用模板\n 同类型题目：二叉树的序列化和反序列化， n叉数的序列化和反序列化\n注意这道题\n- 在进行序列化：使用dfs, 在遍历完所有的chidren后，加上‘/'表示退出当前循环\n- 在进行反序列化时： 使用全局index, index在进入下一层循环和退出循环(注意这里和二叉树不同，有两处)之前都需要+1， 其余情况index保持不变\n- 注意:\n(1)在退出训练时候不是返回null, 而是返回一个Trie对象的指针！！！\n(2)因为一个节点有多个节点，而不是只有二叉树的left和right节点，因此需要使用while判断，如果data[index]=='/'的时候退出while循环\n(3)\n```C++  right\nTrieNode* tmp=new TrieNode(); //注意区分类和结构体\nmap<char, TrieNode*> &childs=tmp->children;\n```\n```C++  wrong\nTrieNode* tmp; //注意区分类和类指针，这里直接申明一个空指针是不对的, 即使是结构体也应该是student s;\nmap<char, TrieNode*> childs;\ntmp->children=childs;\n```\n\n官方题解使用的<data> 进行序列化+栈的方式进行反序列化：<将当前current入栈 >将栈顶出栈 其余：新建一个Trie对象(current)，将当前data[index]指向这个对象\n\n\n//下面模板代码可以用作n叉树的遍历或者trie树遍历，下面的这种方式会将空字符串用<>，如果想要空字符串没有，可以使用dfs2\n\n```C++\n/**\n * Definition of TrieNode:\n * class TrieNode {\n * public:\n *     TrieNode() {}\n *     map<char, TrieNode*> children;\n * };\n */\n //适用于n叉数的遍历， 但是这种方式在进行反序列化的时候，每次从栈中弹出一个元素前，需要将栈顶赋值给cur\n //<1<3<5><6>><2><4>> null节点无<>\n//  lc428 每个节点都被<>分开，即使是同一层\nstring dfs(Node* root){\n    if(root==NULL){\n        return \"\";\n    }\n    string data;\n    int size=root->children.size();\n    data+=to_string(root->val);\n    for(int i=0;i<size;i++){\n        data+=dfs(root->children[i]);\n    }\n    return \"<\"+data+\">\";\n}\n\n//<a<b<e<>>c<>d<f<>>>> 节点之间可能没有<>分开\nclass Solution {\npublic:\n    /**\n     * This method will be invoked first, you should design your own algorithm \n     * to serialize a trie which denote by a root node to a string which\n     * can be easily deserialized by your own \"deserialize\" method later.\n     */\n     \n    void dfs2(TrieNode* root){\n        string dfs(Node* root){\n        if(root==NULL){\n            return \"\";\n        }\n        string data;\n        int size=root->children.size();\n        data+=to_string(root->val);\n        for(int i=0;i<size;i++){\n            data+=dfs(root->children[i]);\n        }\n        return \"<\"+data+\">\";\n    }\n    \n    string serialize(TrieNode* root) {\n        // Write your code here\n        if (root == NULL)\n            return \"\";\n        string data;\n        for (map<char, TrieNode*>::iterator it = root->children.begin();\n             it != root->children.end(); ++it) {\n            data += it->first;\n            data += serialize(it->second);\n        }\n        return \"<\" + data + \">\";\n    }\n\n    /**\n     * This method will be invoked second, the argument data is what exactly\n     * you serialized at method \"serialize\", that means the data is not given by\n     * system, it's given by your own serialize method. So the format of data is\n     * designed by yourself, and deserialize it here as you serialize it in \n     * \"serialize\" method.\n     */\n    TrieNode* deserialize(string data) {\n        // Write your code here\n        if (data.size() == 0)\n            return NULL;\n\n        TrieNode* head = new TrieNode();\n        TrieNode* current = head;\n        stack<TrieNode*> path;\n        int len = data.size();\n        for (int i = 0; i < len; ++i) {\n            switch (data[i]) {\n                case '<':\n                    path.push(current);\n                    break;\n                case '>':\n                    //如果是null节点无<>情况，那么需要在这里赋值cur=path.top()\n                    path.pop();\n                    \n                    break;\n                default:\n                    current = new TrieNode();\n                    path.top()->children[data[i]] = current;\n            }\n        }\n        return head;\n    }\n};\n```\n\n\n3. Trie树专题\n```C++\nclass Trie(){\n    vector<Trie*> children;\n    bool isEnd;\n    Trie(){\n        this->child = vector<Trie*>(26,nullptr); //一定要记得初始化26个节点，而且都为null\n        this->isEnd = false;\n    }\n    search(string s){\n        Trie* root=this;\n        for(int i=0;i<s.size();i++){\n            if(root->children[s[i]-'a']==NULL){\n                return false;\n            }\n            root= root->children[s[i]-'a'];\n        }\n        return root->isEnd;\n    }\n    insert(string s){\n        Trie* root=this;\n        for(int i=0;i<s.size();i++){\n            if(root->children[s[i]-'a']==NULL){\n                root->children[s[i]-'a']=new Trie();\n            }\n            root= root->children[s[i]-'a'];\n        }\n        root->isEnd=true;\n    }\n}\n\n```\n\n二叉树的序列化和反序列可以使用前序遍历实现\n\n4. lc355. 设计推特\n- 需要实现4个功能: 关注， 取消关注， 发表博客， 列出userid和userid最近发表的10条博客\n- 实现关注和取消关注使用unordered_map<int, unordered_set<int>> hash\n- 发表博客使用unordered_map<int, node*> , 其中node记录\nnode{\n    tuiteid, //充当时间戳\n    userid, //发表用户\n    node* next; //指向下一个node, 类似于LRU，方便使用头插入方法\n}\n-  列出userid和userid最近发表的10条博客， 使用K个链表的合并，找出前M个数\n- 为什么使用链表，这样的话扩展非常方便，如果不使用，那么在删除博客的时候就比较麻烦\n\n\n5. 单词自动补全系统\n- 题意：1. 初始化系统，包括一些句子和句子最初始的频率，一个句子之间可能小写字符或者空格 2. 每次input一个字符应该接着上一个字符，同时输出‘#’表示输出的末尾，这时候需要初始化data=\"\", cur=root（全局变量）, 更新句子的频率\n- 解决方案：\n- 1. 使用前缀树+hash(存储句子+频率) 前缀树的每个节点，应该存储一个vector<string> 表示走到这个节点的下面所有字符\n- 2. 注意字符串在进行查找如果cur==null, 那么直接返回空，否则一直在cur的基础上走一步 cur=cur->children[c]//unordered_map<char, TrieNode*> children;\n- 3. 如果走到‘#’，表示走到了末尾，这时候需要初始化data=\"\", cur=root, 同时更新句子的频率 +1（句子频率会更新）\n- 参考答案: https://aaronice.gitbook.io/lintcode/data_structure/design-search-autocomplete-system\nhttps://zhuanlan.zhihu.com/p/99499171 (有点问题，不应该在每个节点里面记录节点的频率，因为这个随时更新，之后就不准确，应该用一个单独的hashmap来记录)\n\n\n#### 总结\n一般是有关于系统， 多个函数的整体设计题目\n比如：GeoHash, GFS, 布隆过滤器， 心跳设计， 缓存系统， LRU cache设计，二叉树的序列化和反序列化等\n还有新定义一种数据结构，嵌套返回list leetcode-扁平化嵌套列表迭代器 使用递归方式分解\n\n为了在vector里面删除元素更快，可以再配合使用一个dict (map)映射特定值对应的index;注意在进行删除元素的时候，除了交换vector中最后一个元素和当前元素，还需要修改hash最后一个元素映射的下标为当前index+从hash中删除key\n\n\n\n","slug":"leetcode/系统设计","published":1,"updated":"2022-04-12T12:52:07.484Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clk5ceint0015jpjba0pr7rzu","content":"<h4 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h4><p><a href=\"https://github.com/donnemartin/system-design-primer\">https://github.com/donnemartin/system-design-primer</a></p>\n<h4 id=\"题型\"><a href=\"#题型\" class=\"headerlink\" title=\"题型\"></a>题型</h4><h5 id=\"1-标准布隆过滤器hash函数的设置\"><a href=\"#1-标准布隆过滤器hash函数的设置\" class=\"headerlink\" title=\"1.标准布隆过滤器hash函数的设置\"></a>1.标准布隆过滤器hash函数的设置</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HashFunction</span> &#123;</span><br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-keyword\">int</span> cap, seed;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">HashFunction</span>(<span class=\"hljs-keyword\">int</span> cap, <span class=\"hljs-keyword\">int</span> seed) &#123;<br>        <span class=\"hljs-keyword\">this</span>-&gt;cap = cap;<br>        <span class=\"hljs-keyword\">this</span>-&gt;seed = seed;<br>    &#125;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">hash</span><span class=\"hljs-params\">(string&amp; value)</span> </span>&#123;<br>        <span class=\"hljs-keyword\">int</span> ret = <span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-keyword\">int</span> n = value.<span class=\"hljs-built_in\">size</span>();<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; n; ++i) &#123;<br>            ret += seed * ret + value[i];<br>            ret %= cap;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> ret;<br>    &#125;<br>&#125;;<br><br><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">StandardBloomFilter</span> &#123;</span><br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-keyword\">int</span> k;<br>    vector&lt;HashFunction*&gt; hashFunc;<br>    bitset&lt;200000&gt; bits;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">StandardBloomFilter</span>(<span class=\"hljs-keyword\">int</span> k) &#123;<br>        <span class=\"hljs-comment\">// initialize your data structure here</span><br>        <span class=\"hljs-keyword\">this</span>-&gt;k = k;<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; k; ++i)<br>            hashFunc.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">HashFunction</span>(<span class=\"hljs-number\">100000</span> + i, <span class=\"hljs-number\">2</span> * i + <span class=\"hljs-number\">3</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>每个字符串通过这个hash函数可以得到一个值（position），然后将bit[200000]中该位置为1，多个函数，那么就会有多个位置为1;判断某一个字符串是否存在，就是判断多个函数计算出来值是否都在bit中位1，如果有一个不为1，说明该字符串不在</p>\n<h5 id=\"2-序列化Trie树-Lintcode\"><a href=\"#2-序列化Trie树-Lintcode\" class=\"headerlink\" title=\"2. 序列化Trie树(Lintcode)\"></a>2. 序列化Trie树(Lintcode)</h5><p> 这个模板一定要记住，不要用自己的方法，用模板<br> 同类型题目：二叉树的序列化和反序列化， n叉数的序列化和反序列化<br>注意这道题</p>\n<ul>\n<li>在进行序列化：使用dfs, 在遍历完所有的chidren后，加上‘/‘表示退出当前循环</li>\n<li>在进行反序列化时： 使用全局index, index在进入下一层循环和退出循环(注意这里和二叉树不同，有两处)之前都需要+1， 其余情况index保持不变</li>\n<li>注意:<br>(1)在退出训练时候不是返回null, 而是返回一个Trie对象的指针！！！<br>(2)因为一个节点有多个节点，而不是只有二叉树的left和right节点，因此需要使用while判断，如果data[index]==’/‘的时候退出while循环<br>(3)<figure class=\"highlight c++\"><figcaption><span>right</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">TrieNode* tmp=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">TrieNode</span>(); <span class=\"hljs-comment\">//注意区分类和结构体</span><br>map&lt;<span class=\"hljs-keyword\">char</span>, TrieNode*&gt; &amp;childs=tmp-&gt;children;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><figcaption><span>wrong</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">TrieNode* tmp; <span class=\"hljs-comment\">//注意区分类和类指针，这里直接申明一个空指针是不对的, 即使是结构体也应该是student s;</span><br>map&lt;<span class=\"hljs-keyword\">char</span>, TrieNode*&gt; childs;<br>tmp-&gt;children=childs;<br></code></pre></td></tr></table></figure></li>\n</ul>\n<p>官方题解使用的<data> 进行序列化+栈的方式进行反序列化：&lt;将当前current入栈 &gt;将栈顶出栈 其余：新建一个Trie对象(current)，将当前data[index]指向这个对象</data></p>\n<p>//下面模板代码可以用作n叉树的遍历或者trie树遍历，下面的这种方式会将空字符串用&lt;&gt;，如果想要空字符串没有，可以使用dfs2</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * Definition of TrieNode:</span><br><span class=\"hljs-comment\"> * class TrieNode &#123;</span><br><span class=\"hljs-comment\"> * public:</span><br><span class=\"hljs-comment\"> *     TrieNode() &#123;&#125;</span><br><span class=\"hljs-comment\"> *     map&lt;char, TrieNode*&gt; children;</span><br><span class=\"hljs-comment\"> * &#125;;</span><br><span class=\"hljs-comment\"> */</span><br> <span class=\"hljs-comment\">//适用于n叉数的遍历， 但是这种方式在进行反序列化的时候，每次从栈中弹出一个元素前，需要将栈顶赋值给cur</span><br> <span class=\"hljs-comment\">//&lt;1&lt;3&lt;5&gt;&lt;6&gt;&gt;&lt;2&gt;&lt;4&gt;&gt; null节点无&lt;&gt;</span><br><span class=\"hljs-comment\">//  lc428 每个节点都被&lt;&gt;分开，即使是同一层</span><br><span class=\"hljs-function\">string <span class=\"hljs-title\">dfs</span><span class=\"hljs-params\">(Node* root)</span></span>&#123;<br>    <span class=\"hljs-keyword\">if</span>(root==<span class=\"hljs-literal\">NULL</span>)&#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;&quot;</span>;<br>    &#125;<br>    string data;<br>    <span class=\"hljs-keyword\">int</span> size=root-&gt;children.<span class=\"hljs-built_in\">size</span>();<br>    data+=<span class=\"hljs-built_in\">to_string</span>(root-&gt;val);<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;size;i++)&#123;<br>        data+=<span class=\"hljs-built_in\">dfs</span>(root-&gt;children[i]);<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;&lt;&quot;</span>+data+<span class=\"hljs-string\">&quot;&gt;&quot;</span>;<br>&#125;<br><br><span class=\"hljs-comment\">//&lt;a&lt;b&lt;e&lt;&gt;&gt;c&lt;&gt;d&lt;f&lt;&gt;&gt;&gt;&gt; 节点之间可能没有&lt;&gt;分开</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> &#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     * This method will be invoked first, you should design your own algorithm </span><br><span class=\"hljs-comment\">     * to serialize a trie which denote by a root node to a string which</span><br><span class=\"hljs-comment\">     * can be easily deserialized by your own &quot;deserialize&quot; method later.</span><br><span class=\"hljs-comment\">     */</span><br>     <br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">dfs2</span><span class=\"hljs-params\">(TrieNode* root)</span></span>&#123;<br>        <span class=\"hljs-function\">string <span class=\"hljs-title\">dfs</span><span class=\"hljs-params\">(Node* root)</span></span>&#123;<br>        <span class=\"hljs-keyword\">if</span>(root==<span class=\"hljs-literal\">NULL</span>)&#123;<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;&quot;</span>;<br>        &#125;<br>        string data;<br>        <span class=\"hljs-keyword\">int</span> size=root-&gt;children.<span class=\"hljs-built_in\">size</span>();<br>        data+=<span class=\"hljs-built_in\">to_string</span>(root-&gt;val);<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;size;i++)&#123;<br>            data+=<span class=\"hljs-built_in\">dfs</span>(root-&gt;children[i]);<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;&lt;&quot;</span>+data+<span class=\"hljs-string\">&quot;&gt;&quot;</span>;<br>    &#125;<br>    <br>    <span class=\"hljs-function\">string <span class=\"hljs-title\">serialize</span><span class=\"hljs-params\">(TrieNode* root)</span> </span>&#123;<br>        <span class=\"hljs-comment\">// Write your code here</span><br>        <span class=\"hljs-keyword\">if</span> (root == <span class=\"hljs-literal\">NULL</span>)<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;&quot;</span>;<br>        string data;<br>        <span class=\"hljs-keyword\">for</span> (map&lt;<span class=\"hljs-keyword\">char</span>, TrieNode*&gt;::iterator it = root-&gt;children.<span class=\"hljs-built_in\">begin</span>();<br>             it != root-&gt;children.<span class=\"hljs-built_in\">end</span>(); ++it) &#123;<br>            data += it-&gt;first;<br>            data += <span class=\"hljs-built_in\">serialize</span>(it-&gt;second);<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;&lt;&quot;</span> + data + <span class=\"hljs-string\">&quot;&gt;&quot;</span>;<br>    &#125;<br><br>    <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     * This method will be invoked second, the argument data is what exactly</span><br><span class=\"hljs-comment\">     * you serialized at method &quot;serialize&quot;, that means the data is not given by</span><br><span class=\"hljs-comment\">     * system, it&#x27;s given by your own serialize method. So the format of data is</span><br><span class=\"hljs-comment\">     * designed by yourself, and deserialize it here as you serialize it in </span><br><span class=\"hljs-comment\">     * &quot;serialize&quot; method.</span><br><span class=\"hljs-comment\">     */</span><br>    <span class=\"hljs-function\">TrieNode* <span class=\"hljs-title\">deserialize</span><span class=\"hljs-params\">(string data)</span> </span>&#123;<br>        <span class=\"hljs-comment\">// Write your code here</span><br>        <span class=\"hljs-keyword\">if</span> (data.<span class=\"hljs-built_in\">size</span>() == <span class=\"hljs-number\">0</span>)<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">NULL</span>;<br><br>        TrieNode* head = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">TrieNode</span>();<br>        TrieNode* current = head;<br>        stack&lt;TrieNode*&gt; path;<br>        <span class=\"hljs-keyword\">int</span> len = data.<span class=\"hljs-built_in\">size</span>();<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; len; ++i) &#123;<br>            <span class=\"hljs-built_in\"><span class=\"hljs-keyword\">switch</span></span> (data[i]) &#123;<br>                <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;&lt;&#x27;</span>:<br>                    path.<span class=\"hljs-built_in\">push</span>(current);<br>                    <span class=\"hljs-keyword\">break</span>;<br>                <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;&gt;&#x27;</span>:<br>                    <span class=\"hljs-comment\">//如果是null节点无&lt;&gt;情况，那么需要在这里赋值cur=path.top()</span><br>                    path.<span class=\"hljs-built_in\">pop</span>();<br>                    <br>                    <span class=\"hljs-keyword\">break</span>;<br>                <span class=\"hljs-keyword\">default</span>:<br>                    current = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">TrieNode</span>();<br>                    path.<span class=\"hljs-built_in\">top</span>()-&gt;children[data[i]] = current;<br>            &#125;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n\n<ol start=\"3\">\n<li>Trie树专题<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\">class <span class=\"hljs-title\">Trie</span><span class=\"hljs-params\">()</span></span>&#123;<br>    vector&lt;Trie*&gt; children;<br>    <span class=\"hljs-keyword\">bool</span> isEnd;<br>    <span class=\"hljs-built_in\">Trie</span>()&#123;<br>        <span class=\"hljs-keyword\">this</span>-&gt;child = vector&lt;Trie*&gt;(<span class=\"hljs-number\">26</span>,<span class=\"hljs-literal\">nullptr</span>); <span class=\"hljs-comment\">//一定要记得初始化26个节点，而且都为null</span><br>        <span class=\"hljs-keyword\">this</span>-&gt;isEnd = <span class=\"hljs-literal\">false</span>;<br>    &#125;<br>    <span class=\"hljs-built_in\">search</span>(string s)&#123;<br>        Trie* root=<span class=\"hljs-keyword\">this</span>;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;s.<span class=\"hljs-built_in\">size</span>();i++)&#123;<br>            <span class=\"hljs-keyword\">if</span>(root-&gt;children[s[i]-<span class=\"hljs-string\">&#x27;a&#x27;</span>]==<span class=\"hljs-literal\">NULL</span>)&#123;<br>                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>            &#125;<br>            root= root-&gt;children[s[i]-<span class=\"hljs-string\">&#x27;a&#x27;</span>];<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> root-&gt;isEnd;<br>    &#125;<br>    <span class=\"hljs-built_in\">insert</span>(string s)&#123;<br>        Trie* root=<span class=\"hljs-keyword\">this</span>;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;s.<span class=\"hljs-built_in\">size</span>();i++)&#123;<br>            <span class=\"hljs-keyword\">if</span>(root-&gt;children[s[i]-<span class=\"hljs-string\">&#x27;a&#x27;</span>]==<span class=\"hljs-literal\">NULL</span>)&#123;<br>                root-&gt;children[s[i]-<span class=\"hljs-string\">&#x27;a&#x27;</span>]=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Trie</span>();<br>            &#125;<br>            root= root-&gt;children[s[i]-<span class=\"hljs-string\">&#x27;a&#x27;</span>];<br>        &#125;<br>        root-&gt;isEnd=<span class=\"hljs-literal\">true</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li>\n</ol>\n<p>二叉树的序列化和反序列可以使用前序遍历实现</p>\n<ol start=\"4\">\n<li>lc355. 设计推特</li>\n</ol>\n<ul>\n<li>需要实现4个功能: 关注， 取消关注， 发表博客， 列出userid和userid最近发表的10条博客</li>\n<li>实现关注和取消关注使用unordered_map&lt;int, unordered_set<int>&gt; hash</int></li>\n<li>发表博客使用unordered_map&lt;int, node*&gt; , 其中node记录<br>node{<br>  tuiteid, //充当时间戳<br>  userid, //发表用户<br>  node* next; //指向下一个node, 类似于LRU，方便使用头插入方法<br>}</li>\n<li> 列出userid和userid最近发表的10条博客， 使用K个链表的合并，找出前M个数</li>\n<li>为什么使用链表，这样的话扩展非常方便，如果不使用，那么在删除博客的时候就比较麻烦</li>\n</ul>\n<ol start=\"5\">\n<li>单词自动补全系统</li>\n</ol>\n<ul>\n<li>题意：1. 初始化系统，包括一些句子和句子最初始的频率，一个句子之间可能小写字符或者空格 2. 每次input一个字符应该接着上一个字符，同时输出‘#’表示输出的末尾，这时候需要初始化data=””, cur=root（全局变量）, 更新句子的频率</li>\n<li>解决方案：</li>\n<li><ol>\n<li>使用前缀树+hash(存储句子+频率) 前缀树的每个节点，应该存储一个vector<string> 表示走到这个节点的下面所有字符</string></li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>注意字符串在进行查找如果cur==null, 那么直接返回空，否则一直在cur的基础上走一步 cur=cur-&gt;children[c]//unordered_map&lt;char, TrieNode*&gt; children;</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>如果走到‘#’，表示走到了末尾，这时候需要初始化data=””, cur=root, 同时更新句子的频率 +1（句子频率会更新）</li>\n</ol>\n</li>\n<li>参考答案: <a href=\"https://aaronice.gitbook.io/lintcode/data_structure/design-search-autocomplete-system\">https://aaronice.gitbook.io/lintcode/data_structure/design-search-autocomplete-system</a><br><a href=\"https://zhuanlan.zhihu.com/p/99499171\">https://zhuanlan.zhihu.com/p/99499171</a> (有点问题，不应该在每个节点里面记录节点的频率，因为这个随时更新，之后就不准确，应该用一个单独的hashmap来记录)</li>\n</ul>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>一般是有关于系统， 多个函数的整体设计题目<br>比如：GeoHash, GFS, 布隆过滤器， 心跳设计， 缓存系统， LRU cache设计，二叉树的序列化和反序列化等<br>还有新定义一种数据结构，嵌套返回list leetcode-扁平化嵌套列表迭代器 使用递归方式分解</p>\n<p>为了在vector里面删除元素更快，可以再配合使用一个dict (map)映射特定值对应的index;注意在进行删除元素的时候，除了交换vector中最后一个元素和当前元素，还需要修改hash最后一个元素映射的下标为当前index+从hash中删除key</p>\n","site":{"data":{}},"wordcount":5713,"excerpt":"","more":"<h4 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h4><p><a href=\"https://github.com/donnemartin/system-design-primer\">https://github.com/donnemartin/system-design-primer</a></p>\n<h4 id=\"题型\"><a href=\"#题型\" class=\"headerlink\" title=\"题型\"></a>题型</h4><h5 id=\"1-标准布隆过滤器hash函数的设置\"><a href=\"#1-标准布隆过滤器hash函数的设置\" class=\"headerlink\" title=\"1.标准布隆过滤器hash函数的设置\"></a>1.标准布隆过滤器hash函数的设置</h5><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HashFunction</span> &#123;</span><br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-keyword\">int</span> cap, seed;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">HashFunction</span>(<span class=\"hljs-keyword\">int</span> cap, <span class=\"hljs-keyword\">int</span> seed) &#123;<br>        <span class=\"hljs-keyword\">this</span>-&gt;cap = cap;<br>        <span class=\"hljs-keyword\">this</span>-&gt;seed = seed;<br>    &#125;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">hash</span><span class=\"hljs-params\">(string&amp; value)</span> </span>&#123;<br>        <span class=\"hljs-keyword\">int</span> ret = <span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-keyword\">int</span> n = value.<span class=\"hljs-built_in\">size</span>();<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; n; ++i) &#123;<br>            ret += seed * ret + value[i];<br>            ret %= cap;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> ret;<br>    &#125;<br>&#125;;<br><br><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">StandardBloomFilter</span> &#123;</span><br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-keyword\">int</span> k;<br>    vector&lt;HashFunction*&gt; hashFunc;<br>    bitset&lt;200000&gt; bits;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">StandardBloomFilter</span>(<span class=\"hljs-keyword\">int</span> k) &#123;<br>        <span class=\"hljs-comment\">// initialize your data structure here</span><br>        <span class=\"hljs-keyword\">this</span>-&gt;k = k;<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; k; ++i)<br>            hashFunc.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">HashFunction</span>(<span class=\"hljs-number\">100000</span> + i, <span class=\"hljs-number\">2</span> * i + <span class=\"hljs-number\">3</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>每个字符串通过这个hash函数可以得到一个值（position），然后将bit[200000]中该位置为1，多个函数，那么就会有多个位置为1;判断某一个字符串是否存在，就是判断多个函数计算出来值是否都在bit中位1，如果有一个不为1，说明该字符串不在</p>\n<h5 id=\"2-序列化Trie树-Lintcode\"><a href=\"#2-序列化Trie树-Lintcode\" class=\"headerlink\" title=\"2. 序列化Trie树(Lintcode)\"></a>2. 序列化Trie树(Lintcode)</h5><p> 这个模板一定要记住，不要用自己的方法，用模板<br> 同类型题目：二叉树的序列化和反序列化， n叉数的序列化和反序列化<br>注意这道题</p>\n<ul>\n<li>在进行序列化：使用dfs, 在遍历完所有的chidren后，加上‘/‘表示退出当前循环</li>\n<li>在进行反序列化时： 使用全局index, index在进入下一层循环和退出循环(注意这里和二叉树不同，有两处)之前都需要+1， 其余情况index保持不变</li>\n<li>注意:<br>(1)在退出训练时候不是返回null, 而是返回一个Trie对象的指针！！！<br>(2)因为一个节点有多个节点，而不是只有二叉树的left和right节点，因此需要使用while判断，如果data[index]==’/‘的时候退出while循环<br>(3)<figure class=\"highlight c++\"><figcaption><span>right</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">TrieNode* tmp=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">TrieNode</span>(); <span class=\"hljs-comment\">//注意区分类和结构体</span><br>map&lt;<span class=\"hljs-keyword\">char</span>, TrieNode*&gt; &amp;childs=tmp-&gt;children;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><figcaption><span>wrong</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">TrieNode* tmp; <span class=\"hljs-comment\">//注意区分类和类指针，这里直接申明一个空指针是不对的, 即使是结构体也应该是student s;</span><br>map&lt;<span class=\"hljs-keyword\">char</span>, TrieNode*&gt; childs;<br>tmp-&gt;children=childs;<br></code></pre></td></tr></table></figure></li>\n</ul>\n<p>官方题解使用的<data> 进行序列化+栈的方式进行反序列化：&lt;将当前current入栈 &gt;将栈顶出栈 其余：新建一个Trie对象(current)，将当前data[index]指向这个对象</data></p>\n<p>//下面模板代码可以用作n叉树的遍历或者trie树遍历，下面的这种方式会将空字符串用&lt;&gt;，如果想要空字符串没有，可以使用dfs2</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * Definition of TrieNode:</span><br><span class=\"hljs-comment\"> * class TrieNode &#123;</span><br><span class=\"hljs-comment\"> * public:</span><br><span class=\"hljs-comment\"> *     TrieNode() &#123;&#125;</span><br><span class=\"hljs-comment\"> *     map&lt;char, TrieNode*&gt; children;</span><br><span class=\"hljs-comment\"> * &#125;;</span><br><span class=\"hljs-comment\"> */</span><br> <span class=\"hljs-comment\">//适用于n叉数的遍历， 但是这种方式在进行反序列化的时候，每次从栈中弹出一个元素前，需要将栈顶赋值给cur</span><br> <span class=\"hljs-comment\">//&lt;1&lt;3&lt;5&gt;&lt;6&gt;&gt;&lt;2&gt;&lt;4&gt;&gt; null节点无&lt;&gt;</span><br><span class=\"hljs-comment\">//  lc428 每个节点都被&lt;&gt;分开，即使是同一层</span><br><span class=\"hljs-function\">string <span class=\"hljs-title\">dfs</span><span class=\"hljs-params\">(Node* root)</span></span>&#123;<br>    <span class=\"hljs-keyword\">if</span>(root==<span class=\"hljs-literal\">NULL</span>)&#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;&quot;</span>;<br>    &#125;<br>    string data;<br>    <span class=\"hljs-keyword\">int</span> size=root-&gt;children.<span class=\"hljs-built_in\">size</span>();<br>    data+=<span class=\"hljs-built_in\">to_string</span>(root-&gt;val);<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;size;i++)&#123;<br>        data+=<span class=\"hljs-built_in\">dfs</span>(root-&gt;children[i]);<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;&lt;&quot;</span>+data+<span class=\"hljs-string\">&quot;&gt;&quot;</span>;<br>&#125;<br><br><span class=\"hljs-comment\">//&lt;a&lt;b&lt;e&lt;&gt;&gt;c&lt;&gt;d&lt;f&lt;&gt;&gt;&gt;&gt; 节点之间可能没有&lt;&gt;分开</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Solution</span> &#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     * This method will be invoked first, you should design your own algorithm </span><br><span class=\"hljs-comment\">     * to serialize a trie which denote by a root node to a string which</span><br><span class=\"hljs-comment\">     * can be easily deserialized by your own &quot;deserialize&quot; method later.</span><br><span class=\"hljs-comment\">     */</span><br>     <br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">dfs2</span><span class=\"hljs-params\">(TrieNode* root)</span></span>&#123;<br>        <span class=\"hljs-function\">string <span class=\"hljs-title\">dfs</span><span class=\"hljs-params\">(Node* root)</span></span>&#123;<br>        <span class=\"hljs-keyword\">if</span>(root==<span class=\"hljs-literal\">NULL</span>)&#123;<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;&quot;</span>;<br>        &#125;<br>        string data;<br>        <span class=\"hljs-keyword\">int</span> size=root-&gt;children.<span class=\"hljs-built_in\">size</span>();<br>        data+=<span class=\"hljs-built_in\">to_string</span>(root-&gt;val);<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;size;i++)&#123;<br>            data+=<span class=\"hljs-built_in\">dfs</span>(root-&gt;children[i]);<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;&lt;&quot;</span>+data+<span class=\"hljs-string\">&quot;&gt;&quot;</span>;<br>    &#125;<br>    <br>    <span class=\"hljs-function\">string <span class=\"hljs-title\">serialize</span><span class=\"hljs-params\">(TrieNode* root)</span> </span>&#123;<br>        <span class=\"hljs-comment\">// Write your code here</span><br>        <span class=\"hljs-keyword\">if</span> (root == <span class=\"hljs-literal\">NULL</span>)<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;&quot;</span>;<br>        string data;<br>        <span class=\"hljs-keyword\">for</span> (map&lt;<span class=\"hljs-keyword\">char</span>, TrieNode*&gt;::iterator it = root-&gt;children.<span class=\"hljs-built_in\">begin</span>();<br>             it != root-&gt;children.<span class=\"hljs-built_in\">end</span>(); ++it) &#123;<br>            data += it-&gt;first;<br>            data += <span class=\"hljs-built_in\">serialize</span>(it-&gt;second);<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;&lt;&quot;</span> + data + <span class=\"hljs-string\">&quot;&gt;&quot;</span>;<br>    &#125;<br><br>    <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">     * This method will be invoked second, the argument data is what exactly</span><br><span class=\"hljs-comment\">     * you serialized at method &quot;serialize&quot;, that means the data is not given by</span><br><span class=\"hljs-comment\">     * system, it&#x27;s given by your own serialize method. So the format of data is</span><br><span class=\"hljs-comment\">     * designed by yourself, and deserialize it here as you serialize it in </span><br><span class=\"hljs-comment\">     * &quot;serialize&quot; method.</span><br><span class=\"hljs-comment\">     */</span><br>    <span class=\"hljs-function\">TrieNode* <span class=\"hljs-title\">deserialize</span><span class=\"hljs-params\">(string data)</span> </span>&#123;<br>        <span class=\"hljs-comment\">// Write your code here</span><br>        <span class=\"hljs-keyword\">if</span> (data.<span class=\"hljs-built_in\">size</span>() == <span class=\"hljs-number\">0</span>)<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">NULL</span>;<br><br>        TrieNode* head = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">TrieNode</span>();<br>        TrieNode* current = head;<br>        stack&lt;TrieNode*&gt; path;<br>        <span class=\"hljs-keyword\">int</span> len = data.<span class=\"hljs-built_in\">size</span>();<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; len; ++i) &#123;<br>            <span class=\"hljs-built_in\"><span class=\"hljs-keyword\">switch</span></span> (data[i]) &#123;<br>                <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;&lt;&#x27;</span>:<br>                    path.<span class=\"hljs-built_in\">push</span>(current);<br>                    <span class=\"hljs-keyword\">break</span>;<br>                <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;&gt;&#x27;</span>:<br>                    <span class=\"hljs-comment\">//如果是null节点无&lt;&gt;情况，那么需要在这里赋值cur=path.top()</span><br>                    path.<span class=\"hljs-built_in\">pop</span>();<br>                    <br>                    <span class=\"hljs-keyword\">break</span>;<br>                <span class=\"hljs-keyword\">default</span>:<br>                    current = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">TrieNode</span>();<br>                    path.<span class=\"hljs-built_in\">top</span>()-&gt;children[data[i]] = current;<br>            &#125;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n\n<ol start=\"3\">\n<li>Trie树专题<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\">class <span class=\"hljs-title\">Trie</span><span class=\"hljs-params\">()</span></span>&#123;<br>    vector&lt;Trie*&gt; children;<br>    <span class=\"hljs-keyword\">bool</span> isEnd;<br>    <span class=\"hljs-built_in\">Trie</span>()&#123;<br>        <span class=\"hljs-keyword\">this</span>-&gt;child = vector&lt;Trie*&gt;(<span class=\"hljs-number\">26</span>,<span class=\"hljs-literal\">nullptr</span>); <span class=\"hljs-comment\">//一定要记得初始化26个节点，而且都为null</span><br>        <span class=\"hljs-keyword\">this</span>-&gt;isEnd = <span class=\"hljs-literal\">false</span>;<br>    &#125;<br>    <span class=\"hljs-built_in\">search</span>(string s)&#123;<br>        Trie* root=<span class=\"hljs-keyword\">this</span>;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;s.<span class=\"hljs-built_in\">size</span>();i++)&#123;<br>            <span class=\"hljs-keyword\">if</span>(root-&gt;children[s[i]-<span class=\"hljs-string\">&#x27;a&#x27;</span>]==<span class=\"hljs-literal\">NULL</span>)&#123;<br>                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>            &#125;<br>            root= root-&gt;children[s[i]-<span class=\"hljs-string\">&#x27;a&#x27;</span>];<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> root-&gt;isEnd;<br>    &#125;<br>    <span class=\"hljs-built_in\">insert</span>(string s)&#123;<br>        Trie* root=<span class=\"hljs-keyword\">this</span>;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;s.<span class=\"hljs-built_in\">size</span>();i++)&#123;<br>            <span class=\"hljs-keyword\">if</span>(root-&gt;children[s[i]-<span class=\"hljs-string\">&#x27;a&#x27;</span>]==<span class=\"hljs-literal\">NULL</span>)&#123;<br>                root-&gt;children[s[i]-<span class=\"hljs-string\">&#x27;a&#x27;</span>]=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Trie</span>();<br>            &#125;<br>            root= root-&gt;children[s[i]-<span class=\"hljs-string\">&#x27;a&#x27;</span>];<br>        &#125;<br>        root-&gt;isEnd=<span class=\"hljs-literal\">true</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li>\n</ol>\n<p>二叉树的序列化和反序列可以使用前序遍历实现</p>\n<ol start=\"4\">\n<li>lc355. 设计推特</li>\n</ol>\n<ul>\n<li>需要实现4个功能: 关注， 取消关注， 发表博客， 列出userid和userid最近发表的10条博客</li>\n<li>实现关注和取消关注使用unordered_map&lt;int, unordered_set<int>&gt; hash</int></li>\n<li>发表博客使用unordered_map&lt;int, node*&gt; , 其中node记录<br>node{<br>  tuiteid, //充当时间戳<br>  userid, //发表用户<br>  node* next; //指向下一个node, 类似于LRU，方便使用头插入方法<br>}</li>\n<li> 列出userid和userid最近发表的10条博客， 使用K个链表的合并，找出前M个数</li>\n<li>为什么使用链表，这样的话扩展非常方便，如果不使用，那么在删除博客的时候就比较麻烦</li>\n</ul>\n<ol start=\"5\">\n<li>单词自动补全系统</li>\n</ol>\n<ul>\n<li>题意：1. 初始化系统，包括一些句子和句子最初始的频率，一个句子之间可能小写字符或者空格 2. 每次input一个字符应该接着上一个字符，同时输出‘#’表示输出的末尾，这时候需要初始化data=””, cur=root（全局变量）, 更新句子的频率</li>\n<li>解决方案：</li>\n<li><ol>\n<li>使用前缀树+hash(存储句子+频率) 前缀树的每个节点，应该存储一个vector<string> 表示走到这个节点的下面所有字符</string></li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>注意字符串在进行查找如果cur==null, 那么直接返回空，否则一直在cur的基础上走一步 cur=cur-&gt;children[c]//unordered_map&lt;char, TrieNode*&gt; children;</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>如果走到‘#’，表示走到了末尾，这时候需要初始化data=””, cur=root, 同时更新句子的频率 +1（句子频率会更新）</li>\n</ol>\n</li>\n<li>参考答案: <a href=\"https://aaronice.gitbook.io/lintcode/data_structure/design-search-autocomplete-system\">https://aaronice.gitbook.io/lintcode/data_structure/design-search-autocomplete-system</a><br><a href=\"https://zhuanlan.zhihu.com/p/99499171\">https://zhuanlan.zhihu.com/p/99499171</a> (有点问题，不应该在每个节点里面记录节点的频率，因为这个随时更新，之后就不准确，应该用一个单独的hashmap来记录)</li>\n</ul>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>一般是有关于系统， 多个函数的整体设计题目<br>比如：GeoHash, GFS, 布隆过滤器， 心跳设计， 缓存系统， LRU cache设计，二叉树的序列化和反序列化等<br>还有新定义一种数据结构，嵌套返回list leetcode-扁平化嵌套列表迭代器 使用递归方式分解</p>\n<p>为了在vector里面删除元素更快，可以再配合使用一个dict (map)映射特定值对应的index;注意在进行删除元素的时候，除了交换vector中最后一个元素和当前元素，还需要修改hash最后一个元素映射的下标为当前index+从hash中删除key</p>\n"},{"title":"贪心算法","catogory":["leetcode 题目汇总"],"date":"2021-11-13T09:22:53.000Z","_content":"\n#### 相关例题\n1. 摆动序列：使用贪心算法，或者动态规划 当前状态可以用前面的一个状态转移过来（可以证明得到，down是由up转移过来，up是由down转移过来），所以时间复杂度只有O(1)\n或者使用diff来进行理解，当前的diff一定要和前一个diff相反\n注意和最长上升子序列的区别，最长上升子序列，当前的状态不能从上一个状态转移过来，所以只能使用内外循环\n\n其实摆动序列也属于动态规划  down[i], up[i]: 0-i之间的最后为up的最长序列，和最后为down的最长序列;一定要注意\ndown[i]=max(down[i-1], up[i-1]+1)//一定要记得和down[i-1]进行比较\n\n2. 最大子序列和\n\n3. 加油站\n\n4. 买卖股票最佳时机 （也属于动态规划） - 两状态目标规划问题\n  买卖股票最佳时机I:只买卖一次，当前最大-之前最小\n  买卖股票最佳时机II:买卖多次，贪心，向上就+，向下就不加\n  买卖股票最佳时机III, IV:最多买卖k次，使用动态规划，需要分两个数组，因为卖出必须在买入后，因此注意最开始初始化buy[0][1]=-prices[0], 否则就会出现在index0/最开始交易就卖出的情况。\n  在0的时候卖出k次，仍然是-卖出一次的价钱 所有需要出示化所有buy[0][k]=-prices[0]\n  因为当前i的状态都是依赖i-1的状态，因此可以使用一维数组，进行状态压缩\n  \n  ```C++\n       for (int i = 1; i <= k; ++i) {\n            buy[i] = -prices[0];\n            sell[i]=0;\n        }\n        buy[0]=0;\n        for (int i = 1; i < n; ++i) {//i表示i时刻\n            sell[0] = 0;\n            for (int j = 1; j <= k; ++j) {\n                buy[j] = max(buy[j], sell[j-1] - prices[i]);\n                sell[j] = max(sell[j], buy[j] + prices[i]);   \n            }\n        }\n        return *max_element(sell.begin(), sell.end());\n  ```\n\n  买卖股票的最佳时机含手续费： 可以买卖无限次，但是每买入卖出一次都会收取一次的手续费用，使用dp, 在卖出的时候-fee\n  ```C++\n   buy[i]=max(buy[i-1],sell[i-1]-prices[i]);\n   sell[i]=max(sell[i-1],buy[i]+prices[i]-fee);\n   return sell[size-1];\n   ```\n\n  - 类似的一个多状态的动态规划问题:lc801. 使序列递增的最小交换次数\n  - 两个长度相等的数组，使得两个数组相等的最小交换次数\n  - 题解：当发生错位的时候，可以当前位置交换，也可以前一个位置交换，因此进行分类讨论，用0 1分别表示两种状态（当前位交换，或者当前位不交换）；同时因为当前位只和上一个位置有关，因此可以使用两个数组before和cur就可以了，不用使用一个二维数组\n\n5. 跳跃游戏\n\n6. 区间相关的题目：主要是判断如何对区间进行排序（左区间还是右区间，遇到重叠该如何处理）\n\n7. 用最少数量的箭引爆气球: 先按照气球的右区间对气球的进行排序，如果遍历到的当前左区间小于end,那么continue；否则更新end, res++\n\n8. 划分字母区间，注意读懂题意: 是同一个字母最多出现在一个区间，而不是一个字母只出现在一个区间！！\n用hash统计一个字母的最后位置，当当前遍历的位置==之前区间达到的最大位置，说明需要划分一个区间了\n\n有点类似跳跃游戏, 跳跃游戏多维护了一个end\n```C++\n int end=0, maxPos=0, step=0;\n  for(int i=0;i<nums.size()-1;i++){\n      maxPos=max(nums[i]+i,maxPos);\n      if(i==end){\n          end=maxPos;\n          step++;\n      }\n  }\n  return step;\n```\n\n9. 无重叠区间: 需要以右边界排序，在两个区间重叠的时候，保留右边界更小的区间\n\n10. 合并区间：以左边界进行排序，注意在修改vector back的右边界的时候可以不用pop_back 然后push_back可以直接使用vec.back()[1]=interval[i][1]\n\n11. 分割数组为连续子序列\n关键点，每次往前往后看是否能凑齐一个最小合格序列\n两种解法：\n- 使用优先队列的方式，用一个map记录以x结尾的序列（使用优先队列存放，unordered_map<int, priority_queue<int, vector<int>,greater<int>>> mp），同时这个序列需要根据长度从小到大进行排序，就是说相同的长度末尾，更倾向于将当前的x追加到长度更短的以x-1的序列上\n\n- 如果使用贪心算法，那就是用两个hash表，一个表记录数据的个数，另外一个表记录以某一个数结尾的合格序列个数。每次都先凑齐一个合格序列，然后在判断后面的数， 首先看有没有x-1的合格序列，有就当前数-1， valid[x-1]--, valid[x]++;否则从当前数开始从后面凑齐一个合格序列\n\n12. 环形子数组的最大值\n分为两种情况，一个区间加起来最大，或者左右两端加起来最大\n那么就是 max(res1, total-res2) res1是中间加起来最大， res2的中间加起来最小\n但是注意！！！ 当total==res2的时候，直接返回res1, 不应该返回max(res1, total-res2) \n\n13.  使数组唯一的最小增量\n有点偏向找规律，使得数组中数据各不相同的最小操作次数（加的次数）\n方法一：可以将多余的数，变为它==后面==相同个数个没有vis的数，返回结果其实就是没有vis数之和-多余数之和\n方法二：先排序，再依次遍历数组元素，若当前元素小于等于它前一个元素，则将其变为前一个数 +1。\n\n14. 吃苹果的最大数目\n注意这个和跳跃问题不一样\n[2,1,10] [2,10,1] 答案是4\n第四天可以吃第2天产的苹果，如果是跳跃的话，答案为3\n使用贪心+优先队列\n最先吃掉最先腐烂的水果，在前n个水果，因为每天可能会产生新的水果，最先腐烂的水果会改变，所以i一天一天相加；在n之后因为不会产生新的水果，所以i+=min(水果个数，腐烂截止-当前天数\n\n优先队列的一些操作：q.top(), q.push() q.pop()\n注意不能直接修改优先队列元素的值，比如q.top().num-- 的操作是错误\n\n#### 区间相关问题\n区间子数组个数 一共有n个数的子区间个数是1+2+3+...+n 也就是(1+n)*n/2\n这道题是最大值在[left, right]的区间个数，可以找到每个数都是<=right的区间个数-每个数都是< left的区间个数\n\nlc352. 将数据流变为多个不相交区间（hard）\n- 题意：添加num, getInterval返回合并了的区间\n- 解决方案: 使用map<int, int> 分别记录区间的左右，然后在插入一个val, 找到这个val左右两边最近的区间（使用一个upper_bound, 然后prev(iter) 如果iter不是hash.begin()）如果这个值在前面这个区间内或者边缘的话，直接返回；否则分四种情况判断，左右边缘衔接处，左边缘，右边缘，或者都不是，分别进行处理，最后遍历map并打印出来就可以了\n- 可以学习的地方，为了减少if里面的判断逻辑，可以单独提取出来放在一个bool变量中\n\n```C++\n//找到区间的左右两个区间iter\nauto pre_iter = (cur_iter == intervals.begin() ? intervals.end() : prev(cur_iter));\nauto next_iter = next(cur_iter);\nbool left_aside = (pre_iter != intervals.end() && index2char[pre_iter->second] == index2char[cur_iter->second]);\nbool right_aside = (next_iter != intervals.end() && index2char[next_iter->second] == index2char[cur_iter->second]);\n```\n          \n\nlc6030. 由单个字符重复的最长子字符串（周赛hard）\n这道题可以学习的一个点是将结构体进行拆分， 区间头尾放在map, 区间长度放在multiset, 两者各自进行排序\n题解：\n  1. 先找到这个要修改下标对应的区间\n  2. 如果要修改的字符和区间字符不一样就删除原来区间，并对原区间进行拆分，同时插入这个新的只有一个字符的区间\n  3. 否则，就不拆分(不进入if内)\n  4. 然后判断这个区间前面的区间字符是否和当前要修改的一样，是就合并（同时修改当前指针指向的区间为新的合并后这个前面区间！！！！！，方便后面的合并）\n  5. 同样判断右侧的\n  6. 使用multiset单独存储长度（自动排序），map单独存储< start, end> ，这样可以直接知道目前最长区间为mullti-set的尾部值* set.rbegin()\n  - 和上面一题一样，同时使用map来记录区间左右\n\n\nlc1642. 可以到达的最远建筑\n- m个梯子，k个砖头，所能到达的最高墙\n- 使用贪心算法，梯子对应的一定是最高前m个墙，那么就用一个m size小根堆, 如果大于m，那么弹出最小的使用砖头 （用梯子应对最大跨度）\n\n\nlc605. 种花问题 (easy)\n- 贪心，遇到0就判断能不能种花\n```C++\nif(flowerbed[i]==0){\n      if((i==0||flowerbed[i-1]==0)&&(i==size-1||flowerbed[i+1]==0)){ //边界处理，可以在两边加0或者分情况判断\n          cnt++;\n      }\n}\n```\n\nlc630. 课程表 III（hard）\n- 使用优先队列 + 贪心算法：1. 优先学习更早结束的课程 2. 如果total_time+当前课程<=当前课程的结束时间，那么直接学习这个课程就可以了；否则在选择的课程中选择时长最大的课程，如果找到课程时间>当前课程，那么就和当前课程进行交换\n\n\n\n### 总结\nok\n1. 贪心算法就是知道当前能够如何优先选择，使得最后的结果不会比当前的结果差\n2. 常见的题型：区间，优先队列，背包其实也是一种贪心\n3. 在使用优先队列的时候，通常可以直接push进去，只有取的时候才判断，队首的这个符不符合条件，不符合直接弹出\n4. 贪心总结: https://leetcode-cn.com/problems/course-schedule-iii/solution/gong-shui-san-xie-jing-dian-tan-xin-yun-ghii2/\n\n\n","source":"_posts/leetcode/贪心算法.md","raw":"---\ntitle: 贪心算法\ncatogory:\n  - leetcode 题目汇总\ncategories:\n  - leetcode\ndate: 2021-11-13 17:22:53\ntags:\n---\n\n#### 相关例题\n1. 摆动序列：使用贪心算法，或者动态规划 当前状态可以用前面的一个状态转移过来（可以证明得到，down是由up转移过来，up是由down转移过来），所以时间复杂度只有O(1)\n或者使用diff来进行理解，当前的diff一定要和前一个diff相反\n注意和最长上升子序列的区别，最长上升子序列，当前的状态不能从上一个状态转移过来，所以只能使用内外循环\n\n其实摆动序列也属于动态规划  down[i], up[i]: 0-i之间的最后为up的最长序列，和最后为down的最长序列;一定要注意\ndown[i]=max(down[i-1], up[i-1]+1)//一定要记得和down[i-1]进行比较\n\n2. 最大子序列和\n\n3. 加油站\n\n4. 买卖股票最佳时机 （也属于动态规划） - 两状态目标规划问题\n  买卖股票最佳时机I:只买卖一次，当前最大-之前最小\n  买卖股票最佳时机II:买卖多次，贪心，向上就+，向下就不加\n  买卖股票最佳时机III, IV:最多买卖k次，使用动态规划，需要分两个数组，因为卖出必须在买入后，因此注意最开始初始化buy[0][1]=-prices[0], 否则就会出现在index0/最开始交易就卖出的情况。\n  在0的时候卖出k次，仍然是-卖出一次的价钱 所有需要出示化所有buy[0][k]=-prices[0]\n  因为当前i的状态都是依赖i-1的状态，因此可以使用一维数组，进行状态压缩\n  \n  ```C++\n       for (int i = 1; i <= k; ++i) {\n            buy[i] = -prices[0];\n            sell[i]=0;\n        }\n        buy[0]=0;\n        for (int i = 1; i < n; ++i) {//i表示i时刻\n            sell[0] = 0;\n            for (int j = 1; j <= k; ++j) {\n                buy[j] = max(buy[j], sell[j-1] - prices[i]);\n                sell[j] = max(sell[j], buy[j] + prices[i]);   \n            }\n        }\n        return *max_element(sell.begin(), sell.end());\n  ```\n\n  买卖股票的最佳时机含手续费： 可以买卖无限次，但是每买入卖出一次都会收取一次的手续费用，使用dp, 在卖出的时候-fee\n  ```C++\n   buy[i]=max(buy[i-1],sell[i-1]-prices[i]);\n   sell[i]=max(sell[i-1],buy[i]+prices[i]-fee);\n   return sell[size-1];\n   ```\n\n  - 类似的一个多状态的动态规划问题:lc801. 使序列递增的最小交换次数\n  - 两个长度相等的数组，使得两个数组相等的最小交换次数\n  - 题解：当发生错位的时候，可以当前位置交换，也可以前一个位置交换，因此进行分类讨论，用0 1分别表示两种状态（当前位交换，或者当前位不交换）；同时因为当前位只和上一个位置有关，因此可以使用两个数组before和cur就可以了，不用使用一个二维数组\n\n5. 跳跃游戏\n\n6. 区间相关的题目：主要是判断如何对区间进行排序（左区间还是右区间，遇到重叠该如何处理）\n\n7. 用最少数量的箭引爆气球: 先按照气球的右区间对气球的进行排序，如果遍历到的当前左区间小于end,那么continue；否则更新end, res++\n\n8. 划分字母区间，注意读懂题意: 是同一个字母最多出现在一个区间，而不是一个字母只出现在一个区间！！\n用hash统计一个字母的最后位置，当当前遍历的位置==之前区间达到的最大位置，说明需要划分一个区间了\n\n有点类似跳跃游戏, 跳跃游戏多维护了一个end\n```C++\n int end=0, maxPos=0, step=0;\n  for(int i=0;i<nums.size()-1;i++){\n      maxPos=max(nums[i]+i,maxPos);\n      if(i==end){\n          end=maxPos;\n          step++;\n      }\n  }\n  return step;\n```\n\n9. 无重叠区间: 需要以右边界排序，在两个区间重叠的时候，保留右边界更小的区间\n\n10. 合并区间：以左边界进行排序，注意在修改vector back的右边界的时候可以不用pop_back 然后push_back可以直接使用vec.back()[1]=interval[i][1]\n\n11. 分割数组为连续子序列\n关键点，每次往前往后看是否能凑齐一个最小合格序列\n两种解法：\n- 使用优先队列的方式，用一个map记录以x结尾的序列（使用优先队列存放，unordered_map<int, priority_queue<int, vector<int>,greater<int>>> mp），同时这个序列需要根据长度从小到大进行排序，就是说相同的长度末尾，更倾向于将当前的x追加到长度更短的以x-1的序列上\n\n- 如果使用贪心算法，那就是用两个hash表，一个表记录数据的个数，另外一个表记录以某一个数结尾的合格序列个数。每次都先凑齐一个合格序列，然后在判断后面的数， 首先看有没有x-1的合格序列，有就当前数-1， valid[x-1]--, valid[x]++;否则从当前数开始从后面凑齐一个合格序列\n\n12. 环形子数组的最大值\n分为两种情况，一个区间加起来最大，或者左右两端加起来最大\n那么就是 max(res1, total-res2) res1是中间加起来最大， res2的中间加起来最小\n但是注意！！！ 当total==res2的时候，直接返回res1, 不应该返回max(res1, total-res2) \n\n13.  使数组唯一的最小增量\n有点偏向找规律，使得数组中数据各不相同的最小操作次数（加的次数）\n方法一：可以将多余的数，变为它==后面==相同个数个没有vis的数，返回结果其实就是没有vis数之和-多余数之和\n方法二：先排序，再依次遍历数组元素，若当前元素小于等于它前一个元素，则将其变为前一个数 +1。\n\n14. 吃苹果的最大数目\n注意这个和跳跃问题不一样\n[2,1,10] [2,10,1] 答案是4\n第四天可以吃第2天产的苹果，如果是跳跃的话，答案为3\n使用贪心+优先队列\n最先吃掉最先腐烂的水果，在前n个水果，因为每天可能会产生新的水果，最先腐烂的水果会改变，所以i一天一天相加；在n之后因为不会产生新的水果，所以i+=min(水果个数，腐烂截止-当前天数\n\n优先队列的一些操作：q.top(), q.push() q.pop()\n注意不能直接修改优先队列元素的值，比如q.top().num-- 的操作是错误\n\n#### 区间相关问题\n区间子数组个数 一共有n个数的子区间个数是1+2+3+...+n 也就是(1+n)*n/2\n这道题是最大值在[left, right]的区间个数，可以找到每个数都是<=right的区间个数-每个数都是< left的区间个数\n\nlc352. 将数据流变为多个不相交区间（hard）\n- 题意：添加num, getInterval返回合并了的区间\n- 解决方案: 使用map<int, int> 分别记录区间的左右，然后在插入一个val, 找到这个val左右两边最近的区间（使用一个upper_bound, 然后prev(iter) 如果iter不是hash.begin()）如果这个值在前面这个区间内或者边缘的话，直接返回；否则分四种情况判断，左右边缘衔接处，左边缘，右边缘，或者都不是，分别进行处理，最后遍历map并打印出来就可以了\n- 可以学习的地方，为了减少if里面的判断逻辑，可以单独提取出来放在一个bool变量中\n\n```C++\n//找到区间的左右两个区间iter\nauto pre_iter = (cur_iter == intervals.begin() ? intervals.end() : prev(cur_iter));\nauto next_iter = next(cur_iter);\nbool left_aside = (pre_iter != intervals.end() && index2char[pre_iter->second] == index2char[cur_iter->second]);\nbool right_aside = (next_iter != intervals.end() && index2char[next_iter->second] == index2char[cur_iter->second]);\n```\n          \n\nlc6030. 由单个字符重复的最长子字符串（周赛hard）\n这道题可以学习的一个点是将结构体进行拆分， 区间头尾放在map, 区间长度放在multiset, 两者各自进行排序\n题解：\n  1. 先找到这个要修改下标对应的区间\n  2. 如果要修改的字符和区间字符不一样就删除原来区间，并对原区间进行拆分，同时插入这个新的只有一个字符的区间\n  3. 否则，就不拆分(不进入if内)\n  4. 然后判断这个区间前面的区间字符是否和当前要修改的一样，是就合并（同时修改当前指针指向的区间为新的合并后这个前面区间！！！！！，方便后面的合并）\n  5. 同样判断右侧的\n  6. 使用multiset单独存储长度（自动排序），map单独存储< start, end> ，这样可以直接知道目前最长区间为mullti-set的尾部值* set.rbegin()\n  - 和上面一题一样，同时使用map来记录区间左右\n\n\nlc1642. 可以到达的最远建筑\n- m个梯子，k个砖头，所能到达的最高墙\n- 使用贪心算法，梯子对应的一定是最高前m个墙，那么就用一个m size小根堆, 如果大于m，那么弹出最小的使用砖头 （用梯子应对最大跨度）\n\n\nlc605. 种花问题 (easy)\n- 贪心，遇到0就判断能不能种花\n```C++\nif(flowerbed[i]==0){\n      if((i==0||flowerbed[i-1]==0)&&(i==size-1||flowerbed[i+1]==0)){ //边界处理，可以在两边加0或者分情况判断\n          cnt++;\n      }\n}\n```\n\nlc630. 课程表 III（hard）\n- 使用优先队列 + 贪心算法：1. 优先学习更早结束的课程 2. 如果total_time+当前课程<=当前课程的结束时间，那么直接学习这个课程就可以了；否则在选择的课程中选择时长最大的课程，如果找到课程时间>当前课程，那么就和当前课程进行交换\n\n\n\n### 总结\nok\n1. 贪心算法就是知道当前能够如何优先选择，使得最后的结果不会比当前的结果差\n2. 常见的题型：区间，优先队列，背包其实也是一种贪心\n3. 在使用优先队列的时候，通常可以直接push进去，只有取的时候才判断，队首的这个符不符合条件，不符合直接弹出\n4. 贪心总结: https://leetcode-cn.com/problems/course-schedule-iii/solution/gong-shui-san-xie-jing-dian-tan-xin-yun-ghii2/\n\n\n","slug":"leetcode/贪心算法","published":1,"updated":"2023-07-10T10:36:19.575Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clk5ceinu0018jpjbbrtpgupw","content":"<h4 id=\"相关例题\"><a href=\"#相关例题\" class=\"headerlink\" title=\"相关例题\"></a>相关例题</h4><ol>\n<li>摆动序列：使用贪心算法，或者动态规划 当前状态可以用前面的一个状态转移过来（可以证明得到，down是由up转移过来，up是由down转移过来），所以时间复杂度只有O(1)<br>或者使用diff来进行理解，当前的diff一定要和前一个diff相反<br>注意和最长上升子序列的区别，最长上升子序列，当前的状态不能从上一个状态转移过来，所以只能使用内外循环</li>\n</ol>\n<p>其实摆动序列也属于动态规划  down[i], up[i]: 0-i之间的最后为up的最长序列，和最后为down的最长序列;一定要注意<br>down[i]=max(down[i-1], up[i-1]+1)//一定要记得和down[i-1]进行比较</p>\n<ol start=\"2\">\n<li><p>最大子序列和</p>\n</li>\n<li><p>加油站</p>\n</li>\n<li><p>买卖股票最佳时机 （也属于动态规划） - 两状态目标规划问题<br>买卖股票最佳时机I:只买卖一次，当前最大-之前最小<br>买卖股票最佳时机II:买卖多次，贪心，向上就+，向下就不加<br>买卖股票最佳时机III, IV:最多买卖k次，使用动态规划，需要分两个数组，因为卖出必须在买入后，因此注意最开始初始化buy[0][1]=-prices[0], 否则就会出现在index0/最开始交易就卖出的情况。<br>在0的时候卖出k次，仍然是-卖出一次的价钱 所有需要出示化所有buy[0][k]=-prices[0]<br>因为当前i的状态都是依赖i-1的状态，因此可以使用一维数组，进行状态压缩</p>\n</li>\n</ol>\n  <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt;= k; ++i) &#123;<br>     buy[i] = -prices[<span class=\"hljs-number\">0</span>];<br>     sell[i]=<span class=\"hljs-number\">0</span>;<br> &#125;<br> buy[<span class=\"hljs-number\">0</span>]=<span class=\"hljs-number\">0</span>;<br> <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt; n; ++i) &#123;<span class=\"hljs-comment\">//i表示i时刻</span><br>     sell[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">0</span>;<br>     <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">1</span>; j &lt;= k; ++j) &#123;<br>         buy[j] = <span class=\"hljs-built_in\">max</span>(buy[j], sell[j<span class=\"hljs-number\">-1</span>] - prices[i]);<br>         sell[j] = <span class=\"hljs-built_in\">max</span>(sell[j], buy[j] + prices[i]);   <br>     &#125;<br> &#125;<br> <span class=\"hljs-keyword\">return</span> *<span class=\"hljs-built_in\">max_element</span>(sell.<span class=\"hljs-built_in\">begin</span>(), sell.<span class=\"hljs-built_in\">end</span>());<br></code></pre></td></tr></table></figure>\n\n<p>  买卖股票的最佳时机含手续费： 可以买卖无限次，但是每买入卖出一次都会收取一次的手续费用，使用dp, 在卖出的时候-fee<br>  <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">buy[i]=<span class=\"hljs-built_in\">max</span>(buy[i<span class=\"hljs-number\">-1</span>],sell[i<span class=\"hljs-number\">-1</span>]-prices[i]);<br>sell[i]=<span class=\"hljs-built_in\">max</span>(sell[i<span class=\"hljs-number\">-1</span>],buy[i]+prices[i]-fee);<br><span class=\"hljs-keyword\">return</span> sell[size<span class=\"hljs-number\">-1</span>];<br></code></pre></td></tr></table></figure></p>\n<ul>\n<li>类似的一个多状态的动态规划问题:lc801. 使序列递增的最小交换次数</li>\n<li>两个长度相等的数组，使得两个数组相等的最小交换次数</li>\n<li>题解：当发生错位的时候，可以当前位置交换，也可以前一个位置交换，因此进行分类讨论，用0 1分别表示两种状态（当前位交换，或者当前位不交换）；同时因为当前位只和上一个位置有关，因此可以使用两个数组before和cur就可以了，不用使用一个二维数组</li>\n</ul>\n<ol start=\"5\">\n<li><p>跳跃游戏</p>\n</li>\n<li><p>区间相关的题目：主要是判断如何对区间进行排序（左区间还是右区间，遇到重叠该如何处理）</p>\n</li>\n<li><p>用最少数量的箭引爆气球: 先按照气球的右区间对气球的进行排序，如果遍历到的当前左区间小于end,那么continue；否则更新end, res++</p>\n</li>\n<li><p>划分字母区间，注意读懂题意: 是同一个字母最多出现在一个区间，而不是一个字母只出现在一个区间！！<br>用hash统计一个字母的最后位置，当当前遍历的位置==之前区间达到的最大位置，说明需要划分一个区间了</p>\n</li>\n</ol>\n<p>有点类似跳跃游戏, 跳跃游戏多维护了一个end</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">int</span> end=<span class=\"hljs-number\">0</span>, maxPos=<span class=\"hljs-number\">0</span>, step=<span class=\"hljs-number\">0</span>;<br> <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;nums.<span class=\"hljs-built_in\">size</span>()<span class=\"hljs-number\">-1</span>;i++)&#123;<br>     maxPos=<span class=\"hljs-built_in\">max</span>(nums[i]+i,maxPos);<br>     <span class=\"hljs-keyword\">if</span>(i==end)&#123;<br>         end=maxPos;<br>         step++;<br>     &#125;<br> &#125;<br> <span class=\"hljs-keyword\">return</span> step;<br></code></pre></td></tr></table></figure>\n\n<ol start=\"9\">\n<li><p>无重叠区间: 需要以右边界排序，在两个区间重叠的时候，保留右边界更小的区间</p>\n</li>\n<li><p>合并区间：以左边界进行排序，注意在修改vector back的右边界的时候可以不用pop_back 然后push_back可以直接使用vec.back()[1]=interval[i][1]</p>\n</li>\n<li><p>分割数组为连续子序列<br>关键点，每次往前往后看是否能凑齐一个最小合格序列<br>两种解法：</p>\n</li>\n</ol>\n<ul>\n<li><p>使用优先队列的方式，用一个map记录以x结尾的序列（使用优先队列存放，unordered_map&lt;int, priority_queue&lt;int, vector<int>,greater<int>&gt;&gt; mp），同时这个序列需要根据长度从小到大进行排序，就是说相同的长度末尾，更倾向于将当前的x追加到长度更短的以x-1的序列上</int></int></p>\n</li>\n<li><p>如果使用贪心算法，那就是用两个hash表，一个表记录数据的个数，另外一个表记录以某一个数结尾的合格序列个数。每次都先凑齐一个合格序列，然后在判断后面的数， 首先看有没有x-1的合格序列，有就当前数-1， valid[x-1]–, valid[x]++;否则从当前数开始从后面凑齐一个合格序列</p>\n</li>\n</ul>\n<ol start=\"12\">\n<li><p>环形子数组的最大值<br>分为两种情况，一个区间加起来最大，或者左右两端加起来最大<br>那么就是 max(res1, total-res2) res1是中间加起来最大， res2的中间加起来最小<br>但是注意！！！ 当total==res2的时候，直接返回res1, 不应该返回max(res1, total-res2) </p>\n</li>\n<li><p> 使数组唯一的最小增量<br>有点偏向找规律，使得数组中数据各不相同的最小操作次数（加的次数）<br>方法一：可以将多余的数，变为它==后面==相同个数个没有vis的数，返回结果其实就是没有vis数之和-多余数之和<br>方法二：先排序，再依次遍历数组元素，若当前元素小于等于它前一个元素，则将其变为前一个数 +1。</p>\n</li>\n<li><p>吃苹果的最大数目<br>注意这个和跳跃问题不一样<br>[2,1,10] [2,10,1] 答案是4<br>第四天可以吃第2天产的苹果，如果是跳跃的话，答案为3<br>使用贪心+优先队列<br>最先吃掉最先腐烂的水果，在前n个水果，因为每天可能会产生新的水果，最先腐烂的水果会改变，所以i一天一天相加；在n之后因为不会产生新的水果，所以i+=min(水果个数，腐烂截止-当前天数</p>\n</li>\n</ol>\n<p>优先队列的一些操作：q.top(), q.push() q.pop()<br>注意不能直接修改优先队列元素的值，比如q.top().num– 的操作是错误</p>\n<h4 id=\"区间相关问题\"><a href=\"#区间相关问题\" class=\"headerlink\" title=\"区间相关问题\"></a>区间相关问题</h4><p>区间子数组个数 一共有n个数的子区间个数是1+2+3+…+n 也就是(1+n)*n/2<br>这道题是最大值在[left, right]的区间个数，可以找到每个数都是&lt;=right的区间个数-每个数都是&lt; left的区间个数</p>\n<p>lc352. 将数据流变为多个不相交区间（hard）</p>\n<ul>\n<li>题意：添加num, getInterval返回合并了的区间</li>\n<li>解决方案: 使用map&lt;int, int&gt; 分别记录区间的左右，然后在插入一个val, 找到这个val左右两边最近的区间（使用一个upper_bound, 然后prev(iter) 如果iter不是hash.begin()）如果这个值在前面这个区间内或者边缘的话，直接返回；否则分四种情况判断，左右边缘衔接处，左边缘，右边缘，或者都不是，分别进行处理，最后遍历map并打印出来就可以了</li>\n<li>可以学习的地方，为了减少if里面的判断逻辑，可以单独提取出来放在一个bool变量中</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-comment\">//找到区间的左右两个区间iter</span><br><span class=\"hljs-keyword\">auto</span> pre_iter = (cur_iter == intervals.<span class=\"hljs-built_in\">begin</span>() ? intervals.<span class=\"hljs-built_in\">end</span>() : <span class=\"hljs-built_in\">prev</span>(cur_iter));<br><span class=\"hljs-keyword\">auto</span> next_iter = <span class=\"hljs-built_in\">next</span>(cur_iter);<br><span class=\"hljs-keyword\">bool</span> left_aside = (pre_iter != intervals.<span class=\"hljs-built_in\">end</span>() &amp;&amp; index2char[pre_iter-&gt;second] == index2char[cur_iter-&gt;second]);<br><span class=\"hljs-keyword\">bool</span> right_aside = (next_iter != intervals.<span class=\"hljs-built_in\">end</span>() &amp;&amp; index2char[next_iter-&gt;second] == index2char[cur_iter-&gt;second]);<br></code></pre></td></tr></table></figure>\n<p>lc6030. 由单个字符重复的最长子字符串（周赛hard）<br>这道题可以学习的一个点是将结构体进行拆分， 区间头尾放在map, 区间长度放在multiset, 两者各自进行排序<br>题解：</p>\n<ol>\n<li>先找到这个要修改下标对应的区间</li>\n<li>如果要修改的字符和区间字符不一样就删除原来区间，并对原区间进行拆分，同时插入这个新的只有一个字符的区间</li>\n<li>否则，就不拆分(不进入if内)</li>\n<li>然后判断这个区间前面的区间字符是否和当前要修改的一样，是就合并（同时修改当前指针指向的区间为新的合并后这个前面区间！！！！！，方便后面的合并）</li>\n<li>同样判断右侧的</li>\n<li>使用multiset单独存储长度（自动排序），map单独存储&lt; start, end&gt; ，这样可以直接知道目前最长区间为mullti-set的尾部值* set.rbegin()</li>\n</ol>\n<ul>\n<li>和上面一题一样，同时使用map来记录区间左右</li>\n</ul>\n<p>lc1642. 可以到达的最远建筑</p>\n<ul>\n<li>m个梯子，k个砖头，所能到达的最高墙</li>\n<li>使用贪心算法，梯子对应的一定是最高前m个墙，那么就用一个m size小根堆, 如果大于m，那么弹出最小的使用砖头 （用梯子应对最大跨度）</li>\n</ul>\n<p>lc605. 种花问题 (easy)</p>\n<ul>\n<li>贪心，遇到0就判断能不能种花<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">if</span>(flowerbed[i]==<span class=\"hljs-number\">0</span>)&#123;<br>      <span class=\"hljs-keyword\">if</span>((i==<span class=\"hljs-number\">0</span>||flowerbed[i<span class=\"hljs-number\">-1</span>]==<span class=\"hljs-number\">0</span>)&amp;&amp;(i==size<span class=\"hljs-number\">-1</span>||flowerbed[i+<span class=\"hljs-number\">1</span>]==<span class=\"hljs-number\">0</span>))&#123; <span class=\"hljs-comment\">//边界处理，可以在两边加0或者分情况判断</span><br>          cnt++;<br>      &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n</ul>\n<p>lc630. 课程表 III（hard）</p>\n<ul>\n<li>使用优先队列 + 贪心算法：1. 优先学习更早结束的课程 2. 如果total_time+当前课程&lt;=当前课程的结束时间，那么直接学习这个课程就可以了；否则在选择的课程中选择时长最大的课程，如果找到课程时间&gt;当前课程，那么就和当前课程进行交换</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>ok</p>\n<ol>\n<li>贪心算法就是知道当前能够如何优先选择，使得最后的结果不会比当前的结果差</li>\n<li>常见的题型：区间，优先队列，背包其实也是一种贪心</li>\n<li>在使用优先队列的时候，通常可以直接push进去，只有取的时候才判断，队首的这个符不符合条件，不符合直接弹出</li>\n<li>贪心总结: <a href=\"https://leetcode-cn.com/problems/course-schedule-iii/solution/gong-shui-san-xie-jing-dian-tan-xin-yun-ghii2/\">https://leetcode-cn.com/problems/course-schedule-iii/solution/gong-shui-san-xie-jing-dian-tan-xin-yun-ghii2/</a></li>\n</ol>\n","site":{"data":{}},"wordcount":4365,"excerpt":"","more":"<h4 id=\"相关例题\"><a href=\"#相关例题\" class=\"headerlink\" title=\"相关例题\"></a>相关例题</h4><ol>\n<li>摆动序列：使用贪心算法，或者动态规划 当前状态可以用前面的一个状态转移过来（可以证明得到，down是由up转移过来，up是由down转移过来），所以时间复杂度只有O(1)<br>或者使用diff来进行理解，当前的diff一定要和前一个diff相反<br>注意和最长上升子序列的区别，最长上升子序列，当前的状态不能从上一个状态转移过来，所以只能使用内外循环</li>\n</ol>\n<p>其实摆动序列也属于动态规划  down[i], up[i]: 0-i之间的最后为up的最长序列，和最后为down的最长序列;一定要注意<br>down[i]=max(down[i-1], up[i-1]+1)//一定要记得和down[i-1]进行比较</p>\n<ol start=\"2\">\n<li><p>最大子序列和</p>\n</li>\n<li><p>加油站</p>\n</li>\n<li><p>买卖股票最佳时机 （也属于动态规划） - 两状态目标规划问题<br>买卖股票最佳时机I:只买卖一次，当前最大-之前最小<br>买卖股票最佳时机II:买卖多次，贪心，向上就+，向下就不加<br>买卖股票最佳时机III, IV:最多买卖k次，使用动态规划，需要分两个数组，因为卖出必须在买入后，因此注意最开始初始化buy[0][1]=-prices[0], 否则就会出现在index0/最开始交易就卖出的情况。<br>在0的时候卖出k次，仍然是-卖出一次的价钱 所有需要出示化所有buy[0][k]=-prices[0]<br>因为当前i的状态都是依赖i-1的状态，因此可以使用一维数组，进行状态压缩</p>\n</li>\n</ol>\n  <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt;= k; ++i) &#123;<br>     buy[i] = -prices[<span class=\"hljs-number\">0</span>];<br>     sell[i]=<span class=\"hljs-number\">0</span>;<br> &#125;<br> buy[<span class=\"hljs-number\">0</span>]=<span class=\"hljs-number\">0</span>;<br> <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt; n; ++i) &#123;<span class=\"hljs-comment\">//i表示i时刻</span><br>     sell[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">0</span>;<br>     <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">1</span>; j &lt;= k; ++j) &#123;<br>         buy[j] = <span class=\"hljs-built_in\">max</span>(buy[j], sell[j<span class=\"hljs-number\">-1</span>] - prices[i]);<br>         sell[j] = <span class=\"hljs-built_in\">max</span>(sell[j], buy[j] + prices[i]);   <br>     &#125;<br> &#125;<br> <span class=\"hljs-keyword\">return</span> *<span class=\"hljs-built_in\">max_element</span>(sell.<span class=\"hljs-built_in\">begin</span>(), sell.<span class=\"hljs-built_in\">end</span>());<br></code></pre></td></tr></table></figure>\n\n<p>  买卖股票的最佳时机含手续费： 可以买卖无限次，但是每买入卖出一次都会收取一次的手续费用，使用dp, 在卖出的时候-fee<br>  <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">buy[i]=<span class=\"hljs-built_in\">max</span>(buy[i<span class=\"hljs-number\">-1</span>],sell[i<span class=\"hljs-number\">-1</span>]-prices[i]);<br>sell[i]=<span class=\"hljs-built_in\">max</span>(sell[i<span class=\"hljs-number\">-1</span>],buy[i]+prices[i]-fee);<br><span class=\"hljs-keyword\">return</span> sell[size<span class=\"hljs-number\">-1</span>];<br></code></pre></td></tr></table></figure></p>\n<ul>\n<li>类似的一个多状态的动态规划问题:lc801. 使序列递增的最小交换次数</li>\n<li>两个长度相等的数组，使得两个数组相等的最小交换次数</li>\n<li>题解：当发生错位的时候，可以当前位置交换，也可以前一个位置交换，因此进行分类讨论，用0 1分别表示两种状态（当前位交换，或者当前位不交换）；同时因为当前位只和上一个位置有关，因此可以使用两个数组before和cur就可以了，不用使用一个二维数组</li>\n</ul>\n<ol start=\"5\">\n<li><p>跳跃游戏</p>\n</li>\n<li><p>区间相关的题目：主要是判断如何对区间进行排序（左区间还是右区间，遇到重叠该如何处理）</p>\n</li>\n<li><p>用最少数量的箭引爆气球: 先按照气球的右区间对气球的进行排序，如果遍历到的当前左区间小于end,那么continue；否则更新end, res++</p>\n</li>\n<li><p>划分字母区间，注意读懂题意: 是同一个字母最多出现在一个区间，而不是一个字母只出现在一个区间！！<br>用hash统计一个字母的最后位置，当当前遍历的位置==之前区间达到的最大位置，说明需要划分一个区间了</p>\n</li>\n</ol>\n<p>有点类似跳跃游戏, 跳跃游戏多维护了一个end</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">int</span> end=<span class=\"hljs-number\">0</span>, maxPos=<span class=\"hljs-number\">0</span>, step=<span class=\"hljs-number\">0</span>;<br> <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;nums.<span class=\"hljs-built_in\">size</span>()<span class=\"hljs-number\">-1</span>;i++)&#123;<br>     maxPos=<span class=\"hljs-built_in\">max</span>(nums[i]+i,maxPos);<br>     <span class=\"hljs-keyword\">if</span>(i==end)&#123;<br>         end=maxPos;<br>         step++;<br>     &#125;<br> &#125;<br> <span class=\"hljs-keyword\">return</span> step;<br></code></pre></td></tr></table></figure>\n\n<ol start=\"9\">\n<li><p>无重叠区间: 需要以右边界排序，在两个区间重叠的时候，保留右边界更小的区间</p>\n</li>\n<li><p>合并区间：以左边界进行排序，注意在修改vector back的右边界的时候可以不用pop_back 然后push_back可以直接使用vec.back()[1]=interval[i][1]</p>\n</li>\n<li><p>分割数组为连续子序列<br>关键点，每次往前往后看是否能凑齐一个最小合格序列<br>两种解法：</p>\n</li>\n</ol>\n<ul>\n<li><p>使用优先队列的方式，用一个map记录以x结尾的序列（使用优先队列存放，unordered_map&lt;int, priority_queue&lt;int, vector<int>,greater<int>&gt;&gt; mp），同时这个序列需要根据长度从小到大进行排序，就是说相同的长度末尾，更倾向于将当前的x追加到长度更短的以x-1的序列上</int></int></p>\n</li>\n<li><p>如果使用贪心算法，那就是用两个hash表，一个表记录数据的个数，另外一个表记录以某一个数结尾的合格序列个数。每次都先凑齐一个合格序列，然后在判断后面的数， 首先看有没有x-1的合格序列，有就当前数-1， valid[x-1]–, valid[x]++;否则从当前数开始从后面凑齐一个合格序列</p>\n</li>\n</ul>\n<ol start=\"12\">\n<li><p>环形子数组的最大值<br>分为两种情况，一个区间加起来最大，或者左右两端加起来最大<br>那么就是 max(res1, total-res2) res1是中间加起来最大， res2的中间加起来最小<br>但是注意！！！ 当total==res2的时候，直接返回res1, 不应该返回max(res1, total-res2) </p>\n</li>\n<li><p> 使数组唯一的最小增量<br>有点偏向找规律，使得数组中数据各不相同的最小操作次数（加的次数）<br>方法一：可以将多余的数，变为它==后面==相同个数个没有vis的数，返回结果其实就是没有vis数之和-多余数之和<br>方法二：先排序，再依次遍历数组元素，若当前元素小于等于它前一个元素，则将其变为前一个数 +1。</p>\n</li>\n<li><p>吃苹果的最大数目<br>注意这个和跳跃问题不一样<br>[2,1,10] [2,10,1] 答案是4<br>第四天可以吃第2天产的苹果，如果是跳跃的话，答案为3<br>使用贪心+优先队列<br>最先吃掉最先腐烂的水果，在前n个水果，因为每天可能会产生新的水果，最先腐烂的水果会改变，所以i一天一天相加；在n之后因为不会产生新的水果，所以i+=min(水果个数，腐烂截止-当前天数</p>\n</li>\n</ol>\n<p>优先队列的一些操作：q.top(), q.push() q.pop()<br>注意不能直接修改优先队列元素的值，比如q.top().num– 的操作是错误</p>\n<h4 id=\"区间相关问题\"><a href=\"#区间相关问题\" class=\"headerlink\" title=\"区间相关问题\"></a>区间相关问题</h4><p>区间子数组个数 一共有n个数的子区间个数是1+2+3+…+n 也就是(1+n)*n/2<br>这道题是最大值在[left, right]的区间个数，可以找到每个数都是&lt;=right的区间个数-每个数都是&lt; left的区间个数</p>\n<p>lc352. 将数据流变为多个不相交区间（hard）</p>\n<ul>\n<li>题意：添加num, getInterval返回合并了的区间</li>\n<li>解决方案: 使用map&lt;int, int&gt; 分别记录区间的左右，然后在插入一个val, 找到这个val左右两边最近的区间（使用一个upper_bound, 然后prev(iter) 如果iter不是hash.begin()）如果这个值在前面这个区间内或者边缘的话，直接返回；否则分四种情况判断，左右边缘衔接处，左边缘，右边缘，或者都不是，分别进行处理，最后遍历map并打印出来就可以了</li>\n<li>可以学习的地方，为了减少if里面的判断逻辑，可以单独提取出来放在一个bool变量中</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-comment\">//找到区间的左右两个区间iter</span><br><span class=\"hljs-keyword\">auto</span> pre_iter = (cur_iter == intervals.<span class=\"hljs-built_in\">begin</span>() ? intervals.<span class=\"hljs-built_in\">end</span>() : <span class=\"hljs-built_in\">prev</span>(cur_iter));<br><span class=\"hljs-keyword\">auto</span> next_iter = <span class=\"hljs-built_in\">next</span>(cur_iter);<br><span class=\"hljs-keyword\">bool</span> left_aside = (pre_iter != intervals.<span class=\"hljs-built_in\">end</span>() &amp;&amp; index2char[pre_iter-&gt;second] == index2char[cur_iter-&gt;second]);<br><span class=\"hljs-keyword\">bool</span> right_aside = (next_iter != intervals.<span class=\"hljs-built_in\">end</span>() &amp;&amp; index2char[next_iter-&gt;second] == index2char[cur_iter-&gt;second]);<br></code></pre></td></tr></table></figure>\n<p>lc6030. 由单个字符重复的最长子字符串（周赛hard）<br>这道题可以学习的一个点是将结构体进行拆分， 区间头尾放在map, 区间长度放在multiset, 两者各自进行排序<br>题解：</p>\n<ol>\n<li>先找到这个要修改下标对应的区间</li>\n<li>如果要修改的字符和区间字符不一样就删除原来区间，并对原区间进行拆分，同时插入这个新的只有一个字符的区间</li>\n<li>否则，就不拆分(不进入if内)</li>\n<li>然后判断这个区间前面的区间字符是否和当前要修改的一样，是就合并（同时修改当前指针指向的区间为新的合并后这个前面区间！！！！！，方便后面的合并）</li>\n<li>同样判断右侧的</li>\n<li>使用multiset单独存储长度（自动排序），map单独存储&lt; start, end&gt; ，这样可以直接知道目前最长区间为mullti-set的尾部值* set.rbegin()</li>\n</ol>\n<ul>\n<li>和上面一题一样，同时使用map来记录区间左右</li>\n</ul>\n<p>lc1642. 可以到达的最远建筑</p>\n<ul>\n<li>m个梯子，k个砖头，所能到达的最高墙</li>\n<li>使用贪心算法，梯子对应的一定是最高前m个墙，那么就用一个m size小根堆, 如果大于m，那么弹出最小的使用砖头 （用梯子应对最大跨度）</li>\n</ul>\n<p>lc605. 种花问题 (easy)</p>\n<ul>\n<li>贪心，遇到0就判断能不能种花<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">if</span>(flowerbed[i]==<span class=\"hljs-number\">0</span>)&#123;<br>      <span class=\"hljs-keyword\">if</span>((i==<span class=\"hljs-number\">0</span>||flowerbed[i<span class=\"hljs-number\">-1</span>]==<span class=\"hljs-number\">0</span>)&amp;&amp;(i==size<span class=\"hljs-number\">-1</span>||flowerbed[i+<span class=\"hljs-number\">1</span>]==<span class=\"hljs-number\">0</span>))&#123; <span class=\"hljs-comment\">//边界处理，可以在两边加0或者分情况判断</span><br>          cnt++;<br>      &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n</ul>\n<p>lc630. 课程表 III（hard）</p>\n<ul>\n<li>使用优先队列 + 贪心算法：1. 优先学习更早结束的课程 2. 如果total_time+当前课程&lt;=当前课程的结束时间，那么直接学习这个课程就可以了；否则在选择的课程中选择时长最大的课程，如果找到课程时间&gt;当前课程，那么就和当前课程进行交换</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>ok</p>\n<ol>\n<li>贪心算法就是知道当前能够如何优先选择，使得最后的结果不会比当前的结果差</li>\n<li>常见的题型：区间，优先队列，背包其实也是一种贪心</li>\n<li>在使用优先队列的时候，通常可以直接push进去，只有取的时候才判断，队首的这个符不符合条件，不符合直接弹出</li>\n<li>贪心总结: <a href=\"https://leetcode-cn.com/problems/course-schedule-iii/solution/gong-shui-san-xie-jing-dian-tan-xin-yun-ghii2/\">https://leetcode-cn.com/problems/course-schedule-iii/solution/gong-shui-san-xie-jing-dian-tan-xin-yun-ghii2/</a></li>\n</ol>\n"},{"title":"链表","date":"2021-11-16T10:29:23.000Z","_content":"\n\n有序链表的合并，一定要注意判断两个链表是否相交，或者链表是否有环的情况，如果遇到这两种情况要特殊处理\n\n\n##### 例题\n1. 扁平化多级双向链表\n\n2. 有序数组或者链表转为二叉搜索树lc109\n  - 常规解法：找到中间节点为当前根节点，分别建立左右子树\n  - 链表找中位数，需要使用快慢指针和断开链表\n  - 为了解决链表找中位数耗时比较大，同时不使用额外空间（不转为数组方法）的方法就是使用中序遍历建树方法：\n  - 我们没有必要“先”找到中间节点：我们可以先构建了左子树，建立结束后，指针自然指向中间结点。那么如何构建左子树呢？其实我们只需要确定子树的大小就可以。所以先用O(n)的时间计算链表长度，之后用中序遍历。当然，指针需要是“引用”。\n  - 为什么要使用指针：因为使用了递归，如果不使用指针，那么递归返回，head就不会被修改，而实际上我们是像达到一个全局变量向前走的效果，因此需要使用指针引用 ListNode* &head\n\n3. 二叉树的最小深度（简单）\n - 注意是叶节点返回1，root==null 返回0， 但是在更新内部节点要判断左右是否为空，若任意一边为空，那么那一边不能加入计算中\n\n\n4. 二叉树展开为链表\n先展开左右两边，然后如果展开的左边不为空，那么将左边展开后返回的头结点插入root->right, 同时设置root->left=null, 然后循环找到之前左边（现在右边）中最下面那个点，连接展开的右边返回的头节点\n```C++\n    TreeNode* flattenFunc2(TreeNode *root){\n        if(root==nullptr){\n            return nullptr;\n        }\n        TreeNode* f_left = flattenFunc2(root->left);\n        TreeNode* f_right = flattenFunc2(root->right);\n        root->left=nullptr;\n        TreeNode* res=root; //一定要记得记录最开始的头结点\n        if(f_left!=nullptr){ //1. 左边不为空插入根和右边之间\n            root->right=f_left;\n            while(root->right!=nullptr){\n                root=root->right; //改变了头结点\n            }\n            root->right=f_right;\n        }else{  //2. 否则直接连接根和右边\n            root->right=f_right;\n        }\n        return res;\n        \n    }\n```\n\n5. lc1019. 链表中的下一个更大节点\n- 题意：求链表中每个元素下一个更大的值\n- 方法1.单独一个vector来记录，单调递减栈下标（从左到右，需要知道前面元素的下标）\n- 方法2.进行链表的翻转，得到list的len， 同时使用单调递减值栈 (从右到左， 不需要知道下标，只需要存储值)\n\n6. lc143. 重排链表\n- 找到链表终点，后面的链表翻转，链表merge\n- 这道题既考了快慢指针查找链表中点，还考了链表翻转以及链表merge 字节+阿里面试题\n\n##### 易错点\n1. 判断head是否为null\n2. 在使用tmp->next 或者tmp->prev 一定要注意判断当前节点不能为null\n也就是if(tmp){\n    \n}\n\n3.双向链表在进行删除某个节点的时候，先固定前面和后面的关系都可以；但是在插入一个节点的时候一定要先固定后面的\n\n4.LRU cache易错点：再删除需要指针+hash都需要消除，cache.erase(lastNode->key); delete lastNode;\n可以用hash.size()定位cache元素\n```C++\n LRU cache（一个双向链表，一个hash）\nstruct LinkNode{\n    int key,val;\n    LinkNode* next;\n    LinkNode* pre;\n    LinkNode(){\n        next=nullptr;\n        pre=nullptr;\n    }\n};\n```\n\nLRU： 使用一个双向链表+unordered_map(数组/(key->*node))\nunordered_map<int,Node*> cache;\nLFU, 需要使用双向链表List(key->*node/ freq_list: (freq-> 链表list头节点，也就是nodelist双向链表))+unordered_map\nmap<int, Node*> key2node;\nmap<int, NodeList*> freq2List;\n\n\n### 总结\nok ok\n1. 注意root=null 特殊情况\n2. 在调整树结构的时候一定要注意，返回节点，否则就可能链表断掉\n3. 充分利用二叉搜索树这些信息\n","source":"_posts/leetcode/链表.md","raw":"---\ntitle: 链表\ncategories:\n  - leetcode\ndate: 2021-11-16 18:29:23\ntags:\n---\n\n\n有序链表的合并，一定要注意判断两个链表是否相交，或者链表是否有环的情况，如果遇到这两种情况要特殊处理\n\n\n##### 例题\n1. 扁平化多级双向链表\n\n2. 有序数组或者链表转为二叉搜索树lc109\n  - 常规解法：找到中间节点为当前根节点，分别建立左右子树\n  - 链表找中位数，需要使用快慢指针和断开链表\n  - 为了解决链表找中位数耗时比较大，同时不使用额外空间（不转为数组方法）的方法就是使用中序遍历建树方法：\n  - 我们没有必要“先”找到中间节点：我们可以先构建了左子树，建立结束后，指针自然指向中间结点。那么如何构建左子树呢？其实我们只需要确定子树的大小就可以。所以先用O(n)的时间计算链表长度，之后用中序遍历。当然，指针需要是“引用”。\n  - 为什么要使用指针：因为使用了递归，如果不使用指针，那么递归返回，head就不会被修改，而实际上我们是像达到一个全局变量向前走的效果，因此需要使用指针引用 ListNode* &head\n\n3. 二叉树的最小深度（简单）\n - 注意是叶节点返回1，root==null 返回0， 但是在更新内部节点要判断左右是否为空，若任意一边为空，那么那一边不能加入计算中\n\n\n4. 二叉树展开为链表\n先展开左右两边，然后如果展开的左边不为空，那么将左边展开后返回的头结点插入root->right, 同时设置root->left=null, 然后循环找到之前左边（现在右边）中最下面那个点，连接展开的右边返回的头节点\n```C++\n    TreeNode* flattenFunc2(TreeNode *root){\n        if(root==nullptr){\n            return nullptr;\n        }\n        TreeNode* f_left = flattenFunc2(root->left);\n        TreeNode* f_right = flattenFunc2(root->right);\n        root->left=nullptr;\n        TreeNode* res=root; //一定要记得记录最开始的头结点\n        if(f_left!=nullptr){ //1. 左边不为空插入根和右边之间\n            root->right=f_left;\n            while(root->right!=nullptr){\n                root=root->right; //改变了头结点\n            }\n            root->right=f_right;\n        }else{  //2. 否则直接连接根和右边\n            root->right=f_right;\n        }\n        return res;\n        \n    }\n```\n\n5. lc1019. 链表中的下一个更大节点\n- 题意：求链表中每个元素下一个更大的值\n- 方法1.单独一个vector来记录，单调递减栈下标（从左到右，需要知道前面元素的下标）\n- 方法2.进行链表的翻转，得到list的len， 同时使用单调递减值栈 (从右到左， 不需要知道下标，只需要存储值)\n\n6. lc143. 重排链表\n- 找到链表终点，后面的链表翻转，链表merge\n- 这道题既考了快慢指针查找链表中点，还考了链表翻转以及链表merge 字节+阿里面试题\n\n##### 易错点\n1. 判断head是否为null\n2. 在使用tmp->next 或者tmp->prev 一定要注意判断当前节点不能为null\n也就是if(tmp){\n    \n}\n\n3.双向链表在进行删除某个节点的时候，先固定前面和后面的关系都可以；但是在插入一个节点的时候一定要先固定后面的\n\n4.LRU cache易错点：再删除需要指针+hash都需要消除，cache.erase(lastNode->key); delete lastNode;\n可以用hash.size()定位cache元素\n```C++\n LRU cache（一个双向链表，一个hash）\nstruct LinkNode{\n    int key,val;\n    LinkNode* next;\n    LinkNode* pre;\n    LinkNode(){\n        next=nullptr;\n        pre=nullptr;\n    }\n};\n```\n\nLRU： 使用一个双向链表+unordered_map(数组/(key->*node))\nunordered_map<int,Node*> cache;\nLFU, 需要使用双向链表List(key->*node/ freq_list: (freq-> 链表list头节点，也就是nodelist双向链表))+unordered_map\nmap<int, Node*> key2node;\nmap<int, NodeList*> freq2List;\n\n\n### 总结\nok ok\n1. 注意root=null 特殊情况\n2. 在调整树结构的时候一定要注意，返回节点，否则就可能链表断掉\n3. 充分利用二叉搜索树这些信息\n","slug":"leetcode/链表","published":1,"updated":"2023-07-10T10:36:19.576Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clk5ceinv001ajpjbcaqg04so","content":"<p>有序链表的合并，一定要注意判断两个链表是否相交，或者链表是否有环的情况，如果遇到这两种情况要特殊处理</p>\n<h5 id=\"例题\"><a href=\"#例题\" class=\"headerlink\" title=\"例题\"></a>例题</h5><ol>\n<li><p>扁平化多级双向链表</p>\n</li>\n<li><p>有序数组或者链表转为二叉搜索树lc109</p>\n</li>\n</ol>\n<ul>\n<li>常规解法：找到中间节点为当前根节点，分别建立左右子树</li>\n<li>链表找中位数，需要使用快慢指针和断开链表</li>\n<li>为了解决链表找中位数耗时比较大，同时不使用额外空间（不转为数组方法）的方法就是使用中序遍历建树方法：</li>\n<li>我们没有必要“先”找到中间节点：我们可以先构建了左子树，建立结束后，指针自然指向中间结点。那么如何构建左子树呢？其实我们只需要确定子树的大小就可以。所以先用O(n)的时间计算链表长度，之后用中序遍历。当然，指针需要是“引用”。</li>\n<li>为什么要使用指针：因为使用了递归，如果不使用指针，那么递归返回，head就不会被修改，而实际上我们是像达到一个全局变量向前走的效果，因此需要使用指针引用 ListNode* &amp;head</li>\n</ul>\n<ol start=\"3\">\n<li>二叉树的最小深度（简单）</li>\n</ol>\n<ul>\n<li>注意是叶节点返回1，root==null 返回0， 但是在更新内部节点要判断左右是否为空，若任意一边为空，那么那一边不能加入计算中</li>\n</ul>\n<ol start=\"4\">\n<li><p>二叉树展开为链表<br>先展开左右两边，然后如果展开的左边不为空，那么将左边展开后返回的头结点插入root-&gt;right, 同时设置root-&gt;left=null, 然后循环找到之前左边（现在右边）中最下面那个点，连接展开的右边返回的头节点</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\">TreeNode* <span class=\"hljs-title\">flattenFunc2</span><span class=\"hljs-params\">(TreeNode *root)</span></span>&#123;<br>    <span class=\"hljs-keyword\">if</span>(root==<span class=\"hljs-literal\">nullptr</span>)&#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nullptr</span>;<br>    &#125;<br>    TreeNode* f_left = <span class=\"hljs-built_in\">flattenFunc2</span>(root-&gt;left);<br>    TreeNode* f_right = <span class=\"hljs-built_in\">flattenFunc2</span>(root-&gt;right);<br>    root-&gt;left=<span class=\"hljs-literal\">nullptr</span>;<br>    TreeNode* res=root; <span class=\"hljs-comment\">//一定要记得记录最开始的头结点</span><br>    <span class=\"hljs-keyword\">if</span>(f_left!=<span class=\"hljs-literal\">nullptr</span>)&#123; <span class=\"hljs-comment\">//1. 左边不为空插入根和右边之间</span><br>        root-&gt;right=f_left;<br>        <span class=\"hljs-keyword\">while</span>(root-&gt;right!=<span class=\"hljs-literal\">nullptr</span>)&#123;<br>            root=root-&gt;right; <span class=\"hljs-comment\">//改变了头结点</span><br>        &#125;<br>        root-&gt;right=f_right;<br>    &#125;<span class=\"hljs-keyword\">else</span>&#123;  <span class=\"hljs-comment\">//2. 否则直接连接根和右边</span><br>        root-&gt;right=f_right;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> res;<br>    <br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li><p>lc1019. 链表中的下一个更大节点</p>\n</li>\n</ol>\n<ul>\n<li>题意：求链表中每个元素下一个更大的值</li>\n<li>方法1.单独一个vector来记录，单调递减栈下标（从左到右，需要知道前面元素的下标）</li>\n<li>方法2.进行链表的翻转，得到list的len， 同时使用单调递减值栈 (从右到左， 不需要知道下标，只需要存储值)</li>\n</ul>\n<ol start=\"6\">\n<li>lc143. 重排链表</li>\n</ol>\n<ul>\n<li>找到链表终点，后面的链表翻转，链表merge</li>\n<li>这道题既考了快慢指针查找链表中点，还考了链表翻转以及链表merge 字节+阿里面试题</li>\n</ul>\n<h5 id=\"易错点\"><a href=\"#易错点\" class=\"headerlink\" title=\"易错点\"></a>易错点</h5><ol>\n<li>判断head是否为null</li>\n<li>在使用tmp-&gt;next 或者tmp-&gt;prev 一定要注意判断当前节点不能为null<br>也就是if(tmp){</li>\n</ol>\n<p>}</p>\n<p>3.双向链表在进行删除某个节点的时候，先固定前面和后面的关系都可以；但是在插入一个节点的时候一定要先固定后面的</p>\n<p>4.LRU cache易错点：再删除需要指针+hash都需要消除，cache.erase(lastNode-&gt;key); delete lastNode;<br>可以用hash.size()定位cache元素</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"> LRU cache（一个双向链表，一个hash）<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">LinkNode</span>&#123;</span><br>    <span class=\"hljs-keyword\">int</span> key,val;<br>    LinkNode* next;<br>    LinkNode* pre;<br>    <span class=\"hljs-built_in\">LinkNode</span>()&#123;<br>        next=<span class=\"hljs-literal\">nullptr</span>;<br>        pre=<span class=\"hljs-literal\">nullptr</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>LRU： 使用一个双向链表+unordered_map(数组/(key-&gt;*node))<br>unordered_map&lt;int,Node*&gt; cache;<br>LFU, 需要使用双向链表List(key-&gt;*node/ freq_list: (freq-&gt; 链表list头节点，也就是nodelist双向链表))+unordered_map<br>map&lt;int, Node*&gt; key2node;<br>map&lt;int, NodeList*&gt; freq2List;</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>ok ok</p>\n<ol>\n<li>注意root=null 特殊情况</li>\n<li>在调整树结构的时候一定要注意，返回节点，否则就可能链表断掉</li>\n<li>充分利用二叉搜索树这些信息</li>\n</ol>\n","site":{"data":{}},"wordcount":1955,"excerpt":"","more":"<p>有序链表的合并，一定要注意判断两个链表是否相交，或者链表是否有环的情况，如果遇到这两种情况要特殊处理</p>\n<h5 id=\"例题\"><a href=\"#例题\" class=\"headerlink\" title=\"例题\"></a>例题</h5><ol>\n<li><p>扁平化多级双向链表</p>\n</li>\n<li><p>有序数组或者链表转为二叉搜索树lc109</p>\n</li>\n</ol>\n<ul>\n<li>常规解法：找到中间节点为当前根节点，分别建立左右子树</li>\n<li>链表找中位数，需要使用快慢指针和断开链表</li>\n<li>为了解决链表找中位数耗时比较大，同时不使用额外空间（不转为数组方法）的方法就是使用中序遍历建树方法：</li>\n<li>我们没有必要“先”找到中间节点：我们可以先构建了左子树，建立结束后，指针自然指向中间结点。那么如何构建左子树呢？其实我们只需要确定子树的大小就可以。所以先用O(n)的时间计算链表长度，之后用中序遍历。当然，指针需要是“引用”。</li>\n<li>为什么要使用指针：因为使用了递归，如果不使用指针，那么递归返回，head就不会被修改，而实际上我们是像达到一个全局变量向前走的效果，因此需要使用指针引用 ListNode* &amp;head</li>\n</ul>\n<ol start=\"3\">\n<li>二叉树的最小深度（简单）</li>\n</ol>\n<ul>\n<li>注意是叶节点返回1，root==null 返回0， 但是在更新内部节点要判断左右是否为空，若任意一边为空，那么那一边不能加入计算中</li>\n</ul>\n<ol start=\"4\">\n<li><p>二叉树展开为链表<br>先展开左右两边，然后如果展开的左边不为空，那么将左边展开后返回的头结点插入root-&gt;right, 同时设置root-&gt;left=null, 然后循环找到之前左边（现在右边）中最下面那个点，连接展开的右边返回的头节点</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\">TreeNode* <span class=\"hljs-title\">flattenFunc2</span><span class=\"hljs-params\">(TreeNode *root)</span></span>&#123;<br>    <span class=\"hljs-keyword\">if</span>(root==<span class=\"hljs-literal\">nullptr</span>)&#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nullptr</span>;<br>    &#125;<br>    TreeNode* f_left = <span class=\"hljs-built_in\">flattenFunc2</span>(root-&gt;left);<br>    TreeNode* f_right = <span class=\"hljs-built_in\">flattenFunc2</span>(root-&gt;right);<br>    root-&gt;left=<span class=\"hljs-literal\">nullptr</span>;<br>    TreeNode* res=root; <span class=\"hljs-comment\">//一定要记得记录最开始的头结点</span><br>    <span class=\"hljs-keyword\">if</span>(f_left!=<span class=\"hljs-literal\">nullptr</span>)&#123; <span class=\"hljs-comment\">//1. 左边不为空插入根和右边之间</span><br>        root-&gt;right=f_left;<br>        <span class=\"hljs-keyword\">while</span>(root-&gt;right!=<span class=\"hljs-literal\">nullptr</span>)&#123;<br>            root=root-&gt;right; <span class=\"hljs-comment\">//改变了头结点</span><br>        &#125;<br>        root-&gt;right=f_right;<br>    &#125;<span class=\"hljs-keyword\">else</span>&#123;  <span class=\"hljs-comment\">//2. 否则直接连接根和右边</span><br>        root-&gt;right=f_right;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> res;<br>    <br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li><p>lc1019. 链表中的下一个更大节点</p>\n</li>\n</ol>\n<ul>\n<li>题意：求链表中每个元素下一个更大的值</li>\n<li>方法1.单独一个vector来记录，单调递减栈下标（从左到右，需要知道前面元素的下标）</li>\n<li>方法2.进行链表的翻转，得到list的len， 同时使用单调递减值栈 (从右到左， 不需要知道下标，只需要存储值)</li>\n</ul>\n<ol start=\"6\">\n<li>lc143. 重排链表</li>\n</ol>\n<ul>\n<li>找到链表终点，后面的链表翻转，链表merge</li>\n<li>这道题既考了快慢指针查找链表中点，还考了链表翻转以及链表merge 字节+阿里面试题</li>\n</ul>\n<h5 id=\"易错点\"><a href=\"#易错点\" class=\"headerlink\" title=\"易错点\"></a>易错点</h5><ol>\n<li>判断head是否为null</li>\n<li>在使用tmp-&gt;next 或者tmp-&gt;prev 一定要注意判断当前节点不能为null<br>也就是if(tmp){</li>\n</ol>\n<p>}</p>\n<p>3.双向链表在进行删除某个节点的时候，先固定前面和后面的关系都可以；但是在插入一个节点的时候一定要先固定后面的</p>\n<p>4.LRU cache易错点：再删除需要指针+hash都需要消除，cache.erase(lastNode-&gt;key); delete lastNode;<br>可以用hash.size()定位cache元素</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"> LRU cache（一个双向链表，一个hash）<br><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">LinkNode</span>&#123;</span><br>    <span class=\"hljs-keyword\">int</span> key,val;<br>    LinkNode* next;<br>    LinkNode* pre;<br>    <span class=\"hljs-built_in\">LinkNode</span>()&#123;<br>        next=<span class=\"hljs-literal\">nullptr</span>;<br>        pre=<span class=\"hljs-literal\">nullptr</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>LRU： 使用一个双向链表+unordered_map(数组/(key-&gt;*node))<br>unordered_map&lt;int,Node*&gt; cache;<br>LFU, 需要使用双向链表List(key-&gt;*node/ freq_list: (freq-&gt; 链表list头节点，也就是nodelist双向链表))+unordered_map<br>map&lt;int, Node*&gt; key2node;<br>map&lt;int, NodeList*&gt; freq2List;</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>ok ok</p>\n<ol>\n<li>注意root=null 特殊情况</li>\n<li>在调整树结构的时候一定要注意，返回节点，否则就可能链表断掉</li>\n<li>充分利用二叉搜索树这些信息</li>\n</ol>\n"},{"title":"DP问题专栏","_content":"DAG上的dp\n\nUVa 437 巴比伦塔 The Tower of Babylon\n\n这道题求最高的塔，其实就是一个记忆化dfs的过程\n一些需要注意的点：\n1. 因为不可能出现一个立方体同时叠两次，因此不需要vis\n2. 因为有三种叠法，所以需要3个方向\n3. 因为最开始让谁做底部是不清楚的，所以使用循环遍历方法\n4. 因为一个底确定之后的最高是确定的，因此使用记忆化搜索，避免重复计算\n5. 对于这种题情况多，再加上dfs的题，先分析一两个小的情况（if-else, 三个方向分情况讨论）， 再暴力（dfs）， 再优化（记忆化数组）\n6. 类似最长路问题\n\n\n树状dp: dfs+dp\n主要是针对图有层级结构（没有上司的舞会），或者选择课程这样的dp, 主要是背包和树状dp结合\n使用dfs+dp\n\n- 一般解题步骤：\n- 先使用dfs记录子节点的状态：dp[i][0]/ dp[i][1]/ dp[i][k]\n- 然后计算当前节点的状态转移 (u是父节点， i是子节点)\n```C++\ndp[u][a+b] = max(dp[u][a+b], dp[u][a]+dp[i][b]) //课程的转移方程\n或者\ndp[u][0] += max(dp[i][0], dp[i][1]); //上司的转移方程\ndp[u][1] += dp[i][0];\n```\n\n- 例题\n洛谷 P2014 CTSC1997 选课 （挺难的）\n- 加入一门课程，森林转为树，求解dp[0][m+1]\n- 我们枚举 u点的每个子结点 ，同时枚举以 i 为根的子树选了几门课程，将子树的结果合并到 u 上。注意这个使用a的取值范围随着访问的子树的数量逐渐增加\n\n```C++\nint dfs(int u) {\n  int p = 1;\n  f[u][1] = s[u];\n  for (auto v : e[u]) {\n    int siz = dfs(v);\n    // 注意下面两重循环的上界和下界\n    // 只考虑已经合并过的子树，以及选的课程数超过 m+1 的状态没有意义\n    for (int i = min(p, m + 1); i; i--)\n      for (int j = 1; j <= siz && i + j <= m + 1; j++)\n        f[u][i + j] = max(f[u][i + j], f[u][i] + f[v][j]);  // 转移方程\n    p += siz; //p逐渐增加\n  }\n  return p;\n}\n```\n\n换根dp: 两次dfs， 找到换根前后dp的转移公式\n- 树和图dfs不一样，不需要使用vis,只需要记录一下当前index，和当前index的father就能避免访问同一节点\n\n\n数位dp感觉比较难\n\n不要62\nhttps://blog.csdn.net/Enjoying_Science/article/details/44082929 动态规划\nhttps://www.cnblogs.com/wenruo/p/4725005.html 动态规划，解释有点问题\nhttp://www.calvinneo.com/2017/09/23/HDU2089%E4%B8%8D%E8%A6%8162/ dfs\nhttps://www.programminghunter.com/article/8939658418/ dfs\n\n\n600. 不含连续1的非负整数\n\n\n","source":"_posts/dp问题专栏/DAG+树状+其他dp.md","raw":"---\ntitle: DP问题专栏\ncategories:\n  - dp问题专栏\n---\nDAG上的dp\n\nUVa 437 巴比伦塔 The Tower of Babylon\n\n这道题求最高的塔，其实就是一个记忆化dfs的过程\n一些需要注意的点：\n1. 因为不可能出现一个立方体同时叠两次，因此不需要vis\n2. 因为有三种叠法，所以需要3个方向\n3. 因为最开始让谁做底部是不清楚的，所以使用循环遍历方法\n4. 因为一个底确定之后的最高是确定的，因此使用记忆化搜索，避免重复计算\n5. 对于这种题情况多，再加上dfs的题，先分析一两个小的情况（if-else, 三个方向分情况讨论）， 再暴力（dfs）， 再优化（记忆化数组）\n6. 类似最长路问题\n\n\n树状dp: dfs+dp\n主要是针对图有层级结构（没有上司的舞会），或者选择课程这样的dp, 主要是背包和树状dp结合\n使用dfs+dp\n\n- 一般解题步骤：\n- 先使用dfs记录子节点的状态：dp[i][0]/ dp[i][1]/ dp[i][k]\n- 然后计算当前节点的状态转移 (u是父节点， i是子节点)\n```C++\ndp[u][a+b] = max(dp[u][a+b], dp[u][a]+dp[i][b]) //课程的转移方程\n或者\ndp[u][0] += max(dp[i][0], dp[i][1]); //上司的转移方程\ndp[u][1] += dp[i][0];\n```\n\n- 例题\n洛谷 P2014 CTSC1997 选课 （挺难的）\n- 加入一门课程，森林转为树，求解dp[0][m+1]\n- 我们枚举 u点的每个子结点 ，同时枚举以 i 为根的子树选了几门课程，将子树的结果合并到 u 上。注意这个使用a的取值范围随着访问的子树的数量逐渐增加\n\n```C++\nint dfs(int u) {\n  int p = 1;\n  f[u][1] = s[u];\n  for (auto v : e[u]) {\n    int siz = dfs(v);\n    // 注意下面两重循环的上界和下界\n    // 只考虑已经合并过的子树，以及选的课程数超过 m+1 的状态没有意义\n    for (int i = min(p, m + 1); i; i--)\n      for (int j = 1; j <= siz && i + j <= m + 1; j++)\n        f[u][i + j] = max(f[u][i + j], f[u][i] + f[v][j]);  // 转移方程\n    p += siz; //p逐渐增加\n  }\n  return p;\n}\n```\n\n换根dp: 两次dfs， 找到换根前后dp的转移公式\n- 树和图dfs不一样，不需要使用vis,只需要记录一下当前index，和当前index的father就能避免访问同一节点\n\n\n数位dp感觉比较难\n\n不要62\nhttps://blog.csdn.net/Enjoying_Science/article/details/44082929 动态规划\nhttps://www.cnblogs.com/wenruo/p/4725005.html 动态规划，解释有点问题\nhttp://www.calvinneo.com/2017/09/23/HDU2089%E4%B8%8D%E8%A6%8162/ dfs\nhttps://www.programminghunter.com/article/8939658418/ dfs\n\n\n600. 不含连续1的非负整数\n\n\n","slug":"dp问题专栏/DAG+树状+其他dp","published":1,"date":"2022-04-04T03:54:12.633Z","updated":"2023-07-12T10:34:45.675Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clk5ceinv001ejpjba3xmeusz","content":"<p>DAG上的dp</p>\n<p>UVa 437 巴比伦塔 The Tower of Babylon</p>\n<p>这道题求最高的塔，其实就是一个记忆化dfs的过程<br>一些需要注意的点：</p>\n<ol>\n<li>因为不可能出现一个立方体同时叠两次，因此不需要vis</li>\n<li>因为有三种叠法，所以需要3个方向</li>\n<li>因为最开始让谁做底部是不清楚的，所以使用循环遍历方法</li>\n<li>因为一个底确定之后的最高是确定的，因此使用记忆化搜索，避免重复计算</li>\n<li>对于这种题情况多，再加上dfs的题，先分析一两个小的情况（if-else, 三个方向分情况讨论）， 再暴力（dfs）， 再优化（记忆化数组）</li>\n<li>类似最长路问题</li>\n</ol>\n<p>树状dp: dfs+dp<br>主要是针对图有层级结构（没有上司的舞会），或者选择课程这样的dp, 主要是背包和树状dp结合<br>使用dfs+dp</p>\n<ul>\n<li><p>一般解题步骤：</p>\n</li>\n<li><p>先使用dfs记录子节点的状态：dp[i][0]/ dp[i][1]/ dp[i][k]</p>\n</li>\n<li><p>然后计算当前节点的状态转移 (u是父节点， i是子节点)</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">dp[u][a+b] = <span class=\"hljs-built_in\">max</span>(dp[u][a+b], dp[u][a]+dp[i][b]) <span class=\"hljs-comment\">//课程的转移方程</span><br>或者<br>dp[u][<span class=\"hljs-number\">0</span>] += <span class=\"hljs-built_in\">max</span>(dp[i][<span class=\"hljs-number\">0</span>], dp[i][<span class=\"hljs-number\">1</span>]); <span class=\"hljs-comment\">//上司的转移方程</span><br>dp[u][<span class=\"hljs-number\">1</span>] += dp[i][<span class=\"hljs-number\">0</span>];<br></code></pre></td></tr></table></figure></li>\n<li><p>例题<br>洛谷 P2014 CTSC1997 选课 （挺难的）</p>\n</li>\n<li><p>加入一门课程，森林转为树，求解dp[0][m+1]</p>\n</li>\n<li><p>我们枚举 u点的每个子结点 ，同时枚举以 i 为根的子树选了几门课程，将子树的结果合并到 u 上。注意这个使用a的取值范围随着访问的子树的数量逐渐增加</p>\n</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">dfs</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> u)</span> </span>&#123;<br>  <span class=\"hljs-keyword\">int</span> p = <span class=\"hljs-number\">1</span>;<br>  f[u][<span class=\"hljs-number\">1</span>] = s[u];<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> v : e[u]) &#123;<br>    <span class=\"hljs-keyword\">int</span> siz = <span class=\"hljs-built_in\">dfs</span>(v);<br>    <span class=\"hljs-comment\">// 注意下面两重循环的上界和下界</span><br>    <span class=\"hljs-comment\">// 只考虑已经合并过的子树，以及选的课程数超过 m+1 的状态没有意义</span><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-built_in\">min</span>(p, m + <span class=\"hljs-number\">1</span>); i; i--)<br>      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">1</span>; j &lt;= siz &amp;&amp; i + j &lt;= m + <span class=\"hljs-number\">1</span>; j++)<br>        f[u][i + j] = <span class=\"hljs-built_in\">max</span>(f[u][i + j], f[u][i] + f[v][j]);  <span class=\"hljs-comment\">// 转移方程</span><br>    p += siz; <span class=\"hljs-comment\">//p逐渐增加</span><br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>换根dp: 两次dfs， 找到换根前后dp的转移公式</p>\n<ul>\n<li>树和图dfs不一样，不需要使用vis,只需要记录一下当前index，和当前index的father就能避免访问同一节点</li>\n</ul>\n<p>数位dp感觉比较难</p>\n<p>不要62<br><a href=\"https://blog.csdn.net/Enjoying_Science/article/details/44082929\">https://blog.csdn.net/Enjoying_Science/article/details/44082929</a> 动态规划<br><a href=\"https://www.cnblogs.com/wenruo/p/4725005.html\">https://www.cnblogs.com/wenruo/p/4725005.html</a> 动态规划，解释有点问题<br><a href=\"http://www.calvinneo.com/2017/09/23/HDU2089%E4%B8%8D%E8%A6%8162/\">http://www.calvinneo.com/2017/09/23/HDU2089%E4%B8%8D%E8%A6%8162/</a> dfs<br><a href=\"https://www.programminghunter.com/article/8939658418/\">https://www.programminghunter.com/article/8939658418/</a> dfs</p>\n<ol start=\"600\">\n<li>不含连续1的非负整数</li>\n</ol>\n","site":{"data":{}},"wordcount":1264,"excerpt":"","more":"<p>DAG上的dp</p>\n<p>UVa 437 巴比伦塔 The Tower of Babylon</p>\n<p>这道题求最高的塔，其实就是一个记忆化dfs的过程<br>一些需要注意的点：</p>\n<ol>\n<li>因为不可能出现一个立方体同时叠两次，因此不需要vis</li>\n<li>因为有三种叠法，所以需要3个方向</li>\n<li>因为最开始让谁做底部是不清楚的，所以使用循环遍历方法</li>\n<li>因为一个底确定之后的最高是确定的，因此使用记忆化搜索，避免重复计算</li>\n<li>对于这种题情况多，再加上dfs的题，先分析一两个小的情况（if-else, 三个方向分情况讨论）， 再暴力（dfs）， 再优化（记忆化数组）</li>\n<li>类似最长路问题</li>\n</ol>\n<p>树状dp: dfs+dp<br>主要是针对图有层级结构（没有上司的舞会），或者选择课程这样的dp, 主要是背包和树状dp结合<br>使用dfs+dp</p>\n<ul>\n<li><p>一般解题步骤：</p>\n</li>\n<li><p>先使用dfs记录子节点的状态：dp[i][0]/ dp[i][1]/ dp[i][k]</p>\n</li>\n<li><p>然后计算当前节点的状态转移 (u是父节点， i是子节点)</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">dp[u][a+b] = <span class=\"hljs-built_in\">max</span>(dp[u][a+b], dp[u][a]+dp[i][b]) <span class=\"hljs-comment\">//课程的转移方程</span><br>或者<br>dp[u][<span class=\"hljs-number\">0</span>] += <span class=\"hljs-built_in\">max</span>(dp[i][<span class=\"hljs-number\">0</span>], dp[i][<span class=\"hljs-number\">1</span>]); <span class=\"hljs-comment\">//上司的转移方程</span><br>dp[u][<span class=\"hljs-number\">1</span>] += dp[i][<span class=\"hljs-number\">0</span>];<br></code></pre></td></tr></table></figure></li>\n<li><p>例题<br>洛谷 P2014 CTSC1997 选课 （挺难的）</p>\n</li>\n<li><p>加入一门课程，森林转为树，求解dp[0][m+1]</p>\n</li>\n<li><p>我们枚举 u点的每个子结点 ，同时枚举以 i 为根的子树选了几门课程，将子树的结果合并到 u 上。注意这个使用a的取值范围随着访问的子树的数量逐渐增加</p>\n</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">dfs</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> u)</span> </span>&#123;<br>  <span class=\"hljs-keyword\">int</span> p = <span class=\"hljs-number\">1</span>;<br>  f[u][<span class=\"hljs-number\">1</span>] = s[u];<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> v : e[u]) &#123;<br>    <span class=\"hljs-keyword\">int</span> siz = <span class=\"hljs-built_in\">dfs</span>(v);<br>    <span class=\"hljs-comment\">// 注意下面两重循环的上界和下界</span><br>    <span class=\"hljs-comment\">// 只考虑已经合并过的子树，以及选的课程数超过 m+1 的状态没有意义</span><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-built_in\">min</span>(p, m + <span class=\"hljs-number\">1</span>); i; i--)<br>      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">1</span>; j &lt;= siz &amp;&amp; i + j &lt;= m + <span class=\"hljs-number\">1</span>; j++)<br>        f[u][i + j] = <span class=\"hljs-built_in\">max</span>(f[u][i + j], f[u][i] + f[v][j]);  <span class=\"hljs-comment\">// 转移方程</span><br>    p += siz; <span class=\"hljs-comment\">//p逐渐增加</span><br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>换根dp: 两次dfs， 找到换根前后dp的转移公式</p>\n<ul>\n<li>树和图dfs不一样，不需要使用vis,只需要记录一下当前index，和当前index的father就能避免访问同一节点</li>\n</ul>\n<p>数位dp感觉比较难</p>\n<p>不要62<br><a href=\"https://blog.csdn.net/Enjoying_Science/article/details/44082929\">https://blog.csdn.net/Enjoying_Science/article/details/44082929</a> 动态规划<br><a href=\"https://www.cnblogs.com/wenruo/p/4725005.html\">https://www.cnblogs.com/wenruo/p/4725005.html</a> 动态规划，解释有点问题<br><a href=\"http://www.calvinneo.com/2017/09/23/HDU2089%E4%B8%8D%E8%A6%8162/\">http://www.calvinneo.com/2017/09/23/HDU2089%E4%B8%8D%E8%A6%8162/</a> dfs<br><a href=\"https://www.programminghunter.com/article/8939658418/\">https://www.programminghunter.com/article/8939658418/</a> dfs</p>\n<ol start=\"600\">\n<li>不含连续1的非负整数</li>\n</ol>\n"},{"title":"资源汇总","date":"2021-11-16T07:32:21.000Z","_content":"\n\n[人工智能相关各种任务数据集下载网站](https://www.payititi.com/)\n\n阿里巴巴各部门:https://blog.csdn.net/alitech2017/article/details/105096822\n\n基础设施部门面经\n\n8a100tianshu账号登录方式：\n登录地址(需之江内网orVPN)：https://access.zhejianglab.com  maokuang 密码请咨询毛旷，登录后：运维--主机运维---“登陆”栏目下的地球图\n密码zjlab!@#\n\n\nhttps://github.com/SharingSource/LogicStack-LeetCode/wiki 宫水三叶的刷题笔记\n\n画图工具：\nhttps://draveness.me/sketch-and-sketch/\n\nhugo为后端的博客\n\n做笔记的工具：notion 截图的工具：snipaste\n\n可以将进程放在后台执行的软件 screen或者tmux\n\n浙江大学正版化软件：http://ms-zju-edu-cn.webvpn.zju.edu.cn:8001/help/install","source":"_posts/其他/各类资源.md","raw":"---\ntitle: 资源汇总\ncategories:\n  - 其他\ndate: 2021-11-16 15:32:21\ntags:\n---\n\n\n[人工智能相关各种任务数据集下载网站](https://www.payititi.com/)\n\n阿里巴巴各部门:https://blog.csdn.net/alitech2017/article/details/105096822\n\n基础设施部门面经\n\n8a100tianshu账号登录方式：\n登录地址(需之江内网orVPN)：https://access.zhejianglab.com  maokuang 密码请咨询毛旷，登录后：运维--主机运维---“登陆”栏目下的地球图\n密码zjlab!@#\n\n\nhttps://github.com/SharingSource/LogicStack-LeetCode/wiki 宫水三叶的刷题笔记\n\n画图工具：\nhttps://draveness.me/sketch-and-sketch/\n\nhugo为后端的博客\n\n做笔记的工具：notion 截图的工具：snipaste\n\n可以将进程放在后台执行的软件 screen或者tmux\n\n浙江大学正版化软件：http://ms-zju-edu-cn.webvpn.zju.edu.cn:8001/help/install","slug":"其他/各类资源","published":1,"updated":"2023-07-10T10:36:19.579Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clk5ceinw001gjpjb4c3udy6a","content":"<p><a href=\"https://www.payititi.com/\">人工智能相关各种任务数据集下载网站</a></p>\n<p>阿里巴巴各部门:<a href=\"https://blog.csdn.net/alitech2017/article/details/105096822\">https://blog.csdn.net/alitech2017/article/details/105096822</a></p>\n<p>基础设施部门面经</p>\n<p>8a100tianshu账号登录方式：<br>登录地址(需之江内网orVPN)：<a href=\"https://access.zhejianglab.com/\">https://access.zhejianglab.com</a>  maokuang 密码请咨询毛旷，登录后：运维–主机运维—“登陆”栏目下的地球图<br>密码zjlab!@#</p>\n<p><a href=\"https://github.com/SharingSource/LogicStack-LeetCode/wiki\">https://github.com/SharingSource/LogicStack-LeetCode/wiki</a> 宫水三叶的刷题笔记</p>\n<p>画图工具：<br><a href=\"https://draveness.me/sketch-and-sketch/\">https://draveness.me/sketch-and-sketch/</a></p>\n<p>hugo为后端的博客</p>\n<p>做笔记的工具：notion 截图的工具：snipaste</p>\n<p>可以将进程放在后台执行的软件 screen或者tmux</p>\n<p>浙江大学正版化软件：<a href=\"http://ms-zju-edu-cn.webvpn.zju.edu.cn:8001/help/install\">http://ms-zju-edu-cn.webvpn.zju.edu.cn:8001/help/install</a></p>\n","site":{"data":{}},"wordcount":446,"excerpt":"","more":"<p><a href=\"https://www.payititi.com/\">人工智能相关各种任务数据集下载网站</a></p>\n<p>阿里巴巴各部门:<a href=\"https://blog.csdn.net/alitech2017/article/details/105096822\">https://blog.csdn.net/alitech2017/article/details/105096822</a></p>\n<p>基础设施部门面经</p>\n<p>8a100tianshu账号登录方式：<br>登录地址(需之江内网orVPN)：<a href=\"https://access.zhejianglab.com/\">https://access.zhejianglab.com</a>  maokuang 密码请咨询毛旷，登录后：运维–主机运维—“登陆”栏目下的地球图<br>密码zjlab!@#</p>\n<p><a href=\"https://github.com/SharingSource/LogicStack-LeetCode/wiki\">https://github.com/SharingSource/LogicStack-LeetCode/wiki</a> 宫水三叶的刷题笔记</p>\n<p>画图工具：<br><a href=\"https://draveness.me/sketch-and-sketch/\">https://draveness.me/sketch-and-sketch/</a></p>\n<p>hugo为后端的博客</p>\n<p>做笔记的工具：notion 截图的工具：snipaste</p>\n<p>可以将进程放在后台执行的软件 screen或者tmux</p>\n<p>浙江大学正版化软件：<a href=\"http://ms-zju-edu-cn.webvpn.zju.edu.cn:8001/help/install\">http://ms-zju-edu-cn.webvpn.zju.edu.cn:8001/help/install</a></p>\n"},{"layout":"blog","title":"Linux命令","date":"2021-11-11T01:52:14.000Z","_content":"\n#### rename\n\n批量修改后缀名\n```bash\n\nrename s/\\后缀1/\\后缀/' *\n\nrename s/\\后缀1/\\后缀/' ** //递归所有的子目录\n\nexample: rename 's/\\.tar.gz.1/\\.tar.gz/' *\n```\n\n#### 手动清理缓存\n```bash\n释放缓存区内存的方法\n1）清理pagecache（页面缓存）\n[root@backup ~]# echo 1 > /proc/sys/vm/drop_caches     或者 # sysctl -w vm.drop_caches=1\n \n2）清理dentries（目录缓存）和inodes\n[root@backup ~]# echo 2 > /proc/sys/vm/drop_caches     或者 # sysctl -w vm.drop_caches=2\n \n3）清理pagecache、dentries和inodes\n[root@backup ~]# echo 3 > /proc/sys/vm/drop_caches     或者 # sysctl -w vm.drop_caches=3\n　\n上面三种方式都是临时释放缓存的方法，要想永久释放缓存，需要在/etc/sysctl.conf文件中配置：vm.drop_caches=1/2/3，然后sysctl -p生效即可！\n \n另外，可以使用sync命令来清理文件系统缓存，还会清理僵尸(zombie)对象和它们占用的内存\n[root@backup ~]# sync\n```\n\n#### 服务器之间使用scp进行文件传输和同步\nrsync -r -P --rsh=ssh source_dir dest_dir(shu@10.5.26.19:/nfs/home/shu/hushuang-8a100)","source":"_posts/工具相关/Linux命令.md","raw":"---\nlayout: blog\ntitle: Linux命令\ndate: 2021-11-11 09:52:14\ntags: Linux command\n---\n\n#### rename\n\n批量修改后缀名\n```bash\n\nrename s/\\后缀1/\\后缀/' *\n\nrename s/\\后缀1/\\后缀/' ** //递归所有的子目录\n\nexample: rename 's/\\.tar.gz.1/\\.tar.gz/' *\n```\n\n#### 手动清理缓存\n```bash\n释放缓存区内存的方法\n1）清理pagecache（页面缓存）\n[root@backup ~]# echo 1 > /proc/sys/vm/drop_caches     或者 # sysctl -w vm.drop_caches=1\n \n2）清理dentries（目录缓存）和inodes\n[root@backup ~]# echo 2 > /proc/sys/vm/drop_caches     或者 # sysctl -w vm.drop_caches=2\n \n3）清理pagecache、dentries和inodes\n[root@backup ~]# echo 3 > /proc/sys/vm/drop_caches     或者 # sysctl -w vm.drop_caches=3\n　\n上面三种方式都是临时释放缓存的方法，要想永久释放缓存，需要在/etc/sysctl.conf文件中配置：vm.drop_caches=1/2/3，然后sysctl -p生效即可！\n \n另外，可以使用sync命令来清理文件系统缓存，还会清理僵尸(zombie)对象和它们占用的内存\n[root@backup ~]# sync\n```\n\n#### 服务器之间使用scp进行文件传输和同步\nrsync -r -P --rsh=ssh source_dir dest_dir(shu@10.5.26.19:/nfs/home/shu/hushuang-8a100)","slug":"工具相关/Linux命令","published":1,"updated":"2023-07-10T10:36:19.581Z","comments":1,"photos":[],"link":"","_id":"clk5ceinx001jjpjb4bpf4bc1","content":"<h4 id=\"rename\"><a href=\"#rename\" class=\"headerlink\" title=\"rename\"></a>rename</h4><p>批量修改后缀名</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><br>rename s/\\后缀1/\\后缀/<span class=\"hljs-string\">&#x27; *</span><br><span class=\"hljs-string\"></span><br><span class=\"hljs-string\">rename s/\\后缀1/\\后缀/&#x27;</span> ** //递归所有的子目录<br><br>example: rename <span class=\"hljs-string\">&#x27;s/\\.tar.gz.1/\\.tar.gz/&#x27;</span> *<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"手动清理缓存\"><a href=\"#手动清理缓存\" class=\"headerlink\" title=\"手动清理缓存\"></a>手动清理缓存</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">释放缓存区内存的方法<br>1）清理pagecache（页面缓存）<br>[root@backup ~]<span class=\"hljs-comment\"># echo 1 &gt; /proc/sys/vm/drop_caches     或者 # sysctl -w vm.drop_caches=1</span><br> <br>2）清理dentries（目录缓存）和inodes<br>[root@backup ~]<span class=\"hljs-comment\"># echo 2 &gt; /proc/sys/vm/drop_caches     或者 # sysctl -w vm.drop_caches=2</span><br> <br>3）清理pagecache、dentries和inodes<br>[root@backup ~]<span class=\"hljs-comment\"># echo 3 &gt; /proc/sys/vm/drop_caches     或者 # sysctl -w vm.drop_caches=3</span><br>　<br>上面三种方式都是临时释放缓存的方法，要想永久释放缓存，需要在/etc/sysctl.conf文件中配置：vm.drop_caches=1/2/3，然后sysctl -p生效即可！<br> <br>另外，可以使用sync命令来清理文件系统缓存，还会清理僵尸(zombie)对象和它们占用的内存<br>[root@backup ~]<span class=\"hljs-comment\"># sync</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"服务器之间使用scp进行文件传输和同步\"><a href=\"#服务器之间使用scp进行文件传输和同步\" class=\"headerlink\" title=\"服务器之间使用scp进行文件传输和同步\"></a>服务器之间使用scp进行文件传输和同步</h4><p>rsync -r -P –rsh=ssh source_dir dest_dir(<a href=\"mailto:&#115;&#x68;&#117;&#x40;&#49;&#x30;&#46;&#53;&#46;&#50;&#x36;&#x2e;&#x31;&#57;\">&#115;&#x68;&#117;&#x40;&#49;&#x30;&#46;&#53;&#46;&#50;&#x36;&#x2e;&#x31;&#57;</a>:/nfs/home/shu/hushuang-8a100)</p>\n","site":{"data":{}},"wordcount":777,"excerpt":"","more":"<h4 id=\"rename\"><a href=\"#rename\" class=\"headerlink\" title=\"rename\"></a>rename</h4><p>批量修改后缀名</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><br>rename s/\\后缀1/\\后缀/<span class=\"hljs-string\">&#x27; *</span><br><span class=\"hljs-string\"></span><br><span class=\"hljs-string\">rename s/\\后缀1/\\后缀/&#x27;</span> ** //递归所有的子目录<br><br>example: rename <span class=\"hljs-string\">&#x27;s/\\.tar.gz.1/\\.tar.gz/&#x27;</span> *<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"手动清理缓存\"><a href=\"#手动清理缓存\" class=\"headerlink\" title=\"手动清理缓存\"></a>手动清理缓存</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">释放缓存区内存的方法<br>1）清理pagecache（页面缓存）<br>[root@backup ~]<span class=\"hljs-comment\"># echo 1 &gt; /proc/sys/vm/drop_caches     或者 # sysctl -w vm.drop_caches=1</span><br> <br>2）清理dentries（目录缓存）和inodes<br>[root@backup ~]<span class=\"hljs-comment\"># echo 2 &gt; /proc/sys/vm/drop_caches     或者 # sysctl -w vm.drop_caches=2</span><br> <br>3）清理pagecache、dentries和inodes<br>[root@backup ~]<span class=\"hljs-comment\"># echo 3 &gt; /proc/sys/vm/drop_caches     或者 # sysctl -w vm.drop_caches=3</span><br>　<br>上面三种方式都是临时释放缓存的方法，要想永久释放缓存，需要在/etc/sysctl.conf文件中配置：vm.drop_caches=1/2/3，然后sysctl -p生效即可！<br> <br>另外，可以使用sync命令来清理文件系统缓存，还会清理僵尸(zombie)对象和它们占用的内存<br>[root@backup ~]<span class=\"hljs-comment\"># sync</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"服务器之间使用scp进行文件传输和同步\"><a href=\"#服务器之间使用scp进行文件传输和同步\" class=\"headerlink\" title=\"服务器之间使用scp进行文件传输和同步\"></a>服务器之间使用scp进行文件传输和同步</h4><p>rsync -r -P –rsh=ssh source_dir dest_dir(<a href=\"mailto:&#115;&#x68;&#117;&#x40;&#49;&#x30;&#46;&#53;&#46;&#50;&#x36;&#x2e;&#x31;&#57;\">&#115;&#x68;&#117;&#x40;&#49;&#x30;&#46;&#53;&#46;&#50;&#x36;&#x2e;&#x31;&#57;</a>:/nfs/home/shu/hushuang-8a100)</p>\n"},{"title":"Anaconda环境搭建","date":"2021-12-15T06:48:24.000Z","_content":"\n### 问题描述\n一个服务器上已经搭建好的环境，但是需要换另一台机器，或者另外的用户需要访问这个环境， 如果另一台服务器上没有anaconda环境就需要从0开始进行搭建，然后再进行环境的迁移\n\n### 解决方案\n\n1. 安装anaconda3\n```\n wget https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda3-5.3.1-Linux-x86_64.sh\n bash Anaconda3-5.3.1-Linux-x86_64.sh\n```\n\n一般情况下安装是默认设置，在安装vscode的时候可以根据需要选择no或者yes\n注意在安装installer的时候需要选择yes, 如果选择了no\n那么可以自行添加环境:\nhttps://zhuanlan.zhihu.com/p/64930395（也就是激活环境中的方法二）\n\n\n2. 激活环境\n```\n# 方法一失效\n输入命令打开配置文件：vim ~/.bashrc\n在最后添加语句：export PATH=/root/xxx/anaconda3/bin:$PATH （/root/xxx 为安装路径）\n最后输入如下命令，更新配置文件即可：source ~/.bashrc\n\n#方法二有效：\n如果conda的初始化时选择了no，则需要自行配置环境变量。\n\n打开profile文件：\n\nvi /etc/profile\n在文件最后加入如下语句（路径需要根据自己的安装位置更改）：\n\nPATH=$PATH:/opt/anaconda3/bin\nexport PATH\n保存文件并退出。最后使用如下命令刷新环境变量即可：\n\nsource /etc/profile\necho $PATH\n```\n\nPS: 如果conda名称弹出问题，使用```sudo vi ~/.bashrc```查看conda路径是否正确\n\n3. conda相关命令\n```\nconda list 查看安装包\nconda info --envs 查看环境\nconda activate XXX 激活环境 （XXX 为环境名称）\npython -V 检查Python版本\n\n如果需要卸载anaconda的话，只需要删除anaconda目录即可:\nrm -rf /root/xxx/anaconda3\n```\n4. 使用conda-pack迁移环境\n\n在源机器：\n```\nconda pack -n env-name --ignore-editable-packages（如果没有后面这个会报错）\n得到一个env_name.tar.gz压缩文件\n```\n\n在目标机器：\n```\ncd ~/anaconda3/envs;\nmkdir env_name\ntar -xzvf env_name.tar.gz -C /home/root_name/anaconda3/envs/env_name\n```\n\n\n5. 使用环境\n```source activate attnGAN```\n\n注意使用conda activate会报错\n目前找到一个解决方案：\nhttps://blog.csdn.net/qq_43828332/article/details/114235922\n\n\n总共耗时 1个半小时左右~\n\n\n#### 参考链接：\n1. https://blog.csdn.net/lwgkzl/article/details/89329383\n2. https://www.jianshu.com/p/1fddd11bcd25\n3. https://blog.csdn.net/ds1302__/article/details/120027173\n\n\n\n注意之江实验室hec anaconda3的安装路径是：/nfs/home \n\n\n#### 相关问题\n在终端输入conda info --envs检验anaconda是否安装成功，发现报错：conda: command not found\n\n原因是因为~/.bashrc文件没有配置好\n\n解决方案：\nsudo vim ~/.bashrc\n在最后一行加上\nexport PATH=$PATH:/home/vincent/anaconda3/bin\n\n","source":"_posts/工具相关/anaconda环境搭建从零到一.md","raw":"---\ntitle: Anaconda环境搭建\ntags: conda environment\ncategories:\n  - 工具相关\ndate: 2021-12-15 14:48:24\n---\n\n### 问题描述\n一个服务器上已经搭建好的环境，但是需要换另一台机器，或者另外的用户需要访问这个环境， 如果另一台服务器上没有anaconda环境就需要从0开始进行搭建，然后再进行环境的迁移\n\n### 解决方案\n\n1. 安装anaconda3\n```\n wget https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda3-5.3.1-Linux-x86_64.sh\n bash Anaconda3-5.3.1-Linux-x86_64.sh\n```\n\n一般情况下安装是默认设置，在安装vscode的时候可以根据需要选择no或者yes\n注意在安装installer的时候需要选择yes, 如果选择了no\n那么可以自行添加环境:\nhttps://zhuanlan.zhihu.com/p/64930395（也就是激活环境中的方法二）\n\n\n2. 激活环境\n```\n# 方法一失效\n输入命令打开配置文件：vim ~/.bashrc\n在最后添加语句：export PATH=/root/xxx/anaconda3/bin:$PATH （/root/xxx 为安装路径）\n最后输入如下命令，更新配置文件即可：source ~/.bashrc\n\n#方法二有效：\n如果conda的初始化时选择了no，则需要自行配置环境变量。\n\n打开profile文件：\n\nvi /etc/profile\n在文件最后加入如下语句（路径需要根据自己的安装位置更改）：\n\nPATH=$PATH:/opt/anaconda3/bin\nexport PATH\n保存文件并退出。最后使用如下命令刷新环境变量即可：\n\nsource /etc/profile\necho $PATH\n```\n\nPS: 如果conda名称弹出问题，使用```sudo vi ~/.bashrc```查看conda路径是否正确\n\n3. conda相关命令\n```\nconda list 查看安装包\nconda info --envs 查看环境\nconda activate XXX 激活环境 （XXX 为环境名称）\npython -V 检查Python版本\n\n如果需要卸载anaconda的话，只需要删除anaconda目录即可:\nrm -rf /root/xxx/anaconda3\n```\n4. 使用conda-pack迁移环境\n\n在源机器：\n```\nconda pack -n env-name --ignore-editable-packages（如果没有后面这个会报错）\n得到一个env_name.tar.gz压缩文件\n```\n\n在目标机器：\n```\ncd ~/anaconda3/envs;\nmkdir env_name\ntar -xzvf env_name.tar.gz -C /home/root_name/anaconda3/envs/env_name\n```\n\n\n5. 使用环境\n```source activate attnGAN```\n\n注意使用conda activate会报错\n目前找到一个解决方案：\nhttps://blog.csdn.net/qq_43828332/article/details/114235922\n\n\n总共耗时 1个半小时左右~\n\n\n#### 参考链接：\n1. https://blog.csdn.net/lwgkzl/article/details/89329383\n2. https://www.jianshu.com/p/1fddd11bcd25\n3. https://blog.csdn.net/ds1302__/article/details/120027173\n\n\n\n注意之江实验室hec anaconda3的安装路径是：/nfs/home \n\n\n#### 相关问题\n在终端输入conda info --envs检验anaconda是否安装成功，发现报错：conda: command not found\n\n原因是因为~/.bashrc文件没有配置好\n\n解决方案：\nsudo vim ~/.bashrc\n在最后一行加上\nexport PATH=$PATH:/home/vincent/anaconda3/bin\n\n","slug":"工具相关/anaconda环境搭建从零到一","published":1,"updated":"2022-02-14T10:03:35.528Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clk5ceinx001mjpjbb2hhbldh","content":"<h3 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h3><p>一个服务器上已经搭建好的环境，但是需要换另一台机器，或者另外的用户需要访问这个环境， 如果另一台服务器上没有anaconda环境就需要从0开始进行搭建，然后再进行环境的迁移</p>\n<h3 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><ol>\n<li>安装anaconda3<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">wget</span> https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda<span class=\"hljs-number\">3</span>-<span class=\"hljs-number\">5</span>.<span class=\"hljs-number\">3</span>.<span class=\"hljs-number\">1</span>-Linux-x<span class=\"hljs-number\">86</span>_<span class=\"hljs-number\">64</span>.sh<br><span class=\"hljs-attribute\">bash</span> Anaconda<span class=\"hljs-number\">3</span>-<span class=\"hljs-number\">5</span>.<span class=\"hljs-number\">3</span>.<span class=\"hljs-number\">1</span>-Linux-x<span class=\"hljs-number\">86</span>_<span class=\"hljs-number\">64</span>.sh<br></code></pre></td></tr></table></figure></li>\n</ol>\n<p>一般情况下安装是默认设置，在安装vscode的时候可以根据需要选择no或者yes<br>注意在安装installer的时候需要选择yes, 如果选择了no<br>那么可以自行添加环境:<br><a href=\"https://zhuanlan.zhihu.com/p/64930395%EF%BC%88%E4%B9%9F%E5%B0%B1%E6%98%AF%E6%BF%80%E6%B4%BB%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%89\">https://zhuanlan.zhihu.com/p/64930395（也就是激活环境中的方法二）</a></p>\n<ol start=\"2\">\n<li>激活环境<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\"><span class=\"hljs-comment\"># 方法一失效</span><br>输入命令打开配置文件：vim ~/.bashrc<br>在最后添加语句：export PATH=<span class=\"hljs-regexp\">/root/</span>xxx<span class=\"hljs-regexp\">/anaconda3/</span>bin:<span class=\"hljs-variable\">$PATH</span> （<span class=\"hljs-regexp\">/root/</span>xxx 为安装路径）<br>最后输入如下命令，更新配置文件即可：source ~/.bashrc<br><br><span class=\"hljs-comment\">#方法二有效：</span><br>如果conda的初始化时选择了no，则需要自行配置环境变量。<br><br>打开profile文件：<br><br>vi <span class=\"hljs-regexp\">/etc/</span>profile<br>在文件最后加入如下语句（路径需要根据自己的安装位置更改）：<br><br>PATH=<span class=\"hljs-variable\">$PATH</span>:<span class=\"hljs-regexp\">/opt/</span>anaconda3/bin<br>export PATH<br>保存文件并退出。最后使用如下命令刷新环境变量即可：<br><br>source <span class=\"hljs-regexp\">/etc/</span>profile<br>echo <span class=\"hljs-variable\">$PATH</span><br></code></pre></td></tr></table></figure></li>\n</ol>\n<p>PS: 如果conda名称弹出问题，使用<code>sudo vi ~/.bashrc</code>查看conda路径是否正确</p>\n<ol start=\"3\">\n<li>conda相关命令<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs applescript\">conda <span class=\"hljs-built_in\">list</span> 查看安装包<br>conda info <span class=\"hljs-comment\">--envs 查看环境</span><br>conda <span class=\"hljs-built_in\">activate</span> XXX 激活环境 （XXX 为环境名称）<br>python -V 检查Python版本<br><br>如果需要卸载anaconda的话，只需要删除anaconda目录即可:<br>rm -rf /root/xxx/anaconda3<br></code></pre></td></tr></table></figure></li>\n<li>使用conda-pack迁移环境</li>\n</ol>\n<p>在源机器：</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs applescript\">conda pack -n env-<span class=\"hljs-built_in\">name</span> <span class=\"hljs-comment\">--ignore-editable-packages（如果没有后面这个会报错）</span><br>得到一个env_name.tar.gz压缩文件<br></code></pre></td></tr></table></figure>\n\n<p>在目标机器：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">cd ~<span class=\"hljs-regexp\">/anaconda3/</span>envs;<br>mkdir env_name<br>tar -xzvf env_name.tar.gz -C <span class=\"hljs-regexp\">/home/</span>root_name<span class=\"hljs-regexp\">/anaconda3/</span>envs/env_name<br></code></pre></td></tr></table></figure>\n\n\n<ol start=\"5\">\n<li>使用环境<br><code>source activate attnGAN</code></li>\n</ol>\n<p>注意使用conda activate会报错<br>目前找到一个解决方案：<br><a href=\"https://blog.csdn.net/qq_43828332/article/details/114235922\">https://blog.csdn.net/qq_43828332/article/details/114235922</a></p>\n<p>总共耗时 1个半小时左右~</p>\n<h4 id=\"参考链接：\"><a href=\"#参考链接：\" class=\"headerlink\" title=\"参考链接：\"></a>参考链接：</h4><ol>\n<li><a href=\"https://blog.csdn.net/lwgkzl/article/details/89329383\">https://blog.csdn.net/lwgkzl/article/details/89329383</a></li>\n<li><a href=\"https://www.jianshu.com/p/1fddd11bcd25\">https://www.jianshu.com/p/1fddd11bcd25</a></li>\n<li><a href=\"https://blog.csdn.net/ds1302__/article/details/120027173\">https://blog.csdn.net/ds1302__/article/details/120027173</a></li>\n</ol>\n<p>注意之江实验室hec anaconda3的安装路径是：/nfs/home </p>\n<h4 id=\"相关问题\"><a href=\"#相关问题\" class=\"headerlink\" title=\"相关问题\"></a>相关问题</h4><p>在终端输入conda info –envs检验anaconda是否安装成功，发现报错：conda: command not found</p>\n<p>原因是因为~/.bashrc文件没有配置好</p>\n<p>解决方案：<br>sudo vim ~/.bashrc<br>在最后一行加上<br>export PATH=$PATH:/home/vincent/anaconda3/bin</p>\n","site":{"data":{}},"wordcount":1591,"excerpt":"","more":"<h3 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h3><p>一个服务器上已经搭建好的环境，但是需要换另一台机器，或者另外的用户需要访问这个环境， 如果另一台服务器上没有anaconda环境就需要从0开始进行搭建，然后再进行环境的迁移</p>\n<h3 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><ol>\n<li>安装anaconda3<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">wget</span> https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda<span class=\"hljs-number\">3</span>-<span class=\"hljs-number\">5</span>.<span class=\"hljs-number\">3</span>.<span class=\"hljs-number\">1</span>-Linux-x<span class=\"hljs-number\">86</span>_<span class=\"hljs-number\">64</span>.sh<br><span class=\"hljs-attribute\">bash</span> Anaconda<span class=\"hljs-number\">3</span>-<span class=\"hljs-number\">5</span>.<span class=\"hljs-number\">3</span>.<span class=\"hljs-number\">1</span>-Linux-x<span class=\"hljs-number\">86</span>_<span class=\"hljs-number\">64</span>.sh<br></code></pre></td></tr></table></figure></li>\n</ol>\n<p>一般情况下安装是默认设置，在安装vscode的时候可以根据需要选择no或者yes<br>注意在安装installer的时候需要选择yes, 如果选择了no<br>那么可以自行添加环境:<br><a href=\"https://zhuanlan.zhihu.com/p/64930395%EF%BC%88%E4%B9%9F%E5%B0%B1%E6%98%AF%E6%BF%80%E6%B4%BB%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%89\">https://zhuanlan.zhihu.com/p/64930395（也就是激活环境中的方法二）</a></p>\n<ol start=\"2\">\n<li>激活环境<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\"><span class=\"hljs-comment\"># 方法一失效</span><br>输入命令打开配置文件：vim ~/.bashrc<br>在最后添加语句：export PATH=<span class=\"hljs-regexp\">/root/</span>xxx<span class=\"hljs-regexp\">/anaconda3/</span>bin:<span class=\"hljs-variable\">$PATH</span> （<span class=\"hljs-regexp\">/root/</span>xxx 为安装路径）<br>最后输入如下命令，更新配置文件即可：source ~/.bashrc<br><br><span class=\"hljs-comment\">#方法二有效：</span><br>如果conda的初始化时选择了no，则需要自行配置环境变量。<br><br>打开profile文件：<br><br>vi <span class=\"hljs-regexp\">/etc/</span>profile<br>在文件最后加入如下语句（路径需要根据自己的安装位置更改）：<br><br>PATH=<span class=\"hljs-variable\">$PATH</span>:<span class=\"hljs-regexp\">/opt/</span>anaconda3/bin<br>export PATH<br>保存文件并退出。最后使用如下命令刷新环境变量即可：<br><br>source <span class=\"hljs-regexp\">/etc/</span>profile<br>echo <span class=\"hljs-variable\">$PATH</span><br></code></pre></td></tr></table></figure></li>\n</ol>\n<p>PS: 如果conda名称弹出问题，使用<code>sudo vi ~/.bashrc</code>查看conda路径是否正确</p>\n<ol start=\"3\">\n<li>conda相关命令<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs applescript\">conda <span class=\"hljs-built_in\">list</span> 查看安装包<br>conda info <span class=\"hljs-comment\">--envs 查看环境</span><br>conda <span class=\"hljs-built_in\">activate</span> XXX 激活环境 （XXX 为环境名称）<br>python -V 检查Python版本<br><br>如果需要卸载anaconda的话，只需要删除anaconda目录即可:<br>rm -rf /root/xxx/anaconda3<br></code></pre></td></tr></table></figure></li>\n<li>使用conda-pack迁移环境</li>\n</ol>\n<p>在源机器：</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs applescript\">conda pack -n env-<span class=\"hljs-built_in\">name</span> <span class=\"hljs-comment\">--ignore-editable-packages（如果没有后面这个会报错）</span><br>得到一个env_name.tar.gz压缩文件<br></code></pre></td></tr></table></figure>\n\n<p>在目标机器：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">cd ~<span class=\"hljs-regexp\">/anaconda3/</span>envs;<br>mkdir env_name<br>tar -xzvf env_name.tar.gz -C <span class=\"hljs-regexp\">/home/</span>root_name<span class=\"hljs-regexp\">/anaconda3/</span>envs/env_name<br></code></pre></td></tr></table></figure>\n\n\n<ol start=\"5\">\n<li>使用环境<br><code>source activate attnGAN</code></li>\n</ol>\n<p>注意使用conda activate会报错<br>目前找到一个解决方案：<br><a href=\"https://blog.csdn.net/qq_43828332/article/details/114235922\">https://blog.csdn.net/qq_43828332/article/details/114235922</a></p>\n<p>总共耗时 1个半小时左右~</p>\n<h4 id=\"参考链接：\"><a href=\"#参考链接：\" class=\"headerlink\" title=\"参考链接：\"></a>参考链接：</h4><ol>\n<li><a href=\"https://blog.csdn.net/lwgkzl/article/details/89329383\">https://blog.csdn.net/lwgkzl/article/details/89329383</a></li>\n<li><a href=\"https://www.jianshu.com/p/1fddd11bcd25\">https://www.jianshu.com/p/1fddd11bcd25</a></li>\n<li><a href=\"https://blog.csdn.net/ds1302__/article/details/120027173\">https://blog.csdn.net/ds1302__/article/details/120027173</a></li>\n</ol>\n<p>注意之江实验室hec anaconda3的安装路径是：/nfs/home </p>\n<h4 id=\"相关问题\"><a href=\"#相关问题\" class=\"headerlink\" title=\"相关问题\"></a>相关问题</h4><p>在终端输入conda info –envs检验anaconda是否安装成功，发现报错：conda: command not found</p>\n<p>原因是因为~/.bashrc文件没有配置好</p>\n<p>解决方案：<br>sudo vim ~/.bashrc<br>在最后一行加上<br>export PATH=$PATH:/home/vincent/anaconda3/bin</p>\n"},{"title":"command-related","date":"2021-11-08T13:37:17.000Z","_content":"\n#### 1.让远程服务器节点使用本地节点的vpn进行翻墙， 适用于远程节点\n\n方法一：\n假设，服务器上你选择使用端口18860，先在你的mac上运行命令：ssh -C  -N -g -R 18860:127.0.0.1:7890 服务器用户名@服务器ip  然后在服务器运行：export https_proxy=http://127.0.0.1:18860 那么当服务器使用Https去下载东西的时候，就会通过端口18860把下载请求转发到你mac的7890端口，然后你的Mac作为一个代理进行下载，服务器就能获取目的网址的内容了。当你下载完的时候，记得unset https_proxy\n``` bash\nssh -C  -N -g -R 18861:127.0.0.1:7890 zhinengjisuan@10.5.30.42 -o ProxyCommand=\"ssh shu@10.5.26.19 -W %h:%p\"\nshu@10.5.26.19's password: \n```\n\n方法二: 使用terminus节点，建立一个新的连接，配置如下\n![image-20211207175530810](command-related/image-20211207175530810.png)\n这个节点相当于加了方法一的命令 ```ssh -C  -N -g -R 18860:127.0.0.1:7890 服务器用户名@服务器ip```\n\n然后运行一下proxy脚本,相当于方法一的第二条命令，具体的脚本内容如下:意思是bash一停（exit）, 这两条命令的效用就停止了\n```bash\n#!/bin/bash\nexport http_proxy=http://127.0.0.1:18880\nexport https_proxy=https://127.0.0.1:18880\nbash\n```\n\nPS: 18860是随机选的端口， 7890的clashx的代理端口\n只能使用curl, 不能使用ping 因为ping是在TCP协议之上的，但是curl是http协议（具体见操作系统）\n#### 2. 查看端口号被哪个进程占用\n```bash\nsudo lsof -i :7891\n```\n\n3. conda安装torch 1.8.0版本\n\n```conda install pytorch==1.8.0 torchvision==0.9.0 torchaudio==0.8.0 cudatoolkit=10.2 -c pytorch```\n\npip install torch==1.8.0+cu101 torchvision==0.9.0+cu101 torchaudio==0.8.0 -f https://download.pytorch.org/whl/torch_stable.html\n\n//1.8.0 如果运行起来还是非常慢的话，修改为1.7 因为1.8.1稳定版本需要gpu驱动大于hec01 440.33\npip install torch==1.7.1+cu101 torchvision==0.8.2+cu101 torchaudio==0.7.2 -f https://download.pytorch.org/whl/torch_stable.html -i https://pypi.douban.com/simple some-package\n\n4. 查看并杀死vscode 进程 macos\n```pgrep -f \"vscode\" | xargs kill``` 或者 ```pgrep -f \"vscode\"``` 查看进程号之后使用 ```kill -9 pid```","source":"_posts/工具相关/command-related.md","raw":"---\ntitle: command-related\ncategories:\n  - 工具相关\ndate: 2021-11-08 21:37:17\ntags:\n---\n\n#### 1.让远程服务器节点使用本地节点的vpn进行翻墙， 适用于远程节点\n\n方法一：\n假设，服务器上你选择使用端口18860，先在你的mac上运行命令：ssh -C  -N -g -R 18860:127.0.0.1:7890 服务器用户名@服务器ip  然后在服务器运行：export https_proxy=http://127.0.0.1:18860 那么当服务器使用Https去下载东西的时候，就会通过端口18860把下载请求转发到你mac的7890端口，然后你的Mac作为一个代理进行下载，服务器就能获取目的网址的内容了。当你下载完的时候，记得unset https_proxy\n``` bash\nssh -C  -N -g -R 18861:127.0.0.1:7890 zhinengjisuan@10.5.30.42 -o ProxyCommand=\"ssh shu@10.5.26.19 -W %h:%p\"\nshu@10.5.26.19's password: \n```\n\n方法二: 使用terminus节点，建立一个新的连接，配置如下\n![image-20211207175530810](command-related/image-20211207175530810.png)\n这个节点相当于加了方法一的命令 ```ssh -C  -N -g -R 18860:127.0.0.1:7890 服务器用户名@服务器ip```\n\n然后运行一下proxy脚本,相当于方法一的第二条命令，具体的脚本内容如下:意思是bash一停（exit）, 这两条命令的效用就停止了\n```bash\n#!/bin/bash\nexport http_proxy=http://127.0.0.1:18880\nexport https_proxy=https://127.0.0.1:18880\nbash\n```\n\nPS: 18860是随机选的端口， 7890的clashx的代理端口\n只能使用curl, 不能使用ping 因为ping是在TCP协议之上的，但是curl是http协议（具体见操作系统）\n#### 2. 查看端口号被哪个进程占用\n```bash\nsudo lsof -i :7891\n```\n\n3. conda安装torch 1.8.0版本\n\n```conda install pytorch==1.8.0 torchvision==0.9.0 torchaudio==0.8.0 cudatoolkit=10.2 -c pytorch```\n\npip install torch==1.8.0+cu101 torchvision==0.9.0+cu101 torchaudio==0.8.0 -f https://download.pytorch.org/whl/torch_stable.html\n\n//1.8.0 如果运行起来还是非常慢的话，修改为1.7 因为1.8.1稳定版本需要gpu驱动大于hec01 440.33\npip install torch==1.7.1+cu101 torchvision==0.8.2+cu101 torchaudio==0.7.2 -f https://download.pytorch.org/whl/torch_stable.html -i https://pypi.douban.com/simple some-package\n\n4. 查看并杀死vscode 进程 macos\n```pgrep -f \"vscode\" | xargs kill``` 或者 ```pgrep -f \"vscode\"``` 查看进程号之后使用 ```kill -9 pid```","slug":"工具相关/command-related","published":1,"updated":"2023-07-10T10:36:19.581Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clk5ceio0001pjpjb0harfmlx","content":"<h4 id=\"1-让远程服务器节点使用本地节点的vpn进行翻墙，-适用于远程节点\"><a href=\"#1-让远程服务器节点使用本地节点的vpn进行翻墙，-适用于远程节点\" class=\"headerlink\" title=\"1.让远程服务器节点使用本地节点的vpn进行翻墙， 适用于远程节点\"></a>1.让远程服务器节点使用本地节点的vpn进行翻墙， 适用于远程节点</h4><p>方法一：<br>假设，服务器上你选择使用端口18860，先在你的mac上运行命令：ssh -C  -N -g -R 18860:127.0.0.1:7890 服务器用户名@服务器ip  然后在服务器运行：export https_proxy=<a href=\"http://127.0.0.1:18860/\">http://127.0.0.1:18860</a> 那么当服务器使用Https去下载东西的时候，就会通过端口18860把下载请求转发到你mac的7890端口，然后你的Mac作为一个代理进行下载，服务器就能获取目的网址的内容了。当你下载完的时候，记得unset https_proxy</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">ssh -C  -N -g -R 18861:127.0.0.1:7890 zhinengjisuan@10.5.30.42 -o ProxyCommand=<span class=\"hljs-string\">&quot;ssh shu@10.5.26.19 -W %h:%p&quot;</span><br>shu@10.5.26.19<span class=\"hljs-string\">&#x27;s password: </span><br></code></pre></td></tr></table></figure>\n\n<p>方法二: 使用terminus节点，建立一个新的连接，配置如下<br><img src=\"/.com//image-20211207175530810.png\" alt=\"image-20211207175530810\"><br>这个节点相当于加了方法一的命令 <code>ssh -C  -N -g -R 18860:127.0.0.1:7890 服务器用户名@服务器ip</code></p>\n<p>然后运行一下proxy脚本,相当于方法一的第二条命令，具体的脚本内容如下:意思是bash一停（exit）, 这两条命令的效用就停止了</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-meta\">#!/bin/bash</span><br><span class=\"hljs-built_in\">export</span> http_proxy=http://127.0.0.1:18880<br><span class=\"hljs-built_in\">export</span> https_proxy=https://127.0.0.1:18880<br>bash<br></code></pre></td></tr></table></figure>\n\n<p>PS: 18860是随机选的端口， 7890的clashx的代理端口<br>只能使用curl, 不能使用ping 因为ping是在TCP协议之上的，但是curl是http协议（具体见操作系统）</p>\n<h4 id=\"2-查看端口号被哪个进程占用\"><a href=\"#2-查看端口号被哪个进程占用\" class=\"headerlink\" title=\"2. 查看端口号被哪个进程占用\"></a>2. 查看端口号被哪个进程占用</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">sudo lsof -i :7891<br></code></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>conda安装torch 1.8.0版本</li>\n</ol>\n<p><code>conda install pytorch==1.8.0 torchvision==0.9.0 torchaudio==0.8.0 cudatoolkit=10.2 -c pytorch</code></p>\n<p>pip install torch==1.8.0+cu101 torchvision==0.9.0+cu101 torchaudio==0.8.0 -f <a href=\"https://download.pytorch.org/whl/torch_stable.html\">https://download.pytorch.org/whl/torch_stable.html</a></p>\n<p>//1.8.0 如果运行起来还是非常慢的话，修改为1.7 因为1.8.1稳定版本需要gpu驱动大于hec01 440.33<br>pip install torch==1.7.1+cu101 torchvision==0.8.2+cu101 torchaudio==0.7.2 -f <a href=\"https://download.pytorch.org/whl/torch_stable.html\">https://download.pytorch.org/whl/torch_stable.html</a> -i <a href=\"https://pypi.douban.com/simple\">https://pypi.douban.com/simple</a> some-package</p>\n<ol start=\"4\">\n<li>查看并杀死vscode 进程 macos<br><code>pgrep -f &quot;vscode&quot; | xargs kill</code> 或者 <code>pgrep -f &quot;vscode&quot;</code> 查看进程号之后使用 <code>kill -9 pid</code></li>\n</ol>\n","site":{"data":{}},"wordcount":1330,"excerpt":"","more":"<h4 id=\"1-让远程服务器节点使用本地节点的vpn进行翻墙，-适用于远程节点\"><a href=\"#1-让远程服务器节点使用本地节点的vpn进行翻墙，-适用于远程节点\" class=\"headerlink\" title=\"1.让远程服务器节点使用本地节点的vpn进行翻墙， 适用于远程节点\"></a>1.让远程服务器节点使用本地节点的vpn进行翻墙， 适用于远程节点</h4><p>方法一：<br>假设，服务器上你选择使用端口18860，先在你的mac上运行命令：ssh -C  -N -g -R 18860:127.0.0.1:7890 服务器用户名@服务器ip  然后在服务器运行：export https_proxy=<a href=\"http://127.0.0.1:18860/\">http://127.0.0.1:18860</a> 那么当服务器使用Https去下载东西的时候，就会通过端口18860把下载请求转发到你mac的7890端口，然后你的Mac作为一个代理进行下载，服务器就能获取目的网址的内容了。当你下载完的时候，记得unset https_proxy</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">ssh -C  -N -g -R 18861:127.0.0.1:7890 zhinengjisuan@10.5.30.42 -o ProxyCommand=<span class=\"hljs-string\">&quot;ssh shu@10.5.26.19 -W %h:%p&quot;</span><br>shu@10.5.26.19<span class=\"hljs-string\">&#x27;s password: </span><br></code></pre></td></tr></table></figure>\n\n<p>方法二: 使用terminus节点，建立一个新的连接，配置如下<br><img src=\"/.com//image-20211207175530810.png\" alt=\"image-20211207175530810\"><br>这个节点相当于加了方法一的命令 <code>ssh -C  -N -g -R 18860:127.0.0.1:7890 服务器用户名@服务器ip</code></p>\n<p>然后运行一下proxy脚本,相当于方法一的第二条命令，具体的脚本内容如下:意思是bash一停（exit）, 这两条命令的效用就停止了</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-meta\">#!/bin/bash</span><br><span class=\"hljs-built_in\">export</span> http_proxy=http://127.0.0.1:18880<br><span class=\"hljs-built_in\">export</span> https_proxy=https://127.0.0.1:18880<br>bash<br></code></pre></td></tr></table></figure>\n\n<p>PS: 18860是随机选的端口， 7890的clashx的代理端口<br>只能使用curl, 不能使用ping 因为ping是在TCP协议之上的，但是curl是http协议（具体见操作系统）</p>\n<h4 id=\"2-查看端口号被哪个进程占用\"><a href=\"#2-查看端口号被哪个进程占用\" class=\"headerlink\" title=\"2. 查看端口号被哪个进程占用\"></a>2. 查看端口号被哪个进程占用</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">sudo lsof -i :7891<br></code></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>conda安装torch 1.8.0版本</li>\n</ol>\n<p><code>conda install pytorch==1.8.0 torchvision==0.9.0 torchaudio==0.8.0 cudatoolkit=10.2 -c pytorch</code></p>\n<p>pip install torch==1.8.0+cu101 torchvision==0.9.0+cu101 torchaudio==0.8.0 -f <a href=\"https://download.pytorch.org/whl/torch_stable.html\">https://download.pytorch.org/whl/torch_stable.html</a></p>\n<p>//1.8.0 如果运行起来还是非常慢的话，修改为1.7 因为1.8.1稳定版本需要gpu驱动大于hec01 440.33<br>pip install torch==1.7.1+cu101 torchvision==0.8.2+cu101 torchaudio==0.7.2 -f <a href=\"https://download.pytorch.org/whl/torch_stable.html\">https://download.pytorch.org/whl/torch_stable.html</a> -i <a href=\"https://pypi.douban.com/simple\">https://pypi.douban.com/simple</a> some-package</p>\n<ol start=\"4\">\n<li>查看并杀死vscode 进程 macos<br><code>pgrep -f &quot;vscode&quot; | xargs kill</code> 或者 <code>pgrep -f &quot;vscode&quot;</code> 查看进程号之后使用 <code>kill -9 pid</code></li>\n</ol>\n"},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/工具相关/hello-world.md","raw":"---\ntitle: Hello World\ncategories:\n  - 工具相关\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"工具相关/hello-world","published":1,"date":"2021-11-13T12:26:46.510Z","updated":"2021-11-13T12:27:48.242Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clk5ceio2001sjpjb3et3gq2z","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo new <span class=\"hljs-string\">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo server<br></code></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo generate<br></code></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo deploy<br></code></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","site":{"data":{}},"wordcount":367,"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo new <span class=\"hljs-string\">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo server<br></code></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo generate<br></code></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo deploy<br></code></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"Hexo 相关笔记","date":"2021-11-08T06:46:10.000Z","_content":"\n\n#### hexo 主题切换\n```\ngit clone xxx.git themes/black-blue //注意在blog路径里面\n\nvim _config.yml //修改theme为black-blue\n\nnpm install --save hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive\n\nhexo clean\n\nhexo g\n\nhexo s\n\n```\n#### 常见命令\n\n```bash\n1.hexo建立某一个目录下的blog\nhexo new blog -p leetcode/new_name.md\n\n2.上传到github仓库 (一定注意在mac电脑上使用sudo)\nsudo hexo d \n\n3. 生成静态页面\nhexo generate\n\n4.查看网页\nhexo server\n\n5.本地查看\nhexo clean && hexo g && hexo s\n```\n\n#### 参考链接\nhttps://juejin.cn/post/6978377036645531662\n配置指南\nhttps://hexo.fluid-dev.com/docs/guide/#%E6%96%87%E7%AB%A0%E5%9C%A8%E9%A6%96%E9%A1%B5%E7%9A%84%E5%B0%81%E9%9D%A2%E5%9B%BE\n\n#### 常见问题\n1. 文章中插入图片无法显示\n解决方法：注意将图片放在/source/img 而不是/img路径，即使是首页图像也是如此","source":"_posts/工具相关/hexo-notes.md","raw":"---\ntitle: Hexo 相关笔记\ncategories:\n  - 工具相关\ndate: 2021-11-08 14:46:10\ntags:\n---\n\n\n#### hexo 主题切换\n```\ngit clone xxx.git themes/black-blue //注意在blog路径里面\n\nvim _config.yml //修改theme为black-blue\n\nnpm install --save hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive\n\nhexo clean\n\nhexo g\n\nhexo s\n\n```\n#### 常见命令\n\n```bash\n1.hexo建立某一个目录下的blog\nhexo new blog -p leetcode/new_name.md\n\n2.上传到github仓库 (一定注意在mac电脑上使用sudo)\nsudo hexo d \n\n3. 生成静态页面\nhexo generate\n\n4.查看网页\nhexo server\n\n5.本地查看\nhexo clean && hexo g && hexo s\n```\n\n#### 参考链接\nhttps://juejin.cn/post/6978377036645531662\n配置指南\nhttps://hexo.fluid-dev.com/docs/guide/#%E6%96%87%E7%AB%A0%E5%9C%A8%E9%A6%96%E9%A1%B5%E7%9A%84%E5%B0%81%E9%9D%A2%E5%9B%BE\n\n#### 常见问题\n1. 文章中插入图片无法显示\n解决方法：注意将图片放在/source/img 而不是/img路径，即使是首页图像也是如此","slug":"工具相关/hexo-notes","published":1,"updated":"2023-07-12T11:14:20.974Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clk5ceio2001ujpjbe69j8puk","content":"<h4 id=\"hexo-主题切换\"><a href=\"#hexo-主题切换\" class=\"headerlink\" title=\"hexo 主题切换\"></a>hexo 主题切换</h4><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\">git <span class=\"hljs-keyword\">clone</span> xxx.git themes/black-blue <span class=\"hljs-comment\">//注意在blog路径里面</span><br><br>vim _config.yml <span class=\"hljs-comment\">//修改theme为black-blue</span><br><br>npm install --save hexo-renderer-jade hexo-<span class=\"hljs-built_in\">generator</span>-feed hexo-<span class=\"hljs-built_in\">generator</span>-sitemap hexo-browsersync hexo-<span class=\"hljs-built_in\">generator</span>-archive<br><br>hexo clean<br><br>hexo g<br><br>hexo s<br><br></code></pre></td></tr></table></figure>\n<h4 id=\"常见命令\"><a href=\"#常见命令\" class=\"headerlink\" title=\"常见命令\"></a>常见命令</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">1.hexo建立某一个目录下的blog<br>hexo new blog -p leetcode/new_name.md<br><br>2.上传到github仓库 (一定注意在mac电脑上使用sudo)<br>sudo hexo d <br><br>3. 生成静态页面<br>hexo generate<br><br>4.查看网页<br>hexo server<br><br>5.本地查看<br>hexo clean &amp;&amp; hexo g &amp;&amp; hexo s<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h4><p><a href=\"https://juejin.cn/post/6978377036645531662\">https://juejin.cn/post/6978377036645531662</a><br>配置指南<br><a href=\"https://hexo.fluid-dev.com/docs/guide/#%E6%96%87%E7%AB%A0%E5%9C%A8%E9%A6%96%E9%A1%B5%E7%9A%84%E5%B0%81%E9%9D%A2%E5%9B%BE\">https://hexo.fluid-dev.com/docs/guide/#%E6%96%87%E7%AB%A0%E5%9C%A8%E9%A6%96%E9%A1%B5%E7%9A%84%E5%B0%81%E9%9D%A2%E5%9B%BE</a></p>\n<h4 id=\"常见问题\"><a href=\"#常见问题\" class=\"headerlink\" title=\"常见问题\"></a>常见问题</h4><ol>\n<li>文章中插入图片无法显示<br>解决方法：注意将图片放在/source/img 而不是/img路径，即使是首页图像也是如此</li>\n</ol>\n","site":{"data":{}},"wordcount":660,"excerpt":"","more":"<h4 id=\"hexo-主题切换\"><a href=\"#hexo-主题切换\" class=\"headerlink\" title=\"hexo 主题切换\"></a>hexo 主题切换</h4><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\">git <span class=\"hljs-keyword\">clone</span> xxx.git themes/black-blue <span class=\"hljs-comment\">//注意在blog路径里面</span><br><br>vim _config.yml <span class=\"hljs-comment\">//修改theme为black-blue</span><br><br>npm install --save hexo-renderer-jade hexo-<span class=\"hljs-built_in\">generator</span>-feed hexo-<span class=\"hljs-built_in\">generator</span>-sitemap hexo-browsersync hexo-<span class=\"hljs-built_in\">generator</span>-archive<br><br>hexo clean<br><br>hexo g<br><br>hexo s<br><br></code></pre></td></tr></table></figure>\n<h4 id=\"常见命令\"><a href=\"#常见命令\" class=\"headerlink\" title=\"常见命令\"></a>常见命令</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">1.hexo建立某一个目录下的blog<br>hexo new blog -p leetcode/new_name.md<br><br>2.上传到github仓库 (一定注意在mac电脑上使用sudo)<br>sudo hexo d <br><br>3. 生成静态页面<br>hexo generate<br><br>4.查看网页<br>hexo server<br><br>5.本地查看<br>hexo clean &amp;&amp; hexo g &amp;&amp; hexo s<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h4><p><a href=\"https://juejin.cn/post/6978377036645531662\">https://juejin.cn/post/6978377036645531662</a><br>配置指南<br><a href=\"https://hexo.fluid-dev.com/docs/guide/#%E6%96%87%E7%AB%A0%E5%9C%A8%E9%A6%96%E9%A1%B5%E7%9A%84%E5%B0%81%E9%9D%A2%E5%9B%BE\">https://hexo.fluid-dev.com/docs/guide/#%E6%96%87%E7%AB%A0%E5%9C%A8%E9%A6%96%E9%A1%B5%E7%9A%84%E5%B0%81%E9%9D%A2%E5%9B%BE</a></p>\n<h4 id=\"常见问题\"><a href=\"#常见问题\" class=\"headerlink\" title=\"常见问题\"></a>常见问题</h4><ol>\n<li>文章中插入图片无法显示<br>解决方法：注意将图片放在/source/img 而不是/img路径，即使是首页图像也是如此</li>\n</ol>\n"},{"layout":"blog","title":"leetcode/单调栈相关","date":"2021-11-13T08:49:53.000Z","_content":"","source":"_posts/工具相关/leetcode-单调栈相关.md","raw":"---\nlayout: blog\ntitle: leetcode/单调栈相关\ndate: 2021-11-13 16:49:53\ntags:\n---\n","slug":"工具相关/leetcode-单调栈相关","published":1,"updated":"2021-11-13T12:26:46.547Z","comments":1,"photos":[],"link":"","_id":"clk5ceio4001zjpjbfn82grl4","content":"","site":{"data":{}},"wordcount":0,"excerpt":"","more":""},{"title":"orangefs","date":"2021-12-01T07:54:01.000Z","_content":"\n### orangefs\n\n1. genconfig是一个go语言文件，它有一个可选参数oranges-server.conf\n\n2. init_start_all.sh相比start_all.sh 多了一个/local500G/orange_store/ 以及多了一条有-f命令的语句 应该是在服务器节点启动pvfs-server\norangefs默认的服务器的文件系统挂载的目录是在oranges-server.conf里面进行配置（/nfs/home/yfwang/orangefs/install/etc/oranges-server.conf）\n\n加上f的原因： 第一次启动PVFS2服务要首先分配空间，添加参数-f：\nroot@ubuntu:~# pvfs2-server /etc/pvfs2-fs.conf -f\n其后启动服务则不需加参数，或使用-d使得服务运行于前台（占用当前终端窗口，终端窗口关闭后服务终止）\n\n```bash\nfor host in `cat /nfs/home/yfwang/orangefs/install/nodelist`\ndo\n#       ssh -t -t -o StrictHostKeyChecking=no -o PasswordAuthentication=no $USER@$host sudo rm -rf /local500G/orange_store/*\n        ssh -t -t -o StrictHostKeyChecking=no -o PasswordAuthentication=no $USER@$host sudo /nfs/home/yfwang/orangefs/install/sbin/pvfs2-server -f /nfs/home/yfwang/orangefs/install/etc/oranges-server.conf\n        ssh -t -t -o StrictHostKeyChecking=no -o PasswordAuthentication=no $USER@$host sudo /nfs/home/yfwang/orangefs/install/sbin/pvfs2-server /nfs/home/yfwang/orangefs/install/etc/oranges-server.conf\ndone \n```\n4. stop_all.sh 停止所有的pvfs-server\n```bash \nfor host in `cat /nfs/home/yfwang/orangefs/install/nodelist`\ndo\n        ssh -t -t -o StrictHostKeyChecking=no -o PasswordAuthentication=no $USER@$host sudo killall pvfs2-server\ndone\n```\n\n5. start_client.sh 启动客户端orangefs-client， 同时将服务器任意一个节点的位置暴露为客户端，例子是hec09\n\n```bash \nsudo /nfs/home/yfwang/orangefs/install/sbin/pvfs2-client -f -p /nfs/home/yfwang/orangefs/install/sbin/pvfs2-client-core\nsudo mount -t pvfs2 tcp://hec09:3334/orangefs /mnt/orangefs\n```\n\nnodelist\n里面直接写hec10 hec11\n\nhttps://github.com/waltligon/orangefs/wiki/Distributions-and-Layouts 设置数据不同的放置策略,一个文件放在一个节点使用basic方式 distribution\n\nhttps://github.com/waltligon/orangefs/wiki/Programming-Guide\n\nsetfattr -n \"user.pvfs2.dist_name\" -v \"basic_dist\" /mnt/pvfs2/directory\n./bin/pvfs2-xattr -s -k \"user.pvfs2.dist_name\" -v \"basic-dist\" /mnt/shu-orangefs/dataset\n\norangefs里面有一个PINT_dist函数\nhttps://www.mcs.anl.gov/~robl/pvfs2/pvfs2-dox/html/pint-distribution_8c.html#a2\n\n##### 现在找到将文件保存在一个服务器的方案：\nhttps://stackoverflow.com/questions/64923445/how-to-configure-orangefs-save-the-file-into-the-same-server-not-split-it\n使用命令：setfattr -n \"user.pvfs2.num_dfiles\" -v \"1\" /mnt/orangefs\n如果按照这种方式设置会报错：setfattr -n \"user.pvfs2.dist_name\" -v \"basic_dist\" /mnt/pvfs2/directory 传输数据会报错\n\n\n\n\n### 配置教程\n安装server\n拷贝已经编译好的程序\ncp -r /nfs/home/yfwang/orangefs/install /nfs/home/weijian/orangefs_install/\n配置server\n./bin/pvfs2-genconfig /nfs/home/weijian/orangefs_install/install/orangefs-server.conf\n具体的配置项，自己可以先记录下来\ntcp\n3336\n/local500G/wj-fast/storage/data\n/local500G/wj-fast/storage/meta\n/var/log/orangefs-server.log\nhec08,hec09\n配置完成时可以cat /nfs/home/weijian/orangefs_install/install/orangefs-server.conf查看配置项是否符合需求\n到各个server上，各自初始化存储目录\nsudo ./sbin/pvfs2-server -f orangefs-server.conf -a <server alias>\n到各个server上，启动服务\nsudo ./sbin/pvfs2-server  orangefs-server.conf\n\n安装client\n拷贝已经编译好的程序（如果已经可以访问就不需要拷贝了）\nscp -r weijian@hec08:/nfs/home/yfwang/orangefs/install/ /nfs/home/weijian/orangefs_install/\n向内核加载orangefs模块\nsudo modprobe orangefs\n创建挂载点\nsudo mkdir /mnt/wj-fast-orangefs\n写配置文件\nsudo sh -c “echo ‘tcp://hec08:3336/orangefs /mnt/wj-fast-orangefs pvfs2’ >> /etc/pvfs2tab”\n测试与server是否连通\n./bin/pvfs2-ping -m /mnt/wj-fast-orangefs\n启动client客户端\nsudo ./sbin/pvfs2-client -p ./sbin/pvfs2-client-core\n挂载\nsudo mount -t pvfs2 tcp://hec08:3336/orangefs /mnt/wj-fast-orangefs","source":"_posts/工具相关/orangefs.md","raw":"---\ntitle: orangefs\ncategories:\n  - 工具相关\ndate: 2021-12-01 15:54:01\ntags:\n---\n\n### orangefs\n\n1. genconfig是一个go语言文件，它有一个可选参数oranges-server.conf\n\n2. init_start_all.sh相比start_all.sh 多了一个/local500G/orange_store/ 以及多了一条有-f命令的语句 应该是在服务器节点启动pvfs-server\norangefs默认的服务器的文件系统挂载的目录是在oranges-server.conf里面进行配置（/nfs/home/yfwang/orangefs/install/etc/oranges-server.conf）\n\n加上f的原因： 第一次启动PVFS2服务要首先分配空间，添加参数-f：\nroot@ubuntu:~# pvfs2-server /etc/pvfs2-fs.conf -f\n其后启动服务则不需加参数，或使用-d使得服务运行于前台（占用当前终端窗口，终端窗口关闭后服务终止）\n\n```bash\nfor host in `cat /nfs/home/yfwang/orangefs/install/nodelist`\ndo\n#       ssh -t -t -o StrictHostKeyChecking=no -o PasswordAuthentication=no $USER@$host sudo rm -rf /local500G/orange_store/*\n        ssh -t -t -o StrictHostKeyChecking=no -o PasswordAuthentication=no $USER@$host sudo /nfs/home/yfwang/orangefs/install/sbin/pvfs2-server -f /nfs/home/yfwang/orangefs/install/etc/oranges-server.conf\n        ssh -t -t -o StrictHostKeyChecking=no -o PasswordAuthentication=no $USER@$host sudo /nfs/home/yfwang/orangefs/install/sbin/pvfs2-server /nfs/home/yfwang/orangefs/install/etc/oranges-server.conf\ndone \n```\n4. stop_all.sh 停止所有的pvfs-server\n```bash \nfor host in `cat /nfs/home/yfwang/orangefs/install/nodelist`\ndo\n        ssh -t -t -o StrictHostKeyChecking=no -o PasswordAuthentication=no $USER@$host sudo killall pvfs2-server\ndone\n```\n\n5. start_client.sh 启动客户端orangefs-client， 同时将服务器任意一个节点的位置暴露为客户端，例子是hec09\n\n```bash \nsudo /nfs/home/yfwang/orangefs/install/sbin/pvfs2-client -f -p /nfs/home/yfwang/orangefs/install/sbin/pvfs2-client-core\nsudo mount -t pvfs2 tcp://hec09:3334/orangefs /mnt/orangefs\n```\n\nnodelist\n里面直接写hec10 hec11\n\nhttps://github.com/waltligon/orangefs/wiki/Distributions-and-Layouts 设置数据不同的放置策略,一个文件放在一个节点使用basic方式 distribution\n\nhttps://github.com/waltligon/orangefs/wiki/Programming-Guide\n\nsetfattr -n \"user.pvfs2.dist_name\" -v \"basic_dist\" /mnt/pvfs2/directory\n./bin/pvfs2-xattr -s -k \"user.pvfs2.dist_name\" -v \"basic-dist\" /mnt/shu-orangefs/dataset\n\norangefs里面有一个PINT_dist函数\nhttps://www.mcs.anl.gov/~robl/pvfs2/pvfs2-dox/html/pint-distribution_8c.html#a2\n\n##### 现在找到将文件保存在一个服务器的方案：\nhttps://stackoverflow.com/questions/64923445/how-to-configure-orangefs-save-the-file-into-the-same-server-not-split-it\n使用命令：setfattr -n \"user.pvfs2.num_dfiles\" -v \"1\" /mnt/orangefs\n如果按照这种方式设置会报错：setfattr -n \"user.pvfs2.dist_name\" -v \"basic_dist\" /mnt/pvfs2/directory 传输数据会报错\n\n\n\n\n### 配置教程\n安装server\n拷贝已经编译好的程序\ncp -r /nfs/home/yfwang/orangefs/install /nfs/home/weijian/orangefs_install/\n配置server\n./bin/pvfs2-genconfig /nfs/home/weijian/orangefs_install/install/orangefs-server.conf\n具体的配置项，自己可以先记录下来\ntcp\n3336\n/local500G/wj-fast/storage/data\n/local500G/wj-fast/storage/meta\n/var/log/orangefs-server.log\nhec08,hec09\n配置完成时可以cat /nfs/home/weijian/orangefs_install/install/orangefs-server.conf查看配置项是否符合需求\n到各个server上，各自初始化存储目录\nsudo ./sbin/pvfs2-server -f orangefs-server.conf -a <server alias>\n到各个server上，启动服务\nsudo ./sbin/pvfs2-server  orangefs-server.conf\n\n安装client\n拷贝已经编译好的程序（如果已经可以访问就不需要拷贝了）\nscp -r weijian@hec08:/nfs/home/yfwang/orangefs/install/ /nfs/home/weijian/orangefs_install/\n向内核加载orangefs模块\nsudo modprobe orangefs\n创建挂载点\nsudo mkdir /mnt/wj-fast-orangefs\n写配置文件\nsudo sh -c “echo ‘tcp://hec08:3336/orangefs /mnt/wj-fast-orangefs pvfs2’ >> /etc/pvfs2tab”\n测试与server是否连通\n./bin/pvfs2-ping -m /mnt/wj-fast-orangefs\n启动client客户端\nsudo ./sbin/pvfs2-client -p ./sbin/pvfs2-client-core\n挂载\nsudo mount -t pvfs2 tcp://hec08:3336/orangefs /mnt/wj-fast-orangefs","slug":"工具相关/orangefs","published":1,"updated":"2022-02-14T10:03:35.528Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clk5ceio50020jpjb3ihv8xj3","content":"<h3 id=\"orangefs\"><a href=\"#orangefs\" class=\"headerlink\" title=\"orangefs\"></a>orangefs</h3><ol>\n<li><p>genconfig是一个go语言文件，它有一个可选参数oranges-server.conf</p>\n</li>\n<li><p>init_start_all.sh相比start_all.sh 多了一个/local500G/orange_store/ 以及多了一条有-f命令的语句 应该是在服务器节点启动pvfs-server<br>orangefs默认的服务器的文件系统挂载的目录是在oranges-server.conf里面进行配置（/nfs/home/yfwang/orangefs/install/etc/oranges-server.conf）</p>\n</li>\n</ol>\n<p>加上f的原因： 第一次启动PVFS2服务要首先分配空间，添加参数-f：<br>root@ubuntu:~# pvfs2-server /etc/pvfs2-fs.conf -f<br>其后启动服务则不需加参数，或使用-d使得服务运行于前台（占用当前终端窗口，终端窗口关闭后服务终止）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-keyword\">for</span> host <span class=\"hljs-keyword\">in</span> `cat /nfs/home/yfwang/orangefs/install/nodelist`<br><span class=\"hljs-keyword\">do</span><br><span class=\"hljs-comment\">#       ssh -t -t -o StrictHostKeyChecking=no -o PasswordAuthentication=no $USER@$host sudo rm -rf /local500G/orange_store/*</span><br>        ssh -t -t -o StrictHostKeyChecking=no -o PasswordAuthentication=no <span class=\"hljs-variable\">$USER</span>@<span class=\"hljs-variable\">$host</span> sudo /nfs/home/yfwang/orangefs/install/sbin/pvfs2-server -f /nfs/home/yfwang/orangefs/install/etc/oranges-server.conf<br>        ssh -t -t -o StrictHostKeyChecking=no -o PasswordAuthentication=no <span class=\"hljs-variable\">$USER</span>@<span class=\"hljs-variable\">$host</span> sudo /nfs/home/yfwang/orangefs/install/sbin/pvfs2-server /nfs/home/yfwang/orangefs/install/etc/oranges-server.conf<br><span class=\"hljs-keyword\">done</span> <br></code></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li><p>stop_all.sh 停止所有的pvfs-server</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-keyword\">for</span> host <span class=\"hljs-keyword\">in</span> `cat /nfs/home/yfwang/orangefs/install/nodelist`<br><span class=\"hljs-keyword\">do</span><br>        ssh -t -t -o StrictHostKeyChecking=no -o PasswordAuthentication=no <span class=\"hljs-variable\">$USER</span>@<span class=\"hljs-variable\">$host</span> sudo killall pvfs2-server<br><span class=\"hljs-keyword\">done</span><br></code></pre></td></tr></table></figure></li>\n<li><p>start_client.sh 启动客户端orangefs-client， 同时将服务器任意一个节点的位置暴露为客户端，例子是hec09</p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">sudo /nfs/home/yfwang/orangefs/install/sbin/pvfs2-client -f -p /nfs/home/yfwang/orangefs/install/sbin/pvfs2-client-core<br>sudo mount -t pvfs2 tcp://hec09:3334/orangefs /mnt/orangefs<br></code></pre></td></tr></table></figure>\n\n<p>nodelist<br>里面直接写hec10 hec11</p>\n<p><a href=\"https://github.com/waltligon/orangefs/wiki/Distributions-and-Layouts\">https://github.com/waltligon/orangefs/wiki/Distributions-and-Layouts</a> 设置数据不同的放置策略,一个文件放在一个节点使用basic方式 distribution</p>\n<p><a href=\"https://github.com/waltligon/orangefs/wiki/Programming-Guide\">https://github.com/waltligon/orangefs/wiki/Programming-Guide</a></p>\n<p>setfattr -n “user.pvfs2.dist_name” -v “basic_dist” /mnt/pvfs2/directory<br>./bin/pvfs2-xattr -s -k “user.pvfs2.dist_name” -v “basic-dist” /mnt/shu-orangefs/dataset</p>\n<p>orangefs里面有一个PINT_dist函数<br><a href=\"https://www.mcs.anl.gov/~robl/pvfs2/pvfs2-dox/html/pint-distribution_8c.html#a2\">https://www.mcs.anl.gov/~robl/pvfs2/pvfs2-dox/html/pint-distribution_8c.html#a2</a></p>\n<h5 id=\"现在找到将文件保存在一个服务器的方案：\"><a href=\"#现在找到将文件保存在一个服务器的方案：\" class=\"headerlink\" title=\"现在找到将文件保存在一个服务器的方案：\"></a>现在找到将文件保存在一个服务器的方案：</h5><p><a href=\"https://stackoverflow.com/questions/64923445/how-to-configure-orangefs-save-the-file-into-the-same-server-not-split-it\">https://stackoverflow.com/questions/64923445/how-to-configure-orangefs-save-the-file-into-the-same-server-not-split-it</a><br>使用命令：setfattr -n “user.pvfs2.num_dfiles” -v “1” /mnt/orangefs<br>如果按照这种方式设置会报错：setfattr -n “user.pvfs2.dist_name” -v “basic_dist” /mnt/pvfs2/directory 传输数据会报错</p>\n<h3 id=\"配置教程\"><a href=\"#配置教程\" class=\"headerlink\" title=\"配置教程\"></a>配置教程</h3><p>安装server<br>拷贝已经编译好的程序<br>cp -r /nfs/home/yfwang/orangefs/install /nfs/home/weijian/orangefs_install/<br>配置server<br>./bin/pvfs2-genconfig /nfs/home/weijian/orangefs_install/install/orangefs-server.conf<br>具体的配置项，自己可以先记录下来<br>tcp<br>3336<br>/local500G/wj-fast/storage/data<br>/local500G/wj-fast/storage/meta<br>/var/log/orangefs-server.log<br>hec08,hec09<br>配置完成时可以cat /nfs/home/weijian/orangefs_install/install/orangefs-server.conf查看配置项是否符合需求<br>到各个server上，各自初始化存储目录<br>sudo ./sbin/pvfs2-server -f orangefs-server.conf -a <server alias><br>到各个server上，启动服务<br>sudo ./sbin/pvfs2-server  orangefs-server.conf</server></p>\n<p>安装client<br>拷贝已经编译好的程序（如果已经可以访问就不需要拷贝了）<br>scp -r weijian@hec08:/nfs/home/yfwang/orangefs/install/ /nfs/home/weijian/orangefs_install/<br>向内核加载orangefs模块<br>sudo modprobe orangefs<br>创建挂载点<br>sudo mkdir /mnt/wj-fast-orangefs<br>写配置文件<br>sudo sh -c “echo ‘tcp://hec08:3336/orangefs /mnt/wj-fast-orangefs pvfs2’ &gt;&gt; /etc/pvfs2tab”<br>测试与server是否连通<br>./bin/pvfs2-ping -m /mnt/wj-fast-orangefs<br>启动client客户端<br>sudo ./sbin/pvfs2-client -p ./sbin/pvfs2-client-core<br>挂载<br>sudo mount -t pvfs2 tcp://hec08:3336/orangefs /mnt/wj-fast-orangefs</p>\n","site":{"data":{}},"wordcount":3060,"excerpt":"","more":"<h3 id=\"orangefs\"><a href=\"#orangefs\" class=\"headerlink\" title=\"orangefs\"></a>orangefs</h3><ol>\n<li><p>genconfig是一个go语言文件，它有一个可选参数oranges-server.conf</p>\n</li>\n<li><p>init_start_all.sh相比start_all.sh 多了一个/local500G/orange_store/ 以及多了一条有-f命令的语句 应该是在服务器节点启动pvfs-server<br>orangefs默认的服务器的文件系统挂载的目录是在oranges-server.conf里面进行配置（/nfs/home/yfwang/orangefs/install/etc/oranges-server.conf）</p>\n</li>\n</ol>\n<p>加上f的原因： 第一次启动PVFS2服务要首先分配空间，添加参数-f：<br>root@ubuntu:~# pvfs2-server /etc/pvfs2-fs.conf -f<br>其后启动服务则不需加参数，或使用-d使得服务运行于前台（占用当前终端窗口，终端窗口关闭后服务终止）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-keyword\">for</span> host <span class=\"hljs-keyword\">in</span> `cat /nfs/home/yfwang/orangefs/install/nodelist`<br><span class=\"hljs-keyword\">do</span><br><span class=\"hljs-comment\">#       ssh -t -t -o StrictHostKeyChecking=no -o PasswordAuthentication=no $USER@$host sudo rm -rf /local500G/orange_store/*</span><br>        ssh -t -t -o StrictHostKeyChecking=no -o PasswordAuthentication=no <span class=\"hljs-variable\">$USER</span>@<span class=\"hljs-variable\">$host</span> sudo /nfs/home/yfwang/orangefs/install/sbin/pvfs2-server -f /nfs/home/yfwang/orangefs/install/etc/oranges-server.conf<br>        ssh -t -t -o StrictHostKeyChecking=no -o PasswordAuthentication=no <span class=\"hljs-variable\">$USER</span>@<span class=\"hljs-variable\">$host</span> sudo /nfs/home/yfwang/orangefs/install/sbin/pvfs2-server /nfs/home/yfwang/orangefs/install/etc/oranges-server.conf<br><span class=\"hljs-keyword\">done</span> <br></code></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li><p>stop_all.sh 停止所有的pvfs-server</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-keyword\">for</span> host <span class=\"hljs-keyword\">in</span> `cat /nfs/home/yfwang/orangefs/install/nodelist`<br><span class=\"hljs-keyword\">do</span><br>        ssh -t -t -o StrictHostKeyChecking=no -o PasswordAuthentication=no <span class=\"hljs-variable\">$USER</span>@<span class=\"hljs-variable\">$host</span> sudo killall pvfs2-server<br><span class=\"hljs-keyword\">done</span><br></code></pre></td></tr></table></figure></li>\n<li><p>start_client.sh 启动客户端orangefs-client， 同时将服务器任意一个节点的位置暴露为客户端，例子是hec09</p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">sudo /nfs/home/yfwang/orangefs/install/sbin/pvfs2-client -f -p /nfs/home/yfwang/orangefs/install/sbin/pvfs2-client-core<br>sudo mount -t pvfs2 tcp://hec09:3334/orangefs /mnt/orangefs<br></code></pre></td></tr></table></figure>\n\n<p>nodelist<br>里面直接写hec10 hec11</p>\n<p><a href=\"https://github.com/waltligon/orangefs/wiki/Distributions-and-Layouts\">https://github.com/waltligon/orangefs/wiki/Distributions-and-Layouts</a> 设置数据不同的放置策略,一个文件放在一个节点使用basic方式 distribution</p>\n<p><a href=\"https://github.com/waltligon/orangefs/wiki/Programming-Guide\">https://github.com/waltligon/orangefs/wiki/Programming-Guide</a></p>\n<p>setfattr -n “user.pvfs2.dist_name” -v “basic_dist” /mnt/pvfs2/directory<br>./bin/pvfs2-xattr -s -k “user.pvfs2.dist_name” -v “basic-dist” /mnt/shu-orangefs/dataset</p>\n<p>orangefs里面有一个PINT_dist函数<br><a href=\"https://www.mcs.anl.gov/~robl/pvfs2/pvfs2-dox/html/pint-distribution_8c.html#a2\">https://www.mcs.anl.gov/~robl/pvfs2/pvfs2-dox/html/pint-distribution_8c.html#a2</a></p>\n<h5 id=\"现在找到将文件保存在一个服务器的方案：\"><a href=\"#现在找到将文件保存在一个服务器的方案：\" class=\"headerlink\" title=\"现在找到将文件保存在一个服务器的方案：\"></a>现在找到将文件保存在一个服务器的方案：</h5><p><a href=\"https://stackoverflow.com/questions/64923445/how-to-configure-orangefs-save-the-file-into-the-same-server-not-split-it\">https://stackoverflow.com/questions/64923445/how-to-configure-orangefs-save-the-file-into-the-same-server-not-split-it</a><br>使用命令：setfattr -n “user.pvfs2.num_dfiles” -v “1” /mnt/orangefs<br>如果按照这种方式设置会报错：setfattr -n “user.pvfs2.dist_name” -v “basic_dist” /mnt/pvfs2/directory 传输数据会报错</p>\n<h3 id=\"配置教程\"><a href=\"#配置教程\" class=\"headerlink\" title=\"配置教程\"></a>配置教程</h3><p>安装server<br>拷贝已经编译好的程序<br>cp -r /nfs/home/yfwang/orangefs/install /nfs/home/weijian/orangefs_install/<br>配置server<br>./bin/pvfs2-genconfig /nfs/home/weijian/orangefs_install/install/orangefs-server.conf<br>具体的配置项，自己可以先记录下来<br>tcp<br>3336<br>/local500G/wj-fast/storage/data<br>/local500G/wj-fast/storage/meta<br>/var/log/orangefs-server.log<br>hec08,hec09<br>配置完成时可以cat /nfs/home/weijian/orangefs_install/install/orangefs-server.conf查看配置项是否符合需求<br>到各个server上，各自初始化存储目录<br>sudo ./sbin/pvfs2-server -f orangefs-server.conf -a <server alias><br>到各个server上，启动服务<br>sudo ./sbin/pvfs2-server  orangefs-server.conf</server></p>\n<p>安装client<br>拷贝已经编译好的程序（如果已经可以访问就不需要拷贝了）<br>scp -r weijian@hec08:/nfs/home/yfwang/orangefs/install/ /nfs/home/weijian/orangefs_install/<br>向内核加载orangefs模块<br>sudo modprobe orangefs<br>创建挂载点<br>sudo mkdir /mnt/wj-fast-orangefs<br>写配置文件<br>sudo sh -c “echo ‘tcp://hec08:3336/orangefs /mnt/wj-fast-orangefs pvfs2’ &gt;&gt; /etc/pvfs2tab”<br>测试与server是否连通<br>./bin/pvfs2-ping -m /mnt/wj-fast-orangefs<br>启动client客户端<br>sudo ./sbin/pvfs2-client -p ./sbin/pvfs2-client-core<br>挂载<br>sudo mount -t pvfs2 tcp://hec08:3336/orangefs /mnt/wj-fast-orangefs</p>\n"},{"title":"md语法相关","date":"2022-01-20T04:11:13.000Z","_content":"\n\n对代码块进行折叠\n<details>\n  <summary>点击时的区域标题</summary>\n<pre>\n\n内容\n\n</code>\n</details>\n\n\n","source":"_posts/工具相关/md语法相关.md","raw":"---\ntitle: md语法相关\ntags: 'typora, md'\ncategories:\n  - 工具相关\ndate: 2022-01-20 12:11:13\n---\n\n\n对代码块进行折叠\n<details>\n  <summary>点击时的区域标题</summary>\n<pre>\n\n内容\n\n</code>\n</details>\n\n\n","slug":"工具相关/md语法相关","published":1,"updated":"2022-02-14T10:03:35.528Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clk5ceio60023jpjbhma13mwp","content":"<p>对代码块进行折叠</p>\n<details>\n  <summary>点击时的区域标题</summary>\n<pre>\n\n<p>内容</p>\n\n</pre></details>\n\n\n","site":{"data":{}},"wordcount":18,"excerpt":"","more":"<p>对代码块进行折叠</p>\n<details>\n  <summary>点击时的区域标题</summary>\n<pre>\n\n<p>内容</p>\n\n</pre></details>\n\n\n"},{"layout":"python相关","title":"python相关","date":"2021-11-11T11:06:48.000Z","_content":"\n\n#### Python语言部分\n1. python 开启debug模式，使用logger.setLevel 以及在logger的时候设置不同的logger.info  logger.error  logger.warning等\n\n``` python\nimport logging\nimport requests\nlogging.basicConfig(level=logging.DEBUG,\n                    format='%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s',\n                    datefmt='%a, %d %b %Y %H:%M:%S',\n                    filename='myapp.log',\n                    filemode='w')\n \nlogging.debug(session.get('http://www.qq.com'))\nlogging.debug(session.get('http://www.qq.com'))\n\n```\n\n\ntuple和list的区别\n\ntuple和list都可以通过下标访问元素，但是list是可以修改列表中的元素， 但是tuple一旦初始化就不能修改，不能append和insert\n\n\n#### PyTorch 部分\n\n1. 在如果在模型训练的时候，一部分卷积使用的是dataparallel一部分使用的是直接cuda (比如alexnet) 这种情况在模型参数的加载的时候，需要修改keys中包含 module.的部分（dataparallel 部分）\n\n方法一:\n修改保存或者加载时的字典\n```\nfrom collections import OrderedDict\nnew_state_dict = OrderedDict()\nfor k, v in state_dict.items():\n    namekey = k[7:] if k.startswith('module.') else k\n    new_state_dict[namekey] = v\n```\n\n方法二：\n```\nuni_model.load_state_dict({k.replace('module.','') :v for k,v in model_queue.get(block=False).items() })\n```\n\n\n2. DatasetFolder类的解读\n数据类别，是通过遍历目标文件夹，得到每个文件夹的名字，以及名字对应的下标\nmake_data返回的是 数据的路径+类别下标 序列元组 List of (sample path, class_index) tuples 得到self.samples\n然后再在get_item函数中使用path = self.samples[index] self.loader(path) 获得图片实例\n\n\n那么我自定义的缓存，既可以在MyDataSet里面的DataSet_ImageNet里面修改，判断是应该从缓存中取还是从文件系统；\n也可以修改ImageFolder, 里面加一个缓存， 在self.loader那里加上if-else判断语句\n\n但是多进程会初始化多个dataset, 这样每个进程都会有一个cache， 我的目的应该是只有一个cache, 然后多进程从里面都可以从这个cache中取数据；而且多进程如果每一轮的dataset的实例被销毁的话会导致\ncache也会被销毁\n\n\n3. DatasetLoader类的解读\n问题：\nworker_init_fn， prefetch_factor 和persistent_workers（保持被实例化的Dataset在下一轮仍然保持alive） 的作用是什么\nwarning中表示如果spwarn start method被使用， 那么worker_init_fn 不能是一个unpicklable object\n\n_MultiProcessingDataLoaderIter 可以学习一下多进程的退出\n使用了三个队列 index_queue worker_result_queue data_queue\n\nworkers_done_event 检测一个迭代器是否shut down, 如果一个迭代器进行shutdown，那么那个进程的input_queue里面的数据只需要为None就好了， 就不用一直等待那个queue里面的数据\n\n为什么要使用 cancel_join_thread()  index_queue.cancel_join_thread()\n\n记录：\n多进程每个进程都可以创建多个dataset实例(这个好像是错的), 是否在主函数中初始化一个cacheout类，然后作为dataset的参数传过去，这样多进程也是使用的一个cache\n主要的逻辑\n\n```python\nfor i in range(self._num_workers):\n            # No certainty which module multiprocessing_context is\n            index_queue = multiprocessing_context.Queue()  # type: ignore\n            # Need to `cancel_join_thread` here!\n            # See sections (2) and (3b) above.\n            index_queue.cancel_join_thread()\n            w = multiprocessing_context.Process(\n                target=_utils.worker._worker_loop,\n                args=(self._dataset_kind, self._dataset, index_queue,\n                      self._worker_result_queue, self._workers_done_event,\n                      self._auto_collation, self._collate_fn, self._drop_last,\n                      self._base_seed + i, self._worker_init_fn, i, self._num_workers,\n                      self._persistent_workers))\n```\n只有一个worker_result_queue, 以及多个result_queue; 如果pin_memory=True, 那么会将worker_result_queue里面的数据，全部放在另外一个_data_queue中\n\n#### pyTorch取数据过程详解（面试版本）\n1. 初始化的时候，每个进程都会拥有自己的index_queue,里面最多存储两个batch 的index\n2. 每个worker会不断判断自己的index_queue里面有没有数据，如果有，那么就取读一个batch, 读取的时候调用collate_fn函数，读取之后放入多进程共享的data_queue / worker_result_queue 里面\n3. data_queue里面的数据会先放入reorder字典中进行重新排序，如果需要的下一个batch在reorder_dict里面，那么就从reorder_dict中弹出这个数据，否则就等待\n4. 某个worker读取的数据被消耗之后，dataloader就会将新的index放到对应worker的index_queue里面，这个worker就继续从queue里面读下标和取数据\n参考：\nhttps://www.dazhuanlan.com/yiliabi/topics/1111356\n\n\n4. 代码常见标记\nTODO：英语翻译为待办事项，备忘录。如果代码中有该标识，说明在标识处有功能代码待编写，待实现的功能在说明中会简略说明。\n\nFIXME：可以拆成短语，fix me ，意为修理我。如果代码中有该标识，说明标识处代码需要修正，甚至代码是错误的，不能工作，需要修复，如何修正会在说明中简略说明。\n\nXXX：如果代码中有该标识，说明标识处代码虽然实现了功能，但是实现的方法有待商榷，希望将来能改进，要改进的地方会在说明中简略说明。\n\nHACK：英语翻译为砍。如果代码中有该标识，说明标识处代码我们需要根据自己的需求去调整程序代码。\n\n\n5. pytorch安装各种版本链接：\nhttps://pytorch.org/get-started/previous-versions/\n\n6. pytorch 多进程数据加载流程\n\n\n7. iterator和next函数的关系\n生成器都是iterator对象\n可以被next函数调用的都是一个iterator对象，Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。直到没有数据时抛出StopIteration错误。\nlist/dict/str这些是iterable但是不是iterator\n\nPython的for循环本质上就是通过不断调用next()函数实现的，首先需要将list作为参数，传入iter函数中，获得一个iterator对象，然后才能调用next函数\n","source":"_posts/工具相关/python相关.md","raw":"---\nlayout: python相关\ntitle: python相关\ndate: 2021-11-11 19:06:48\ntags:\n---\n\n\n#### Python语言部分\n1. python 开启debug模式，使用logger.setLevel 以及在logger的时候设置不同的logger.info  logger.error  logger.warning等\n\n``` python\nimport logging\nimport requests\nlogging.basicConfig(level=logging.DEBUG,\n                    format='%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s',\n                    datefmt='%a, %d %b %Y %H:%M:%S',\n                    filename='myapp.log',\n                    filemode='w')\n \nlogging.debug(session.get('http://www.qq.com'))\nlogging.debug(session.get('http://www.qq.com'))\n\n```\n\n\ntuple和list的区别\n\ntuple和list都可以通过下标访问元素，但是list是可以修改列表中的元素， 但是tuple一旦初始化就不能修改，不能append和insert\n\n\n#### PyTorch 部分\n\n1. 在如果在模型训练的时候，一部分卷积使用的是dataparallel一部分使用的是直接cuda (比如alexnet) 这种情况在模型参数的加载的时候，需要修改keys中包含 module.的部分（dataparallel 部分）\n\n方法一:\n修改保存或者加载时的字典\n```\nfrom collections import OrderedDict\nnew_state_dict = OrderedDict()\nfor k, v in state_dict.items():\n    namekey = k[7:] if k.startswith('module.') else k\n    new_state_dict[namekey] = v\n```\n\n方法二：\n```\nuni_model.load_state_dict({k.replace('module.','') :v for k,v in model_queue.get(block=False).items() })\n```\n\n\n2. DatasetFolder类的解读\n数据类别，是通过遍历目标文件夹，得到每个文件夹的名字，以及名字对应的下标\nmake_data返回的是 数据的路径+类别下标 序列元组 List of (sample path, class_index) tuples 得到self.samples\n然后再在get_item函数中使用path = self.samples[index] self.loader(path) 获得图片实例\n\n\n那么我自定义的缓存，既可以在MyDataSet里面的DataSet_ImageNet里面修改，判断是应该从缓存中取还是从文件系统；\n也可以修改ImageFolder, 里面加一个缓存， 在self.loader那里加上if-else判断语句\n\n但是多进程会初始化多个dataset, 这样每个进程都会有一个cache， 我的目的应该是只有一个cache, 然后多进程从里面都可以从这个cache中取数据；而且多进程如果每一轮的dataset的实例被销毁的话会导致\ncache也会被销毁\n\n\n3. DatasetLoader类的解读\n问题：\nworker_init_fn， prefetch_factor 和persistent_workers（保持被实例化的Dataset在下一轮仍然保持alive） 的作用是什么\nwarning中表示如果spwarn start method被使用， 那么worker_init_fn 不能是一个unpicklable object\n\n_MultiProcessingDataLoaderIter 可以学习一下多进程的退出\n使用了三个队列 index_queue worker_result_queue data_queue\n\nworkers_done_event 检测一个迭代器是否shut down, 如果一个迭代器进行shutdown，那么那个进程的input_queue里面的数据只需要为None就好了， 就不用一直等待那个queue里面的数据\n\n为什么要使用 cancel_join_thread()  index_queue.cancel_join_thread()\n\n记录：\n多进程每个进程都可以创建多个dataset实例(这个好像是错的), 是否在主函数中初始化一个cacheout类，然后作为dataset的参数传过去，这样多进程也是使用的一个cache\n主要的逻辑\n\n```python\nfor i in range(self._num_workers):\n            # No certainty which module multiprocessing_context is\n            index_queue = multiprocessing_context.Queue()  # type: ignore\n            # Need to `cancel_join_thread` here!\n            # See sections (2) and (3b) above.\n            index_queue.cancel_join_thread()\n            w = multiprocessing_context.Process(\n                target=_utils.worker._worker_loop,\n                args=(self._dataset_kind, self._dataset, index_queue,\n                      self._worker_result_queue, self._workers_done_event,\n                      self._auto_collation, self._collate_fn, self._drop_last,\n                      self._base_seed + i, self._worker_init_fn, i, self._num_workers,\n                      self._persistent_workers))\n```\n只有一个worker_result_queue, 以及多个result_queue; 如果pin_memory=True, 那么会将worker_result_queue里面的数据，全部放在另外一个_data_queue中\n\n#### pyTorch取数据过程详解（面试版本）\n1. 初始化的时候，每个进程都会拥有自己的index_queue,里面最多存储两个batch 的index\n2. 每个worker会不断判断自己的index_queue里面有没有数据，如果有，那么就取读一个batch, 读取的时候调用collate_fn函数，读取之后放入多进程共享的data_queue / worker_result_queue 里面\n3. data_queue里面的数据会先放入reorder字典中进行重新排序，如果需要的下一个batch在reorder_dict里面，那么就从reorder_dict中弹出这个数据，否则就等待\n4. 某个worker读取的数据被消耗之后，dataloader就会将新的index放到对应worker的index_queue里面，这个worker就继续从queue里面读下标和取数据\n参考：\nhttps://www.dazhuanlan.com/yiliabi/topics/1111356\n\n\n4. 代码常见标记\nTODO：英语翻译为待办事项，备忘录。如果代码中有该标识，说明在标识处有功能代码待编写，待实现的功能在说明中会简略说明。\n\nFIXME：可以拆成短语，fix me ，意为修理我。如果代码中有该标识，说明标识处代码需要修正，甚至代码是错误的，不能工作，需要修复，如何修正会在说明中简略说明。\n\nXXX：如果代码中有该标识，说明标识处代码虽然实现了功能，但是实现的方法有待商榷，希望将来能改进，要改进的地方会在说明中简略说明。\n\nHACK：英语翻译为砍。如果代码中有该标识，说明标识处代码我们需要根据自己的需求去调整程序代码。\n\n\n5. pytorch安装各种版本链接：\nhttps://pytorch.org/get-started/previous-versions/\n\n6. pytorch 多进程数据加载流程\n\n\n7. iterator和next函数的关系\n生成器都是iterator对象\n可以被next函数调用的都是一个iterator对象，Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。直到没有数据时抛出StopIteration错误。\nlist/dict/str这些是iterable但是不是iterator\n\nPython的for循环本质上就是通过不断调用next()函数实现的，首先需要将list作为参数，传入iter函数中，获得一个iterator对象，然后才能调用next函数\n","slug":"工具相关/python相关","published":1,"updated":"2022-02-25T02:05:30.101Z","comments":1,"photos":[],"link":"","_id":"clk5ceio70025jpjbgl960hbo","content":"<h4 id=\"Python语言部分\"><a href=\"#Python语言部分\" class=\"headerlink\" title=\"Python语言部分\"></a>Python语言部分</h4><ol>\n<li>python 开启debug模式，使用logger.setLevel 以及在logger的时候设置不同的logger.info  logger.error  logger.warning等</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> logging<br><span class=\"hljs-keyword\">import</span> requests<br>logging.basicConfig(level=logging.DEBUG,<br>                    <span class=\"hljs-built_in\">format</span>=<span class=\"hljs-string\">&#x27;%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s&#x27;</span>,<br>                    datefmt=<span class=\"hljs-string\">&#x27;%a, %d %b %Y %H:%M:%S&#x27;</span>,<br>                    filename=<span class=\"hljs-string\">&#x27;myapp.log&#x27;</span>,<br>                    filemode=<span class=\"hljs-string\">&#x27;w&#x27;</span>)<br> <br>logging.debug(session.get(<span class=\"hljs-string\">&#x27;http://www.qq.com&#x27;</span>))<br>logging.debug(session.get(<span class=\"hljs-string\">&#x27;http://www.qq.com&#x27;</span>))<br><br></code></pre></td></tr></table></figure>\n\n\n<p>tuple和list的区别</p>\n<p>tuple和list都可以通过下标访问元素，但是list是可以修改列表中的元素， 但是tuple一旦初始化就不能修改，不能append和insert</p>\n<h4 id=\"PyTorch-部分\"><a href=\"#PyTorch-部分\" class=\"headerlink\" title=\"PyTorch 部分\"></a>PyTorch 部分</h4><ol>\n<li>在如果在模型训练的时候，一部分卷积使用的是dataparallel一部分使用的是直接cuda (比如alexnet) 这种情况在模型参数的加载的时候，需要修改keys中包含 module.的部分（dataparallel 部分）</li>\n</ol>\n<p>方法一:<br>修改保存或者加载时的字典</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs haxe\">from collections <span class=\"hljs-keyword\">import</span> OrderedDict<br><span class=\"hljs-keyword\">new</span><span class=\"hljs-type\">_state_dict</span> = OrderedDict()<br><span class=\"hljs-keyword\">for</span> k, v <span class=\"hljs-keyword\">in</span> state_dict.items():<span class=\"hljs-type\"></span><br>    namekey = k[<span class=\"hljs-number\">7</span>:<span class=\"hljs-type\"></span>] <span class=\"hljs-keyword\">if</span> k.startswith(<span class=\"hljs-string\">&#x27;module.&#x27;</span>) <span class=\"hljs-keyword\">else</span> k<br>    <span class=\"hljs-keyword\">new</span><span class=\"hljs-type\">_state_dict</span>[namekey] = v<br></code></pre></td></tr></table></figure>\n\n<p>方法二：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">uni_model.load_state_dict(&#123;k.replace(<span class=\"hljs-string\">&#x27;module.&#x27;</span>,<span class=\"hljs-string\">&#x27;&#x27;</span>) :v <span class=\"hljs-keyword\">for</span> k,v <span class=\"hljs-keyword\">in</span> model_queue.<span class=\"hljs-builtin-name\">get</span>(<span class=\"hljs-attribute\">block</span>=<span class=\"hljs-literal\">False</span>).items() &#125;)<br></code></pre></td></tr></table></figure>\n\n\n<ol start=\"2\">\n<li>DatasetFolder类的解读<br>数据类别，是通过遍历目标文件夹，得到每个文件夹的名字，以及名字对应的下标<br>make_data返回的是 数据的路径+类别下标 序列元组 List of (sample path, class_index) tuples 得到self.samples<br>然后再在get_item函数中使用path = self.samples[index] self.loader(path) 获得图片实例</li>\n</ol>\n<p>那么我自定义的缓存，既可以在MyDataSet里面的DataSet_ImageNet里面修改，判断是应该从缓存中取还是从文件系统；<br>也可以修改ImageFolder, 里面加一个缓存， 在self.loader那里加上if-else判断语句</p>\n<p>但是多进程会初始化多个dataset, 这样每个进程都会有一个cache， 我的目的应该是只有一个cache, 然后多进程从里面都可以从这个cache中取数据；而且多进程如果每一轮的dataset的实例被销毁的话会导致<br>cache也会被销毁</p>\n<ol start=\"3\">\n<li>DatasetLoader类的解读<br>问题：<br>worker_init_fn， prefetch_factor 和persistent_workers（保持被实例化的Dataset在下一轮仍然保持alive） 的作用是什么<br>warning中表示如果spwarn start method被使用， 那么worker_init_fn 不能是一个unpicklable object</li>\n</ol>\n<p>_MultiProcessingDataLoaderIter 可以学习一下多进程的退出<br>使用了三个队列 index_queue worker_result_queue data_queue</p>\n<p>workers_done_event 检测一个迭代器是否shut down, 如果一个迭代器进行shutdown，那么那个进程的input_queue里面的数据只需要为None就好了， 就不用一直等待那个queue里面的数据</p>\n<p>为什么要使用 cancel_join_thread()  index_queue.cancel_join_thread()</p>\n<p>记录：<br>多进程每个进程都可以创建多个dataset实例(这个好像是错的), 是否在主函数中初始化一个cacheout类，然后作为dataset的参数传过去，这样多进程也是使用的一个cache<br>主要的逻辑</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(self._num_workers):<br>            <span class=\"hljs-comment\"># No certainty which module multiprocessing_context is</span><br>            index_queue = multiprocessing_context.Queue()  <span class=\"hljs-comment\"># type: ignore</span><br>            <span class=\"hljs-comment\"># Need to `cancel_join_thread` here!</span><br>            <span class=\"hljs-comment\"># See sections (2) and (3b) above.</span><br>            index_queue.cancel_join_thread()<br>            w = multiprocessing_context.Process(<br>                target=_utils.worker._worker_loop,<br>                args=(self._dataset_kind, self._dataset, index_queue,<br>                      self._worker_result_queue, self._workers_done_event,<br>                      self._auto_collation, self._collate_fn, self._drop_last,<br>                      self._base_seed + i, self._worker_init_fn, i, self._num_workers,<br>                      self._persistent_workers))<br></code></pre></td></tr></table></figure>\n<p>只有一个worker_result_queue, 以及多个result_queue; 如果pin_memory=True, 那么会将worker_result_queue里面的数据，全部放在另外一个_data_queue中</p>\n<h4 id=\"pyTorch取数据过程详解（面试版本）\"><a href=\"#pyTorch取数据过程详解（面试版本）\" class=\"headerlink\" title=\"pyTorch取数据过程详解（面试版本）\"></a>pyTorch取数据过程详解（面试版本）</h4><ol>\n<li>初始化的时候，每个进程都会拥有自己的index_queue,里面最多存储两个batch 的index</li>\n<li>每个worker会不断判断自己的index_queue里面有没有数据，如果有，那么就取读一个batch, 读取的时候调用collate_fn函数，读取之后放入多进程共享的data_queue / worker_result_queue 里面</li>\n<li>data_queue里面的数据会先放入reorder字典中进行重新排序，如果需要的下一个batch在reorder_dict里面，那么就从reorder_dict中弹出这个数据，否则就等待</li>\n<li>某个worker读取的数据被消耗之后，dataloader就会将新的index放到对应worker的index_queue里面，这个worker就继续从queue里面读下标和取数据<br>参考：<br><a href=\"https://www.dazhuanlan.com/yiliabi/topics/1111356\">https://www.dazhuanlan.com/yiliabi/topics/1111356</a></li>\n</ol>\n<ol start=\"4\">\n<li>代码常见标记<br>TODO：英语翻译为待办事项，备忘录。如果代码中有该标识，说明在标识处有功能代码待编写，待实现的功能在说明中会简略说明。</li>\n</ol>\n<p>FIXME：可以拆成短语，fix me ，意为修理我。如果代码中有该标识，说明标识处代码需要修正，甚至代码是错误的，不能工作，需要修复，如何修正会在说明中简略说明。</p>\n<p>XXX：如果代码中有该标识，说明标识处代码虽然实现了功能，但是实现的方法有待商榷，希望将来能改进，要改进的地方会在说明中简略说明。</p>\n<p>HACK：英语翻译为砍。如果代码中有该标识，说明标识处代码我们需要根据自己的需求去调整程序代码。</p>\n<ol start=\"5\">\n<li><p>pytorch安装各种版本链接：<br><a href=\"https://pytorch.org/get-started/previous-versions/\">https://pytorch.org/get-started/previous-versions/</a></p>\n</li>\n<li><p>pytorch 多进程数据加载流程</p>\n</li>\n</ol>\n<ol start=\"7\">\n<li>iterator和next函数的关系<br>生成器都是iterator对象<br>可以被next函数调用的都是一个iterator对象，Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。直到没有数据时抛出StopIteration错误。<br>list/dict/str这些是iterable但是不是iterator</li>\n</ol>\n<p>Python的for循环本质上就是通过不断调用next()函数实现的，首先需要将list作为参数，传入iter函数中，获得一个iterator对象，然后才能调用next函数</p>\n","site":{"data":{}},"wordcount":3611,"excerpt":"","more":"<h4 id=\"Python语言部分\"><a href=\"#Python语言部分\" class=\"headerlink\" title=\"Python语言部分\"></a>Python语言部分</h4><ol>\n<li>python 开启debug模式，使用logger.setLevel 以及在logger的时候设置不同的logger.info  logger.error  logger.warning等</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> logging<br><span class=\"hljs-keyword\">import</span> requests<br>logging.basicConfig(level=logging.DEBUG,<br>                    <span class=\"hljs-built_in\">format</span>=<span class=\"hljs-string\">&#x27;%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s&#x27;</span>,<br>                    datefmt=<span class=\"hljs-string\">&#x27;%a, %d %b %Y %H:%M:%S&#x27;</span>,<br>                    filename=<span class=\"hljs-string\">&#x27;myapp.log&#x27;</span>,<br>                    filemode=<span class=\"hljs-string\">&#x27;w&#x27;</span>)<br> <br>logging.debug(session.get(<span class=\"hljs-string\">&#x27;http://www.qq.com&#x27;</span>))<br>logging.debug(session.get(<span class=\"hljs-string\">&#x27;http://www.qq.com&#x27;</span>))<br><br></code></pre></td></tr></table></figure>\n\n\n<p>tuple和list的区别</p>\n<p>tuple和list都可以通过下标访问元素，但是list是可以修改列表中的元素， 但是tuple一旦初始化就不能修改，不能append和insert</p>\n<h4 id=\"PyTorch-部分\"><a href=\"#PyTorch-部分\" class=\"headerlink\" title=\"PyTorch 部分\"></a>PyTorch 部分</h4><ol>\n<li>在如果在模型训练的时候，一部分卷积使用的是dataparallel一部分使用的是直接cuda (比如alexnet) 这种情况在模型参数的加载的时候，需要修改keys中包含 module.的部分（dataparallel 部分）</li>\n</ol>\n<p>方法一:<br>修改保存或者加载时的字典</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs haxe\">from collections <span class=\"hljs-keyword\">import</span> OrderedDict<br><span class=\"hljs-keyword\">new</span><span class=\"hljs-type\">_state_dict</span> = OrderedDict()<br><span class=\"hljs-keyword\">for</span> k, v <span class=\"hljs-keyword\">in</span> state_dict.items():<span class=\"hljs-type\"></span><br>    namekey = k[<span class=\"hljs-number\">7</span>:<span class=\"hljs-type\"></span>] <span class=\"hljs-keyword\">if</span> k.startswith(<span class=\"hljs-string\">&#x27;module.&#x27;</span>) <span class=\"hljs-keyword\">else</span> k<br>    <span class=\"hljs-keyword\">new</span><span class=\"hljs-type\">_state_dict</span>[namekey] = v<br></code></pre></td></tr></table></figure>\n\n<p>方法二：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">uni_model.load_state_dict(&#123;k.replace(<span class=\"hljs-string\">&#x27;module.&#x27;</span>,<span class=\"hljs-string\">&#x27;&#x27;</span>) :v <span class=\"hljs-keyword\">for</span> k,v <span class=\"hljs-keyword\">in</span> model_queue.<span class=\"hljs-builtin-name\">get</span>(<span class=\"hljs-attribute\">block</span>=<span class=\"hljs-literal\">False</span>).items() &#125;)<br></code></pre></td></tr></table></figure>\n\n\n<ol start=\"2\">\n<li>DatasetFolder类的解读<br>数据类别，是通过遍历目标文件夹，得到每个文件夹的名字，以及名字对应的下标<br>make_data返回的是 数据的路径+类别下标 序列元组 List of (sample path, class_index) tuples 得到self.samples<br>然后再在get_item函数中使用path = self.samples[index] self.loader(path) 获得图片实例</li>\n</ol>\n<p>那么我自定义的缓存，既可以在MyDataSet里面的DataSet_ImageNet里面修改，判断是应该从缓存中取还是从文件系统；<br>也可以修改ImageFolder, 里面加一个缓存， 在self.loader那里加上if-else判断语句</p>\n<p>但是多进程会初始化多个dataset, 这样每个进程都会有一个cache， 我的目的应该是只有一个cache, 然后多进程从里面都可以从这个cache中取数据；而且多进程如果每一轮的dataset的实例被销毁的话会导致<br>cache也会被销毁</p>\n<ol start=\"3\">\n<li>DatasetLoader类的解读<br>问题：<br>worker_init_fn， prefetch_factor 和persistent_workers（保持被实例化的Dataset在下一轮仍然保持alive） 的作用是什么<br>warning中表示如果spwarn start method被使用， 那么worker_init_fn 不能是一个unpicklable object</li>\n</ol>\n<p>_MultiProcessingDataLoaderIter 可以学习一下多进程的退出<br>使用了三个队列 index_queue worker_result_queue data_queue</p>\n<p>workers_done_event 检测一个迭代器是否shut down, 如果一个迭代器进行shutdown，那么那个进程的input_queue里面的数据只需要为None就好了， 就不用一直等待那个queue里面的数据</p>\n<p>为什么要使用 cancel_join_thread()  index_queue.cancel_join_thread()</p>\n<p>记录：<br>多进程每个进程都可以创建多个dataset实例(这个好像是错的), 是否在主函数中初始化一个cacheout类，然后作为dataset的参数传过去，这样多进程也是使用的一个cache<br>主要的逻辑</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(self._num_workers):<br>            <span class=\"hljs-comment\"># No certainty which module multiprocessing_context is</span><br>            index_queue = multiprocessing_context.Queue()  <span class=\"hljs-comment\"># type: ignore</span><br>            <span class=\"hljs-comment\"># Need to `cancel_join_thread` here!</span><br>            <span class=\"hljs-comment\"># See sections (2) and (3b) above.</span><br>            index_queue.cancel_join_thread()<br>            w = multiprocessing_context.Process(<br>                target=_utils.worker._worker_loop,<br>                args=(self._dataset_kind, self._dataset, index_queue,<br>                      self._worker_result_queue, self._workers_done_event,<br>                      self._auto_collation, self._collate_fn, self._drop_last,<br>                      self._base_seed + i, self._worker_init_fn, i, self._num_workers,<br>                      self._persistent_workers))<br></code></pre></td></tr></table></figure>\n<p>只有一个worker_result_queue, 以及多个result_queue; 如果pin_memory=True, 那么会将worker_result_queue里面的数据，全部放在另外一个_data_queue中</p>\n<h4 id=\"pyTorch取数据过程详解（面试版本）\"><a href=\"#pyTorch取数据过程详解（面试版本）\" class=\"headerlink\" title=\"pyTorch取数据过程详解（面试版本）\"></a>pyTorch取数据过程详解（面试版本）</h4><ol>\n<li>初始化的时候，每个进程都会拥有自己的index_queue,里面最多存储两个batch 的index</li>\n<li>每个worker会不断判断自己的index_queue里面有没有数据，如果有，那么就取读一个batch, 读取的时候调用collate_fn函数，读取之后放入多进程共享的data_queue / worker_result_queue 里面</li>\n<li>data_queue里面的数据会先放入reorder字典中进行重新排序，如果需要的下一个batch在reorder_dict里面，那么就从reorder_dict中弹出这个数据，否则就等待</li>\n<li>某个worker读取的数据被消耗之后，dataloader就会将新的index放到对应worker的index_queue里面，这个worker就继续从queue里面读下标和取数据<br>参考：<br><a href=\"https://www.dazhuanlan.com/yiliabi/topics/1111356\">https://www.dazhuanlan.com/yiliabi/topics/1111356</a></li>\n</ol>\n<ol start=\"4\">\n<li>代码常见标记<br>TODO：英语翻译为待办事项，备忘录。如果代码中有该标识，说明在标识处有功能代码待编写，待实现的功能在说明中会简略说明。</li>\n</ol>\n<p>FIXME：可以拆成短语，fix me ，意为修理我。如果代码中有该标识，说明标识处代码需要修正，甚至代码是错误的，不能工作，需要修复，如何修正会在说明中简略说明。</p>\n<p>XXX：如果代码中有该标识，说明标识处代码虽然实现了功能，但是实现的方法有待商榷，希望将来能改进，要改进的地方会在说明中简略说明。</p>\n<p>HACK：英语翻译为砍。如果代码中有该标识，说明标识处代码我们需要根据自己的需求去调整程序代码。</p>\n<ol start=\"5\">\n<li><p>pytorch安装各种版本链接：<br><a href=\"https://pytorch.org/get-started/previous-versions/\">https://pytorch.org/get-started/previous-versions/</a></p>\n</li>\n<li><p>pytorch 多进程数据加载流程</p>\n</li>\n</ol>\n<ol start=\"7\">\n<li>iterator和next函数的关系<br>生成器都是iterator对象<br>可以被next函数调用的都是一个iterator对象，Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。直到没有数据时抛出StopIteration错误。<br>list/dict/str这些是iterable但是不是iterator</li>\n</ol>\n<p>Python的for循环本质上就是通过不断调用next()函数实现的，首先需要将list作为参数，传入iter函数中，获得一个iterator对象，然后才能调用next函数</p>\n"},{"title":"rclone","date":"2021-11-08T13:39:25.000Z","_content":"\n### 从google drive中下载文件的两种方法\n\n#### 1.让远程服务器使用rclone挂载google drive (谷歌云端硬盘)\n\n简易步骤：\n1. 下载rclone:\n``` bash\nwget https://www.moerats.com/usr/shell/rclone_debian.sh && bash rclone_debian.sh\n```\n\n2. rclone的配置\n\n``` bash\nrclone config\n```\n\n3.使用rclone进行google drive的挂载\n\n``` bash \n#新建本地文件夹，路径自己定，即下面的LocalFolder\nmkdir /root/GoogleDrive\n#挂载为磁盘，下面的DriveName、Folder、LocalFolder参数根据说明自行替换\nrclone mount DriveName:Folder LocalFolder --copy-links --no-gzip-encoding --no-check-certificate --allow-other --allow-non-empty --umask 000\n\n#eg. DriveName:Folader ==> GoogleDrive:/   LoacalFolder ==> /data1/shu \n\n#rclone取消挂载\nfusermount -qzu <本地路径>\n```\n\n参考链接： https://www.moerats.com/archives/481/\n\n\n#### 2. 从google drive中使用wget下载单个文件 \n\n1.下载小文件\n\n``` bash\nwget --no-check-certificate 'https://docs.google.com/uc?export=download&id=FILEID' -O FILENAME\n\n#有的评论说针对rar文件需要加上-r\nwget --no-check-certificate -r 'https://docs.google.com/uc?export=download&id=FILEID' -O FILENAME\n```\n\n2.下载大文件\n\n``` bash\nwget --load-cookies /tmp/cookies.txt \"https://docs.google.com/uc?export=download&confirm=$(wget --quiet --save-cookies /tmp/cookies.txt --keep-session-cookies --no-check-certificate 'https://docs.google.com/uc?export=download&id=FILEID' -O- | sed -rn 's/.*confirm=([0-9A-Za-z_]+).*/\\1\\n/p')&id=FILEID\" -O FILENAME && rm -rf /tmp/cookies.txt\n\n```\n\nPS:注意都是下载的文件，不是文件夹; folder目前找到的解决方案是使用循环\n\n\n参考链接： https://gist.github.com/iamtekeste/3cdfd0366ebfd2c0d805\n\n\n\n\n","source":"_posts/工具相关/rclone.md","raw":"---\ntitle: rclone\ncategories:\n  - 工具相关\ndate: 2021-11-08 21:39:25\ntags:\n---\n\n### 从google drive中下载文件的两种方法\n\n#### 1.让远程服务器使用rclone挂载google drive (谷歌云端硬盘)\n\n简易步骤：\n1. 下载rclone:\n``` bash\nwget https://www.moerats.com/usr/shell/rclone_debian.sh && bash rclone_debian.sh\n```\n\n2. rclone的配置\n\n``` bash\nrclone config\n```\n\n3.使用rclone进行google drive的挂载\n\n``` bash \n#新建本地文件夹，路径自己定，即下面的LocalFolder\nmkdir /root/GoogleDrive\n#挂载为磁盘，下面的DriveName、Folder、LocalFolder参数根据说明自行替换\nrclone mount DriveName:Folder LocalFolder --copy-links --no-gzip-encoding --no-check-certificate --allow-other --allow-non-empty --umask 000\n\n#eg. DriveName:Folader ==> GoogleDrive:/   LoacalFolder ==> /data1/shu \n\n#rclone取消挂载\nfusermount -qzu <本地路径>\n```\n\n参考链接： https://www.moerats.com/archives/481/\n\n\n#### 2. 从google drive中使用wget下载单个文件 \n\n1.下载小文件\n\n``` bash\nwget --no-check-certificate 'https://docs.google.com/uc?export=download&id=FILEID' -O FILENAME\n\n#有的评论说针对rar文件需要加上-r\nwget --no-check-certificate -r 'https://docs.google.com/uc?export=download&id=FILEID' -O FILENAME\n```\n\n2.下载大文件\n\n``` bash\nwget --load-cookies /tmp/cookies.txt \"https://docs.google.com/uc?export=download&confirm=$(wget --quiet --save-cookies /tmp/cookies.txt --keep-session-cookies --no-check-certificate 'https://docs.google.com/uc?export=download&id=FILEID' -O- | sed -rn 's/.*confirm=([0-9A-Za-z_]+).*/\\1\\n/p')&id=FILEID\" -O FILENAME && rm -rf /tmp/cookies.txt\n\n```\n\nPS:注意都是下载的文件，不是文件夹; folder目前找到的解决方案是使用循环\n\n\n参考链接： https://gist.github.com/iamtekeste/3cdfd0366ebfd2c0d805\n\n\n\n\n","slug":"工具相关/rclone","published":1,"updated":"2021-11-13T12:27:48.242Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clk5ceio80029jpjb1rzzdac7","content":"<h3 id=\"从google-drive中下载文件的两种方法\"><a href=\"#从google-drive中下载文件的两种方法\" class=\"headerlink\" title=\"从google drive中下载文件的两种方法\"></a>从google drive中下载文件的两种方法</h3><h4 id=\"1-让远程服务器使用rclone挂载google-drive-谷歌云端硬盘\"><a href=\"#1-让远程服务器使用rclone挂载google-drive-谷歌云端硬盘\" class=\"headerlink\" title=\"1.让远程服务器使用rclone挂载google drive (谷歌云端硬盘)\"></a>1.让远程服务器使用rclone挂载google drive (谷歌云端硬盘)</h4><p>简易步骤：</p>\n<ol>\n<li><p>下载rclone:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">wget https://www.moerats.com/usr/shell/rclone_debian.sh &amp;&amp; bash rclone_debian.sh<br></code></pre></td></tr></table></figure></li>\n<li><p>rclone的配置</p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">rclone config<br></code></pre></td></tr></table></figure>\n\n<p>3.使用rclone进行google drive的挂载</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#新建本地文件夹，路径自己定，即下面的LocalFolder</span><br>mkdir /root/GoogleDrive<br><span class=\"hljs-comment\">#挂载为磁盘，下面的DriveName、Folder、LocalFolder参数根据说明自行替换</span><br>rclone mount DriveName:Folder LocalFolder --copy-links --no-gzip-encoding --no-check-certificate --allow-other --allow-non-empty --<span class=\"hljs-built_in\">umask</span> 000<br><br><span class=\"hljs-comment\">#eg. DriveName:Folader ==&gt; GoogleDrive:/   LoacalFolder ==&gt; /data1/shu </span><br><br><span class=\"hljs-comment\">#rclone取消挂载</span><br>fusermount -qzu &lt;本地路径&gt;<br></code></pre></td></tr></table></figure>\n\n<p>参考链接： <a href=\"https://www.moerats.com/archives/481/\">https://www.moerats.com/archives/481/</a></p>\n<h4 id=\"2-从google-drive中使用wget下载单个文件\"><a href=\"#2-从google-drive中使用wget下载单个文件\" class=\"headerlink\" title=\"2. 从google drive中使用wget下载单个文件\"></a>2. 从google drive中使用wget下载单个文件</h4><p>1.下载小文件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">wget --no-check-certificate <span class=\"hljs-string\">&#x27;https://docs.google.com/uc?export=download&amp;id=FILEID&#x27;</span> -O FILENAME<br><br><span class=\"hljs-comment\">#有的评论说针对rar文件需要加上-r</span><br>wget --no-check-certificate -r <span class=\"hljs-string\">&#x27;https://docs.google.com/uc?export=download&amp;id=FILEID&#x27;</span> -O FILENAME<br></code></pre></td></tr></table></figure>\n\n<p>2.下载大文件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">wget --load-cookies /tmp/cookies.txt <span class=\"hljs-string\">&quot;https://docs.google.com/uc?export=download&amp;confirm=<span class=\"hljs-subst\">$(wget --quiet --save-cookies /tmp/cookies.txt --keep-session-cookies --no-check-certificate &#x27;https://docs.google.com/uc?export=download&amp;id=FILEID&#x27; -O- | sed -rn &#x27;s/.*confirm=([0-9A-Za-z_]+)</span>.*/\\1\\n/p&#x27;)&amp;id=FILEID&quot;</span> -O FILENAME &amp;&amp; rm -rf /tmp/cookies.txt<br><br></code></pre></td></tr></table></figure>\n\n<p>PS:注意都是下载的文件，不是文件夹; folder目前找到的解决方案是使用循环</p>\n<p>参考链接： <a href=\"https://gist.github.com/iamtekeste/3cdfd0366ebfd2c0d805\">https://gist.github.com/iamtekeste/3cdfd0366ebfd2c0d805</a></p>\n","site":{"data":{}},"wordcount":1337,"excerpt":"","more":"<h3 id=\"从google-drive中下载文件的两种方法\"><a href=\"#从google-drive中下载文件的两种方法\" class=\"headerlink\" title=\"从google drive中下载文件的两种方法\"></a>从google drive中下载文件的两种方法</h3><h4 id=\"1-让远程服务器使用rclone挂载google-drive-谷歌云端硬盘\"><a href=\"#1-让远程服务器使用rclone挂载google-drive-谷歌云端硬盘\" class=\"headerlink\" title=\"1.让远程服务器使用rclone挂载google drive (谷歌云端硬盘)\"></a>1.让远程服务器使用rclone挂载google drive (谷歌云端硬盘)</h4><p>简易步骤：</p>\n<ol>\n<li><p>下载rclone:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">wget https://www.moerats.com/usr/shell/rclone_debian.sh &amp;&amp; bash rclone_debian.sh<br></code></pre></td></tr></table></figure></li>\n<li><p>rclone的配置</p>\n</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">rclone config<br></code></pre></td></tr></table></figure>\n\n<p>3.使用rclone进行google drive的挂载</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">#新建本地文件夹，路径自己定，即下面的LocalFolder</span><br>mkdir /root/GoogleDrive<br><span class=\"hljs-comment\">#挂载为磁盘，下面的DriveName、Folder、LocalFolder参数根据说明自行替换</span><br>rclone mount DriveName:Folder LocalFolder --copy-links --no-gzip-encoding --no-check-certificate --allow-other --allow-non-empty --<span class=\"hljs-built_in\">umask</span> 000<br><br><span class=\"hljs-comment\">#eg. DriveName:Folader ==&gt; GoogleDrive:/   LoacalFolder ==&gt; /data1/shu </span><br><br><span class=\"hljs-comment\">#rclone取消挂载</span><br>fusermount -qzu &lt;本地路径&gt;<br></code></pre></td></tr></table></figure>\n\n<p>参考链接： <a href=\"https://www.moerats.com/archives/481/\">https://www.moerats.com/archives/481/</a></p>\n<h4 id=\"2-从google-drive中使用wget下载单个文件\"><a href=\"#2-从google-drive中使用wget下载单个文件\" class=\"headerlink\" title=\"2. 从google drive中使用wget下载单个文件\"></a>2. 从google drive中使用wget下载单个文件</h4><p>1.下载小文件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">wget --no-check-certificate <span class=\"hljs-string\">&#x27;https://docs.google.com/uc?export=download&amp;id=FILEID&#x27;</span> -O FILENAME<br><br><span class=\"hljs-comment\">#有的评论说针对rar文件需要加上-r</span><br>wget --no-check-certificate -r <span class=\"hljs-string\">&#x27;https://docs.google.com/uc?export=download&amp;id=FILEID&#x27;</span> -O FILENAME<br></code></pre></td></tr></table></figure>\n\n<p>2.下载大文件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">wget --load-cookies /tmp/cookies.txt <span class=\"hljs-string\">&quot;https://docs.google.com/uc?export=download&amp;confirm=<span class=\"hljs-subst\">$(wget --quiet --save-cookies /tmp/cookies.txt --keep-session-cookies --no-check-certificate &#x27;https://docs.google.com/uc?export=download&amp;id=FILEID&#x27; -O- | sed -rn &#x27;s/.*confirm=([0-9A-Za-z_]+)</span>.*/\\1\\n/p&#x27;)&amp;id=FILEID&quot;</span> -O FILENAME &amp;&amp; rm -rf /tmp/cookies.txt<br><br></code></pre></td></tr></table></figure>\n\n<p>PS:注意都是下载的文件，不是文件夹; folder目前找到的解决方案是使用循环</p>\n<p>参考链接： <a href=\"https://gist.github.com/iamtekeste/3cdfd0366ebfd2c0d805\">https://gist.github.com/iamtekeste/3cdfd0366ebfd2c0d805</a></p>\n"},{"title":"RPC related","date":"2021-12-03T02:01:07.000Z","_content":"\ngRPC 可以保证不同语言之间的通讯\n编写.proto文件，生成指定语言源代码。\n编写服务端代码\n编写客户端代码\nhttps://www.liwenzhou.com/posts/Go/gRPC/  一个python客户端和go服务端的例子\n\n\npytorch的官网框架\nrpc常见方法\nrpc_sync同步远程调用、rpc_async异步远程调用、remote异步远程调用。\n\nrpc.init_rpc 初始化rpc，需要在master和worker都进行初始化，方便之后的通讯\nrpc.rpc_sync  worker端调用在master上进行执行的方法\nrpc.rpc_async  \nrpc.remote\n\n\n\n\ndist_autograd.get_gradient(cid) 目前猜测在rpc场景进行前向传播，的梯度反向传播需要使用dist_grad\n\nTrainNet是worker调用的假的网络，实际的网络是在Net里面调用，每次worker里面数据的前向传播，实际上都是在master里面的调用net进行前向传播\n### 分析rpc_parameter_server代码\nmaster和worker都需要init_rpc\n\nworker里面主要执行TrainNet：初始化的时候得到远程parameterServer的引用，然后包含二个函数 get_global_param_rref 以及forward函数(均要调用remote_method)\nmaster里面执行parameterServer类，：初始的时候，得到真实训练的model, 同时实现三个函数, 对模型参数加上的引用rpc.RRef，使用dist_autograd得到模型参数，以及对输入数据进行前向传播\n\n在master中加上\n\nuni_sample_score_rref\n\n\n### gRPC\n\nroute_guide_client文件主要是通过stub 和传入的参数调用server的函数\n\nroute_guide_server里面主要是编写得到输入服务器处理函数逻辑\n\nroute_guide_pb2_grpc，类似于头文件，定义Stub类和Servicer类，每个类只是定义函数，但不进行具体的实现； 以及一个add_RouteGuideServicer_to_server的函数\n\n \n#### 使用go语言\n- 前置安装要求\n安装go，和protocol buffer编译器\nhttps://grpc.io/docs/languages/go/quickstart/#prerequisites\n\ngo command not found\n使用export， 重启一个控制台窗口就找不到这个命令了\n需要使用vim ~/.bashrc写入文件 将这个命令写进去，然后使用source ~/.bashrc\n(~/.bashrc:是用户相关的终端（shell）的环境设置，通常打开一个新终端时，默认会load里面的设置，在这里的设置不影响其它人。\n/etc/profile会影响所有的用户)\n\ngo download超时解决：\nexport GOPROXY=https://goproxy.cn\n\n\n#### 使用python\n一个python小例子：https://grpc.io/docs/languages/python/quickstart/","source":"_posts/工具相关/rpc.md","raw":"---\ntitle: RPC related\ncategories:\n  - 工具相关\ndate: 2021-12-03 10:01:07\ntags:\n---\n\ngRPC 可以保证不同语言之间的通讯\n编写.proto文件，生成指定语言源代码。\n编写服务端代码\n编写客户端代码\nhttps://www.liwenzhou.com/posts/Go/gRPC/  一个python客户端和go服务端的例子\n\n\npytorch的官网框架\nrpc常见方法\nrpc_sync同步远程调用、rpc_async异步远程调用、remote异步远程调用。\n\nrpc.init_rpc 初始化rpc，需要在master和worker都进行初始化，方便之后的通讯\nrpc.rpc_sync  worker端调用在master上进行执行的方法\nrpc.rpc_async  \nrpc.remote\n\n\n\n\ndist_autograd.get_gradient(cid) 目前猜测在rpc场景进行前向传播，的梯度反向传播需要使用dist_grad\n\nTrainNet是worker调用的假的网络，实际的网络是在Net里面调用，每次worker里面数据的前向传播，实际上都是在master里面的调用net进行前向传播\n### 分析rpc_parameter_server代码\nmaster和worker都需要init_rpc\n\nworker里面主要执行TrainNet：初始化的时候得到远程parameterServer的引用，然后包含二个函数 get_global_param_rref 以及forward函数(均要调用remote_method)\nmaster里面执行parameterServer类，：初始的时候，得到真实训练的model, 同时实现三个函数, 对模型参数加上的引用rpc.RRef，使用dist_autograd得到模型参数，以及对输入数据进行前向传播\n\n在master中加上\n\nuni_sample_score_rref\n\n\n### gRPC\n\nroute_guide_client文件主要是通过stub 和传入的参数调用server的函数\n\nroute_guide_server里面主要是编写得到输入服务器处理函数逻辑\n\nroute_guide_pb2_grpc，类似于头文件，定义Stub类和Servicer类，每个类只是定义函数，但不进行具体的实现； 以及一个add_RouteGuideServicer_to_server的函数\n\n \n#### 使用go语言\n- 前置安装要求\n安装go，和protocol buffer编译器\nhttps://grpc.io/docs/languages/go/quickstart/#prerequisites\n\ngo command not found\n使用export， 重启一个控制台窗口就找不到这个命令了\n需要使用vim ~/.bashrc写入文件 将这个命令写进去，然后使用source ~/.bashrc\n(~/.bashrc:是用户相关的终端（shell）的环境设置，通常打开一个新终端时，默认会load里面的设置，在这里的设置不影响其它人。\n/etc/profile会影响所有的用户)\n\ngo download超时解决：\nexport GOPROXY=https://goproxy.cn\n\n\n#### 使用python\n一个python小例子：https://grpc.io/docs/languages/python/quickstart/","slug":"工具相关/rpc","published":1,"updated":"2023-07-10T10:36:19.582Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clk5ceio9002bjpjbg2ag3u1b","content":"<p>gRPC 可以保证不同语言之间的通讯<br>编写.proto文件，生成指定语言源代码。<br>编写服务端代码<br>编写客户端代码<br><a href=\"https://www.liwenzhou.com/posts/Go/gRPC/\">https://www.liwenzhou.com/posts/Go/gRPC/</a>  一个python客户端和go服务端的例子</p>\n<p>pytorch的官网框架<br>rpc常见方法<br>rpc_sync同步远程调用、rpc_async异步远程调用、remote异步远程调用。</p>\n<p>rpc.init_rpc 初始化rpc，需要在master和worker都进行初始化，方便之后的通讯<br>rpc.rpc_sync  worker端调用在master上进行执行的方法<br>rpc.rpc_async<br>rpc.remote</p>\n<p>dist_autograd.get_gradient(cid) 目前猜测在rpc场景进行前向传播，的梯度反向传播需要使用dist_grad</p>\n<p>TrainNet是worker调用的假的网络，实际的网络是在Net里面调用，每次worker里面数据的前向传播，实际上都是在master里面的调用net进行前向传播</p>\n<h3 id=\"分析rpc-parameter-server代码\"><a href=\"#分析rpc-parameter-server代码\" class=\"headerlink\" title=\"分析rpc_parameter_server代码\"></a>分析rpc_parameter_server代码</h3><p>master和worker都需要init_rpc</p>\n<p>worker里面主要执行TrainNet：初始化的时候得到远程parameterServer的引用，然后包含二个函数 get_global_param_rref 以及forward函数(均要调用remote_method)<br>master里面执行parameterServer类，：初始的时候，得到真实训练的model, 同时实现三个函数, 对模型参数加上的引用rpc.RRef，使用dist_autograd得到模型参数，以及对输入数据进行前向传播</p>\n<p>在master中加上</p>\n<p>uni_sample_score_rref</p>\n<h3 id=\"gRPC\"><a href=\"#gRPC\" class=\"headerlink\" title=\"gRPC\"></a>gRPC</h3><p>route_guide_client文件主要是通过stub 和传入的参数调用server的函数</p>\n<p>route_guide_server里面主要是编写得到输入服务器处理函数逻辑</p>\n<p>route_guide_pb2_grpc，类似于头文件，定义Stub类和Servicer类，每个类只是定义函数，但不进行具体的实现； 以及一个add_RouteGuideServicer_to_server的函数</p>\n<h4 id=\"使用go语言\"><a href=\"#使用go语言\" class=\"headerlink\" title=\"使用go语言\"></a>使用go语言</h4><ul>\n<li>前置安装要求<br>安装go，和protocol buffer编译器<br><a href=\"https://grpc.io/docs/languages/go/quickstart/#prerequisites\">https://grpc.io/docs/languages/go/quickstart/#prerequisites</a></li>\n</ul>\n<p>go command not found<br>使用export， 重启一个控制台窗口就找不到这个命令了<br>需要使用vim <del>/.bashrc写入文件 将这个命令写进去，然后使用source ~/.bashrc<br>(</del>/.bashrc:是用户相关的终端（shell）的环境设置，通常打开一个新终端时，默认会load里面的设置，在这里的设置不影响其它人。<br>/etc/profile会影响所有的用户)</p>\n<p>go download超时解决：<br>export GOPROXY=<a href=\"https://goproxy.cn/\">https://goproxy.cn</a></p>\n<h4 id=\"使用python\"><a href=\"#使用python\" class=\"headerlink\" title=\"使用python\"></a>使用python</h4><p>一个python小例子：<a href=\"https://grpc.io/docs/languages/python/quickstart/\">https://grpc.io/docs/languages/python/quickstart/</a></p>\n","site":{"data":{}},"wordcount":1314,"excerpt":"","more":"<p>gRPC 可以保证不同语言之间的通讯<br>编写.proto文件，生成指定语言源代码。<br>编写服务端代码<br>编写客户端代码<br><a href=\"https://www.liwenzhou.com/posts/Go/gRPC/\">https://www.liwenzhou.com/posts/Go/gRPC/</a>  一个python客户端和go服务端的例子</p>\n<p>pytorch的官网框架<br>rpc常见方法<br>rpc_sync同步远程调用、rpc_async异步远程调用、remote异步远程调用。</p>\n<p>rpc.init_rpc 初始化rpc，需要在master和worker都进行初始化，方便之后的通讯<br>rpc.rpc_sync  worker端调用在master上进行执行的方法<br>rpc.rpc_async<br>rpc.remote</p>\n<p>dist_autograd.get_gradient(cid) 目前猜测在rpc场景进行前向传播，的梯度反向传播需要使用dist_grad</p>\n<p>TrainNet是worker调用的假的网络，实际的网络是在Net里面调用，每次worker里面数据的前向传播，实际上都是在master里面的调用net进行前向传播</p>\n<h3 id=\"分析rpc-parameter-server代码\"><a href=\"#分析rpc-parameter-server代码\" class=\"headerlink\" title=\"分析rpc_parameter_server代码\"></a>分析rpc_parameter_server代码</h3><p>master和worker都需要init_rpc</p>\n<p>worker里面主要执行TrainNet：初始化的时候得到远程parameterServer的引用，然后包含二个函数 get_global_param_rref 以及forward函数(均要调用remote_method)<br>master里面执行parameterServer类，：初始的时候，得到真实训练的model, 同时实现三个函数, 对模型参数加上的引用rpc.RRef，使用dist_autograd得到模型参数，以及对输入数据进行前向传播</p>\n<p>在master中加上</p>\n<p>uni_sample_score_rref</p>\n<h3 id=\"gRPC\"><a href=\"#gRPC\" class=\"headerlink\" title=\"gRPC\"></a>gRPC</h3><p>route_guide_client文件主要是通过stub 和传入的参数调用server的函数</p>\n<p>route_guide_server里面主要是编写得到输入服务器处理函数逻辑</p>\n<p>route_guide_pb2_grpc，类似于头文件，定义Stub类和Servicer类，每个类只是定义函数，但不进行具体的实现； 以及一个add_RouteGuideServicer_to_server的函数</p>\n<h4 id=\"使用go语言\"><a href=\"#使用go语言\" class=\"headerlink\" title=\"使用go语言\"></a>使用go语言</h4><ul>\n<li>前置安装要求<br>安装go，和protocol buffer编译器<br><a href=\"https://grpc.io/docs/languages/go/quickstart/#prerequisites\">https://grpc.io/docs/languages/go/quickstart/#prerequisites</a></li>\n</ul>\n<p>go command not found<br>使用export， 重启一个控制台窗口就找不到这个命令了<br>需要使用vim <del>/.bashrc写入文件 将这个命令写进去，然后使用source ~/.bashrc<br>(</del>/.bashrc:是用户相关的终端（shell）的环境设置，通常打开一个新终端时，默认会load里面的设置，在这里的设置不影响其它人。<br>/etc/profile会影响所有的用户)</p>\n<p>go download超时解决：<br>export GOPROXY=<a href=\"https://goproxy.cn/\">https://goproxy.cn</a></p>\n<h4 id=\"使用python\"><a href=\"#使用python\" class=\"headerlink\" title=\"使用python\"></a>使用python</h4><p>一个python小例子：<a href=\"https://grpc.io/docs/languages/python/quickstart/\">https://grpc.io/docs/languages/python/quickstart/</a></p>\n"},{"layout":"blog","title":"scheduler_ralated","date":"2021-11-12T02:04:52.000Z","_content":"\n调度需要关注的问题/或者目标：提高资源利用率，负载均衡，用户的优先级和公平性\n\n可能是针对深度学习场景的调度，也可能是平常的请求任务\n\nParSync:调度器需要进行及时的同步，如果不及时进行同步那么就可能造成大量冲突；但是在同步的时候，如果一个调度器固定同步固定几个机器的话。就无法充分利用机器空闲资源；\n所以这篇论文提出利用分片同步的策略，就是一个调度器通过轮训的方式，分时段和多个机器进行同步；同时给最后同步的机器更高的优先级，因为它的状态最新，最可信，因此发生冲突的可能性会更小\n\n\nGavel: 针对深度学习的异构感知的集群调度策略； 将调度转为一个优化问题\n\n\n\n### 阿里项目\n\n资源池化的理解：\nCPU、内存、磁盘、I/O等硬件变成可以动态管理的“资源池”，从而提高资源的利用率，简化系统管理，实现服务器整合。核心思想：能够通过区分资源优先次序并随时随地能够将服务器资源分配给最需要它们的工作负载来简化管理和提高效率，从而减少为单个工作负载峰值而存储的资源。\n\n>池化简单来讲就是使用远程访问的形式使用GPU资源，任务使用本机的CPU和另一台机器的GPU，两者通过网络进行通信。\n\nref:https://bbs.cvmart.net/articles/3696\n\n深度学习场景下异构池化资源管理和任务调度研究\n\n池化和异构集群下的资源调度有什么区别？\n\n相关研究工作：\n\nDemand Based Hierarchical QoS Using Storage Resource Pools\n\n化零为整:将多台服务器上的GPU集合起来提供给一个容器或者一个虚拟机使用\n隔空取物：将虚拟机或者容器运行在一台没有物理 GPU 的服务器上，通过计算机网络，透明地使用另一台服务器上的 GPU 资源。\n小模型场景的典型应用：从算力和显存两个角度，对GPU资源进行切分\n\n问题：\n这个池化是GPU还是包括CPU， 存储所有资源的池化\n这个GPU的池化和云服务器有什么区别\nGPU池化之后，拉远，数据传输的开销如何弥补\n如果做到多个应用之间互不影响的，因为虽然充分应用了GPU的显存和算力资源，但是数据传输的带宽，不会因为任务量多，而相互竞争，从而影响效率吗\n\n通过算力和显存从切分， 不在一个GPU上算力和显存如何协作起来，完成一件事情\n与k8S的区别在哪里\n\n为什么需要劫持调用才能实现资源的隔离\n\n这里的调度是分配好了，就固定直到任务结束，还是像gandivia一样需要动态调整\n主要是针对deep learning 的训练 推理还是普遍多任务背景下的任务调度，与资源池化\n\n\n之后的安排：\n看一下legoos 以及一些相关论文\n看一下k8s的官方文档\n看一下ppt里面的一些链接\n讨论一下任务\n\n\n\n相关论文总结：\n### Multi-Job：\nGandiva: 主要是针对multi-job 超参数搜索的场景下的可预测性，在训练过程中，自适应的调整job, 最大化GPU资源的利用率\n\n### 训练推理混合调度：\nAntMan : Dynamic Scaling on GPU Clusters for Deep Learning\nPipeSwitch: Fast Pipelined Context Switching for Deep Learning Applications\n\n将推理任务插入训练的时间片中，充分利用GPU的资源\n\n### 池化相关\nLegoOS: A Disseminated, Distributed OS for Hardware Resource Disaggregation\n推翻常规的整体server模式，使process memory和storage通过网络来进行通讯，而不是总线，使用一个全局manager进行粗粒度的分配，然后使用一个local manager进行细粒度资源管理\n\nrCUDA remote CUDA\nrCUDA: Going Further in Remote GPU Virtualization\nVMware-vSphere-Bitfusion\n驱动科技的GPU拉远策略\n\n### 异构/集群资源调度\nScaling Large Production Clusters with Partitioned Synchronization\n主要是多个调度器对集群支援进行调度，同时为了保证调度维持较好的实时性，减低可能发生的资源竞争，使用时间片轮训的方式，让一个调度器对多个机器组成的组进行调度\n\nHiveD : Sharing a GPU Cluster for Deep Learning with Guarantees\nHeterogeneity-Aware Cluster Scheduling Policies for Deep Learning Workloads\nTopology-aware GPU scheduling for learning workloads in cloud environments\nTiresias: A GPU cluster manager for distributed deep learning\nGandiva: Introspective cluster scheduling for deep learning\n\n\n### 针对深度学习的GPU共享survey\nhttps://bbs.cvmart.net/articles/3696\n\nhttps://cloud.tencent.com/developer/article/1766184   Improving GPU Utilization in Kubernetes\n\n","source":"_posts/工具相关/scheduler-ralated.md","raw":"---\nlayout: blog\ntitle: scheduler_ralated\ndate: 2021-11-12 10:04:52\ntags: scheduler\n---\n\n调度需要关注的问题/或者目标：提高资源利用率，负载均衡，用户的优先级和公平性\n\n可能是针对深度学习场景的调度，也可能是平常的请求任务\n\nParSync:调度器需要进行及时的同步，如果不及时进行同步那么就可能造成大量冲突；但是在同步的时候，如果一个调度器固定同步固定几个机器的话。就无法充分利用机器空闲资源；\n所以这篇论文提出利用分片同步的策略，就是一个调度器通过轮训的方式，分时段和多个机器进行同步；同时给最后同步的机器更高的优先级，因为它的状态最新，最可信，因此发生冲突的可能性会更小\n\n\nGavel: 针对深度学习的异构感知的集群调度策略； 将调度转为一个优化问题\n\n\n\n### 阿里项目\n\n资源池化的理解：\nCPU、内存、磁盘、I/O等硬件变成可以动态管理的“资源池”，从而提高资源的利用率，简化系统管理，实现服务器整合。核心思想：能够通过区分资源优先次序并随时随地能够将服务器资源分配给最需要它们的工作负载来简化管理和提高效率，从而减少为单个工作负载峰值而存储的资源。\n\n>池化简单来讲就是使用远程访问的形式使用GPU资源，任务使用本机的CPU和另一台机器的GPU，两者通过网络进行通信。\n\nref:https://bbs.cvmart.net/articles/3696\n\n深度学习场景下异构池化资源管理和任务调度研究\n\n池化和异构集群下的资源调度有什么区别？\n\n相关研究工作：\n\nDemand Based Hierarchical QoS Using Storage Resource Pools\n\n化零为整:将多台服务器上的GPU集合起来提供给一个容器或者一个虚拟机使用\n隔空取物：将虚拟机或者容器运行在一台没有物理 GPU 的服务器上，通过计算机网络，透明地使用另一台服务器上的 GPU 资源。\n小模型场景的典型应用：从算力和显存两个角度，对GPU资源进行切分\n\n问题：\n这个池化是GPU还是包括CPU， 存储所有资源的池化\n这个GPU的池化和云服务器有什么区别\nGPU池化之后，拉远，数据传输的开销如何弥补\n如果做到多个应用之间互不影响的，因为虽然充分应用了GPU的显存和算力资源，但是数据传输的带宽，不会因为任务量多，而相互竞争，从而影响效率吗\n\n通过算力和显存从切分， 不在一个GPU上算力和显存如何协作起来，完成一件事情\n与k8S的区别在哪里\n\n为什么需要劫持调用才能实现资源的隔离\n\n这里的调度是分配好了，就固定直到任务结束，还是像gandivia一样需要动态调整\n主要是针对deep learning 的训练 推理还是普遍多任务背景下的任务调度，与资源池化\n\n\n之后的安排：\n看一下legoos 以及一些相关论文\n看一下k8s的官方文档\n看一下ppt里面的一些链接\n讨论一下任务\n\n\n\n相关论文总结：\n### Multi-Job：\nGandiva: 主要是针对multi-job 超参数搜索的场景下的可预测性，在训练过程中，自适应的调整job, 最大化GPU资源的利用率\n\n### 训练推理混合调度：\nAntMan : Dynamic Scaling on GPU Clusters for Deep Learning\nPipeSwitch: Fast Pipelined Context Switching for Deep Learning Applications\n\n将推理任务插入训练的时间片中，充分利用GPU的资源\n\n### 池化相关\nLegoOS: A Disseminated, Distributed OS for Hardware Resource Disaggregation\n推翻常规的整体server模式，使process memory和storage通过网络来进行通讯，而不是总线，使用一个全局manager进行粗粒度的分配，然后使用一个local manager进行细粒度资源管理\n\nrCUDA remote CUDA\nrCUDA: Going Further in Remote GPU Virtualization\nVMware-vSphere-Bitfusion\n驱动科技的GPU拉远策略\n\n### 异构/集群资源调度\nScaling Large Production Clusters with Partitioned Synchronization\n主要是多个调度器对集群支援进行调度，同时为了保证调度维持较好的实时性，减低可能发生的资源竞争，使用时间片轮训的方式，让一个调度器对多个机器组成的组进行调度\n\nHiveD : Sharing a GPU Cluster for Deep Learning with Guarantees\nHeterogeneity-Aware Cluster Scheduling Policies for Deep Learning Workloads\nTopology-aware GPU scheduling for learning workloads in cloud environments\nTiresias: A GPU cluster manager for distributed deep learning\nGandiva: Introspective cluster scheduling for deep learning\n\n\n### 针对深度学习的GPU共享survey\nhttps://bbs.cvmart.net/articles/3696\n\nhttps://cloud.tencent.com/developer/article/1766184   Improving GPU Utilization in Kubernetes\n\n","slug":"工具相关/scheduler-ralated","published":1,"updated":"2023-07-10T10:36:19.582Z","comments":1,"photos":[],"link":"","_id":"clk5ceio9002ejpjbh8yb95as","content":"<p>调度需要关注的问题/或者目标：提高资源利用率，负载均衡，用户的优先级和公平性</p>\n<p>可能是针对深度学习场景的调度，也可能是平常的请求任务</p>\n<p>ParSync:调度器需要进行及时的同步，如果不及时进行同步那么就可能造成大量冲突；但是在同步的时候，如果一个调度器固定同步固定几个机器的话。就无法充分利用机器空闲资源；<br>所以这篇论文提出利用分片同步的策略，就是一个调度器通过轮训的方式，分时段和多个机器进行同步；同时给最后同步的机器更高的优先级，因为它的状态最新，最可信，因此发生冲突的可能性会更小</p>\n<p>Gavel: 针对深度学习的异构感知的集群调度策略； 将调度转为一个优化问题</p>\n<h3 id=\"阿里项目\"><a href=\"#阿里项目\" class=\"headerlink\" title=\"阿里项目\"></a>阿里项目</h3><p>资源池化的理解：<br>CPU、内存、磁盘、I/O等硬件变成可以动态管理的“资源池”，从而提高资源的利用率，简化系统管理，实现服务器整合。核心思想：能够通过区分资源优先次序并随时随地能够将服务器资源分配给最需要它们的工作负载来简化管理和提高效率，从而减少为单个工作负载峰值而存储的资源。</p>\n<blockquote>\n<p>池化简单来讲就是使用远程访问的形式使用GPU资源，任务使用本机的CPU和另一台机器的GPU，两者通过网络进行通信。</p>\n</blockquote>\n<p>ref:<a href=\"https://bbs.cvmart.net/articles/3696\">https://bbs.cvmart.net/articles/3696</a></p>\n<p>深度学习场景下异构池化资源管理和任务调度研究</p>\n<p>池化和异构集群下的资源调度有什么区别？</p>\n<p>相关研究工作：</p>\n<p>Demand Based Hierarchical QoS Using Storage Resource Pools</p>\n<p>化零为整:将多台服务器上的GPU集合起来提供给一个容器或者一个虚拟机使用<br>隔空取物：将虚拟机或者容器运行在一台没有物理 GPU 的服务器上，通过计算机网络，透明地使用另一台服务器上的 GPU 资源。<br>小模型场景的典型应用：从算力和显存两个角度，对GPU资源进行切分</p>\n<p>问题：<br>这个池化是GPU还是包括CPU， 存储所有资源的池化<br>这个GPU的池化和云服务器有什么区别<br>GPU池化之后，拉远，数据传输的开销如何弥补<br>如果做到多个应用之间互不影响的，因为虽然充分应用了GPU的显存和算力资源，但是数据传输的带宽，不会因为任务量多，而相互竞争，从而影响效率吗</p>\n<p>通过算力和显存从切分， 不在一个GPU上算力和显存如何协作起来，完成一件事情<br>与k8S的区别在哪里</p>\n<p>为什么需要劫持调用才能实现资源的隔离</p>\n<p>这里的调度是分配好了，就固定直到任务结束，还是像gandivia一样需要动态调整<br>主要是针对deep learning 的训练 推理还是普遍多任务背景下的任务调度，与资源池化</p>\n<p>之后的安排：<br>看一下legoos 以及一些相关论文<br>看一下k8s的官方文档<br>看一下ppt里面的一些链接<br>讨论一下任务</p>\n<p>相关论文总结：</p>\n<h3 id=\"Multi-Job：\"><a href=\"#Multi-Job：\" class=\"headerlink\" title=\"Multi-Job：\"></a>Multi-Job：</h3><p>Gandiva: 主要是针对multi-job 超参数搜索的场景下的可预测性，在训练过程中，自适应的调整job, 最大化GPU资源的利用率</p>\n<h3 id=\"训练推理混合调度：\"><a href=\"#训练推理混合调度：\" class=\"headerlink\" title=\"训练推理混合调度：\"></a>训练推理混合调度：</h3><p>AntMan : Dynamic Scaling on GPU Clusters for Deep Learning<br>PipeSwitch: Fast Pipelined Context Switching for Deep Learning Applications</p>\n<p>将推理任务插入训练的时间片中，充分利用GPU的资源</p>\n<h3 id=\"池化相关\"><a href=\"#池化相关\" class=\"headerlink\" title=\"池化相关\"></a>池化相关</h3><p>LegoOS: A Disseminated, Distributed OS for Hardware Resource Disaggregation<br>推翻常规的整体server模式，使process memory和storage通过网络来进行通讯，而不是总线，使用一个全局manager进行粗粒度的分配，然后使用一个local manager进行细粒度资源管理</p>\n<p>rCUDA remote CUDA<br>rCUDA: Going Further in Remote GPU Virtualization<br>VMware-vSphere-Bitfusion<br>驱动科技的GPU拉远策略</p>\n<h3 id=\"异构-集群资源调度\"><a href=\"#异构-集群资源调度\" class=\"headerlink\" title=\"异构/集群资源调度\"></a>异构/集群资源调度</h3><p>Scaling Large Production Clusters with Partitioned Synchronization<br>主要是多个调度器对集群支援进行调度，同时为了保证调度维持较好的实时性，减低可能发生的资源竞争，使用时间片轮训的方式，让一个调度器对多个机器组成的组进行调度</p>\n<p>HiveD : Sharing a GPU Cluster for Deep Learning with Guarantees<br>Heterogeneity-Aware Cluster Scheduling Policies for Deep Learning Workloads<br>Topology-aware GPU scheduling for learning workloads in cloud environments<br>Tiresias: A GPU cluster manager for distributed deep learning<br>Gandiva: Introspective cluster scheduling for deep learning</p>\n<h3 id=\"针对深度学习的GPU共享survey\"><a href=\"#针对深度学习的GPU共享survey\" class=\"headerlink\" title=\"针对深度学习的GPU共享survey\"></a>针对深度学习的GPU共享survey</h3><p><a href=\"https://bbs.cvmart.net/articles/3696\">https://bbs.cvmart.net/articles/3696</a></p>\n<p><a href=\"https://cloud.tencent.com/developer/article/1766184\">https://cloud.tencent.com/developer/article/1766184</a>   Improving GPU Utilization in Kubernetes</p>\n","site":{"data":{}},"wordcount":2157,"excerpt":"","more":"<p>调度需要关注的问题/或者目标：提高资源利用率，负载均衡，用户的优先级和公平性</p>\n<p>可能是针对深度学习场景的调度，也可能是平常的请求任务</p>\n<p>ParSync:调度器需要进行及时的同步，如果不及时进行同步那么就可能造成大量冲突；但是在同步的时候，如果一个调度器固定同步固定几个机器的话。就无法充分利用机器空闲资源；<br>所以这篇论文提出利用分片同步的策略，就是一个调度器通过轮训的方式，分时段和多个机器进行同步；同时给最后同步的机器更高的优先级，因为它的状态最新，最可信，因此发生冲突的可能性会更小</p>\n<p>Gavel: 针对深度学习的异构感知的集群调度策略； 将调度转为一个优化问题</p>\n<h3 id=\"阿里项目\"><a href=\"#阿里项目\" class=\"headerlink\" title=\"阿里项目\"></a>阿里项目</h3><p>资源池化的理解：<br>CPU、内存、磁盘、I/O等硬件变成可以动态管理的“资源池”，从而提高资源的利用率，简化系统管理，实现服务器整合。核心思想：能够通过区分资源优先次序并随时随地能够将服务器资源分配给最需要它们的工作负载来简化管理和提高效率，从而减少为单个工作负载峰值而存储的资源。</p>\n<blockquote>\n<p>池化简单来讲就是使用远程访问的形式使用GPU资源，任务使用本机的CPU和另一台机器的GPU，两者通过网络进行通信。</p>\n</blockquote>\n<p>ref:<a href=\"https://bbs.cvmart.net/articles/3696\">https://bbs.cvmart.net/articles/3696</a></p>\n<p>深度学习场景下异构池化资源管理和任务调度研究</p>\n<p>池化和异构集群下的资源调度有什么区别？</p>\n<p>相关研究工作：</p>\n<p>Demand Based Hierarchical QoS Using Storage Resource Pools</p>\n<p>化零为整:将多台服务器上的GPU集合起来提供给一个容器或者一个虚拟机使用<br>隔空取物：将虚拟机或者容器运行在一台没有物理 GPU 的服务器上，通过计算机网络，透明地使用另一台服务器上的 GPU 资源。<br>小模型场景的典型应用：从算力和显存两个角度，对GPU资源进行切分</p>\n<p>问题：<br>这个池化是GPU还是包括CPU， 存储所有资源的池化<br>这个GPU的池化和云服务器有什么区别<br>GPU池化之后，拉远，数据传输的开销如何弥补<br>如果做到多个应用之间互不影响的，因为虽然充分应用了GPU的显存和算力资源，但是数据传输的带宽，不会因为任务量多，而相互竞争，从而影响效率吗</p>\n<p>通过算力和显存从切分， 不在一个GPU上算力和显存如何协作起来，完成一件事情<br>与k8S的区别在哪里</p>\n<p>为什么需要劫持调用才能实现资源的隔离</p>\n<p>这里的调度是分配好了，就固定直到任务结束，还是像gandivia一样需要动态调整<br>主要是针对deep learning 的训练 推理还是普遍多任务背景下的任务调度，与资源池化</p>\n<p>之后的安排：<br>看一下legoos 以及一些相关论文<br>看一下k8s的官方文档<br>看一下ppt里面的一些链接<br>讨论一下任务</p>\n<p>相关论文总结：</p>\n<h3 id=\"Multi-Job：\"><a href=\"#Multi-Job：\" class=\"headerlink\" title=\"Multi-Job：\"></a>Multi-Job：</h3><p>Gandiva: 主要是针对multi-job 超参数搜索的场景下的可预测性，在训练过程中，自适应的调整job, 最大化GPU资源的利用率</p>\n<h3 id=\"训练推理混合调度：\"><a href=\"#训练推理混合调度：\" class=\"headerlink\" title=\"训练推理混合调度：\"></a>训练推理混合调度：</h3><p>AntMan : Dynamic Scaling on GPU Clusters for Deep Learning<br>PipeSwitch: Fast Pipelined Context Switching for Deep Learning Applications</p>\n<p>将推理任务插入训练的时间片中，充分利用GPU的资源</p>\n<h3 id=\"池化相关\"><a href=\"#池化相关\" class=\"headerlink\" title=\"池化相关\"></a>池化相关</h3><p>LegoOS: A Disseminated, Distributed OS for Hardware Resource Disaggregation<br>推翻常规的整体server模式，使process memory和storage通过网络来进行通讯，而不是总线，使用一个全局manager进行粗粒度的分配，然后使用一个local manager进行细粒度资源管理</p>\n<p>rCUDA remote CUDA<br>rCUDA: Going Further in Remote GPU Virtualization<br>VMware-vSphere-Bitfusion<br>驱动科技的GPU拉远策略</p>\n<h3 id=\"异构-集群资源调度\"><a href=\"#异构-集群资源调度\" class=\"headerlink\" title=\"异构/集群资源调度\"></a>异构/集群资源调度</h3><p>Scaling Large Production Clusters with Partitioned Synchronization<br>主要是多个调度器对集群支援进行调度，同时为了保证调度维持较好的实时性，减低可能发生的资源竞争，使用时间片轮训的方式，让一个调度器对多个机器组成的组进行调度</p>\n<p>HiveD : Sharing a GPU Cluster for Deep Learning with Guarantees<br>Heterogeneity-Aware Cluster Scheduling Policies for Deep Learning Workloads<br>Topology-aware GPU scheduling for learning workloads in cloud environments<br>Tiresias: A GPU cluster manager for distributed deep learning<br>Gandiva: Introspective cluster scheduling for deep learning</p>\n<h3 id=\"针对深度学习的GPU共享survey\"><a href=\"#针对深度学习的GPU共享survey\" class=\"headerlink\" title=\"针对深度学习的GPU共享survey\"></a>针对深度学习的GPU共享survey</h3><p><a href=\"https://bbs.cvmart.net/articles/3696\">https://bbs.cvmart.net/articles/3696</a></p>\n<p><a href=\"https://cloud.tencent.com/developer/article/1766184\">https://cloud.tencent.com/developer/article/1766184</a>   Improving GPU Utilization in Kubernetes</p>\n"},{"layout":"blog","title":"secrete","date":"2021-11-10T13:08:14.000Z","_content":"\nThis is a page with lock","source":"_posts/工具相关/secrete.md","raw":"---\nlayout: blog\ntitle: secrete\ndate: 2021-11-10 21:08:14\ntags:\n    private\n---\n\nThis is a page with lock","slug":"工具相关/secrete","published":1,"updated":"2021-11-13T12:26:46.675Z","comments":1,"photos":[],"link":"","_id":"clk5ceioa002hjpjb2yf786k5","content":"<div class=\"hbe hbe-container\" id=\"hexo-blog-encrypt\" data-wpm=\"抱歉, 这个密码看着不太对, 请再试试.\" data-whm=\"抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.\">\n  <script id=\"hbeData\" type=\"hbeData\" data-hmacdigest=\"42bdb50f24ef810bd1fe9c3a68189192ac22e3a686b9d240c1c7f8ebad6aba86\">792393e20cb95a16d338204aed962f21dfc09fc732608dcc9224b9c53e390244da9a389fb5651bdcf8a6634c53e59a5aa6711d5b381e161d71676c092e311df3</script>\n  <div class=\"hbe hbe-content\">\n    <div class=\"hbe hbe-input hbe-input-default\">\n      <input class=\"hbe hbe-input-field hbe-input-field-default\" type=\"password\" id=\"hbePass\">\n      <label class=\"hbe hbe-input-label hbe-input-label-default\" for=\"hbePass\">\n        <span class=\"hbe hbe-input-label-content hbe-input-label-content-default\">您好, 这里需要密码.</span>\n      </label>\n    </div>\n  </div>\n</div>\n<script data-pjax src=\"/lib/hbe.js\"></script><link href=\"/css/hbe.style.css\" rel=\"stylesheet\" type=\"text/css\">","site":{"data":{}},"wordcount":19,"excerpt":"这里有东西被加密了，需要输入密码查看哦。","more":"这里有东西被加密了，需要输入密码查看哦。","origin":"<p>This is a page with lock</p>\n","encrypt":true},{"layout":"blog","title":"vscode 配置","date":"2022-02-25T01:45:56.000Z","_content":"\n1. 有关于在macos big sur上配置c/c++程序运行和调试详细步骤：\n注意需要安装codellb\nhttps://blog.csdn.net/weixin_44881648/article/details/111046381\n\n","source":"_posts/工具相关/vscode.md","raw":"---\nlayout: blog\ntitle: vscode 配置\ndate: 2022-02-25 09:45:56\ntags:\n---\n\n1. 有关于在macos big sur上配置c/c++程序运行和调试详细步骤：\n注意需要安装codellb\nhttps://blog.csdn.net/weixin_44881648/article/details/111046381\n\n","slug":"工具相关/vscode","published":1,"updated":"2023-07-10T10:36:19.583Z","comments":1,"photos":[],"link":"","_id":"clk5ceiob002kjpjb4bpbaizx","content":"<ol>\n<li>有关于在macos big sur上配置c/c++程序运行和调试详细步骤：<br>注意需要安装codellb<br><a href=\"https://blog.csdn.net/weixin_44881648/article/details/111046381\">https://blog.csdn.net/weixin_44881648/article/details/111046381</a></li>\n</ol>\n","site":{"data":{}},"wordcount":111,"excerpt":"","more":"<ol>\n<li>有关于在macos big sur上配置c/c++程序运行和调试详细步骤：<br>注意需要安装codellb<br><a href=\"https://blog.csdn.net/weixin_44881648/article/details/111046381\">https://blog.csdn.net/weixin_44881648/article/details/111046381</a></li>\n</ol>\n"},{"title":"Zplot画图相关知识点","date":"2022-01-04T08:04:52.000Z","_content":"\n\nZplot-folder\n|--breakdown\n    |--Makefile\n    |--breakdown1.py\n    |--breakdown1.data\n    |--breakdown2.py\n    |--breakdown2.data\n|--eval_lineplot\n    |--Makefile\n|--...\n|--makefig.sh\n\n1. 每次运行的时候只需要运行makefig文件就可以了，如果要修改所有生成的pdf在的目录，直接修改makefig.sh\n\n2。 Makefile里面的文件主要是运行当前py文件生成eps文件，然后使用ps2pdf转为pdf并使用pdf2crop对生成的pdf文件进行裁剪\nPS：一定要注意python文件的名字一定要和data文件名字相同，否则会报错\n\n\nprequisuite\n\n```bash\npip install zplot \n#注意可能会出现list错误，可能是由于python2 和python3的不兼容原因，只需要将zplot.py里面的ListType改为list就可以了\n\nsudo apt-get install texlive-extra-utils  \n```\n\nMakefile文件分析\n```bash\nPY=python\nEPS2PDF=ps2pdf\nCROP=pdfcrop\n\nSRC := $(wildcard *.py) #列出所有文件对应的py文件\nSRC := $(filter-out zplot.py, $(SRC))\nEPS = $(patsubst %.py,%.eps,$(SRC))\nPDF = $(patsubst %.py,%.pdf,$(SRC)) #列出所有文件对应的eps和pdf文件\n\nall: $(EPS) $(PDF)\n\n%.eps: %.py  # 目标文件： 源文件\n\t$(PY) $< eps  #$< 表示源文件  $@表示目标文件//官方解释： $< 表示第一个依赖文件， $@ 表示目标集\n\n%.pdf: %.eps\n\t$(EPS2PDF) $<\n\t$(CROP) $@ $@\n\trm -rf $<\n\nfig:\n\t# mv -f *.pdf ../../../fig/\t #将所有的文件都转移到zplot对应的root目录下面\n\tmv -f *.pdf ../../\n\trm -rf *.eps *.pdf\n```\nmakefile语法的参考链接： https://seisman.github.io/how-to-write-makefile/rules.html \n\n\nmakefig.sh文件分析\n```bash\n\nrm -rf *.pdf #这是我自己家的，在执行生成之前，现将之前生成的pdf文件删除，应该是也不用\n\nfor  dir  in  `find .  -name Makefile`  #找到包含Makefile文件的dir\ndo\n\tpath=`dirname $dir` #找到dir对应的路径path\n    # echo $path\n    # echo $dir\n\tif  [ $path  !=  . ]\n\tthen\n\techo $path #打印出path的路径\n\tcd $path  \n\tmake    #执行make和makefig命令\n\tmake fig\n\tcd  -\n\tfi\ndone\n\n```","source":"_posts/工具相关/zplot.md","raw":"---\ntitle: Zplot画图相关知识点\ntags: zplot\ncategories:\n  - 工具相关\ndate: 2022-01-04 16:04:52\n---\n\n\nZplot-folder\n|--breakdown\n    |--Makefile\n    |--breakdown1.py\n    |--breakdown1.data\n    |--breakdown2.py\n    |--breakdown2.data\n|--eval_lineplot\n    |--Makefile\n|--...\n|--makefig.sh\n\n1. 每次运行的时候只需要运行makefig文件就可以了，如果要修改所有生成的pdf在的目录，直接修改makefig.sh\n\n2。 Makefile里面的文件主要是运行当前py文件生成eps文件，然后使用ps2pdf转为pdf并使用pdf2crop对生成的pdf文件进行裁剪\nPS：一定要注意python文件的名字一定要和data文件名字相同，否则会报错\n\n\nprequisuite\n\n```bash\npip install zplot \n#注意可能会出现list错误，可能是由于python2 和python3的不兼容原因，只需要将zplot.py里面的ListType改为list就可以了\n\nsudo apt-get install texlive-extra-utils  \n```\n\nMakefile文件分析\n```bash\nPY=python\nEPS2PDF=ps2pdf\nCROP=pdfcrop\n\nSRC := $(wildcard *.py) #列出所有文件对应的py文件\nSRC := $(filter-out zplot.py, $(SRC))\nEPS = $(patsubst %.py,%.eps,$(SRC))\nPDF = $(patsubst %.py,%.pdf,$(SRC)) #列出所有文件对应的eps和pdf文件\n\nall: $(EPS) $(PDF)\n\n%.eps: %.py  # 目标文件： 源文件\n\t$(PY) $< eps  #$< 表示源文件  $@表示目标文件//官方解释： $< 表示第一个依赖文件， $@ 表示目标集\n\n%.pdf: %.eps\n\t$(EPS2PDF) $<\n\t$(CROP) $@ $@\n\trm -rf $<\n\nfig:\n\t# mv -f *.pdf ../../../fig/\t #将所有的文件都转移到zplot对应的root目录下面\n\tmv -f *.pdf ../../\n\trm -rf *.eps *.pdf\n```\nmakefile语法的参考链接： https://seisman.github.io/how-to-write-makefile/rules.html \n\n\nmakefig.sh文件分析\n```bash\n\nrm -rf *.pdf #这是我自己家的，在执行生成之前，现将之前生成的pdf文件删除，应该是也不用\n\nfor  dir  in  `find .  -name Makefile`  #找到包含Makefile文件的dir\ndo\n\tpath=`dirname $dir` #找到dir对应的路径path\n    # echo $path\n    # echo $dir\n\tif  [ $path  !=  . ]\n\tthen\n\techo $path #打印出path的路径\n\tcd $path  \n\tmake    #执行make和makefig命令\n\tmake fig\n\tcd  -\n\tfi\ndone\n\n```","slug":"工具相关/zplot","published":1,"updated":"2022-07-31T09:11:32.488Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clk5ceiob002mjpjbgdg2flbz","content":"<p>Zplot-folder<br>|–breakdown<br>    |–Makefile<br>    |–breakdown1.py<br>    |–breakdown1.data<br>    |–breakdown2.py<br>    |–breakdown2.data<br>|–eval_lineplot<br>    |–Makefile<br>|–…<br>|–makefig.sh</p>\n<ol>\n<li>每次运行的时候只需要运行makefig文件就可以了，如果要修改所有生成的pdf在的目录，直接修改makefig.sh</li>\n</ol>\n<p>2。 Makefile里面的文件主要是运行当前py文件生成eps文件，然后使用ps2pdf转为pdf并使用pdf2crop对生成的pdf文件进行裁剪<br>PS：一定要注意python文件的名字一定要和data文件名字相同，否则会报错</p>\n<p>prequisuite</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">pip install zplot <br><span class=\"hljs-comment\">#注意可能会出现list错误，可能是由于python2 和python3的不兼容原因，只需要将zplot.py里面的ListType改为list就可以了</span><br><br>sudo apt-get install texlive-extra-utils  <br></code></pre></td></tr></table></figure>\n\n<p>Makefile文件分析</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">PY=python<br>EPS2PDF=ps2pdf<br>CROP=pdfcrop<br><br>SRC := $(wildcard *.py) <span class=\"hljs-comment\">#列出所有文件对应的py文件</span><br>SRC := $(filter-out zplot.py, $(SRC))<br>EPS = $(patsubst %.py,%.eps,$(SRC))<br>PDF = $(patsubst %.py,%.pdf,$(SRC)) <span class=\"hljs-comment\">#列出所有文件对应的eps和pdf文件</span><br><br>all: $(EPS) $(PDF)<br><br>%.eps: %.py  <span class=\"hljs-comment\"># 目标文件： 源文件</span><br>\t$(PY) $&lt; eps  <span class=\"hljs-comment\">#$&lt; 表示源文件  $@表示目标文件//官方解释： $&lt; 表示第一个依赖文件， $@ 表示目标集</span><br><br>%.pdf: %.eps<br>\t$(EPS2PDF) $&lt;<br>\t$(CROP) <span class=\"hljs-variable\">$@</span> <span class=\"hljs-variable\">$@</span><br>\trm -rf $&lt;<br><br>fig:<br>\t<span class=\"hljs-comment\"># mv -f *.pdf ../../../fig/\t #将所有的文件都转移到zplot对应的root目录下面</span><br>\tmv -f *.pdf ../../<br>\trm -rf *.eps *.pdf<br></code></pre></td></tr></table></figure>\n<p>makefile语法的参考链接： <a href=\"https://seisman.github.io/how-to-write-makefile/rules.html\">https://seisman.github.io/how-to-write-makefile/rules.html</a> </p>\n<p>makefig.sh文件分析</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><br>rm -rf *.pdf <span class=\"hljs-comment\">#这是我自己家的，在执行生成之前，现将之前生成的pdf文件删除，应该是也不用</span><br><br><span class=\"hljs-keyword\">for</span>  dir  <span class=\"hljs-keyword\">in</span>  `find .  -name Makefile`  <span class=\"hljs-comment\">#找到包含Makefile文件的dir</span><br><span class=\"hljs-keyword\">do</span><br>\tpath=`dirname <span class=\"hljs-variable\">$dir</span>` <span class=\"hljs-comment\">#找到dir对应的路径path</span><br>    <span class=\"hljs-comment\"># echo $path</span><br>    <span class=\"hljs-comment\"># echo $dir</span><br>\t<span class=\"hljs-keyword\">if</span>  [ <span class=\"hljs-variable\">$path</span>  !=  . ]<br>\t<span class=\"hljs-keyword\">then</span><br>\t<span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$path</span> <span class=\"hljs-comment\">#打印出path的路径</span><br>\t<span class=\"hljs-built_in\">cd</span> <span class=\"hljs-variable\">$path</span>  <br>\tmake    <span class=\"hljs-comment\">#执行make和makefig命令</span><br>\tmake fig<br>\t<span class=\"hljs-built_in\">cd</span>  -<br>\t<span class=\"hljs-keyword\">fi</span><br><span class=\"hljs-keyword\">done</span><br><br></code></pre></td></tr></table></figure>","site":{"data":{}},"wordcount":1254,"excerpt":"","more":"<p>Zplot-folder<br>|–breakdown<br>    |–Makefile<br>    |–breakdown1.py<br>    |–breakdown1.data<br>    |–breakdown2.py<br>    |–breakdown2.data<br>|–eval_lineplot<br>    |–Makefile<br>|–…<br>|–makefig.sh</p>\n<ol>\n<li>每次运行的时候只需要运行makefig文件就可以了，如果要修改所有生成的pdf在的目录，直接修改makefig.sh</li>\n</ol>\n<p>2。 Makefile里面的文件主要是运行当前py文件生成eps文件，然后使用ps2pdf转为pdf并使用pdf2crop对生成的pdf文件进行裁剪<br>PS：一定要注意python文件的名字一定要和data文件名字相同，否则会报错</p>\n<p>prequisuite</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">pip install zplot <br><span class=\"hljs-comment\">#注意可能会出现list错误，可能是由于python2 和python3的不兼容原因，只需要将zplot.py里面的ListType改为list就可以了</span><br><br>sudo apt-get install texlive-extra-utils  <br></code></pre></td></tr></table></figure>\n\n<p>Makefile文件分析</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">PY=python<br>EPS2PDF=ps2pdf<br>CROP=pdfcrop<br><br>SRC := $(wildcard *.py) <span class=\"hljs-comment\">#列出所有文件对应的py文件</span><br>SRC := $(filter-out zplot.py, $(SRC))<br>EPS = $(patsubst %.py,%.eps,$(SRC))<br>PDF = $(patsubst %.py,%.pdf,$(SRC)) <span class=\"hljs-comment\">#列出所有文件对应的eps和pdf文件</span><br><br>all: $(EPS) $(PDF)<br><br>%.eps: %.py  <span class=\"hljs-comment\"># 目标文件： 源文件</span><br>\t$(PY) $&lt; eps  <span class=\"hljs-comment\">#$&lt; 表示源文件  $@表示目标文件//官方解释： $&lt; 表示第一个依赖文件， $@ 表示目标集</span><br><br>%.pdf: %.eps<br>\t$(EPS2PDF) $&lt;<br>\t$(CROP) <span class=\"hljs-variable\">$@</span> <span class=\"hljs-variable\">$@</span><br>\trm -rf $&lt;<br><br>fig:<br>\t<span class=\"hljs-comment\"># mv -f *.pdf ../../../fig/\t #将所有的文件都转移到zplot对应的root目录下面</span><br>\tmv -f *.pdf ../../<br>\trm -rf *.eps *.pdf<br></code></pre></td></tr></table></figure>\n<p>makefile语法的参考链接： <a href=\"https://seisman.github.io/how-to-write-makefile/rules.html\">https://seisman.github.io/how-to-write-makefile/rules.html</a> </p>\n<p>makefig.sh文件分析</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><br>rm -rf *.pdf <span class=\"hljs-comment\">#这是我自己家的，在执行生成之前，现将之前生成的pdf文件删除，应该是也不用</span><br><br><span class=\"hljs-keyword\">for</span>  dir  <span class=\"hljs-keyword\">in</span>  `find .  -name Makefile`  <span class=\"hljs-comment\">#找到包含Makefile文件的dir</span><br><span class=\"hljs-keyword\">do</span><br>\tpath=`dirname <span class=\"hljs-variable\">$dir</span>` <span class=\"hljs-comment\">#找到dir对应的路径path</span><br>    <span class=\"hljs-comment\"># echo $path</span><br>    <span class=\"hljs-comment\"># echo $dir</span><br>\t<span class=\"hljs-keyword\">if</span>  [ <span class=\"hljs-variable\">$path</span>  !=  . ]<br>\t<span class=\"hljs-keyword\">then</span><br>\t<span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$path</span> <span class=\"hljs-comment\">#打印出path的路径</span><br>\t<span class=\"hljs-built_in\">cd</span> <span class=\"hljs-variable\">$path</span>  <br>\tmake    <span class=\"hljs-comment\">#执行make和makefig命令</span><br>\tmake fig<br>\t<span class=\"hljs-built_in\">cd</span>  -<br>\t<span class=\"hljs-keyword\">fi</span><br><span class=\"hljs-keyword\">done</span><br><br></code></pre></td></tr></table></figure>"},{"title":"分布式训练","date":"2022-01-26T02:50:50.000Z","_content":"\n### 资料：\n一个pytorch 分布式 单机多卡/多机多卡的例子\nhttps://github.com/lesliejackson/PyTorch-Distributed-Training\n\n\n常见分布式训练讲解，但是主要命令是启动单机多卡，而不是多机多卡 包括slum, apex, horovod\nhttps://github.com/tczhangzhi/pytorch-distributed \n\npytorch DDP介绍\nhttps://zhuanlan.zhihu.com/p/76638962\n\nhttps://github.com/richardkxu/distributed-pytorch （也有多机多卡的命令）\n\n可能会用到：\n两个机器之间相互免密登录：https://blog.csdn.net/u010391029/article/details/51126210\n\n\nDDP time breakdown\nhttps://discuss.pytorch.org/t/how-to-measure-ddp-time-breakdown/78925\nhttps://discuss.pytorch.org/t/how-to-measure-ddp-time-breakdown/78925\nhttps://discuss.pytorch.org/t/calculating-flops-of-a-given-pytorch-model/3711/4 FLOPS计算\n\n\n多进程logging和mkdir设置，分布式inferenc/ 分布式训练的一些小技巧\n\nhttps://zhuanlan.zhihu.com/p/250471767 \n\n> 包括的内容1. 在DDP中引入SyncBN\n> 2. DDP下的Gradient Accumulation的进一步加速\n> 3. 多机多卡环境下的inference加速\n> 4. 保证DDP性能：确保数据的一致性\n> 5. 和DDP有关的小技巧\n> 6. 1. 控制不同进程的执行顺序\n>    2. 避免DDP带来的冗余输出\n\nRay分布式执行框架  PyTorch + Ray Tune 调参\nhttps://blog.csdn.net/tszupup/article/details/112059788\n\n分布式相关论文源码\nhttps://github.com/msr-fiddle/pipedream  pipedream源码 mini-bath parallism\nhttps://github.com/kakaobrain/torchgpipe\n\npytorch分布式训练的时候保存一定要用model.module\nhttps://blog.csdn.net/comway_Li/article/details/107531165 一些需要注意的地方\n\n\nhorovod多机多卡\nhttp://chaopeng.name/2020/01/03/horovod%E5%A4%9A%E6%9C%BA%E5%A4%9A%E5%8D%A1%E5%90%AF%E5%8A%A8%E6%8C%87%E5%8D%97/\n\n\n### 知识点\n1. DP和DDP区别\nDP是单进程多线程数据并行，将模型copy到每个设备，scatter数据到每个设备进行计算后，将多个GPU输出传到master device(一般为设备0)进行损失计算，（可以优化一下：将loss作为forward 一部分，这样的话每个GPU上自行计算loss，而不用进行模型输出的传输）将损失结果（分发的是各个GPU分别对应的loss）传给每个设备进行反向传播，每个设备将反向传播后的梯度到主设备进行汇聚求平均，然后replicate一份模型的参数到每个设备中，重复上诉的训练过程。\n\n\n2. DDP中all reduce与PS\n    DDP （all reduce）同步的是梯度，不是参数\n    PS，传给master的是梯度，返回的是参数\n\n    思考：对不重要的梯度进行累积后同步/直接不同步（会不会造成模型的不一致）\n\n3. 同步代码\n分布式训练源代码解读：https://zhuanlan.zhihu.com/p/343951042\n```\n手动同步梯度\nfor param in ddp_model.parameters(): \n\tdist.all_reduce(param.grad.data, op=dist.reduce_op.SUM)\n    param.grad.data /= world_size \n\t\n手动同步参数：\n在不重要的样本反向传播后但是不同步参数后，同步梯度\nfor param in ddp_model.parameters(): \n\tdist.all_reduce(param.data, op=dist.reduce_op.SUM)\n    param.data /= world_size \n```\n\n### 例子\n#### solution 1 - atom版本\n裸机 多节点 atom平台\n```bash\ncd /workspace/mnt/storage/anchao/ac_file/traffic_iteration/SupreVision && \\\n./install.sh && \\\npython -m torch.distributed.launch \\\n        --nnode=4 \\\n        --node_rank=0 \\\n        --nproc_per_node=8 \\\n        --master_addr=\"10.244.55.30\" \\\n        --master_port=23467 \\\n        tools/train.py \\\n        --config_file configs/YOLOv3/opencv_pelee_reorg.yml \\\n        SOLVER.IMS_PER_BATCH \"16\" \\\n        MODEL.DEVICE_ID \"('0,1,2,3,4,5,6,7')\" \\\n        > detection0.log 2>&1\n```\n\n单机多卡\n```bash\ncd /workspace/mnt/storage/anchao/ac_file/traffic_iteration/SupreVision && \\\n./install.sh && \\\nCUDA_VISIBLE_DEVICES=3,4,5,6 python -m torch.distributed.launch \\\n                --nproc_per_node=2 \\\n                --master_port=$((RANDOM + 20000)) \\\n                ./imagenet_final_train_master.py \\\n                --config_file configs/YOLOv3/opencv_pelee_reorg.yml \\\n                > detection0.log 2>&1\n```\n\n#### solution 2 - 简洁版\n多机多卡\nsuppose we have two machines and one machine have 4 gpus\nIn multi machine multi gpu situation, you have to choose a machine to be master node.\nwe named the machines A and B, and set A to be master node\n```bash\nscript run at A\n\npython -m torch.distributed.launch --nproc_per_node=4 --nnode=2 --node_rank=0 --master_addr=A_ip_address master_port=29500 main.py ... \n\nscript run at B\n\npython -m torch.distributed.launch --nproc_per_node=4 --nnode=2 --node_rank=1 --master_addr=A_ip_address master_port=29500 main.py ... \n```\n\n单机多卡\n```bash\npython -m torch.distributed.launch --nproc_per_node=ngpus --master_port=29500 main.py ... \n```","source":"_posts/工具相关/分布式训练.md","raw":"---\ntitle: 分布式训练\ncategories:\n  - 工具相关\ndate: 2022-01-26 10:50:50\ntags:\n---\n\n### 资料：\n一个pytorch 分布式 单机多卡/多机多卡的例子\nhttps://github.com/lesliejackson/PyTorch-Distributed-Training\n\n\n常见分布式训练讲解，但是主要命令是启动单机多卡，而不是多机多卡 包括slum, apex, horovod\nhttps://github.com/tczhangzhi/pytorch-distributed \n\npytorch DDP介绍\nhttps://zhuanlan.zhihu.com/p/76638962\n\nhttps://github.com/richardkxu/distributed-pytorch （也有多机多卡的命令）\n\n可能会用到：\n两个机器之间相互免密登录：https://blog.csdn.net/u010391029/article/details/51126210\n\n\nDDP time breakdown\nhttps://discuss.pytorch.org/t/how-to-measure-ddp-time-breakdown/78925\nhttps://discuss.pytorch.org/t/how-to-measure-ddp-time-breakdown/78925\nhttps://discuss.pytorch.org/t/calculating-flops-of-a-given-pytorch-model/3711/4 FLOPS计算\n\n\n多进程logging和mkdir设置，分布式inferenc/ 分布式训练的一些小技巧\n\nhttps://zhuanlan.zhihu.com/p/250471767 \n\n> 包括的内容1. 在DDP中引入SyncBN\n> 2. DDP下的Gradient Accumulation的进一步加速\n> 3. 多机多卡环境下的inference加速\n> 4. 保证DDP性能：确保数据的一致性\n> 5. 和DDP有关的小技巧\n> 6. 1. 控制不同进程的执行顺序\n>    2. 避免DDP带来的冗余输出\n\nRay分布式执行框架  PyTorch + Ray Tune 调参\nhttps://blog.csdn.net/tszupup/article/details/112059788\n\n分布式相关论文源码\nhttps://github.com/msr-fiddle/pipedream  pipedream源码 mini-bath parallism\nhttps://github.com/kakaobrain/torchgpipe\n\npytorch分布式训练的时候保存一定要用model.module\nhttps://blog.csdn.net/comway_Li/article/details/107531165 一些需要注意的地方\n\n\nhorovod多机多卡\nhttp://chaopeng.name/2020/01/03/horovod%E5%A4%9A%E6%9C%BA%E5%A4%9A%E5%8D%A1%E5%90%AF%E5%8A%A8%E6%8C%87%E5%8D%97/\n\n\n### 知识点\n1. DP和DDP区别\nDP是单进程多线程数据并行，将模型copy到每个设备，scatter数据到每个设备进行计算后，将多个GPU输出传到master device(一般为设备0)进行损失计算，（可以优化一下：将loss作为forward 一部分，这样的话每个GPU上自行计算loss，而不用进行模型输出的传输）将损失结果（分发的是各个GPU分别对应的loss）传给每个设备进行反向传播，每个设备将反向传播后的梯度到主设备进行汇聚求平均，然后replicate一份模型的参数到每个设备中，重复上诉的训练过程。\n\n\n2. DDP中all reduce与PS\n    DDP （all reduce）同步的是梯度，不是参数\n    PS，传给master的是梯度，返回的是参数\n\n    思考：对不重要的梯度进行累积后同步/直接不同步（会不会造成模型的不一致）\n\n3. 同步代码\n分布式训练源代码解读：https://zhuanlan.zhihu.com/p/343951042\n```\n手动同步梯度\nfor param in ddp_model.parameters(): \n\tdist.all_reduce(param.grad.data, op=dist.reduce_op.SUM)\n    param.grad.data /= world_size \n\t\n手动同步参数：\n在不重要的样本反向传播后但是不同步参数后，同步梯度\nfor param in ddp_model.parameters(): \n\tdist.all_reduce(param.data, op=dist.reduce_op.SUM)\n    param.data /= world_size \n```\n\n### 例子\n#### solution 1 - atom版本\n裸机 多节点 atom平台\n```bash\ncd /workspace/mnt/storage/anchao/ac_file/traffic_iteration/SupreVision && \\\n./install.sh && \\\npython -m torch.distributed.launch \\\n        --nnode=4 \\\n        --node_rank=0 \\\n        --nproc_per_node=8 \\\n        --master_addr=\"10.244.55.30\" \\\n        --master_port=23467 \\\n        tools/train.py \\\n        --config_file configs/YOLOv3/opencv_pelee_reorg.yml \\\n        SOLVER.IMS_PER_BATCH \"16\" \\\n        MODEL.DEVICE_ID \"('0,1,2,3,4,5,6,7')\" \\\n        > detection0.log 2>&1\n```\n\n单机多卡\n```bash\ncd /workspace/mnt/storage/anchao/ac_file/traffic_iteration/SupreVision && \\\n./install.sh && \\\nCUDA_VISIBLE_DEVICES=3,4,5,6 python -m torch.distributed.launch \\\n                --nproc_per_node=2 \\\n                --master_port=$((RANDOM + 20000)) \\\n                ./imagenet_final_train_master.py \\\n                --config_file configs/YOLOv3/opencv_pelee_reorg.yml \\\n                > detection0.log 2>&1\n```\n\n#### solution 2 - 简洁版\n多机多卡\nsuppose we have two machines and one machine have 4 gpus\nIn multi machine multi gpu situation, you have to choose a machine to be master node.\nwe named the machines A and B, and set A to be master node\n```bash\nscript run at A\n\npython -m torch.distributed.launch --nproc_per_node=4 --nnode=2 --node_rank=0 --master_addr=A_ip_address master_port=29500 main.py ... \n\nscript run at B\n\npython -m torch.distributed.launch --nproc_per_node=4 --nnode=2 --node_rank=1 --master_addr=A_ip_address master_port=29500 main.py ... \n```\n\n单机多卡\n```bash\npython -m torch.distributed.launch --nproc_per_node=ngpus --master_port=29500 main.py ... \n```","slug":"工具相关/分布式训练","published":1,"updated":"2022-02-14T10:03:35.528Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clk5ceioc002ojpjbgqfdhpcy","content":"<h3 id=\"资料：\"><a href=\"#资料：\" class=\"headerlink\" title=\"资料：\"></a>资料：</h3><p>一个pytorch 分布式 单机多卡/多机多卡的例子<br><a href=\"https://github.com/lesliejackson/PyTorch-Distributed-Training\">https://github.com/lesliejackson/PyTorch-Distributed-Training</a></p>\n<p>常见分布式训练讲解，但是主要命令是启动单机多卡，而不是多机多卡 包括slum, apex, horovod<br><a href=\"https://github.com/tczhangzhi/pytorch-distributed\">https://github.com/tczhangzhi/pytorch-distributed</a> </p>\n<p>pytorch DDP介绍<br><a href=\"https://zhuanlan.zhihu.com/p/76638962\">https://zhuanlan.zhihu.com/p/76638962</a></p>\n<p><a href=\"https://github.com/richardkxu/distributed-pytorch\">https://github.com/richardkxu/distributed-pytorch</a> （也有多机多卡的命令）</p>\n<p>可能会用到：<br>两个机器之间相互免密登录：<a href=\"https://blog.csdn.net/u010391029/article/details/51126210\">https://blog.csdn.net/u010391029/article/details/51126210</a></p>\n<p>DDP time breakdown<br><a href=\"https://discuss.pytorch.org/t/how-to-measure-ddp-time-breakdown/78925\">https://discuss.pytorch.org/t/how-to-measure-ddp-time-breakdown/78925</a><br><a href=\"https://discuss.pytorch.org/t/how-to-measure-ddp-time-breakdown/78925\">https://discuss.pytorch.org/t/how-to-measure-ddp-time-breakdown/78925</a><br><a href=\"https://discuss.pytorch.org/t/calculating-flops-of-a-given-pytorch-model/3711/4\">https://discuss.pytorch.org/t/calculating-flops-of-a-given-pytorch-model/3711/4</a> FLOPS计算</p>\n<p>多进程logging和mkdir设置，分布式inferenc/ 分布式训练的一些小技巧</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/250471767\">https://zhuanlan.zhihu.com/p/250471767</a> </p>\n<blockquote>\n<p>包括的内容1. 在DDP中引入SyncBN<br>2. DDP下的Gradient Accumulation的进一步加速<br>3. 多机多卡环境下的inference加速<br>4. 保证DDP性能：确保数据的一致性<br>5. 和DDP有关的小技巧<br>6. 1. 控制不同进程的执行顺序<br>   2. 避免DDP带来的冗余输出</p>\n</blockquote>\n<p>Ray分布式执行框架  PyTorch + Ray Tune 调参<br><a href=\"https://blog.csdn.net/tszupup/article/details/112059788\">https://blog.csdn.net/tszupup/article/details/112059788</a></p>\n<p>分布式相关论文源码<br><a href=\"https://github.com/msr-fiddle/pipedream\">https://github.com/msr-fiddle/pipedream</a>  pipedream源码 mini-bath parallism<br><a href=\"https://github.com/kakaobrain/torchgpipe\">https://github.com/kakaobrain/torchgpipe</a></p>\n<p>pytorch分布式训练的时候保存一定要用model.module<br><a href=\"https://blog.csdn.net/comway_Li/article/details/107531165\">https://blog.csdn.net/comway_Li/article/details/107531165</a> 一些需要注意的地方</p>\n<p>horovod多机多卡<br><a href=\"http://chaopeng.name/2020/01/03/horovod%E5%A4%9A%E6%9C%BA%E5%A4%9A%E5%8D%A1%E5%90%AF%E5%8A%A8%E6%8C%87%E5%8D%97/\">http://chaopeng.name/2020/01/03/horovod%E5%A4%9A%E6%9C%BA%E5%A4%9A%E5%8D%A1%E5%90%AF%E5%8A%A8%E6%8C%87%E5%8D%97/</a></p>\n<h3 id=\"知识点\"><a href=\"#知识点\" class=\"headerlink\" title=\"知识点\"></a>知识点</h3><ol>\n<li>DP和DDP区别<br>DP是单进程多线程数据并行，将模型copy到每个设备，scatter数据到每个设备进行计算后，将多个GPU输出传到master device(一般为设备0)进行损失计算，（可以优化一下：将loss作为forward 一部分，这样的话每个GPU上自行计算loss，而不用进行模型输出的传输）将损失结果（分发的是各个GPU分别对应的loss）传给每个设备进行反向传播，每个设备将反向传播后的梯度到主设备进行汇聚求平均，然后replicate一份模型的参数到每个设备中，重复上诉的训练过程。</li>\n</ol>\n<ol start=\"2\">\n<li><p>DDP中all reduce与PS<br> DDP （all reduce）同步的是梯度，不是参数<br> PS，传给master的是梯度，返回的是参数</p>\n<p> 思考：对不重要的梯度进行累积后同步/直接不同步（会不会造成模型的不一致）</p>\n</li>\n<li><p>同步代码<br>分布式训练源代码解读：<a href=\"https://zhuanlan.zhihu.com/p/343951042\">https://zhuanlan.zhihu.com/p/343951042</a></p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs reasonml\">手动同步梯度<br><span class=\"hljs-keyword\">for</span> param <span class=\"hljs-keyword\">in</span> ddp_model.parameters<span class=\"hljs-literal\">()</span>: <br>\tdist.all<span class=\"hljs-constructor\">_reduce(<span class=\"hljs-params\">param</span>.<span class=\"hljs-params\">grad</span>.<span class=\"hljs-params\">data</span>, <span class=\"hljs-params\">op</span>=<span class=\"hljs-params\">dist</span>.<span class=\"hljs-params\">reduce_op</span>.SUM)</span><br>    param.grad.data /= world_size <br>\t<br>手动同步参数：<br>在不重要的样本反向传播后但是不同步参数后，同步梯度<br><span class=\"hljs-keyword\">for</span> param <span class=\"hljs-keyword\">in</span> ddp_model.parameters<span class=\"hljs-literal\">()</span>: <br>\tdist.all<span class=\"hljs-constructor\">_reduce(<span class=\"hljs-params\">param</span>.<span class=\"hljs-params\">data</span>, <span class=\"hljs-params\">op</span>=<span class=\"hljs-params\">dist</span>.<span class=\"hljs-params\">reduce_op</span>.SUM)</span><br>    param.data /= world_size <br></code></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h3><h4 id=\"solution-1-atom版本\"><a href=\"#solution-1-atom版本\" class=\"headerlink\" title=\"solution 1 - atom版本\"></a>solution 1 - atom版本</h4><p>裸机 多节点 atom平台</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">cd</span> /workspace/mnt/storage/anchao/ac_file/traffic_iteration/SupreVision &amp;&amp; \\<br>./install.sh &amp;&amp; \\<br>python -m torch.distributed.launch \\<br>        --nnode=4 \\<br>        --node_rank=0 \\<br>        --nproc_per_node=8 \\<br>        --master_addr=<span class=\"hljs-string\">&quot;10.244.55.30&quot;</span> \\<br>        --master_port=23467 \\<br>        tools/train.py \\<br>        --config_file configs/YOLOv3/opencv_pelee_reorg.yml \\<br>        SOLVER.IMS_PER_BATCH <span class=\"hljs-string\">&quot;16&quot;</span> \\<br>        MODEL.DEVICE_ID <span class=\"hljs-string\">&quot;(&#x27;0,1,2,3,4,5,6,7&#x27;)&quot;</span> \\<br>        &gt; detection0.log 2&gt;&amp;1<br></code></pre></td></tr></table></figure>\n\n<p>单机多卡</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">cd</span> /workspace/mnt/storage/anchao/ac_file/traffic_iteration/SupreVision &amp;&amp; \\<br>./install.sh &amp;&amp; \\<br>CUDA_VISIBLE_DEVICES=3,4,5,6 python -m torch.distributed.launch \\<br>                --nproc_per_node=2 \\<br>                --master_port=$((RANDOM + <span class=\"hljs-number\">20000</span>)) \\<br>                ./imagenet_final_train_master.py \\<br>                --config_file configs/YOLOv3/opencv_pelee_reorg.yml \\<br>                &gt; detection0.log 2&gt;&amp;1<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"solution-2-简洁版\"><a href=\"#solution-2-简洁版\" class=\"headerlink\" title=\"solution 2 - 简洁版\"></a>solution 2 - 简洁版</h4><p>多机多卡<br>suppose we have two machines and one machine have 4 gpus<br>In multi machine multi gpu situation, you have to choose a machine to be master node.<br>we named the machines A and B, and set A to be master node</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">script run at A<br><br>python -m torch.distributed.launch --nproc_per_node=4 --nnode=2 --node_rank=0 --master_addr=A_ip_address master_port=29500 main.py ... <br><br>script run at B<br><br>python -m torch.distributed.launch --nproc_per_node=4 --nnode=2 --node_rank=1 --master_addr=A_ip_address master_port=29500 main.py ... <br></code></pre></td></tr></table></figure>\n\n<p>单机多卡</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">python -m torch.distributed.launch --nproc_per_node=ngpus --master_port=29500 main.py ... <br></code></pre></td></tr></table></figure>","site":{"data":{}},"wordcount":3274,"excerpt":"","more":"<h3 id=\"资料：\"><a href=\"#资料：\" class=\"headerlink\" title=\"资料：\"></a>资料：</h3><p>一个pytorch 分布式 单机多卡/多机多卡的例子<br><a href=\"https://github.com/lesliejackson/PyTorch-Distributed-Training\">https://github.com/lesliejackson/PyTorch-Distributed-Training</a></p>\n<p>常见分布式训练讲解，但是主要命令是启动单机多卡，而不是多机多卡 包括slum, apex, horovod<br><a href=\"https://github.com/tczhangzhi/pytorch-distributed\">https://github.com/tczhangzhi/pytorch-distributed</a> </p>\n<p>pytorch DDP介绍<br><a href=\"https://zhuanlan.zhihu.com/p/76638962\">https://zhuanlan.zhihu.com/p/76638962</a></p>\n<p><a href=\"https://github.com/richardkxu/distributed-pytorch\">https://github.com/richardkxu/distributed-pytorch</a> （也有多机多卡的命令）</p>\n<p>可能会用到：<br>两个机器之间相互免密登录：<a href=\"https://blog.csdn.net/u010391029/article/details/51126210\">https://blog.csdn.net/u010391029/article/details/51126210</a></p>\n<p>DDP time breakdown<br><a href=\"https://discuss.pytorch.org/t/how-to-measure-ddp-time-breakdown/78925\">https://discuss.pytorch.org/t/how-to-measure-ddp-time-breakdown/78925</a><br><a href=\"https://discuss.pytorch.org/t/how-to-measure-ddp-time-breakdown/78925\">https://discuss.pytorch.org/t/how-to-measure-ddp-time-breakdown/78925</a><br><a href=\"https://discuss.pytorch.org/t/calculating-flops-of-a-given-pytorch-model/3711/4\">https://discuss.pytorch.org/t/calculating-flops-of-a-given-pytorch-model/3711/4</a> FLOPS计算</p>\n<p>多进程logging和mkdir设置，分布式inferenc/ 分布式训练的一些小技巧</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/250471767\">https://zhuanlan.zhihu.com/p/250471767</a> </p>\n<blockquote>\n<p>包括的内容1. 在DDP中引入SyncBN<br>2. DDP下的Gradient Accumulation的进一步加速<br>3. 多机多卡环境下的inference加速<br>4. 保证DDP性能：确保数据的一致性<br>5. 和DDP有关的小技巧<br>6. 1. 控制不同进程的执行顺序<br>   2. 避免DDP带来的冗余输出</p>\n</blockquote>\n<p>Ray分布式执行框架  PyTorch + Ray Tune 调参<br><a href=\"https://blog.csdn.net/tszupup/article/details/112059788\">https://blog.csdn.net/tszupup/article/details/112059788</a></p>\n<p>分布式相关论文源码<br><a href=\"https://github.com/msr-fiddle/pipedream\">https://github.com/msr-fiddle/pipedream</a>  pipedream源码 mini-bath parallism<br><a href=\"https://github.com/kakaobrain/torchgpipe\">https://github.com/kakaobrain/torchgpipe</a></p>\n<p>pytorch分布式训练的时候保存一定要用model.module<br><a href=\"https://blog.csdn.net/comway_Li/article/details/107531165\">https://blog.csdn.net/comway_Li/article/details/107531165</a> 一些需要注意的地方</p>\n<p>horovod多机多卡<br><a href=\"http://chaopeng.name/2020/01/03/horovod%E5%A4%9A%E6%9C%BA%E5%A4%9A%E5%8D%A1%E5%90%AF%E5%8A%A8%E6%8C%87%E5%8D%97/\">http://chaopeng.name/2020/01/03/horovod%E5%A4%9A%E6%9C%BA%E5%A4%9A%E5%8D%A1%E5%90%AF%E5%8A%A8%E6%8C%87%E5%8D%97/</a></p>\n<h3 id=\"知识点\"><a href=\"#知识点\" class=\"headerlink\" title=\"知识点\"></a>知识点</h3><ol>\n<li>DP和DDP区别<br>DP是单进程多线程数据并行，将模型copy到每个设备，scatter数据到每个设备进行计算后，将多个GPU输出传到master device(一般为设备0)进行损失计算，（可以优化一下：将loss作为forward 一部分，这样的话每个GPU上自行计算loss，而不用进行模型输出的传输）将损失结果（分发的是各个GPU分别对应的loss）传给每个设备进行反向传播，每个设备将反向传播后的梯度到主设备进行汇聚求平均，然后replicate一份模型的参数到每个设备中，重复上诉的训练过程。</li>\n</ol>\n<ol start=\"2\">\n<li><p>DDP中all reduce与PS<br> DDP （all reduce）同步的是梯度，不是参数<br> PS，传给master的是梯度，返回的是参数</p>\n<p> 思考：对不重要的梯度进行累积后同步/直接不同步（会不会造成模型的不一致）</p>\n</li>\n<li><p>同步代码<br>分布式训练源代码解读：<a href=\"https://zhuanlan.zhihu.com/p/343951042\">https://zhuanlan.zhihu.com/p/343951042</a></p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs reasonml\">手动同步梯度<br><span class=\"hljs-keyword\">for</span> param <span class=\"hljs-keyword\">in</span> ddp_model.parameters<span class=\"hljs-literal\">()</span>: <br>\tdist.all<span class=\"hljs-constructor\">_reduce(<span class=\"hljs-params\">param</span>.<span class=\"hljs-params\">grad</span>.<span class=\"hljs-params\">data</span>, <span class=\"hljs-params\">op</span>=<span class=\"hljs-params\">dist</span>.<span class=\"hljs-params\">reduce_op</span>.SUM)</span><br>    param.grad.data /= world_size <br>\t<br>手动同步参数：<br>在不重要的样本反向传播后但是不同步参数后，同步梯度<br><span class=\"hljs-keyword\">for</span> param <span class=\"hljs-keyword\">in</span> ddp_model.parameters<span class=\"hljs-literal\">()</span>: <br>\tdist.all<span class=\"hljs-constructor\">_reduce(<span class=\"hljs-params\">param</span>.<span class=\"hljs-params\">data</span>, <span class=\"hljs-params\">op</span>=<span class=\"hljs-params\">dist</span>.<span class=\"hljs-params\">reduce_op</span>.SUM)</span><br>    param.data /= world_size <br></code></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h3><h4 id=\"solution-1-atom版本\"><a href=\"#solution-1-atom版本\" class=\"headerlink\" title=\"solution 1 - atom版本\"></a>solution 1 - atom版本</h4><p>裸机 多节点 atom平台</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">cd</span> /workspace/mnt/storage/anchao/ac_file/traffic_iteration/SupreVision &amp;&amp; \\<br>./install.sh &amp;&amp; \\<br>python -m torch.distributed.launch \\<br>        --nnode=4 \\<br>        --node_rank=0 \\<br>        --nproc_per_node=8 \\<br>        --master_addr=<span class=\"hljs-string\">&quot;10.244.55.30&quot;</span> \\<br>        --master_port=23467 \\<br>        tools/train.py \\<br>        --config_file configs/YOLOv3/opencv_pelee_reorg.yml \\<br>        SOLVER.IMS_PER_BATCH <span class=\"hljs-string\">&quot;16&quot;</span> \\<br>        MODEL.DEVICE_ID <span class=\"hljs-string\">&quot;(&#x27;0,1,2,3,4,5,6,7&#x27;)&quot;</span> \\<br>        &gt; detection0.log 2&gt;&amp;1<br></code></pre></td></tr></table></figure>\n\n<p>单机多卡</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">cd</span> /workspace/mnt/storage/anchao/ac_file/traffic_iteration/SupreVision &amp;&amp; \\<br>./install.sh &amp;&amp; \\<br>CUDA_VISIBLE_DEVICES=3,4,5,6 python -m torch.distributed.launch \\<br>                --nproc_per_node=2 \\<br>                --master_port=$((RANDOM + <span class=\"hljs-number\">20000</span>)) \\<br>                ./imagenet_final_train_master.py \\<br>                --config_file configs/YOLOv3/opencv_pelee_reorg.yml \\<br>                &gt; detection0.log 2&gt;&amp;1<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"solution-2-简洁版\"><a href=\"#solution-2-简洁版\" class=\"headerlink\" title=\"solution 2 - 简洁版\"></a>solution 2 - 简洁版</h4><p>多机多卡<br>suppose we have two machines and one machine have 4 gpus<br>In multi machine multi gpu situation, you have to choose a machine to be master node.<br>we named the machines A and B, and set A to be master node</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">script run at A<br><br>python -m torch.distributed.launch --nproc_per_node=4 --nnode=2 --node_rank=0 --master_addr=A_ip_address master_port=29500 main.py ... <br><br>script run at B<br><br>python -m torch.distributed.launch --nproc_per_node=4 --nnode=2 --node_rank=1 --master_addr=A_ip_address master_port=29500 main.py ... <br></code></pre></td></tr></table></figure>\n\n<p>单机多卡</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">python -m torch.distributed.launch --nproc_per_node=ngpus --master_port=29500 main.py ... <br></code></pre></td></tr></table></figure>"},{"layout":"blog","title":"常见问题及解决方案","date":"2021-11-11T08:48:29.000Z","_content":"\n1. vscode调试的时候找不到路径\n\n- 解决方案:在运行的python文件中添加sys.path，同时注意vscode调试的环境可以通过vscode界面最下面一栏进行替换\n```\nimport sys\nsys.path.append(\"/root/hushuang/IS-code\")\n```\n\n2. 程序运行的时候报错 no module named XXX\n- 如果是引入了与当前包并行的其他包里面的python文件，需要对文件使用setup tools进行打包，才能看到其他module里面的python文件\n```\nsetup.py\n    from setuptools import setup, find_packages\n\n    setup(\n        name='IO-aware Importance Sampling',               # 应用名\n        version='1.0',              # 版本号\n        packages=find_packages(),   # 包括在安装包内的Python包\n        include_package_data=True,   # 启用清单文件MANIFEST.in\n        # exclude_package_date={'':['.gitignore']},\n        # install_requires=[          # 依赖列表\n        #     'Flask>=0.10',\n        #     'Flask-SQLAlchemy>=1.5,<=2.1'\n        # ]\n    )\n\ninstall.sh\n    python setup.py \n//生成的XXX.egg.info文件是和install.sh一个目录内， build文件夹 是和setup.py同一个目录内\n```\n- 在import的时候不能导入整个包名 比如IOAS/A/a.py 想要访问IOAS/B/b.py的函数时候，不能在a.py函数里面写 from IOAS.B.b import func_XXX; 正确应该是 from B.b import func_XXX; \n\n\n3. vscode无法连接远程服务器，但是能够ssh\n\n解决方案：服务器/home目录满，清理之后就可以了\n方法二：清理~/.vscode-server 删除就可以了\n\n4. python 出现no module find XX\n\n一般是一个python文件引用了同一个文件夹里面另外一个python文件，解决方案就是添加一个setup文件，同时一定要注意install文件和setup文件要放在整个目录的最外层 IOAS里面包含的第一层\n\n如果出现函数参数和报错信息不一致的话，可能是因为setup安装了两个同名的文件，导致出错，使用pip unistall 自己的项目文件名称就可以了\n\n\n5. 在使用RPC的时候发现如下问题\n>  uni_score_rref = rpc.rpc_async(\"worker\", get_uni_sample_score_rref, args=(rank, uni_list_rref, model_param_rref, args, ))\n  File \"/nfs/home/shu/.local/lib/python3.6/site-packages/torch/distributed/rpc/api.py\", line 77, in wrapper\n    return func(*args, **kwargs)\n  File \"/nfs/home/shu/.local/lib/python3.6/site-packages/torch/distributed/rpc/api.py\", line 635, in rpc_async\n    return _invoke_rpc(to, func, RPCExecMode.ASYNC, args, kwargs)\n  File \"/nfs/home/shu/.local/lib/python3.6/site-packages/torch/distributed/rpc/api.py\", line 481, in _invoke_rpc\n    PythonUDF(func, args, kwargs)\n  File \"/nfs/home/shu/.local/lib/python3.6/site-packages/torch/distributed/rpc/internal.py\", line 86, in serialize\n    p.dump(obj)\nTypeError: can't pickle _thread.RLock objects\n\n解决：去掉调用rpc函数里面的args参数，因为args参数里面有一个logger 会导致报错\n\n\n\n6. The results is different when placing rpc_aync at a different .py file\n\n\nI want to execute a function at the worker side and return the results to the master. However, I find that the results is different when placing rpc_async at a different .py file\n\n#### Method 1\n\nmaster.py:\n\n``` python\n\nimport os\nimport torch\nimport torch.distributed.rpc as rpc\nfrom torch.distributed.rpc import RRef\nfrom test import sub_fun\n\nos.environ['MASTER_ADDR'] = '10.5.26.19'\nos.environ['MASTER_PORT'] = '5677'\n\nrpc.init_rpc(\"master\", rank=0, world_size=2)\nrref = torch.Tensor([0])\nsub_fun(rref)\nrpc.shutdown()\n```\n\ntest.py\n\n```python\n\ndef f(rref):\nprint(\"function is executed on master\")\n\ndef sub_fun(rref):\nx = rpc.rpc_async(\"worker\", f, args=(rref,))\n```\n\nworker.py:\n\n```python\nimport os\nimport torch\nimport torch.distributed.rpc as rpc\nfrom torch.distributed.rpc import RRef\n\nos.environ['MASTER_ADDR'] = '10.5.26.19'\nos.environ['MASTER_PORT'] = '5677'\n\ndef f(rref):\nprint(\"function is executed on worker\")\nrpc.init_rpc(\"worker\", rank=1, world_size=2)\nrpc.shutdown()\n```\n\nI found that the output is \"function is executed on master\" at the worker side.\n\n#### Method 2\n\nwhen I put the two functions: sub_fun and f in the master.py rather than the test.py, the result is \"function is executed on worker\".\n\nWhy the two ways output the different results. and how can I get the result 2 with the method 1.\n\n\n7. args 删除里面的某个参数\n```python\n  logger_arg = args.logger\n  del vars(args)['logger']\n\n  print('--------args----------')\n  for k in list(vars(args).keys()):\n      print(k)\n      # print('%s: %s' % (k, vars(args)[k]))\n  print('--------args----------\\n')\n```\n\n\n8. torch.distributed.rpc.rpc_aync\nrref相关文档 https://m.w3cschool.cn/pytorch/pytorch-cdva3buf.html\n\nhttps://github.com/pytorch/pytorch/issues/26759\n\n9. 修改账户sudo权限\n在有sudo权限的账户下执行 sudo visudo\n并在下面添加以下权限\nzhinengjisuan ALL=(ALL)     ALL\n\n\n10. how to share a cache among multiple subprocesses when using PyTorch DDP training.\n\nI want to share a cache among multiple processes when using ddp training. \nI found a potential solution is to use shared memory with torch.multiprocessing. \nHowever, it is not convinient if I want to training on multiple nodes, thus I choose the method ```torch.distributed.launch``` rather than ```mp.spwarn``` to init DDP training. \nThe question is how can I share a cache among multiple subprocesses in the same node,  when using the method ```torch.distributed.init_process_group```. \nSupposed that there are N nodes, we should create N caches, and these subprocesses in the same node share one of the caches.\n\nHas someone encounter the same problem before?\n\n已解决:\nmp.set_start_method('spawn')\n\n\n11. /nfs/home/shu/.local/lib/python3.6/site-packages/PIL/TiffImagePlugin.py:788: UserWarning: Corrupt EXIF data.  Expecting to read 4 bytes but only got 0.\n  warnings.warn(str(msg))\n\nsolution 1:\n```python\nimport os\nfrom PIL import Image\n\nimageFolder = /Path/To/Image/Folder\nlistImages = os.listdir(imageFolder)\n\nfor img in listImages:\n    imgPath = os.path.join(imageFolder,img)\n            \n    try:\n        img = Image.open(imgPath)\n        exif_data = img._getexif()\n    except ValueError as err:\n        print(err)\n        print(\"Error on image: \", img)\n```\n\n12. 8a100连接hec报错\nTorch RPC Connection closed by peer \n[W tensorpipe_agent.cpp:942] RPC agent for worker encountered error when sending outgoing request #0 to master: ECONNREFUSED: connection refused\n[W tensorpipe_agent.cpp:942] RPC agent for worker encountered error when sending outgoing request #1 to master: ECONNREFUSED: connection refused\n\n\n真正的解决方案：backend=rpc.BackendType.PROCESS_GROUP， \n不需要加其他的 os.environ['TF_SOCKET_IFNAME'] = 'ens3' 或者os.environ['GLOO_SOCKET_IFNAME'] = 'ens3'\n\n\n13. git pull超时，访问缓慢的解决方案\n参考链接：\nhttps://jasonkayzk.github.io/2019/10/10/%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8Git%E6%97%B6push-pull%E8%B6%85%E6%97%B6-%E4%BB%A5%E5%8F%8AGithub%E8%AE%BF%E9%97%AE%E6%85%A2%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/","source":"_posts/工具相关/常见问题及解决方案.md","raw":"---\nlayout: blog\ntitle: 常见问题及解决方案\ndate: 2021-11-11 16:48:29\ntags:  vscode python\n---\n\n1. vscode调试的时候找不到路径\n\n- 解决方案:在运行的python文件中添加sys.path，同时注意vscode调试的环境可以通过vscode界面最下面一栏进行替换\n```\nimport sys\nsys.path.append(\"/root/hushuang/IS-code\")\n```\n\n2. 程序运行的时候报错 no module named XXX\n- 如果是引入了与当前包并行的其他包里面的python文件，需要对文件使用setup tools进行打包，才能看到其他module里面的python文件\n```\nsetup.py\n    from setuptools import setup, find_packages\n\n    setup(\n        name='IO-aware Importance Sampling',               # 应用名\n        version='1.0',              # 版本号\n        packages=find_packages(),   # 包括在安装包内的Python包\n        include_package_data=True,   # 启用清单文件MANIFEST.in\n        # exclude_package_date={'':['.gitignore']},\n        # install_requires=[          # 依赖列表\n        #     'Flask>=0.10',\n        #     'Flask-SQLAlchemy>=1.5,<=2.1'\n        # ]\n    )\n\ninstall.sh\n    python setup.py \n//生成的XXX.egg.info文件是和install.sh一个目录内， build文件夹 是和setup.py同一个目录内\n```\n- 在import的时候不能导入整个包名 比如IOAS/A/a.py 想要访问IOAS/B/b.py的函数时候，不能在a.py函数里面写 from IOAS.B.b import func_XXX; 正确应该是 from B.b import func_XXX; \n\n\n3. vscode无法连接远程服务器，但是能够ssh\n\n解决方案：服务器/home目录满，清理之后就可以了\n方法二：清理~/.vscode-server 删除就可以了\n\n4. python 出现no module find XX\n\n一般是一个python文件引用了同一个文件夹里面另外一个python文件，解决方案就是添加一个setup文件，同时一定要注意install文件和setup文件要放在整个目录的最外层 IOAS里面包含的第一层\n\n如果出现函数参数和报错信息不一致的话，可能是因为setup安装了两个同名的文件，导致出错，使用pip unistall 自己的项目文件名称就可以了\n\n\n5. 在使用RPC的时候发现如下问题\n>  uni_score_rref = rpc.rpc_async(\"worker\", get_uni_sample_score_rref, args=(rank, uni_list_rref, model_param_rref, args, ))\n  File \"/nfs/home/shu/.local/lib/python3.6/site-packages/torch/distributed/rpc/api.py\", line 77, in wrapper\n    return func(*args, **kwargs)\n  File \"/nfs/home/shu/.local/lib/python3.6/site-packages/torch/distributed/rpc/api.py\", line 635, in rpc_async\n    return _invoke_rpc(to, func, RPCExecMode.ASYNC, args, kwargs)\n  File \"/nfs/home/shu/.local/lib/python3.6/site-packages/torch/distributed/rpc/api.py\", line 481, in _invoke_rpc\n    PythonUDF(func, args, kwargs)\n  File \"/nfs/home/shu/.local/lib/python3.6/site-packages/torch/distributed/rpc/internal.py\", line 86, in serialize\n    p.dump(obj)\nTypeError: can't pickle _thread.RLock objects\n\n解决：去掉调用rpc函数里面的args参数，因为args参数里面有一个logger 会导致报错\n\n\n\n6. The results is different when placing rpc_aync at a different .py file\n\n\nI want to execute a function at the worker side and return the results to the master. However, I find that the results is different when placing rpc_async at a different .py file\n\n#### Method 1\n\nmaster.py:\n\n``` python\n\nimport os\nimport torch\nimport torch.distributed.rpc as rpc\nfrom torch.distributed.rpc import RRef\nfrom test import sub_fun\n\nos.environ['MASTER_ADDR'] = '10.5.26.19'\nos.environ['MASTER_PORT'] = '5677'\n\nrpc.init_rpc(\"master\", rank=0, world_size=2)\nrref = torch.Tensor([0])\nsub_fun(rref)\nrpc.shutdown()\n```\n\ntest.py\n\n```python\n\ndef f(rref):\nprint(\"function is executed on master\")\n\ndef sub_fun(rref):\nx = rpc.rpc_async(\"worker\", f, args=(rref,))\n```\n\nworker.py:\n\n```python\nimport os\nimport torch\nimport torch.distributed.rpc as rpc\nfrom torch.distributed.rpc import RRef\n\nos.environ['MASTER_ADDR'] = '10.5.26.19'\nos.environ['MASTER_PORT'] = '5677'\n\ndef f(rref):\nprint(\"function is executed on worker\")\nrpc.init_rpc(\"worker\", rank=1, world_size=2)\nrpc.shutdown()\n```\n\nI found that the output is \"function is executed on master\" at the worker side.\n\n#### Method 2\n\nwhen I put the two functions: sub_fun and f in the master.py rather than the test.py, the result is \"function is executed on worker\".\n\nWhy the two ways output the different results. and how can I get the result 2 with the method 1.\n\n\n7. args 删除里面的某个参数\n```python\n  logger_arg = args.logger\n  del vars(args)['logger']\n\n  print('--------args----------')\n  for k in list(vars(args).keys()):\n      print(k)\n      # print('%s: %s' % (k, vars(args)[k]))\n  print('--------args----------\\n')\n```\n\n\n8. torch.distributed.rpc.rpc_aync\nrref相关文档 https://m.w3cschool.cn/pytorch/pytorch-cdva3buf.html\n\nhttps://github.com/pytorch/pytorch/issues/26759\n\n9. 修改账户sudo权限\n在有sudo权限的账户下执行 sudo visudo\n并在下面添加以下权限\nzhinengjisuan ALL=(ALL)     ALL\n\n\n10. how to share a cache among multiple subprocesses when using PyTorch DDP training.\n\nI want to share a cache among multiple processes when using ddp training. \nI found a potential solution is to use shared memory with torch.multiprocessing. \nHowever, it is not convinient if I want to training on multiple nodes, thus I choose the method ```torch.distributed.launch``` rather than ```mp.spwarn``` to init DDP training. \nThe question is how can I share a cache among multiple subprocesses in the same node,  when using the method ```torch.distributed.init_process_group```. \nSupposed that there are N nodes, we should create N caches, and these subprocesses in the same node share one of the caches.\n\nHas someone encounter the same problem before?\n\n已解决:\nmp.set_start_method('spawn')\n\n\n11. /nfs/home/shu/.local/lib/python3.6/site-packages/PIL/TiffImagePlugin.py:788: UserWarning: Corrupt EXIF data.  Expecting to read 4 bytes but only got 0.\n  warnings.warn(str(msg))\n\nsolution 1:\n```python\nimport os\nfrom PIL import Image\n\nimageFolder = /Path/To/Image/Folder\nlistImages = os.listdir(imageFolder)\n\nfor img in listImages:\n    imgPath = os.path.join(imageFolder,img)\n            \n    try:\n        img = Image.open(imgPath)\n        exif_data = img._getexif()\n    except ValueError as err:\n        print(err)\n        print(\"Error on image: \", img)\n```\n\n12. 8a100连接hec报错\nTorch RPC Connection closed by peer \n[W tensorpipe_agent.cpp:942] RPC agent for worker encountered error when sending outgoing request #0 to master: ECONNREFUSED: connection refused\n[W tensorpipe_agent.cpp:942] RPC agent for worker encountered error when sending outgoing request #1 to master: ECONNREFUSED: connection refused\n\n\n真正的解决方案：backend=rpc.BackendType.PROCESS_GROUP， \n不需要加其他的 os.environ['TF_SOCKET_IFNAME'] = 'ens3' 或者os.environ['GLOO_SOCKET_IFNAME'] = 'ens3'\n\n\n13. git pull超时，访问缓慢的解决方案\n参考链接：\nhttps://jasonkayzk.github.io/2019/10/10/%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8Git%E6%97%B6push-pull%E8%B6%85%E6%97%B6-%E4%BB%A5%E5%8F%8AGithub%E8%AE%BF%E9%97%AE%E6%85%A2%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/","slug":"工具相关/常见问题及解决方案","published":1,"updated":"2023-07-10T10:36:19.583Z","comments":1,"photos":[],"link":"","_id":"clk5ceioc002sjpjb9ftq37gz","content":"<ol>\n<li>vscode调试的时候找不到路径</li>\n</ol>\n<ul>\n<li>解决方案:在运行的python文件中添加sys.path，同时注意vscode调试的环境可以通过vscode界面最下面一栏进行替换<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elm\"><span class=\"hljs-keyword\">import</span> sys<br><span class=\"hljs-title\">sys</span>.path.append(<span class=\"hljs-string\">&quot;/root/hushuang/IS-code&quot;</span>)<br></code></pre></td></tr></table></figure></li>\n</ul>\n<ol start=\"2\">\n<li>程序运行的时候报错 no module named XXX</li>\n</ol>\n<ul>\n<li>如果是引入了与当前包并行的其他包里面的python文件，需要对文件使用setup tools进行打包，才能看到其他module里面的python文件<figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs clean\">setup.py<br>    <span class=\"hljs-keyword\">from</span> setuptools <span class=\"hljs-keyword\">import</span> setup, find_packages<br><br>    setup(<br>        name=<span class=\"hljs-string\">&#x27;IO-aware Importance Sampling&#x27;</span>,               # 应用名<br>        version=<span class=\"hljs-string\">&#x27;1.0&#x27;</span>,              # 版本号<br>        packages=find_packages(),   # 包括在安装包内的Python包<br>        include_package_data=<span class=\"hljs-literal\">True</span>,   # 启用清单文件MANIFEST.<span class=\"hljs-keyword\">in</span><br>        # exclude_package_date=&#123;<span class=\"hljs-string\">&#x27;&#x27;</span>:[<span class=\"hljs-string\">&#x27;.gitignore&#x27;</span>]&#125;,<br>        # install_requires=[          # 依赖列表<br>        #     <span class=\"hljs-string\">&#x27;Flask&gt;=0.10&#x27;</span>,<br>        #     <span class=\"hljs-string\">&#x27;Flask-SQLAlchemy&gt;=1.5,&lt;=2.1&#x27;</span><br>        # ]<br>    )<br><br>install.sh<br>    python setup.py <br><span class=\"hljs-comment\">//生成的XXX.egg.info文件是和install.sh一个目录内， build文件夹 是和setup.py同一个目录内</span><br></code></pre></td></tr></table></figure></li>\n<li>在import的时候不能导入整个包名 比如IOAS/A/a.py 想要访问IOAS/B/b.py的函数时候，不能在a.py函数里面写 from IOAS.B.b import func_XXX; 正确应该是 from B.b import func_XXX; </li>\n</ul>\n<ol start=\"3\">\n<li>vscode无法连接远程服务器，但是能够ssh</li>\n</ol>\n<p>解决方案：服务器/home目录满，清理之后就可以了<br>方法二：清理~/.vscode-server 删除就可以了</p>\n<ol start=\"4\">\n<li>python 出现no module find XX</li>\n</ol>\n<p>一般是一个python文件引用了同一个文件夹里面另外一个python文件，解决方案就是添加一个setup文件，同时一定要注意install文件和setup文件要放在整个目录的最外层 IOAS里面包含的第一层</p>\n<p>如果出现函数参数和报错信息不一致的话，可能是因为setup安装了两个同名的文件，导致出错，使用pip unistall 自己的项目文件名称就可以了</p>\n<ol start=\"5\">\n<li>在使用RPC的时候发现如下问题<blockquote>\n<p> uni_score_rref = rpc.rpc_async(“worker”, get_uni_sample_score_rref, args=(rank, uni_list_rref, model_param_rref, args, ))<br>File “/nfs/home/shu/.local/lib/python3.6/site-packages/torch/distributed/rpc/api.py”, line 77, in wrapper<br> return func(*args, **kwargs)<br>File “/nfs/home/shu/.local/lib/python3.6/site-packages/torch/distributed/rpc/api.py”, line 635, in rpc_async<br> return _invoke_rpc(to, func, RPCExecMode.ASYNC, args, kwargs)<br>File “/nfs/home/shu/.local/lib/python3.6/site-packages/torch/distributed/rpc/api.py”, line 481, in _invoke_rpc<br> PythonUDF(func, args, kwargs)<br>File “/nfs/home/shu/.local/lib/python3.6/site-packages/torch/distributed/rpc/internal.py”, line 86, in serialize<br> p.dump(obj)<br>TypeError: can’t pickle _thread.RLock objects</p>\n</blockquote>\n</li>\n</ol>\n<p>解决：去掉调用rpc函数里面的args参数，因为args参数里面有一个logger 会导致报错</p>\n<ol start=\"6\">\n<li>The results is different when placing rpc_aync at a different .py file</li>\n</ol>\n<p>I want to execute a function at the worker side and return the results to the master. However, I find that the results is different when placing rpc_async at a different .py file</p>\n<h4 id=\"Method-1\"><a href=\"#Method-1\" class=\"headerlink\" title=\"Method 1\"></a>Method 1</h4><p>master.py:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><br><span class=\"hljs-keyword\">import</span> os<br><span class=\"hljs-keyword\">import</span> torch<br><span class=\"hljs-keyword\">import</span> torch.distributed.rpc <span class=\"hljs-keyword\">as</span> rpc<br><span class=\"hljs-keyword\">from</span> torch.distributed.rpc <span class=\"hljs-keyword\">import</span> RRef<br><span class=\"hljs-keyword\">from</span> test <span class=\"hljs-keyword\">import</span> sub_fun<br><br>os.environ[<span class=\"hljs-string\">&#x27;MASTER_ADDR&#x27;</span>] = <span class=\"hljs-string\">&#x27;10.5.26.19&#x27;</span><br>os.environ[<span class=\"hljs-string\">&#x27;MASTER_PORT&#x27;</span>] = <span class=\"hljs-string\">&#x27;5677&#x27;</span><br><br>rpc.init_rpc(<span class=\"hljs-string\">&quot;master&quot;</span>, rank=<span class=\"hljs-number\">0</span>, world_size=<span class=\"hljs-number\">2</span>)<br>rref = torch.Tensor([<span class=\"hljs-number\">0</span>])<br>sub_fun(rref)<br>rpc.shutdown()<br></code></pre></td></tr></table></figure>\n\n<p>test.py</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">f</span>(<span class=\"hljs-params\">rref</span>):</span><br><span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;function is executed on master&quot;</span>)<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">sub_fun</span>(<span class=\"hljs-params\">rref</span>):</span><br>x = rpc.rpc_async(<span class=\"hljs-string\">&quot;worker&quot;</span>, f, args=(rref,))<br></code></pre></td></tr></table></figure>\n\n<p>worker.py:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> os<br><span class=\"hljs-keyword\">import</span> torch<br><span class=\"hljs-keyword\">import</span> torch.distributed.rpc <span class=\"hljs-keyword\">as</span> rpc<br><span class=\"hljs-keyword\">from</span> torch.distributed.rpc <span class=\"hljs-keyword\">import</span> RRef<br><br>os.environ[<span class=\"hljs-string\">&#x27;MASTER_ADDR&#x27;</span>] = <span class=\"hljs-string\">&#x27;10.5.26.19&#x27;</span><br>os.environ[<span class=\"hljs-string\">&#x27;MASTER_PORT&#x27;</span>] = <span class=\"hljs-string\">&#x27;5677&#x27;</span><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">f</span>(<span class=\"hljs-params\">rref</span>):</span><br><span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;function is executed on worker&quot;</span>)<br>rpc.init_rpc(<span class=\"hljs-string\">&quot;worker&quot;</span>, rank=<span class=\"hljs-number\">1</span>, world_size=<span class=\"hljs-number\">2</span>)<br>rpc.shutdown()<br></code></pre></td></tr></table></figure>\n\n<p>I found that the output is “function is executed on master” at the worker side.</p>\n<h4 id=\"Method-2\"><a href=\"#Method-2\" class=\"headerlink\" title=\"Method 2\"></a>Method 2</h4><p>when I put the two functions: sub_fun and f in the master.py rather than the test.py, the result is “function is executed on worker”.</p>\n<p>Why the two ways output the different results. and how can I get the result 2 with the method 1.</p>\n<ol start=\"7\">\n<li>args 删除里面的某个参数<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">logger_arg = args.logger<br><span class=\"hljs-keyword\">del</span> <span class=\"hljs-built_in\">vars</span>(args)[<span class=\"hljs-string\">&#x27;logger&#x27;</span>]<br><br><span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;--------args----------&#x27;</span>)<br><span class=\"hljs-keyword\">for</span> k <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">list</span>(<span class=\"hljs-built_in\">vars</span>(args).keys()):<br>    <span class=\"hljs-built_in\">print</span>(k)<br>    <span class=\"hljs-comment\"># print(&#x27;%s: %s&#x27; % (k, vars(args)[k]))</span><br><span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;--------args----------\\n&#x27;</span>)<br></code></pre></td></tr></table></figure></li>\n</ol>\n<ol start=\"8\">\n<li>torch.distributed.rpc.rpc_aync<br>rref相关文档 <a href=\"https://m.w3cschool.cn/pytorch/pytorch-cdva3buf.html\">https://m.w3cschool.cn/pytorch/pytorch-cdva3buf.html</a></li>\n</ol>\n<p><a href=\"https://github.com/pytorch/pytorch/issues/26759\">https://github.com/pytorch/pytorch/issues/26759</a></p>\n<ol start=\"9\">\n<li>修改账户sudo权限<br>在有sudo权限的账户下执行 sudo visudo<br>并在下面添加以下权限<br>zhinengjisuan ALL=(ALL)     ALL</li>\n</ol>\n<ol start=\"10\">\n<li>how to share a cache among multiple subprocesses when using PyTorch DDP training.</li>\n</ol>\n<p>I want to share a cache among multiple processes when using ddp training.<br>I found a potential solution is to use shared memory with torch.multiprocessing.<br>However, it is not convinient if I want to training on multiple nodes, thus I choose the method <code>torch.distributed.launch</code> rather than <code>mp.spwarn</code> to init DDP training.<br>The question is how can I share a cache among multiple subprocesses in the same node,  when using the method <code>torch.distributed.init_process_group</code>.<br>Supposed that there are N nodes, we should create N caches, and these subprocesses in the same node share one of the caches.</p>\n<p>Has someone encounter the same problem before?</p>\n<p>已解决:<br>mp.set_start_method(‘spawn’)</p>\n<ol start=\"11\">\n<li>/nfs/home/shu/.local/lib/python3.6/site-packages/PIL/TiffImagePlugin.py:788: UserWarning: Corrupt EXIF data.  Expecting to read 4 bytes but only got 0.<br>warnings.warn(str(msg))</li>\n</ol>\n<p>solution 1:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> os<br><span class=\"hljs-keyword\">from</span> PIL <span class=\"hljs-keyword\">import</span> Image<br><br>imageFolder = /Path/To/Image/Folder<br>listImages = os.listdir(imageFolder)<br><br><span class=\"hljs-keyword\">for</span> img <span class=\"hljs-keyword\">in</span> listImages:<br>    imgPath = os.path.join(imageFolder,img)<br>            <br>    <span class=\"hljs-keyword\">try</span>:<br>        img = Image.<span class=\"hljs-built_in\">open</span>(imgPath)<br>        exif_data = img._getexif()<br>    <span class=\"hljs-keyword\">except</span> ValueError <span class=\"hljs-keyword\">as</span> err:<br>        <span class=\"hljs-built_in\">print</span>(err)<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;Error on image: &quot;</span>, img)<br></code></pre></td></tr></table></figure>\n\n<ol start=\"12\">\n<li>8a100连接hec报错<br>Torch RPC Connection closed by peer<br>[W tensorpipe_agent.cpp:942] RPC agent for worker encountered error when sending outgoing request #0 to master: ECONNREFUSED: connection refused<br>[W tensorpipe_agent.cpp:942] RPC agent for worker encountered error when sending outgoing request #1 to master: ECONNREFUSED: connection refused</li>\n</ol>\n<p>真正的解决方案：backend=rpc.BackendType.PROCESS_GROUP，<br>不需要加其他的 os.environ[‘TF_SOCKET_IFNAME’] = ‘ens3’ 或者os.environ[‘GLOO_SOCKET_IFNAME’] = ‘ens3’</p>\n<ol start=\"13\">\n<li>git pull超时，访问缓慢的解决方案<br>参考链接：<br><a href=\"https://jasonkayzk.github.io/2019/10/10/%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8Git%E6%97%B6push-pull%E8%B6%85%E6%97%B6-%E4%BB%A5%E5%8F%8AGithub%E8%AE%BF%E9%97%AE%E6%85%A2%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/\">https://jasonkayzk.github.io/2019/10/10/%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8Git%E6%97%B6push-pull%E8%B6%85%E6%97%B6-%E4%BB%A5%E5%8F%8AGithub%E8%AE%BF%E9%97%AE%E6%85%A2%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</a></li>\n</ol>\n","site":{"data":{}},"wordcount":5383,"excerpt":"","more":"<ol>\n<li>vscode调试的时候找不到路径</li>\n</ol>\n<ul>\n<li>解决方案:在运行的python文件中添加sys.path，同时注意vscode调试的环境可以通过vscode界面最下面一栏进行替换<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elm\"><span class=\"hljs-keyword\">import</span> sys<br><span class=\"hljs-title\">sys</span>.path.append(<span class=\"hljs-string\">&quot;/root/hushuang/IS-code&quot;</span>)<br></code></pre></td></tr></table></figure></li>\n</ul>\n<ol start=\"2\">\n<li>程序运行的时候报错 no module named XXX</li>\n</ol>\n<ul>\n<li>如果是引入了与当前包并行的其他包里面的python文件，需要对文件使用setup tools进行打包，才能看到其他module里面的python文件<figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs clean\">setup.py<br>    <span class=\"hljs-keyword\">from</span> setuptools <span class=\"hljs-keyword\">import</span> setup, find_packages<br><br>    setup(<br>        name=<span class=\"hljs-string\">&#x27;IO-aware Importance Sampling&#x27;</span>,               # 应用名<br>        version=<span class=\"hljs-string\">&#x27;1.0&#x27;</span>,              # 版本号<br>        packages=find_packages(),   # 包括在安装包内的Python包<br>        include_package_data=<span class=\"hljs-literal\">True</span>,   # 启用清单文件MANIFEST.<span class=\"hljs-keyword\">in</span><br>        # exclude_package_date=&#123;<span class=\"hljs-string\">&#x27;&#x27;</span>:[<span class=\"hljs-string\">&#x27;.gitignore&#x27;</span>]&#125;,<br>        # install_requires=[          # 依赖列表<br>        #     <span class=\"hljs-string\">&#x27;Flask&gt;=0.10&#x27;</span>,<br>        #     <span class=\"hljs-string\">&#x27;Flask-SQLAlchemy&gt;=1.5,&lt;=2.1&#x27;</span><br>        # ]<br>    )<br><br>install.sh<br>    python setup.py <br><span class=\"hljs-comment\">//生成的XXX.egg.info文件是和install.sh一个目录内， build文件夹 是和setup.py同一个目录内</span><br></code></pre></td></tr></table></figure></li>\n<li>在import的时候不能导入整个包名 比如IOAS/A/a.py 想要访问IOAS/B/b.py的函数时候，不能在a.py函数里面写 from IOAS.B.b import func_XXX; 正确应该是 from B.b import func_XXX; </li>\n</ul>\n<ol start=\"3\">\n<li>vscode无法连接远程服务器，但是能够ssh</li>\n</ol>\n<p>解决方案：服务器/home目录满，清理之后就可以了<br>方法二：清理~/.vscode-server 删除就可以了</p>\n<ol start=\"4\">\n<li>python 出现no module find XX</li>\n</ol>\n<p>一般是一个python文件引用了同一个文件夹里面另外一个python文件，解决方案就是添加一个setup文件，同时一定要注意install文件和setup文件要放在整个目录的最外层 IOAS里面包含的第一层</p>\n<p>如果出现函数参数和报错信息不一致的话，可能是因为setup安装了两个同名的文件，导致出错，使用pip unistall 自己的项目文件名称就可以了</p>\n<ol start=\"5\">\n<li>在使用RPC的时候发现如下问题<blockquote>\n<p> uni_score_rref = rpc.rpc_async(“worker”, get_uni_sample_score_rref, args=(rank, uni_list_rref, model_param_rref, args, ))<br>File “/nfs/home/shu/.local/lib/python3.6/site-packages/torch/distributed/rpc/api.py”, line 77, in wrapper<br> return func(*args, **kwargs)<br>File “/nfs/home/shu/.local/lib/python3.6/site-packages/torch/distributed/rpc/api.py”, line 635, in rpc_async<br> return _invoke_rpc(to, func, RPCExecMode.ASYNC, args, kwargs)<br>File “/nfs/home/shu/.local/lib/python3.6/site-packages/torch/distributed/rpc/api.py”, line 481, in _invoke_rpc<br> PythonUDF(func, args, kwargs)<br>File “/nfs/home/shu/.local/lib/python3.6/site-packages/torch/distributed/rpc/internal.py”, line 86, in serialize<br> p.dump(obj)<br>TypeError: can’t pickle _thread.RLock objects</p>\n</blockquote>\n</li>\n</ol>\n<p>解决：去掉调用rpc函数里面的args参数，因为args参数里面有一个logger 会导致报错</p>\n<ol start=\"6\">\n<li>The results is different when placing rpc_aync at a different .py file</li>\n</ol>\n<p>I want to execute a function at the worker side and return the results to the master. However, I find that the results is different when placing rpc_async at a different .py file</p>\n<h4 id=\"Method-1\"><a href=\"#Method-1\" class=\"headerlink\" title=\"Method 1\"></a>Method 1</h4><p>master.py:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><br><span class=\"hljs-keyword\">import</span> os<br><span class=\"hljs-keyword\">import</span> torch<br><span class=\"hljs-keyword\">import</span> torch.distributed.rpc <span class=\"hljs-keyword\">as</span> rpc<br><span class=\"hljs-keyword\">from</span> torch.distributed.rpc <span class=\"hljs-keyword\">import</span> RRef<br><span class=\"hljs-keyword\">from</span> test <span class=\"hljs-keyword\">import</span> sub_fun<br><br>os.environ[<span class=\"hljs-string\">&#x27;MASTER_ADDR&#x27;</span>] = <span class=\"hljs-string\">&#x27;10.5.26.19&#x27;</span><br>os.environ[<span class=\"hljs-string\">&#x27;MASTER_PORT&#x27;</span>] = <span class=\"hljs-string\">&#x27;5677&#x27;</span><br><br>rpc.init_rpc(<span class=\"hljs-string\">&quot;master&quot;</span>, rank=<span class=\"hljs-number\">0</span>, world_size=<span class=\"hljs-number\">2</span>)<br>rref = torch.Tensor([<span class=\"hljs-number\">0</span>])<br>sub_fun(rref)<br>rpc.shutdown()<br></code></pre></td></tr></table></figure>\n\n<p>test.py</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">f</span>(<span class=\"hljs-params\">rref</span>):</span><br><span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;function is executed on master&quot;</span>)<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">sub_fun</span>(<span class=\"hljs-params\">rref</span>):</span><br>x = rpc.rpc_async(<span class=\"hljs-string\">&quot;worker&quot;</span>, f, args=(rref,))<br></code></pre></td></tr></table></figure>\n\n<p>worker.py:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> os<br><span class=\"hljs-keyword\">import</span> torch<br><span class=\"hljs-keyword\">import</span> torch.distributed.rpc <span class=\"hljs-keyword\">as</span> rpc<br><span class=\"hljs-keyword\">from</span> torch.distributed.rpc <span class=\"hljs-keyword\">import</span> RRef<br><br>os.environ[<span class=\"hljs-string\">&#x27;MASTER_ADDR&#x27;</span>] = <span class=\"hljs-string\">&#x27;10.5.26.19&#x27;</span><br>os.environ[<span class=\"hljs-string\">&#x27;MASTER_PORT&#x27;</span>] = <span class=\"hljs-string\">&#x27;5677&#x27;</span><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">f</span>(<span class=\"hljs-params\">rref</span>):</span><br><span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;function is executed on worker&quot;</span>)<br>rpc.init_rpc(<span class=\"hljs-string\">&quot;worker&quot;</span>, rank=<span class=\"hljs-number\">1</span>, world_size=<span class=\"hljs-number\">2</span>)<br>rpc.shutdown()<br></code></pre></td></tr></table></figure>\n\n<p>I found that the output is “function is executed on master” at the worker side.</p>\n<h4 id=\"Method-2\"><a href=\"#Method-2\" class=\"headerlink\" title=\"Method 2\"></a>Method 2</h4><p>when I put the two functions: sub_fun and f in the master.py rather than the test.py, the result is “function is executed on worker”.</p>\n<p>Why the two ways output the different results. and how can I get the result 2 with the method 1.</p>\n<ol start=\"7\">\n<li>args 删除里面的某个参数<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">logger_arg = args.logger<br><span class=\"hljs-keyword\">del</span> <span class=\"hljs-built_in\">vars</span>(args)[<span class=\"hljs-string\">&#x27;logger&#x27;</span>]<br><br><span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;--------args----------&#x27;</span>)<br><span class=\"hljs-keyword\">for</span> k <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">list</span>(<span class=\"hljs-built_in\">vars</span>(args).keys()):<br>    <span class=\"hljs-built_in\">print</span>(k)<br>    <span class=\"hljs-comment\"># print(&#x27;%s: %s&#x27; % (k, vars(args)[k]))</span><br><span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;--------args----------\\n&#x27;</span>)<br></code></pre></td></tr></table></figure></li>\n</ol>\n<ol start=\"8\">\n<li>torch.distributed.rpc.rpc_aync<br>rref相关文档 <a href=\"https://m.w3cschool.cn/pytorch/pytorch-cdva3buf.html\">https://m.w3cschool.cn/pytorch/pytorch-cdva3buf.html</a></li>\n</ol>\n<p><a href=\"https://github.com/pytorch/pytorch/issues/26759\">https://github.com/pytorch/pytorch/issues/26759</a></p>\n<ol start=\"9\">\n<li>修改账户sudo权限<br>在有sudo权限的账户下执行 sudo visudo<br>并在下面添加以下权限<br>zhinengjisuan ALL=(ALL)     ALL</li>\n</ol>\n<ol start=\"10\">\n<li>how to share a cache among multiple subprocesses when using PyTorch DDP training.</li>\n</ol>\n<p>I want to share a cache among multiple processes when using ddp training.<br>I found a potential solution is to use shared memory with torch.multiprocessing.<br>However, it is not convinient if I want to training on multiple nodes, thus I choose the method <code>torch.distributed.launch</code> rather than <code>mp.spwarn</code> to init DDP training.<br>The question is how can I share a cache among multiple subprocesses in the same node,  when using the method <code>torch.distributed.init_process_group</code>.<br>Supposed that there are N nodes, we should create N caches, and these subprocesses in the same node share one of the caches.</p>\n<p>Has someone encounter the same problem before?</p>\n<p>已解决:<br>mp.set_start_method(‘spawn’)</p>\n<ol start=\"11\">\n<li>/nfs/home/shu/.local/lib/python3.6/site-packages/PIL/TiffImagePlugin.py:788: UserWarning: Corrupt EXIF data.  Expecting to read 4 bytes but only got 0.<br>warnings.warn(str(msg))</li>\n</ol>\n<p>solution 1:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> os<br><span class=\"hljs-keyword\">from</span> PIL <span class=\"hljs-keyword\">import</span> Image<br><br>imageFolder = /Path/To/Image/Folder<br>listImages = os.listdir(imageFolder)<br><br><span class=\"hljs-keyword\">for</span> img <span class=\"hljs-keyword\">in</span> listImages:<br>    imgPath = os.path.join(imageFolder,img)<br>            <br>    <span class=\"hljs-keyword\">try</span>:<br>        img = Image.<span class=\"hljs-built_in\">open</span>(imgPath)<br>        exif_data = img._getexif()<br>    <span class=\"hljs-keyword\">except</span> ValueError <span class=\"hljs-keyword\">as</span> err:<br>        <span class=\"hljs-built_in\">print</span>(err)<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;Error on image: &quot;</span>, img)<br></code></pre></td></tr></table></figure>\n\n<ol start=\"12\">\n<li>8a100连接hec报错<br>Torch RPC Connection closed by peer<br>[W tensorpipe_agent.cpp:942] RPC agent for worker encountered error when sending outgoing request #0 to master: ECONNREFUSED: connection refused<br>[W tensorpipe_agent.cpp:942] RPC agent for worker encountered error when sending outgoing request #1 to master: ECONNREFUSED: connection refused</li>\n</ol>\n<p>真正的解决方案：backend=rpc.BackendType.PROCESS_GROUP，<br>不需要加其他的 os.environ[‘TF_SOCKET_IFNAME’] = ‘ens3’ 或者os.environ[‘GLOO_SOCKET_IFNAME’] = ‘ens3’</p>\n<ol start=\"13\">\n<li>git pull超时，访问缓慢的解决方案<br>参考链接：<br><a href=\"https://jasonkayzk.github.io/2019/10/10/%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8Git%E6%97%B6push-pull%E8%B6%85%E6%97%B6-%E4%BB%A5%E5%8F%8AGithub%E8%AE%BF%E9%97%AE%E6%85%A2%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/\">https://jasonkayzk.github.io/2019/10/10/%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8Git%E6%97%B6push-pull%E8%B6%85%E6%97%B6-%E4%BB%A5%E5%8F%8AGithub%E8%AE%BF%E9%97%AE%E6%85%A2%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</a></li>\n</ol>\n"},{"title":"每天任务记录","hide":true,"date":"2021-11-15T03:19:12.000Z","_content":"11-15\n记得之后验证一下multiple是否支持只有loss这种情况，如果支持的话，sampler全部修改为一个，同时目前只修改和看BS这种情况\n\ntune参数包括warm_up_epoch and sampling rate\n\n\n完成情况：整理完之前的IOAS代码，将multi和single进行融合，同时使用字典形式来替换if-else多个flag的情况\n记录：leetcode 刷题指南完成：贪心算法， 哈希表，双指针部分, 栈与队列部分\n\n\n11-16\n初步完成论文框架思维导图\n\n修改代码，找到IO瓶颈场景\n\n在代码中添加上视频分析这个场景\n\n今天突然想到suprevision是用的什么anchor box，需要将数据下载完成后验证，猜测使用featmap_size??而不是预设的anchor\n\n总结：\n看完interviewtop上操作系统的八股文\n下载coco数据\n完成一版xmind思路调整\n查看阿里基础架构面经\n\n\n11-17\n找到io为瓶颈的场景，并进行重要性采样实验\n目前发现MS比BS精度高\n\nBS：面临的问题  如何选择阈值 目前：搜索出初始thres_ratio, 之后使用历史+当前thres_ratio调整，//没有被计算的使用远程存储的模型进行计算,以及根据模型能力调整thres_ratio\n\nMS: recall interval,不同等级之间的recall 时间差距是1 epoch 吗，新划分出来训练的类又如何根据阈值划分呢（等分感觉不科学）//建一个模型自动划分和确定等待的时间  （多个阈值和多个等待时间的确定）\n\n现在只修改BS (1)实现在存储端计算样本重要性， （2）感觉样本的位置\n\nhttps://www.sigarch.org/the-new-bottlenecks-of-ml-training-a-storage-perspective/ 这个讲得挺好\n处理的浏览了一下FreqCheck 的源码 但是每太明白细节上是如何在torch.save()后面封装 fsync(),   以及如何根据runtime overhead的profile结果进行自适应的checkpointing frequency超参数的调节\n\n目标：弄懂多进程异步/模型的异步训练， 参考autoassist 以及checkFreq，subprocess\n以及另外开一个进程来进行io带宽的测量(profile)以及未读取数据的重要性更新，另外一个空闲节点\n\n\n11-18\n\n看了autoassist的多进程，但是他们在训练另外一个模型进行样本的现在是训练了另外一个二分模型，这个二分模型的目标是 loss大于均值为target或者target model判断错误的label=1\n\n\n我要训练的另外一个模型是在存储节点训练的模型，无需训练只需要将模型每次最新权重穿过来，在checkpoint的时候将模型传给远端; screen 需要同时训练另外一个模型会加重CPU和GPU训练负担，同时也不是很好同步轻量级模型和远程target模型判断样本重要性的差距\n\n完成另外一个进程异步训练模型的初步代码\n\n11-22\n\n完成情况：\n完成主进程和子进程相互传输重要性分数，invalid list以及模型初步代码\n\n明天需要解决的问题：\n1）如果解决模型参数保存的时候使用model.cpu().state_dict() 但是计算的时候需要使用dp 或者cuda, 保存模型这个动作如何转为复制模型参数，而不是真正将模型保存到cpu\n\n2) 如何减少推理时间太长的问题，如果使用原模型进行不重要样本重要性计算\n\n3）如果将一个节点转移到两个节点间的数据传输（远端存储系统情况）\n\n4）把这个解决了，再解决如何修改io module 自定义一个缓冲区，然后在缓冲区/cache中实现TLB表，以及数据从缓冲区中读取\n\n\n\n要解决的问题：1 分布式训练如何将另外一个进程计算得到的uni_score广播给其他进程\n而且注意是多个分布式训练主进程对应一个子进程，不应该建立多个进行不重要样本重要性计算的子进程\n\n目前遇到的问题：RuntimeError: module must have its parameters and buffers on device cuda:0 (device_ids[0]) but found one of them on device: cpu-->解决，因为model.cpu().state_dict导致\n\n\n11-23\n\n完成情况：\n\n1）使用一个copy.deepcopy完成在gpu上模型的拷贝到cpu\n2) 解决子进程无法正常退出的问题\n3）初步熟悉dataloader和dataset的代码\n\n下一步：\n如何解决判断数据是在缓存， 本地磁盘， 还是远端存储系统呢\n\n11-24  \n\n1）调整了lru_cache的逻辑\n2）但是目前不知道如何将tlb得到的信息转为io_predict_time\n3）初步使用多进程访问同一个cache,同时记录总访问次数和命中率，因为多进程需要共享一个数据结构，因此使用multiprocessing.Manager 因为LRUcache是自定义的一个数据结构，因此需要使用自定义的manager\n\n目前发现worker越多，access 缓存次数越多\n\nworker = 8\nself.size:256\ntotal_access_time:2432, hit_time:128\n\nworker = 4\nself.size:256\ntotal_access_time:1048, hit_time:128\n\n\nworker = 0\nself.size:128\ntotal_access_time:384, hit_time:256\n\n如何只是对cache的每个变量使用multiprocessing进行加锁的话会导致出现None 结构remove错误，所以对于cache的get set函数都应该是一个原子操作（一个事务），所以需要对cache使用原子操作（加锁），而不仅仅是里面的一个变量加锁就可以了\n\n11-25\n\n验证多进程为什么总的访问次数会增加，以及为什么使用缓存的大小增加，但是命中率会减小\n考虑如何将tlb功能转为IO score的计算\n如何感知数据的位置，在其他节点的存储中，本地存储中，还是缓存中\n\n发现：epoch=0和epoch=1的时候多进程取数据hit time=0， cache size=256 但是如果worker=0的话， epoch=1时候的命中率应该为128 cache size=128\n解释：因为我在执行流程中间break了，但是数据还在提前取后面一轮的，所以导致cache size会满，同时命中率下降；第二轮本来要取的序列就减少了，所以多进程也没有讲缓存的数据冲走；也可以解释第0轮epoch就有2000多次的访问量\n\n加上缓存：\nTraining done in 0.069387 hours \nTraining  done in 0.068791 hours\n\n\n不加缓存：\nTraining  done in 0.017339 hours\nTraining  done in 0.035785 hours\nTraining  done in 0.037956 hours 命中率384\n\n\n使用字典进行缓存，随机置换：\nTraining  done in 0.022509 hours \nTraining  done in 0.039637 hours  命中率 224\n\n\npyshmht 为python设计的基于hash表的共享内存\n\nasyncio\n\n目前结论：使用一个随机置换策略的缓存相比LRU置换效果更好  或者直接使用coodl的缓存后就固定不变\n\n感觉应该是LRU每次加锁读写链表\n\n明日安排：完成整个训练过程加缓存以及如何将缓存的位置转化为IO score\n\n\n11-29\n\nRPC小例子\nhttps://zhuanlan.zhihu.com/p/136372142\n\n了解一下rpc pytorch， 打算使用nfs再使用orangefs来实现两个节点上worker的通信\n看了两篇论文：1.是分析深度学习不同存储方式的性能 2.运用机器学习判断应用的IO模式，然后自适应的选择相应的优化策略（主要是针对有读写，以及I/O模式在整个应用生命过程中会改变，但深度学习是只读的，I/O模式似乎都是一样的）\nhttps://github.com/apachecn/apachecn-dl-zh/blob/master/docs/pt-tut-17/65.md\n\n11-30\n使用sudo aptitude install nfs-common 选择n y的时候安装失败，导致sudo无法使用，同时机器无法连接，修机器\n参加rebuttal的会议\n\n12-1\n\n问题如何在orangefs上挂imagenet, 挂了之后仍然像ext4文件一样访问 /mnt/orangefs吗， 记得修改默认orangefs 服务器的文件目录，目前默认是/local500/storage-orangefs/吗\n最后为什么是mount hec09的orangefs 为什么不是local500/storage-orangefs\n\n\n12-2 \n\n1. 完成 rebuttal的提交\n2. 初步在节点hec01 和hec03上实现 rpc测试  学长使用的是不同语言之间相互通信的grpc 先写一个.proto 文件，然后使用一个工具 将他编译为目标py文件或者go文件，然后分别在py和go文件里面使用这个编译好的文件\n\n在提交英文版本的时候一定要注意英语的拼写问题\n\npytorch官网上的rpc网络： https://github.com/pytorch/pytorch/blob/master/docs/source/rpc.rst\n\n\n\n12-3 现在的问题是：worker如何确定当前可以shutdown\n\n目前遇到的问题是如果是将远程过程调用放在sampler，如果是多进程取sampler的话会导致 出错，因此应该把远程过程调用的逻辑放在主函数里面\n\n多进程会有多个sampler副本吗  难道是多进程访问sampler会加锁？？\n \n\n\n明天 1.实现在每个epoch前进行重要性计算 train_one_epoch前  2. score通过字典传递，而不是list\n\nrpc在远程过程调用的时候，如果调用的函数和初始化不在main函数下面py文件(主要的train_main 文件里)内会导致调用函数不一样 本来打算调用worker, 调用到master端\n\n\n12-7\n实现使用nfs， 以及torch.distributed.rpc实现两个任务之间的通信， 阅读grpc 的route_guide example源码， 如果要使用grpc需要使用异步+call back函数，或者使用一个子进程+同步grpc，然后实现主进程和子进程之间通过共享内存实现数据的共享\n\n\n\n12-13\n\n在hec01使用setattr修改了文件dataset的属性\n现在的问题是存储单元如何得知自己存储节点的数据，或者假设存储节点非常的近，那么存储节点只需要派一个节点进行训练就好了\n\n现在可以实现在一个存储单元上挂载orangefs-client查看数据， 之后换到新机器上实验orangefs形式的存储单元和计算单元 通讯和传递消息，目前server端只需要一个节点来进行推理，不需要每个server对每个server端的数据进行推理\n\n12-14 \n找到一个bug， loss.mean().backward应该在loss.cpu.detach()前面，否则就会训练的时候精度一直为0，怀疑是torch版本的问题\n打算再新环境中使用orangefs，然后进行通讯任务训练\n以及考虑加上cache + IO score 预先训练cache中的数据\n\n\n今天leetcode练习到532题\n\n明日安排：\n1. 先profile一下cache time 是否真的的比ssd time小很多 \n2. 同时查看一下是不是每轮epoch 第一个iteration时间最长， 找到网上解答原因\n3. multi-criterion到底应该怎么用。\n4. 写一个简单的用cache的信息加入到multi-criterion计算（不同的优先级给定一个分数），以及在cache中采样第一个batch, 以及随机置换的cache策略，先写一个版本\n\n5. cache size以及cache的转换策略将对io score产生怎样的影响\n\n相同数据每次的load time是不是都是变化很大。我感觉应该用时间近似，而不应该用level,因为不同cache的ssd的远近可能导致这两个时间相差很大，有的ssd读取和cache时间差不多那么io score应该就差不多，否则就应该加大io score的差距\n\n\n感觉多进程预取会抵消cache好处？？如果IO是瓶颈的话，那么预取的效果就比从cache中取数据的效果差\n\n\n12-15 完成一个简易版本的cache-aware sampling\n\n主要包含下面三个功能的实现：\n1. IO score的计算问题 使用profile的cache的时间和ssd时间近似替代训练序列的all_result_list['iotime']\n2. sampler的序列问题， 先使用cache 里面缓存的序列\n3. cache的置换问题，初步使用self.vis字典实现先替换cache中vis的序列，但是问题是每个epoch都需要clear一下cache的vis序列\n\n但是现在还是在注释中\n\n\n12-16\n尝试在8a100上实验，可能会考虑到分布式训练的sampler的修改\n使之适应于分布式+orangefs这种场景\n\n完成情况：目前在多GPU上调试了之前hec上面的代码，可以跑通单机多卡加上cache, 和修改了cache time计算方式的代码\n初步完成昨天1， 2， 3个功能，目前的问题就是DataParallel+ another model in storage side可能会有问题\n\n发现4 worker的时候 每4个iteration 第一个时间最长， 之后的时间都递减\n\n明日计划：\n\n四叉树合集有时间看看\n\n\n12-17 数据传输慢是因为传输的带宽被占满了吗？ 是否可以开不同的数据取线程？来为用于级别cache增加命中率\n为什么4worker时每个iteration 4个中必有一个时间长 （已解决）\n这个iteration time和worker的设置有关\n\n\n12-20\nTODO: 分布式情况，多个节点得有多个cache, 这样的话在进行取数据的时候首先取cache中缓存的数据就不对，需要通过RDMA 需要直接取其他节点的cache数据才行\n目前分析原因是消耗比读取快，消耗了一轮回过来，还是没有讲一个batch读完，所以又会在worker1处阻塞住，同时在worker1阻塞的时候，其他worker也在读取，所以表现为每隔一段时间就会出现一个IO时间非常长\n\n但是如果计算是瓶颈，应该不会出现这个\nresnet152的时候io_time就能够被计算时间覆盖了，所以所有的iotime大概都是0.0003左右\n\n\n那么可以找到一个比较便捷的io瓶颈测量是将，看是否iotime是否随着worker进行周期变化； 但是总体上来说都是第一个iteration的iotime时间最长为1.6左右，因为没有任何计算来对iotime进行覆盖\nalexnet其他worker每隔一段时间大概为0.5；resnet大概为0.2；其余为0.0003\n\nhttps://kangsheng.xyz/2020/07/14/pytorch%E4%B8%ADdataloader%E7%9A%84num_workers%E8%AE%BE%E7%BD%AE/  \n这里的iotime包括进程开销，以及batch读取+batch处理开销 但是多进程加载数据包括读+处理两个部分， 而不是只读\n8A100 2个物理CPU, 每个cpu 物理64核， 每个核有两个逻辑处理器；所以两个cpu一起就有256个逻辑处理器（2*2*64）\nhec02是8个cpu, 每个cpu上面只有一个核\n\n\nhttps://zhuanlan.zhihu.com/p/91521705 查看dataset多worker加载数据，每个worker负责一个batch,只有在当前batch消耗掉之后才会取下一个分配的任务，而不是一直取数据。同时这个worker取数据包括读+数据增强两个部分\n>其实各个worker之间读取数据时间差不多，并且由于是多进程任务，所以每次第一个worker读完数据就绪以后其他也准备就绪了，主进程随即开始连续前向传递了，并轮询的向各worker发送读新一批数据的信号，只不过跑完上一轮次所有worker产生的数据（num_workers个batch）后，各worker中新一轮次数据还没就绪，所以阻塞住了。\n\n4worker的情况下；\nio_time: 0.6680457592010498\nio_time: 0.00039649009704589844\nio_time: 0.0004131793975830078\nio_time: 0.00040602684020996094\nio_time: 0.7091846466064453\n\n\n8worker的情况下：\nio_time: 0.583601713180542\nio_time: 0.00048732757568359375\nio_time: 0.011454343795776367\nio_time: 0.0005695819854736328\nio_time: 0.00035643577575683594\nio_time: 0.0003287792205810547\nio_time: 0.0004932880401611328\nio_time: 0.0003211498260498047\nio_time: 0.5443663597106934\n\n\n16worker的时候：\nio_time: 0.6202142238616943\nio_time: 0.0005917549133300781\nio_time: 0.0004055500030517578\nio_time: 0.00042128562927246094\nio_time: 0.0004863739013671875\nio_time: 0.00027370452880859375\nio_time: 0.0002474784851074219\nio_time: 0.0002865791320800781\nio_time: 0.00033855438232421875\nio_time: 0.00021886825561523438\nio_time: 0.0002658367156982422\nio_time: 0.00020456314086914062\nio_time: 0.0001895427703857422\nio_time: 0.0005667209625244141\nio_time: 0.0004878044128417969\nio_time: 0.013859033584594727\n\nworker数量越小，出现io_time突然增加的可能性越高\n现在的问题是：在worker数量不足的时候是否这种用另外的worker去取数据，是否会影响数据加载的性能；相当于增加了线程数量；这好像更多加一个worker，然后多加一个缓存空间，实现超前预取没有实质区别\n另外一种合理的解释就是说利用data worker取数据的空闲时间来进行cache的换新，但是IO 瓶颈data worker空闲的时间也不多呀；只有计算密集的data worker才会空闲\n\n而且cache如果这样设计的话和buffer没有什么区别，因为都是取一次用一次，结论在buffer里面实现预取进程无用! 而且可能增加磁盘带宽压力\n\n\ncoordl又讲使用cache的理由吗？感觉可以直接沿用coordl理由\n\nGist：在两次数据利用之间有长时间的gap，因此可以对数据进行压缩，之后要用的时候再解压缩， ==在cache里面对数据进行压缩解压== 问题是data没有稀疏性，如果较好的无损压缩\n\n\n12-21\n目前分别在hec 和 8a100上测试远程过程调用和cache的代码\n\n看代码的时候注意一下几个方面：\n1）远程过程调用现在不能使用dataparallel  create_file\n2) cache代码里面可以使用DP, 需要确定cache大小\n3）loss.backward一定要在loss.cpu/记录loss 之前，否则会报错\n4）合起来的时候一定要注意将init_rpc 以及 有关worker和master的代码打开（train_evaluate）\n5) 感觉增加worker数量就能消除IO瓶颈的问题如何解决\n\n找到一个bug: 使用dp的时候，batch_size应该*gpu数量，因为是一个batch size拆分，但是ddp不是\n\n明天任务：\n如何实现多GPU情况下，多进程共享一个数据结构cache， 因为现在好像是多个进程，每个可能都会创建一个cache这个是不合理的\n\n12.22 \n\n看了以及整理了一下括号相关的leetcode题目\n\nrpc在回调结果的时候遇到一个问题：\n``` python\nmaster使用远程过程调用的结果来更新criterion_history_list_dict\nTraceback (most recent call last):\n  File \"./imagenet_final_train_master.py\", line 206, in <module>\n    train_main(args.gpu, ngpus_per_node, args, kwargs)\n  File \"./imagenet_final_train_master.py\", line 94, in train_main\n    run_training(model, trainloader, testloader, trainset, testset,  optimizer, criterion, dirs, args.epochs, args, kwargs)\n  File \"/nfs/home/shu/hushuang_all_files/ImageClassification/8a100-code/IOAS/imagenet/train_evaluate.py\", line 177, in run_training\n    refresh_uni_list( uni_score_rref, allscore_numpy_dict, args)\n  File \"/nfs/home/shu/hushuang_all_files/ImageClassification/8a100-code/IOAS/imagenet/rpc_func.py\", line 44, in refresh_uni_list\n    uni_score_list = uni_score_rref.to_here().numpy().tolist()\nRuntimeError: RPCErr:1:RPC ran for more than set timeout (60000 ms) and will now be marked with an error\n\n# worker 端\n\n[W tensorpipe_agent.cpp:498] RPC agent for worker1 encountered error when sending response to request #16 to worker0: EOF: end of file\n```\n\n\n12.23\n现在8a100端注释了master的和worker代码就可以实现 存储端计算重要性+主进程端使用cache缓存部分数据\n\n主要逻辑：（cache 3+ 存储单元 1）\n1. 0epoch冷启动， 在1epoch缓存端已经开始缓存数据， 每轮训练的时候将vis的数据打一个标记，置换策略将vis的数据随机置换出去\n2. 下一轮 sampler返回训练的时候将cache中的数据放在前面\n3. 在重要性采样开始前一轮epoch，开始搜集重要性metric设计的分数，如果有io 分数的话，通过profile 的iotime 来对cache time的ssd load time进行估计（求平均值），同时对下一轮样本的iotime进行预测\n4. 将计算出来的重要的样本下一轮训练，不重要的样本序列通过rpc传给存储端的计算单元，让master和worker分别更新重要的样本和不重要样本的分数。\n5. 然后之后在进行采样的使用用全部更新好的重要性分数，重复排序和训练更新步骤\n\n\n解决两个bug:\n1) 之所以8a100上面使用分布式调用不起来，是因为我之前在使用torch.distributed.rpc的时候写了os['environment'] =hec01  导致分布式错误\n2) 训练精度很低， 修改criterion\ncriterion = nn.CrossEntropyLoss(reduce=False).cuda(args.gpu) hec02实验\n目前是用这个解决了，但是assert语句显示一致, 不知道原因\n\n\n12-27\n解决cache在mp.spawn 使用多进程训练的时候导致段错误或者信号接收错误\n选择启动方式：mp.set_start_method('spawn')\n\n在进行调试的时候，break不应该放在args,rank==0下面，否则就会卡死\n\n12-28\n现在的任务就是看rpc是否能和分布式训练的mp.spawn同时存在, 应该主进程主要负责rpc\n\nssh需要输入密码的节点为何无法使用rpc进行通信\n\n\n12-29\n今天主要看了legoos这篇论文， 对调度相关的其他论文也进行了总结和分类，以及看了ppt下面的链接有关内容\n明日安排，做一下最短路径（单源或者多源情况）， 练习今天学到的有关Dijstra, Bellman-Ford算法以及Floyd算法\n\n\n#### 2022\n1-3\n完成>400目标\n代码主要就是看分布式+rpc是否能够兼容(+cache目前通过mp.spawn解决)并调试通过，实在ddp+rpc无法完成，就只能使用dp+rpc\n\n\n1-6 现在遇到的问题：1.有ssh密码登录的机器，使用rpc无法正常运行， 同时rpc在同一台机器好像也无法正常运行\n\n解决！\n注意在rpc中发出rpc_async请求的是worker, 接收请求的是master\n\nhec上使用pytorch 1.8.1只能在没有gpu的节点上，如果在hec01 hec02上就会报错\n\n现在问题 8a100和hec06节点连接会报错：\naster: ECONNREFUSED: connection refused\nFailed to respond to 'Shutdown Proceed' in time, got error ECONNREFUSED: connection refused\nTraceback (most recent call last):\n  File \"worker.py\", line 88, in <module>\n    rpc.shutdown()\n  File \"/nfs/home/anaconda3/envs/pytorch-shu/lib/python3.6/site-packages/torch/distributed/rpc/api.py\", line 78, in wrapper\n    return func(*args, **kwargs)\n  File \"/nfs/home/anaconda3/envs/pytorch-shu/lib/python3.6/site-packages/torch/distributed/rpc/api.py\", line 284, in shutdown\n    _get_current_rpc_agent().join()\nRuntimeError: [/opt/conda/conda-bld/pytorch_1607370193460/work/third_party/gloo/gloo/transport/tcp/pair.cc:575] Connection closed by peer [10.5.30.42]:27806\n\nSolution: Edit /etc/hosts and change 127.0.1.1 to your actual ip-address 目前看到的一个答案\n分析：现在在hec上互相使用rpc（即使有密码）是可以的，但是在8a100就不行，所以现在怀疑的是需要在host里面添加目录，以及需要在两台机器上换成同一个用户才行\n第二种解决方案，应该使用tpc的init_method，以及使用gloo后端，但是目前试验过，仍然会报错\n\n感觉在分布式多台机器上训练也会出现相同的问题\n\n找到的真正的解决方案：backend=rpc.BackendType.PROCESS_GROUP， 不需要加其他的\nos.environ['TF_SOCKET_IFNAME'] = 'ens3' (x)\nos.environ['GLOO_SOCKET_IFNAME'] = 'ens3' (x)\n\n\n寒假安排：\n1. leetcode争取上500 可以先将宫水三叶的题刷完，应该都是经典题目\n2. 对之前写的leetcode进行总结，整理，转为每个知识点，先放总结的思路，或者针对的题型，然后放相应的例题，没道例题简答写一下解决方案，和总结的思路进行对应\n3. 回归操作系统，计网的基础知识, 转为笔试的xmind (408题目看看) \ngithub和牛客网应该有许多资源，多看看多比较; 包括深度学习和目标检测相关的面试题目\n牛客网上， 网友的总结：(CyC2018)\n[https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E7%9B%AE%E5%BD%95.md]\n4. 补充面试的xmind\n5. 有时间学一下grpc\n6. 记得备份一下8a100上面的数据 (目前正在8a100使用rsync进行传输 到hec06 /nfs目录下)\n7。一些公司名单和深度学习的资料\nhttps://github.com/amusi/CV-Company-List\n注意关注一下春招信息，微软已经开始投递了，然后我因为错过了问卷，错过了提前批，之后注意准备面试和之后的问卷\n8. 修改简历，变为项目两个， research两个，将重要性采样自己的工作写上去zzw\n9. 项目一定要非常非常熟悉，整理面试可能问到的每一个问题，和自己优化的思考！！！\n\n\n刷完八股之后，进行自测：https://github.com/youngyangyang04/TechCPP\nhttps://github.com/youngyangyang04/leetcode-master\n\n有关于C++的八股文：https://github.com/Light-City/CPlusPlusThings\n\n\n\n408资料\nhttps://github.com/CodePanda66/CSPostgraduate-408\n408历年真题大题查看\n\n\n公司：思科，\n\n\n别人的面经总结：\nhttps://prohuper.github.io/2020/04/17/interview_exp2/\n\n推荐资料:\n力扣1-300题（前300道题非常经典，建议学有余力的同学都刷一刷）\n力扣HOT100（跟上面有不少是重复的，刷的时候要注意总结）\n啊哈！算法、大话数据结构（这两本书都是面向新手的图书，图画很多）\n剑指offer（这本书不需要多做介绍，校招必备）\n挑战程序设计竞赛（这本书属于进阶一点的算法书籍了，作者是ACM-ICPC全球总冠军，可以说是\n世界顶级程序设计高手的经验总结了，需要慢慢消化，经典题型太多）\n程序员代码面试指南（左程云大神的书，我并没有看完，只是看了其中的海量数据处理部分的题\n目就已经十分受用了，在某大厂三面中就考查到了其中的海量数据集处理的问题）\n\n\n按公司分题：https://github.com/afatcoder/LeetcodeTop（面试前刷一刷）\n\nhttps://github.com/HarleysZhang/2021_algorithm_intern_information 计算机视觉-算法岗位相关\nhttps://github.com/DWCTOD/interview\n\n\n把leetcode的剑指offer开头 和leetcode全部看一篇","source":"_posts/日常记事/每天任务记录.md","raw":"---\ntitle: 每天任务记录\ntags: daily task\ncategories:\n  - 日常记事\nhide: true\ndate: 2021-11-15 11:19:12\n---\n11-15\n记得之后验证一下multiple是否支持只有loss这种情况，如果支持的话，sampler全部修改为一个，同时目前只修改和看BS这种情况\n\ntune参数包括warm_up_epoch and sampling rate\n\n\n完成情况：整理完之前的IOAS代码，将multi和single进行融合，同时使用字典形式来替换if-else多个flag的情况\n记录：leetcode 刷题指南完成：贪心算法， 哈希表，双指针部分, 栈与队列部分\n\n\n11-16\n初步完成论文框架思维导图\n\n修改代码，找到IO瓶颈场景\n\n在代码中添加上视频分析这个场景\n\n今天突然想到suprevision是用的什么anchor box，需要将数据下载完成后验证，猜测使用featmap_size??而不是预设的anchor\n\n总结：\n看完interviewtop上操作系统的八股文\n下载coco数据\n完成一版xmind思路调整\n查看阿里基础架构面经\n\n\n11-17\n找到io为瓶颈的场景，并进行重要性采样实验\n目前发现MS比BS精度高\n\nBS：面临的问题  如何选择阈值 目前：搜索出初始thres_ratio, 之后使用历史+当前thres_ratio调整，//没有被计算的使用远程存储的模型进行计算,以及根据模型能力调整thres_ratio\n\nMS: recall interval,不同等级之间的recall 时间差距是1 epoch 吗，新划分出来训练的类又如何根据阈值划分呢（等分感觉不科学）//建一个模型自动划分和确定等待的时间  （多个阈值和多个等待时间的确定）\n\n现在只修改BS (1)实现在存储端计算样本重要性， （2）感觉样本的位置\n\nhttps://www.sigarch.org/the-new-bottlenecks-of-ml-training-a-storage-perspective/ 这个讲得挺好\n处理的浏览了一下FreqCheck 的源码 但是每太明白细节上是如何在torch.save()后面封装 fsync(),   以及如何根据runtime overhead的profile结果进行自适应的checkpointing frequency超参数的调节\n\n目标：弄懂多进程异步/模型的异步训练， 参考autoassist 以及checkFreq，subprocess\n以及另外开一个进程来进行io带宽的测量(profile)以及未读取数据的重要性更新，另外一个空闲节点\n\n\n11-18\n\n看了autoassist的多进程，但是他们在训练另外一个模型进行样本的现在是训练了另外一个二分模型，这个二分模型的目标是 loss大于均值为target或者target model判断错误的label=1\n\n\n我要训练的另外一个模型是在存储节点训练的模型，无需训练只需要将模型每次最新权重穿过来，在checkpoint的时候将模型传给远端; screen 需要同时训练另外一个模型会加重CPU和GPU训练负担，同时也不是很好同步轻量级模型和远程target模型判断样本重要性的差距\n\n完成另外一个进程异步训练模型的初步代码\n\n11-22\n\n完成情况：\n完成主进程和子进程相互传输重要性分数，invalid list以及模型初步代码\n\n明天需要解决的问题：\n1）如果解决模型参数保存的时候使用model.cpu().state_dict() 但是计算的时候需要使用dp 或者cuda, 保存模型这个动作如何转为复制模型参数，而不是真正将模型保存到cpu\n\n2) 如何减少推理时间太长的问题，如果使用原模型进行不重要样本重要性计算\n\n3）如果将一个节点转移到两个节点间的数据传输（远端存储系统情况）\n\n4）把这个解决了，再解决如何修改io module 自定义一个缓冲区，然后在缓冲区/cache中实现TLB表，以及数据从缓冲区中读取\n\n\n\n要解决的问题：1 分布式训练如何将另外一个进程计算得到的uni_score广播给其他进程\n而且注意是多个分布式训练主进程对应一个子进程，不应该建立多个进行不重要样本重要性计算的子进程\n\n目前遇到的问题：RuntimeError: module must have its parameters and buffers on device cuda:0 (device_ids[0]) but found one of them on device: cpu-->解决，因为model.cpu().state_dict导致\n\n\n11-23\n\n完成情况：\n\n1）使用一个copy.deepcopy完成在gpu上模型的拷贝到cpu\n2) 解决子进程无法正常退出的问题\n3）初步熟悉dataloader和dataset的代码\n\n下一步：\n如何解决判断数据是在缓存， 本地磁盘， 还是远端存储系统呢\n\n11-24  \n\n1）调整了lru_cache的逻辑\n2）但是目前不知道如何将tlb得到的信息转为io_predict_time\n3）初步使用多进程访问同一个cache,同时记录总访问次数和命中率，因为多进程需要共享一个数据结构，因此使用multiprocessing.Manager 因为LRUcache是自定义的一个数据结构，因此需要使用自定义的manager\n\n目前发现worker越多，access 缓存次数越多\n\nworker = 8\nself.size:256\ntotal_access_time:2432, hit_time:128\n\nworker = 4\nself.size:256\ntotal_access_time:1048, hit_time:128\n\n\nworker = 0\nself.size:128\ntotal_access_time:384, hit_time:256\n\n如何只是对cache的每个变量使用multiprocessing进行加锁的话会导致出现None 结构remove错误，所以对于cache的get set函数都应该是一个原子操作（一个事务），所以需要对cache使用原子操作（加锁），而不仅仅是里面的一个变量加锁就可以了\n\n11-25\n\n验证多进程为什么总的访问次数会增加，以及为什么使用缓存的大小增加，但是命中率会减小\n考虑如何将tlb功能转为IO score的计算\n如何感知数据的位置，在其他节点的存储中，本地存储中，还是缓存中\n\n发现：epoch=0和epoch=1的时候多进程取数据hit time=0， cache size=256 但是如果worker=0的话， epoch=1时候的命中率应该为128 cache size=128\n解释：因为我在执行流程中间break了，但是数据还在提前取后面一轮的，所以导致cache size会满，同时命中率下降；第二轮本来要取的序列就减少了，所以多进程也没有讲缓存的数据冲走；也可以解释第0轮epoch就有2000多次的访问量\n\n加上缓存：\nTraining done in 0.069387 hours \nTraining  done in 0.068791 hours\n\n\n不加缓存：\nTraining  done in 0.017339 hours\nTraining  done in 0.035785 hours\nTraining  done in 0.037956 hours 命中率384\n\n\n使用字典进行缓存，随机置换：\nTraining  done in 0.022509 hours \nTraining  done in 0.039637 hours  命中率 224\n\n\npyshmht 为python设计的基于hash表的共享内存\n\nasyncio\n\n目前结论：使用一个随机置换策略的缓存相比LRU置换效果更好  或者直接使用coodl的缓存后就固定不变\n\n感觉应该是LRU每次加锁读写链表\n\n明日安排：完成整个训练过程加缓存以及如何将缓存的位置转化为IO score\n\n\n11-29\n\nRPC小例子\nhttps://zhuanlan.zhihu.com/p/136372142\n\n了解一下rpc pytorch， 打算使用nfs再使用orangefs来实现两个节点上worker的通信\n看了两篇论文：1.是分析深度学习不同存储方式的性能 2.运用机器学习判断应用的IO模式，然后自适应的选择相应的优化策略（主要是针对有读写，以及I/O模式在整个应用生命过程中会改变，但深度学习是只读的，I/O模式似乎都是一样的）\nhttps://github.com/apachecn/apachecn-dl-zh/blob/master/docs/pt-tut-17/65.md\n\n11-30\n使用sudo aptitude install nfs-common 选择n y的时候安装失败，导致sudo无法使用，同时机器无法连接，修机器\n参加rebuttal的会议\n\n12-1\n\n问题如何在orangefs上挂imagenet, 挂了之后仍然像ext4文件一样访问 /mnt/orangefs吗， 记得修改默认orangefs 服务器的文件目录，目前默认是/local500/storage-orangefs/吗\n最后为什么是mount hec09的orangefs 为什么不是local500/storage-orangefs\n\n\n12-2 \n\n1. 完成 rebuttal的提交\n2. 初步在节点hec01 和hec03上实现 rpc测试  学长使用的是不同语言之间相互通信的grpc 先写一个.proto 文件，然后使用一个工具 将他编译为目标py文件或者go文件，然后分别在py和go文件里面使用这个编译好的文件\n\n在提交英文版本的时候一定要注意英语的拼写问题\n\npytorch官网上的rpc网络： https://github.com/pytorch/pytorch/blob/master/docs/source/rpc.rst\n\n\n\n12-3 现在的问题是：worker如何确定当前可以shutdown\n\n目前遇到的问题是如果是将远程过程调用放在sampler，如果是多进程取sampler的话会导致 出错，因此应该把远程过程调用的逻辑放在主函数里面\n\n多进程会有多个sampler副本吗  难道是多进程访问sampler会加锁？？\n \n\n\n明天 1.实现在每个epoch前进行重要性计算 train_one_epoch前  2. score通过字典传递，而不是list\n\nrpc在远程过程调用的时候，如果调用的函数和初始化不在main函数下面py文件(主要的train_main 文件里)内会导致调用函数不一样 本来打算调用worker, 调用到master端\n\n\n12-7\n实现使用nfs， 以及torch.distributed.rpc实现两个任务之间的通信， 阅读grpc 的route_guide example源码， 如果要使用grpc需要使用异步+call back函数，或者使用一个子进程+同步grpc，然后实现主进程和子进程之间通过共享内存实现数据的共享\n\n\n\n12-13\n\n在hec01使用setattr修改了文件dataset的属性\n现在的问题是存储单元如何得知自己存储节点的数据，或者假设存储节点非常的近，那么存储节点只需要派一个节点进行训练就好了\n\n现在可以实现在一个存储单元上挂载orangefs-client查看数据， 之后换到新机器上实验orangefs形式的存储单元和计算单元 通讯和传递消息，目前server端只需要一个节点来进行推理，不需要每个server对每个server端的数据进行推理\n\n12-14 \n找到一个bug， loss.mean().backward应该在loss.cpu.detach()前面，否则就会训练的时候精度一直为0，怀疑是torch版本的问题\n打算再新环境中使用orangefs，然后进行通讯任务训练\n以及考虑加上cache + IO score 预先训练cache中的数据\n\n\n今天leetcode练习到532题\n\n明日安排：\n1. 先profile一下cache time 是否真的的比ssd time小很多 \n2. 同时查看一下是不是每轮epoch 第一个iteration时间最长， 找到网上解答原因\n3. multi-criterion到底应该怎么用。\n4. 写一个简单的用cache的信息加入到multi-criterion计算（不同的优先级给定一个分数），以及在cache中采样第一个batch, 以及随机置换的cache策略，先写一个版本\n\n5. cache size以及cache的转换策略将对io score产生怎样的影响\n\n相同数据每次的load time是不是都是变化很大。我感觉应该用时间近似，而不应该用level,因为不同cache的ssd的远近可能导致这两个时间相差很大，有的ssd读取和cache时间差不多那么io score应该就差不多，否则就应该加大io score的差距\n\n\n感觉多进程预取会抵消cache好处？？如果IO是瓶颈的话，那么预取的效果就比从cache中取数据的效果差\n\n\n12-15 完成一个简易版本的cache-aware sampling\n\n主要包含下面三个功能的实现：\n1. IO score的计算问题 使用profile的cache的时间和ssd时间近似替代训练序列的all_result_list['iotime']\n2. sampler的序列问题， 先使用cache 里面缓存的序列\n3. cache的置换问题，初步使用self.vis字典实现先替换cache中vis的序列，但是问题是每个epoch都需要clear一下cache的vis序列\n\n但是现在还是在注释中\n\n\n12-16\n尝试在8a100上实验，可能会考虑到分布式训练的sampler的修改\n使之适应于分布式+orangefs这种场景\n\n完成情况：目前在多GPU上调试了之前hec上面的代码，可以跑通单机多卡加上cache, 和修改了cache time计算方式的代码\n初步完成昨天1， 2， 3个功能，目前的问题就是DataParallel+ another model in storage side可能会有问题\n\n发现4 worker的时候 每4个iteration 第一个时间最长， 之后的时间都递减\n\n明日计划：\n\n四叉树合集有时间看看\n\n\n12-17 数据传输慢是因为传输的带宽被占满了吗？ 是否可以开不同的数据取线程？来为用于级别cache增加命中率\n为什么4worker时每个iteration 4个中必有一个时间长 （已解决）\n这个iteration time和worker的设置有关\n\n\n12-20\nTODO: 分布式情况，多个节点得有多个cache, 这样的话在进行取数据的时候首先取cache中缓存的数据就不对，需要通过RDMA 需要直接取其他节点的cache数据才行\n目前分析原因是消耗比读取快，消耗了一轮回过来，还是没有讲一个batch读完，所以又会在worker1处阻塞住，同时在worker1阻塞的时候，其他worker也在读取，所以表现为每隔一段时间就会出现一个IO时间非常长\n\n但是如果计算是瓶颈，应该不会出现这个\nresnet152的时候io_time就能够被计算时间覆盖了，所以所有的iotime大概都是0.0003左右\n\n\n那么可以找到一个比较便捷的io瓶颈测量是将，看是否iotime是否随着worker进行周期变化； 但是总体上来说都是第一个iteration的iotime时间最长为1.6左右，因为没有任何计算来对iotime进行覆盖\nalexnet其他worker每隔一段时间大概为0.5；resnet大概为0.2；其余为0.0003\n\nhttps://kangsheng.xyz/2020/07/14/pytorch%E4%B8%ADdataloader%E7%9A%84num_workers%E8%AE%BE%E7%BD%AE/  \n这里的iotime包括进程开销，以及batch读取+batch处理开销 但是多进程加载数据包括读+处理两个部分， 而不是只读\n8A100 2个物理CPU, 每个cpu 物理64核， 每个核有两个逻辑处理器；所以两个cpu一起就有256个逻辑处理器（2*2*64）\nhec02是8个cpu, 每个cpu上面只有一个核\n\n\nhttps://zhuanlan.zhihu.com/p/91521705 查看dataset多worker加载数据，每个worker负责一个batch,只有在当前batch消耗掉之后才会取下一个分配的任务，而不是一直取数据。同时这个worker取数据包括读+数据增强两个部分\n>其实各个worker之间读取数据时间差不多，并且由于是多进程任务，所以每次第一个worker读完数据就绪以后其他也准备就绪了，主进程随即开始连续前向传递了，并轮询的向各worker发送读新一批数据的信号，只不过跑完上一轮次所有worker产生的数据（num_workers个batch）后，各worker中新一轮次数据还没就绪，所以阻塞住了。\n\n4worker的情况下；\nio_time: 0.6680457592010498\nio_time: 0.00039649009704589844\nio_time: 0.0004131793975830078\nio_time: 0.00040602684020996094\nio_time: 0.7091846466064453\n\n\n8worker的情况下：\nio_time: 0.583601713180542\nio_time: 0.00048732757568359375\nio_time: 0.011454343795776367\nio_time: 0.0005695819854736328\nio_time: 0.00035643577575683594\nio_time: 0.0003287792205810547\nio_time: 0.0004932880401611328\nio_time: 0.0003211498260498047\nio_time: 0.5443663597106934\n\n\n16worker的时候：\nio_time: 0.6202142238616943\nio_time: 0.0005917549133300781\nio_time: 0.0004055500030517578\nio_time: 0.00042128562927246094\nio_time: 0.0004863739013671875\nio_time: 0.00027370452880859375\nio_time: 0.0002474784851074219\nio_time: 0.0002865791320800781\nio_time: 0.00033855438232421875\nio_time: 0.00021886825561523438\nio_time: 0.0002658367156982422\nio_time: 0.00020456314086914062\nio_time: 0.0001895427703857422\nio_time: 0.0005667209625244141\nio_time: 0.0004878044128417969\nio_time: 0.013859033584594727\n\nworker数量越小，出现io_time突然增加的可能性越高\n现在的问题是：在worker数量不足的时候是否这种用另外的worker去取数据，是否会影响数据加载的性能；相当于增加了线程数量；这好像更多加一个worker，然后多加一个缓存空间，实现超前预取没有实质区别\n另外一种合理的解释就是说利用data worker取数据的空闲时间来进行cache的换新，但是IO 瓶颈data worker空闲的时间也不多呀；只有计算密集的data worker才会空闲\n\n而且cache如果这样设计的话和buffer没有什么区别，因为都是取一次用一次，结论在buffer里面实现预取进程无用! 而且可能增加磁盘带宽压力\n\n\ncoordl又讲使用cache的理由吗？感觉可以直接沿用coordl理由\n\nGist：在两次数据利用之间有长时间的gap，因此可以对数据进行压缩，之后要用的时候再解压缩， ==在cache里面对数据进行压缩解压== 问题是data没有稀疏性，如果较好的无损压缩\n\n\n12-21\n目前分别在hec 和 8a100上测试远程过程调用和cache的代码\n\n看代码的时候注意一下几个方面：\n1）远程过程调用现在不能使用dataparallel  create_file\n2) cache代码里面可以使用DP, 需要确定cache大小\n3）loss.backward一定要在loss.cpu/记录loss 之前，否则会报错\n4）合起来的时候一定要注意将init_rpc 以及 有关worker和master的代码打开（train_evaluate）\n5) 感觉增加worker数量就能消除IO瓶颈的问题如何解决\n\n找到一个bug: 使用dp的时候，batch_size应该*gpu数量，因为是一个batch size拆分，但是ddp不是\n\n明天任务：\n如何实现多GPU情况下，多进程共享一个数据结构cache， 因为现在好像是多个进程，每个可能都会创建一个cache这个是不合理的\n\n12.22 \n\n看了以及整理了一下括号相关的leetcode题目\n\nrpc在回调结果的时候遇到一个问题：\n``` python\nmaster使用远程过程调用的结果来更新criterion_history_list_dict\nTraceback (most recent call last):\n  File \"./imagenet_final_train_master.py\", line 206, in <module>\n    train_main(args.gpu, ngpus_per_node, args, kwargs)\n  File \"./imagenet_final_train_master.py\", line 94, in train_main\n    run_training(model, trainloader, testloader, trainset, testset,  optimizer, criterion, dirs, args.epochs, args, kwargs)\n  File \"/nfs/home/shu/hushuang_all_files/ImageClassification/8a100-code/IOAS/imagenet/train_evaluate.py\", line 177, in run_training\n    refresh_uni_list( uni_score_rref, allscore_numpy_dict, args)\n  File \"/nfs/home/shu/hushuang_all_files/ImageClassification/8a100-code/IOAS/imagenet/rpc_func.py\", line 44, in refresh_uni_list\n    uni_score_list = uni_score_rref.to_here().numpy().tolist()\nRuntimeError: RPCErr:1:RPC ran for more than set timeout (60000 ms) and will now be marked with an error\n\n# worker 端\n\n[W tensorpipe_agent.cpp:498] RPC agent for worker1 encountered error when sending response to request #16 to worker0: EOF: end of file\n```\n\n\n12.23\n现在8a100端注释了master的和worker代码就可以实现 存储端计算重要性+主进程端使用cache缓存部分数据\n\n主要逻辑：（cache 3+ 存储单元 1）\n1. 0epoch冷启动， 在1epoch缓存端已经开始缓存数据， 每轮训练的时候将vis的数据打一个标记，置换策略将vis的数据随机置换出去\n2. 下一轮 sampler返回训练的时候将cache中的数据放在前面\n3. 在重要性采样开始前一轮epoch，开始搜集重要性metric设计的分数，如果有io 分数的话，通过profile 的iotime 来对cache time的ssd load time进行估计（求平均值），同时对下一轮样本的iotime进行预测\n4. 将计算出来的重要的样本下一轮训练，不重要的样本序列通过rpc传给存储端的计算单元，让master和worker分别更新重要的样本和不重要样本的分数。\n5. 然后之后在进行采样的使用用全部更新好的重要性分数，重复排序和训练更新步骤\n\n\n解决两个bug:\n1) 之所以8a100上面使用分布式调用不起来，是因为我之前在使用torch.distributed.rpc的时候写了os['environment'] =hec01  导致分布式错误\n2) 训练精度很低， 修改criterion\ncriterion = nn.CrossEntropyLoss(reduce=False).cuda(args.gpu) hec02实验\n目前是用这个解决了，但是assert语句显示一致, 不知道原因\n\n\n12-27\n解决cache在mp.spawn 使用多进程训练的时候导致段错误或者信号接收错误\n选择启动方式：mp.set_start_method('spawn')\n\n在进行调试的时候，break不应该放在args,rank==0下面，否则就会卡死\n\n12-28\n现在的任务就是看rpc是否能和分布式训练的mp.spawn同时存在, 应该主进程主要负责rpc\n\nssh需要输入密码的节点为何无法使用rpc进行通信\n\n\n12-29\n今天主要看了legoos这篇论文， 对调度相关的其他论文也进行了总结和分类，以及看了ppt下面的链接有关内容\n明日安排，做一下最短路径（单源或者多源情况）， 练习今天学到的有关Dijstra, Bellman-Ford算法以及Floyd算法\n\n\n#### 2022\n1-3\n完成>400目标\n代码主要就是看分布式+rpc是否能够兼容(+cache目前通过mp.spawn解决)并调试通过，实在ddp+rpc无法完成，就只能使用dp+rpc\n\n\n1-6 现在遇到的问题：1.有ssh密码登录的机器，使用rpc无法正常运行， 同时rpc在同一台机器好像也无法正常运行\n\n解决！\n注意在rpc中发出rpc_async请求的是worker, 接收请求的是master\n\nhec上使用pytorch 1.8.1只能在没有gpu的节点上，如果在hec01 hec02上就会报错\n\n现在问题 8a100和hec06节点连接会报错：\naster: ECONNREFUSED: connection refused\nFailed to respond to 'Shutdown Proceed' in time, got error ECONNREFUSED: connection refused\nTraceback (most recent call last):\n  File \"worker.py\", line 88, in <module>\n    rpc.shutdown()\n  File \"/nfs/home/anaconda3/envs/pytorch-shu/lib/python3.6/site-packages/torch/distributed/rpc/api.py\", line 78, in wrapper\n    return func(*args, **kwargs)\n  File \"/nfs/home/anaconda3/envs/pytorch-shu/lib/python3.6/site-packages/torch/distributed/rpc/api.py\", line 284, in shutdown\n    _get_current_rpc_agent().join()\nRuntimeError: [/opt/conda/conda-bld/pytorch_1607370193460/work/third_party/gloo/gloo/transport/tcp/pair.cc:575] Connection closed by peer [10.5.30.42]:27806\n\nSolution: Edit /etc/hosts and change 127.0.1.1 to your actual ip-address 目前看到的一个答案\n分析：现在在hec上互相使用rpc（即使有密码）是可以的，但是在8a100就不行，所以现在怀疑的是需要在host里面添加目录，以及需要在两台机器上换成同一个用户才行\n第二种解决方案，应该使用tpc的init_method，以及使用gloo后端，但是目前试验过，仍然会报错\n\n感觉在分布式多台机器上训练也会出现相同的问题\n\n找到的真正的解决方案：backend=rpc.BackendType.PROCESS_GROUP， 不需要加其他的\nos.environ['TF_SOCKET_IFNAME'] = 'ens3' (x)\nos.environ['GLOO_SOCKET_IFNAME'] = 'ens3' (x)\n\n\n寒假安排：\n1. leetcode争取上500 可以先将宫水三叶的题刷完，应该都是经典题目\n2. 对之前写的leetcode进行总结，整理，转为每个知识点，先放总结的思路，或者针对的题型，然后放相应的例题，没道例题简答写一下解决方案，和总结的思路进行对应\n3. 回归操作系统，计网的基础知识, 转为笔试的xmind (408题目看看) \ngithub和牛客网应该有许多资源，多看看多比较; 包括深度学习和目标检测相关的面试题目\n牛客网上， 网友的总结：(CyC2018)\n[https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E7%9B%AE%E5%BD%95.md]\n4. 补充面试的xmind\n5. 有时间学一下grpc\n6. 记得备份一下8a100上面的数据 (目前正在8a100使用rsync进行传输 到hec06 /nfs目录下)\n7。一些公司名单和深度学习的资料\nhttps://github.com/amusi/CV-Company-List\n注意关注一下春招信息，微软已经开始投递了，然后我因为错过了问卷，错过了提前批，之后注意准备面试和之后的问卷\n8. 修改简历，变为项目两个， research两个，将重要性采样自己的工作写上去zzw\n9. 项目一定要非常非常熟悉，整理面试可能问到的每一个问题，和自己优化的思考！！！\n\n\n刷完八股之后，进行自测：https://github.com/youngyangyang04/TechCPP\nhttps://github.com/youngyangyang04/leetcode-master\n\n有关于C++的八股文：https://github.com/Light-City/CPlusPlusThings\n\n\n\n408资料\nhttps://github.com/CodePanda66/CSPostgraduate-408\n408历年真题大题查看\n\n\n公司：思科，\n\n\n别人的面经总结：\nhttps://prohuper.github.io/2020/04/17/interview_exp2/\n\n推荐资料:\n力扣1-300题（前300道题非常经典，建议学有余力的同学都刷一刷）\n力扣HOT100（跟上面有不少是重复的，刷的时候要注意总结）\n啊哈！算法、大话数据结构（这两本书都是面向新手的图书，图画很多）\n剑指offer（这本书不需要多做介绍，校招必备）\n挑战程序设计竞赛（这本书属于进阶一点的算法书籍了，作者是ACM-ICPC全球总冠军，可以说是\n世界顶级程序设计高手的经验总结了，需要慢慢消化，经典题型太多）\n程序员代码面试指南（左程云大神的书，我并没有看完，只是看了其中的海量数据处理部分的题\n目就已经十分受用了，在某大厂三面中就考查到了其中的海量数据集处理的问题）\n\n\n按公司分题：https://github.com/afatcoder/LeetcodeTop（面试前刷一刷）\n\nhttps://github.com/HarleysZhang/2021_algorithm_intern_information 计算机视觉-算法岗位相关\nhttps://github.com/DWCTOD/interview\n\n\n把leetcode的剑指offer开头 和leetcode全部看一篇","slug":"日常记事/每天任务记录","published":1,"updated":"2023-07-12T12:10:28.257Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clk5ceiod002tjpjb9xc3g26u","content":"<p>11-15<br>记得之后验证一下multiple是否支持只有loss这种情况，如果支持的话，sampler全部修改为一个，同时目前只修改和看BS这种情况</p>\n<p>tune参数包括warm_up_epoch and sampling rate</p>\n<p>完成情况：整理完之前的IOAS代码，将multi和single进行融合，同时使用字典形式来替换if-else多个flag的情况<br>记录：leetcode 刷题指南完成：贪心算法， 哈希表，双指针部分, 栈与队列部分</p>\n<p>11-16<br>初步完成论文框架思维导图</p>\n<p>修改代码，找到IO瓶颈场景</p>\n<p>在代码中添加上视频分析这个场景</p>\n<p>今天突然想到suprevision是用的什么anchor box，需要将数据下载完成后验证，猜测使用featmap_size??而不是预设的anchor</p>\n<p>总结：<br>看完interviewtop上操作系统的八股文<br>下载coco数据<br>完成一版xmind思路调整<br>查看阿里基础架构面经</p>\n<p>11-17<br>找到io为瓶颈的场景，并进行重要性采样实验<br>目前发现MS比BS精度高</p>\n<p>BS：面临的问题  如何选择阈值 目前：搜索出初始thres_ratio, 之后使用历史+当前thres_ratio调整，//没有被计算的使用远程存储的模型进行计算,以及根据模型能力调整thres_ratio</p>\n<p>MS: recall interval,不同等级之间的recall 时间差距是1 epoch 吗，新划分出来训练的类又如何根据阈值划分呢（等分感觉不科学）//建一个模型自动划分和确定等待的时间  （多个阈值和多个等待时间的确定）</p>\n<p>现在只修改BS (1)实现在存储端计算样本重要性， （2）感觉样本的位置</p>\n<p><a href=\"https://www.sigarch.org/the-new-bottlenecks-of-ml-training-a-storage-perspective/\">https://www.sigarch.org/the-new-bottlenecks-of-ml-training-a-storage-perspective/</a> 这个讲得挺好<br>处理的浏览了一下FreqCheck 的源码 但是每太明白细节上是如何在torch.save()后面封装 fsync(),   以及如何根据runtime overhead的profile结果进行自适应的checkpointing frequency超参数的调节</p>\n<p>目标：弄懂多进程异步/模型的异步训练， 参考autoassist 以及checkFreq，subprocess<br>以及另外开一个进程来进行io带宽的测量(profile)以及未读取数据的重要性更新，另外一个空闲节点</p>\n<p>11-18</p>\n<p>看了autoassist的多进程，但是他们在训练另外一个模型进行样本的现在是训练了另外一个二分模型，这个二分模型的目标是 loss大于均值为target或者target model判断错误的label=1</p>\n<p>我要训练的另外一个模型是在存储节点训练的模型，无需训练只需要将模型每次最新权重穿过来，在checkpoint的时候将模型传给远端; screen 需要同时训练另外一个模型会加重CPU和GPU训练负担，同时也不是很好同步轻量级模型和远程target模型判断样本重要性的差距</p>\n<p>完成另外一个进程异步训练模型的初步代码</p>\n<p>11-22</p>\n<p>完成情况：<br>完成主进程和子进程相互传输重要性分数，invalid list以及模型初步代码</p>\n<p>明天需要解决的问题：<br>1）如果解决模型参数保存的时候使用model.cpu().state_dict() 但是计算的时候需要使用dp 或者cuda, 保存模型这个动作如何转为复制模型参数，而不是真正将模型保存到cpu</p>\n<ol start=\"2\">\n<li>如何减少推理时间太长的问题，如果使用原模型进行不重要样本重要性计算</li>\n</ol>\n<p>3）如果将一个节点转移到两个节点间的数据传输（远端存储系统情况）</p>\n<p>4）把这个解决了，再解决如何修改io module 自定义一个缓冲区，然后在缓冲区/cache中实现TLB表，以及数据从缓冲区中读取</p>\n<p>要解决的问题：1 分布式训练如何将另外一个进程计算得到的uni_score广播给其他进程<br>而且注意是多个分布式训练主进程对应一个子进程，不应该建立多个进行不重要样本重要性计算的子进程</p>\n<p>目前遇到的问题：RuntimeError: module must have its parameters and buffers on device cuda:0 (device_ids[0]) but found one of them on device: cpu–&gt;解决，因为model.cpu().state_dict导致</p>\n<p>11-23</p>\n<p>完成情况：</p>\n<p>1）使用一个copy.deepcopy完成在gpu上模型的拷贝到cpu<br>2) 解决子进程无法正常退出的问题<br>3）初步熟悉dataloader和dataset的代码</p>\n<p>下一步：<br>如何解决判断数据是在缓存， 本地磁盘， 还是远端存储系统呢</p>\n<p>11-24  </p>\n<p>1）调整了lru_cache的逻辑<br>2）但是目前不知道如何将tlb得到的信息转为io_predict_time<br>3）初步使用多进程访问同一个cache,同时记录总访问次数和命中率，因为多进程需要共享一个数据结构，因此使用multiprocessing.Manager 因为LRUcache是自定义的一个数据结构，因此需要使用自定义的manager</p>\n<p>目前发现worker越多，access 缓存次数越多</p>\n<p>worker = 8<br>self.size:256<br>total_access_time:2432, hit_time:128</p>\n<p>worker = 4<br>self.size:256<br>total_access_time:1048, hit_time:128</p>\n<p>worker = 0<br>self.size:128<br>total_access_time:384, hit_time:256</p>\n<p>如何只是对cache的每个变量使用multiprocessing进行加锁的话会导致出现None 结构remove错误，所以对于cache的get set函数都应该是一个原子操作（一个事务），所以需要对cache使用原子操作（加锁），而不仅仅是里面的一个变量加锁就可以了</p>\n<p>11-25</p>\n<p>验证多进程为什么总的访问次数会增加，以及为什么使用缓存的大小增加，但是命中率会减小<br>考虑如何将tlb功能转为IO score的计算<br>如何感知数据的位置，在其他节点的存储中，本地存储中，还是缓存中</p>\n<p>发现：epoch=0和epoch=1的时候多进程取数据hit time=0， cache size=256 但是如果worker=0的话， epoch=1时候的命中率应该为128 cache size=128<br>解释：因为我在执行流程中间break了，但是数据还在提前取后面一轮的，所以导致cache size会满，同时命中率下降；第二轮本来要取的序列就减少了，所以多进程也没有讲缓存的数据冲走；也可以解释第0轮epoch就有2000多次的访问量</p>\n<p>加上缓存：<br>Training done in 0.069387 hours<br>Training  done in 0.068791 hours</p>\n<p>不加缓存：<br>Training  done in 0.017339 hours<br>Training  done in 0.035785 hours<br>Training  done in 0.037956 hours 命中率384</p>\n<p>使用字典进行缓存，随机置换：<br>Training  done in 0.022509 hours<br>Training  done in 0.039637 hours  命中率 224</p>\n<p>pyshmht 为python设计的基于hash表的共享内存</p>\n<p>asyncio</p>\n<p>目前结论：使用一个随机置换策略的缓存相比LRU置换效果更好  或者直接使用coodl的缓存后就固定不变</p>\n<p>感觉应该是LRU每次加锁读写链表</p>\n<p>明日安排：完成整个训练过程加缓存以及如何将缓存的位置转化为IO score</p>\n<p>11-29</p>\n<p>RPC小例子<br><a href=\"https://zhuanlan.zhihu.com/p/136372142\">https://zhuanlan.zhihu.com/p/136372142</a></p>\n<p>了解一下rpc pytorch， 打算使用nfs再使用orangefs来实现两个节点上worker的通信<br>看了两篇论文：1.是分析深度学习不同存储方式的性能 2.运用机器学习判断应用的IO模式，然后自适应的选择相应的优化策略（主要是针对有读写，以及I/O模式在整个应用生命过程中会改变，但深度学习是只读的，I/O模式似乎都是一样的）<br><a href=\"https://github.com/apachecn/apachecn-dl-zh/blob/master/docs/pt-tut-17/65.md\">https://github.com/apachecn/apachecn-dl-zh/blob/master/docs/pt-tut-17/65.md</a></p>\n<p>11-30<br>使用sudo aptitude install nfs-common 选择n y的时候安装失败，导致sudo无法使用，同时机器无法连接，修机器<br>参加rebuttal的会议</p>\n<p>12-1</p>\n<p>问题如何在orangefs上挂imagenet, 挂了之后仍然像ext4文件一样访问 /mnt/orangefs吗， 记得修改默认orangefs 服务器的文件目录，目前默认是/local500/storage-orangefs/吗<br>最后为什么是mount hec09的orangefs 为什么不是local500/storage-orangefs</p>\n<p>12-2 </p>\n<ol>\n<li>完成 rebuttal的提交</li>\n<li>初步在节点hec01 和hec03上实现 rpc测试  学长使用的是不同语言之间相互通信的grpc 先写一个.proto 文件，然后使用一个工具 将他编译为目标py文件或者go文件，然后分别在py和go文件里面使用这个编译好的文件</li>\n</ol>\n<p>在提交英文版本的时候一定要注意英语的拼写问题</p>\n<p>pytorch官网上的rpc网络： <a href=\"https://github.com/pytorch/pytorch/blob/master/docs/source/rpc.rst\">https://github.com/pytorch/pytorch/blob/master/docs/source/rpc.rst</a></p>\n<p>12-3 现在的问题是：worker如何确定当前可以shutdown</p>\n<p>目前遇到的问题是如果是将远程过程调用放在sampler，如果是多进程取sampler的话会导致 出错，因此应该把远程过程调用的逻辑放在主函数里面</p>\n<p>多进程会有多个sampler副本吗  难道是多进程访问sampler会加锁？？</p>\n<p>明天 1.实现在每个epoch前进行重要性计算 train_one_epoch前  2. score通过字典传递，而不是list</p>\n<p>rpc在远程过程调用的时候，如果调用的函数和初始化不在main函数下面py文件(主要的train_main 文件里)内会导致调用函数不一样 本来打算调用worker, 调用到master端</p>\n<p>12-7<br>实现使用nfs， 以及torch.distributed.rpc实现两个任务之间的通信， 阅读grpc 的route_guide example源码， 如果要使用grpc需要使用异步+call back函数，或者使用一个子进程+同步grpc，然后实现主进程和子进程之间通过共享内存实现数据的共享</p>\n<p>12-13</p>\n<p>在hec01使用setattr修改了文件dataset的属性<br>现在的问题是存储单元如何得知自己存储节点的数据，或者假设存储节点非常的近，那么存储节点只需要派一个节点进行训练就好了</p>\n<p>现在可以实现在一个存储单元上挂载orangefs-client查看数据， 之后换到新机器上实验orangefs形式的存储单元和计算单元 通讯和传递消息，目前server端只需要一个节点来进行推理，不需要每个server对每个server端的数据进行推理</p>\n<p>12-14<br>找到一个bug， loss.mean().backward应该在loss.cpu.detach()前面，否则就会训练的时候精度一直为0，怀疑是torch版本的问题<br>打算再新环境中使用orangefs，然后进行通讯任务训练<br>以及考虑加上cache + IO score 预先训练cache中的数据</p>\n<p>今天leetcode练习到532题</p>\n<p>明日安排：</p>\n<ol>\n<li><p>先profile一下cache time 是否真的的比ssd time小很多 </p>\n</li>\n<li><p>同时查看一下是不是每轮epoch 第一个iteration时间最长， 找到网上解答原因</p>\n</li>\n<li><p>multi-criterion到底应该怎么用。</p>\n</li>\n<li><p>写一个简单的用cache的信息加入到multi-criterion计算（不同的优先级给定一个分数），以及在cache中采样第一个batch, 以及随机置换的cache策略，先写一个版本</p>\n</li>\n<li><p>cache size以及cache的转换策略将对io score产生怎样的影响</p>\n</li>\n</ol>\n<p>相同数据每次的load time是不是都是变化很大。我感觉应该用时间近似，而不应该用level,因为不同cache的ssd的远近可能导致这两个时间相差很大，有的ssd读取和cache时间差不多那么io score应该就差不多，否则就应该加大io score的差距</p>\n<p>感觉多进程预取会抵消cache好处？？如果IO是瓶颈的话，那么预取的效果就比从cache中取数据的效果差</p>\n<p>12-15 完成一个简易版本的cache-aware sampling</p>\n<p>主要包含下面三个功能的实现：</p>\n<ol>\n<li>IO score的计算问题 使用profile的cache的时间和ssd时间近似替代训练序列的all_result_list[‘iotime’]</li>\n<li>sampler的序列问题， 先使用cache 里面缓存的序列</li>\n<li>cache的置换问题，初步使用self.vis字典实现先替换cache中vis的序列，但是问题是每个epoch都需要clear一下cache的vis序列</li>\n</ol>\n<p>但是现在还是在注释中</p>\n<p>12-16<br>尝试在8a100上实验，可能会考虑到分布式训练的sampler的修改<br>使之适应于分布式+orangefs这种场景</p>\n<p>完成情况：目前在多GPU上调试了之前hec上面的代码，可以跑通单机多卡加上cache, 和修改了cache time计算方式的代码<br>初步完成昨天1， 2， 3个功能，目前的问题就是DataParallel+ another model in storage side可能会有问题</p>\n<p>发现4 worker的时候 每4个iteration 第一个时间最长， 之后的时间都递减</p>\n<p>明日计划：</p>\n<p>四叉树合集有时间看看</p>\n<p>12-17 数据传输慢是因为传输的带宽被占满了吗？ 是否可以开不同的数据取线程？来为用于级别cache增加命中率<br>为什么4worker时每个iteration 4个中必有一个时间长 （已解决）<br>这个iteration time和worker的设置有关</p>\n<p>12-20<br>TODO: 分布式情况，多个节点得有多个cache, 这样的话在进行取数据的时候首先取cache中缓存的数据就不对，需要通过RDMA 需要直接取其他节点的cache数据才行<br>目前分析原因是消耗比读取快，消耗了一轮回过来，还是没有讲一个batch读完，所以又会在worker1处阻塞住，同时在worker1阻塞的时候，其他worker也在读取，所以表现为每隔一段时间就会出现一个IO时间非常长</p>\n<p>但是如果计算是瓶颈，应该不会出现这个<br>resnet152的时候io_time就能够被计算时间覆盖了，所以所有的iotime大概都是0.0003左右</p>\n<p>那么可以找到一个比较便捷的io瓶颈测量是将，看是否iotime是否随着worker进行周期变化； 但是总体上来说都是第一个iteration的iotime时间最长为1.6左右，因为没有任何计算来对iotime进行覆盖<br>alexnet其他worker每隔一段时间大概为0.5；resnet大概为0.2；其余为0.0003</p>\n<p><a href=\"https://kangsheng.xyz/2020/07/14/pytorch%E4%B8%ADdataloader%E7%9A%84num_workers%E8%AE%BE%E7%BD%AE/\">https://kangsheng.xyz/2020/07/14/pytorch%E4%B8%ADdataloader%E7%9A%84num_workers%E8%AE%BE%E7%BD%AE/</a><br>这里的iotime包括进程开销，以及batch读取+batch处理开销 但是多进程加载数据包括读+处理两个部分， 而不是只读<br>8A100 2个物理CPU, 每个cpu 物理64核， 每个核有两个逻辑处理器；所以两个cpu一起就有256个逻辑处理器（2<em>2</em>64）<br>hec02是8个cpu, 每个cpu上面只有一个核</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/91521705\">https://zhuanlan.zhihu.com/p/91521705</a> 查看dataset多worker加载数据，每个worker负责一个batch,只有在当前batch消耗掉之后才会取下一个分配的任务，而不是一直取数据。同时这个worker取数据包括读+数据增强两个部分</p>\n<blockquote>\n<p>其实各个worker之间读取数据时间差不多，并且由于是多进程任务，所以每次第一个worker读完数据就绪以后其他也准备就绪了，主进程随即开始连续前向传递了，并轮询的向各worker发送读新一批数据的信号，只不过跑完上一轮次所有worker产生的数据（num_workers个batch）后，各worker中新一轮次数据还没就绪，所以阻塞住了。</p>\n</blockquote>\n<p>4worker的情况下；<br>io_time: 0.6680457592010498<br>io_time: 0.00039649009704589844<br>io_time: 0.0004131793975830078<br>io_time: 0.00040602684020996094<br>io_time: 0.7091846466064453</p>\n<p>8worker的情况下：<br>io_time: 0.583601713180542<br>io_time: 0.00048732757568359375<br>io_time: 0.011454343795776367<br>io_time: 0.0005695819854736328<br>io_time: 0.00035643577575683594<br>io_time: 0.0003287792205810547<br>io_time: 0.0004932880401611328<br>io_time: 0.0003211498260498047<br>io_time: 0.5443663597106934</p>\n<p>16worker的时候：<br>io_time: 0.6202142238616943<br>io_time: 0.0005917549133300781<br>io_time: 0.0004055500030517578<br>io_time: 0.00042128562927246094<br>io_time: 0.0004863739013671875<br>io_time: 0.00027370452880859375<br>io_time: 0.0002474784851074219<br>io_time: 0.0002865791320800781<br>io_time: 0.00033855438232421875<br>io_time: 0.00021886825561523438<br>io_time: 0.0002658367156982422<br>io_time: 0.00020456314086914062<br>io_time: 0.0001895427703857422<br>io_time: 0.0005667209625244141<br>io_time: 0.0004878044128417969<br>io_time: 0.013859033584594727</p>\n<p>worker数量越小，出现io_time突然增加的可能性越高<br>现在的问题是：在worker数量不足的时候是否这种用另外的worker去取数据，是否会影响数据加载的性能；相当于增加了线程数量；这好像更多加一个worker，然后多加一个缓存空间，实现超前预取没有实质区别<br>另外一种合理的解释就是说利用data worker取数据的空闲时间来进行cache的换新，但是IO 瓶颈data worker空闲的时间也不多呀；只有计算密集的data worker才会空闲</p>\n<p>而且cache如果这样设计的话和buffer没有什么区别，因为都是取一次用一次，结论在buffer里面实现预取进程无用! 而且可能增加磁盘带宽压力</p>\n<p>coordl又讲使用cache的理由吗？感觉可以直接沿用coordl理由</p>\n<p>Gist：在两次数据利用之间有长时间的gap，因此可以对数据进行压缩，之后要用的时候再解压缩， ==在cache里面对数据进行压缩解压== 问题是data没有稀疏性，如果较好的无损压缩</p>\n<p>12-21<br>目前分别在hec 和 8a100上测试远程过程调用和cache的代码</p>\n<p>看代码的时候注意一下几个方面：<br>1）远程过程调用现在不能使用dataparallel  create_file<br>2) cache代码里面可以使用DP, 需要确定cache大小<br>3）loss.backward一定要在loss.cpu/记录loss 之前，否则会报错<br>4）合起来的时候一定要注意将init_rpc 以及 有关worker和master的代码打开（train_evaluate）<br>5) 感觉增加worker数量就能消除IO瓶颈的问题如何解决</p>\n<p>找到一个bug: 使用dp的时候，batch_size应该*gpu数量，因为是一个batch size拆分，但是ddp不是</p>\n<p>明天任务：<br>如何实现多GPU情况下，多进程共享一个数据结构cache， 因为现在好像是多个进程，每个可能都会创建一个cache这个是不合理的</p>\n<p>12.22 </p>\n<p>看了以及整理了一下括号相关的leetcode题目</p>\n<p>rpc在回调结果的时候遇到一个问题：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">master使用远程过程调用的结果来更新criterion_history_list_dict<br>Traceback (most recent call last):<br>  File <span class=\"hljs-string\">&quot;./imagenet_final_train_master.py&quot;</span>, line <span class=\"hljs-number\">206</span>, <span class=\"hljs-keyword\">in</span> &lt;module&gt;<br>    train_main(args.gpu, ngpus_per_node, args, kwargs)<br>  File <span class=\"hljs-string\">&quot;./imagenet_final_train_master.py&quot;</span>, line <span class=\"hljs-number\">94</span>, <span class=\"hljs-keyword\">in</span> train_main<br>    run_training(model, trainloader, testloader, trainset, testset,  optimizer, criterion, dirs, args.epochs, args, kwargs)<br>  File <span class=\"hljs-string\">&quot;/nfs/home/shu/hushuang_all_files/ImageClassification/8a100-code/IOAS/imagenet/train_evaluate.py&quot;</span>, line <span class=\"hljs-number\">177</span>, <span class=\"hljs-keyword\">in</span> run_training<br>    refresh_uni_list( uni_score_rref, allscore_numpy_dict, args)<br>  File <span class=\"hljs-string\">&quot;/nfs/home/shu/hushuang_all_files/ImageClassification/8a100-code/IOAS/imagenet/rpc_func.py&quot;</span>, line <span class=\"hljs-number\">44</span>, <span class=\"hljs-keyword\">in</span> refresh_uni_list<br>    uni_score_list = uni_score_rref.to_here().numpy().tolist()<br>RuntimeError: RPCErr:<span class=\"hljs-number\">1</span>:RPC ran <span class=\"hljs-keyword\">for</span> more than <span class=\"hljs-built_in\">set</span> timeout (<span class=\"hljs-number\">60000</span> ms) <span class=\"hljs-keyword\">and</span> will now be marked <span class=\"hljs-keyword\">with</span> an error<br><br><span class=\"hljs-comment\"># worker 端</span><br><br>[W tensorpipe_agent.cpp:<span class=\"hljs-number\">498</span>] RPC agent <span class=\"hljs-keyword\">for</span> worker1 encountered error when sending response to request <span class=\"hljs-comment\">#16 to worker0: EOF: end of file</span><br></code></pre></td></tr></table></figure>\n\n\n<p>12.23<br>现在8a100端注释了master的和worker代码就可以实现 存储端计算重要性+主进程端使用cache缓存部分数据</p>\n<p>主要逻辑：（cache 3+ 存储单元 1）</p>\n<ol>\n<li>0epoch冷启动， 在1epoch缓存端已经开始缓存数据， 每轮训练的时候将vis的数据打一个标记，置换策略将vis的数据随机置换出去</li>\n<li>下一轮 sampler返回训练的时候将cache中的数据放在前面</li>\n<li>在重要性采样开始前一轮epoch，开始搜集重要性metric设计的分数，如果有io 分数的话，通过profile 的iotime 来对cache time的ssd load time进行估计（求平均值），同时对下一轮样本的iotime进行预测</li>\n<li>将计算出来的重要的样本下一轮训练，不重要的样本序列通过rpc传给存储端的计算单元，让master和worker分别更新重要的样本和不重要样本的分数。</li>\n<li>然后之后在进行采样的使用用全部更新好的重要性分数，重复排序和训练更新步骤</li>\n</ol>\n<p>解决两个bug:</p>\n<ol>\n<li>之所以8a100上面使用分布式调用不起来，是因为我之前在使用torch.distributed.rpc的时候写了os[‘environment’] =hec01  导致分布式错误</li>\n<li>训练精度很低， 修改criterion<br>criterion = nn.CrossEntropyLoss(reduce=False).cuda(args.gpu) hec02实验<br>目前是用这个解决了，但是assert语句显示一致, 不知道原因</li>\n</ol>\n<p>12-27<br>解决cache在mp.spawn 使用多进程训练的时候导致段错误或者信号接收错误<br>选择启动方式：mp.set_start_method(‘spawn’)</p>\n<p>在进行调试的时候，break不应该放在args,rank==0下面，否则就会卡死</p>\n<p>12-28<br>现在的任务就是看rpc是否能和分布式训练的mp.spawn同时存在, 应该主进程主要负责rpc</p>\n<p>ssh需要输入密码的节点为何无法使用rpc进行通信</p>\n<p>12-29<br>今天主要看了legoos这篇论文， 对调度相关的其他论文也进行了总结和分类，以及看了ppt下面的链接有关内容<br>明日安排，做一下最短路径（单源或者多源情况）， 练习今天学到的有关Dijstra, Bellman-Ford算法以及Floyd算法</p>\n<h4 id=\"2022\"><a href=\"#2022\" class=\"headerlink\" title=\"2022\"></a>2022</h4><p>1-3<br>完成&gt;400目标<br>代码主要就是看分布式+rpc是否能够兼容(+cache目前通过mp.spawn解决)并调试通过，实在ddp+rpc无法完成，就只能使用dp+rpc</p>\n<p>1-6 现在遇到的问题：1.有ssh密码登录的机器，使用rpc无法正常运行， 同时rpc在同一台机器好像也无法正常运行</p>\n<p>解决！<br>注意在rpc中发出rpc_async请求的是worker, 接收请求的是master</p>\n<p>hec上使用pytorch 1.8.1只能在没有gpu的节点上，如果在hec01 hec02上就会报错</p>\n<p>现在问题 8a100和hec06节点连接会报错：<br>aster: ECONNREFUSED: connection refused<br>Failed to respond to ‘Shutdown Proceed’ in time, got error ECONNREFUSED: connection refused<br>Traceback (most recent call last):<br>  File “worker.py”, line 88, in <module><br>    rpc.shutdown()<br>  File “/nfs/home/anaconda3/envs/pytorch-shu/lib/python3.6/site-packages/torch/distributed/rpc/api.py”, line 78, in wrapper<br>    return func(*args, **kwargs)<br>  File “/nfs/home/anaconda3/envs/pytorch-shu/lib/python3.6/site-packages/torch/distributed/rpc/api.py”, line 284, in shutdown<br>    _get_current_rpc_agent().join()<br>RuntimeError: [/opt/conda/conda-bld/pytorch_1607370193460/work/third_party/gloo/gloo/transport/tcp/pair.cc:575] Connection closed by peer [10.5.30.42]:27806</module></p>\n<p>Solution: Edit /etc/hosts and change 127.0.1.1 to your actual ip-address 目前看到的一个答案<br>分析：现在在hec上互相使用rpc（即使有密码）是可以的，但是在8a100就不行，所以现在怀疑的是需要在host里面添加目录，以及需要在两台机器上换成同一个用户才行<br>第二种解决方案，应该使用tpc的init_method，以及使用gloo后端，但是目前试验过，仍然会报错</p>\n<p>感觉在分布式多台机器上训练也会出现相同的问题</p>\n<p>找到的真正的解决方案：backend=rpc.BackendType.PROCESS_GROUP， 不需要加其他的<br>os.environ[‘TF_SOCKET_IFNAME’] = ‘ens3’ (x)<br>os.environ[‘GLOO_SOCKET_IFNAME’] = ‘ens3’ (x)</p>\n<p>寒假安排：</p>\n<ol>\n<li>leetcode争取上500 可以先将宫水三叶的题刷完，应该都是经典题目</li>\n<li>对之前写的leetcode进行总结，整理，转为每个知识点，先放总结的思路，或者针对的题型，然后放相应的例题，没道例题简答写一下解决方案，和总结的思路进行对应</li>\n<li>回归操作系统，计网的基础知识, 转为笔试的xmind (408题目看看)<br>github和牛客网应该有许多资源，多看看多比较; 包括深度学习和目标检测相关的面试题目<br>牛客网上， 网友的总结：(CyC2018)<br>[<a href=\"https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E7%9B%AE%E5%BD%95.md]\">https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E7%9B%AE%E5%BD%95.md]</a></li>\n<li>补充面试的xmind</li>\n<li>有时间学一下grpc</li>\n<li>记得备份一下8a100上面的数据 (目前正在8a100使用rsync进行传输 到hec06 /nfs目录下)<br>7。一些公司名单和深度学习的资料<br><a href=\"https://github.com/amusi/CV-Company-List\">https://github.com/amusi/CV-Company-List</a><br>注意关注一下春招信息，微软已经开始投递了，然后我因为错过了问卷，错过了提前批，之后注意准备面试和之后的问卷</li>\n<li>修改简历，变为项目两个， research两个，将重要性采样自己的工作写上去zzw</li>\n<li>项目一定要非常非常熟悉，整理面试可能问到的每一个问题，和自己优化的思考！！！</li>\n</ol>\n<p>刷完八股之后，进行自测：<a href=\"https://github.com/youngyangyang04/TechCPP\">https://github.com/youngyangyang04/TechCPP</a><br><a href=\"https://github.com/youngyangyang04/leetcode-master\">https://github.com/youngyangyang04/leetcode-master</a></p>\n<p>有关于C++的八股文：<a href=\"https://github.com/Light-City/CPlusPlusThings\">https://github.com/Light-City/CPlusPlusThings</a></p>\n<p>408资料<br><a href=\"https://github.com/CodePanda66/CSPostgraduate-408\">https://github.com/CodePanda66/CSPostgraduate-408</a><br>408历年真题大题查看</p>\n<p>公司：思科，</p>\n<p>别人的面经总结：<br><a href=\"https://prohuper.github.io/2020/04/17/interview_exp2/\">https://prohuper.github.io/2020/04/17/interview_exp2/</a></p>\n<p>推荐资料:<br>力扣1-300题（前300道题非常经典，建议学有余力的同学都刷一刷）<br>力扣HOT100（跟上面有不少是重复的，刷的时候要注意总结）<br>啊哈！算法、大话数据结构（这两本书都是面向新手的图书，图画很多）<br>剑指offer（这本书不需要多做介绍，校招必备）<br>挑战程序设计竞赛（这本书属于进阶一点的算法书籍了，作者是ACM-ICPC全球总冠军，可以说是<br>世界顶级程序设计高手的经验总结了，需要慢慢消化，经典题型太多）<br>程序员代码面试指南（左程云大神的书，我并没有看完，只是看了其中的海量数据处理部分的题<br>目就已经十分受用了，在某大厂三面中就考查到了其中的海量数据集处理的问题）</p>\n<p>按公司分题：<a href=\"https://github.com/afatcoder/LeetcodeTop%EF%BC%88%E9%9D%A2%E8%AF%95%E5%89%8D%E5%88%B7%E4%B8%80%E5%88%B7%EF%BC%89\">https://github.com/afatcoder/LeetcodeTop（面试前刷一刷）</a></p>\n<p><a href=\"https://github.com/HarleysZhang/2021_algorithm_intern_information\">https://github.com/HarleysZhang/2021_algorithm_intern_information</a> 计算机视觉-算法岗位相关<br><a href=\"https://github.com/DWCTOD/interview\">https://github.com/DWCTOD/interview</a></p>\n<p>把leetcode的剑指offer开头 和leetcode全部看一篇</p>\n","site":{"data":{}},"wordcount":12912,"excerpt":"","more":"<p>11-15<br>记得之后验证一下multiple是否支持只有loss这种情况，如果支持的话，sampler全部修改为一个，同时目前只修改和看BS这种情况</p>\n<p>tune参数包括warm_up_epoch and sampling rate</p>\n<p>完成情况：整理完之前的IOAS代码，将multi和single进行融合，同时使用字典形式来替换if-else多个flag的情况<br>记录：leetcode 刷题指南完成：贪心算法， 哈希表，双指针部分, 栈与队列部分</p>\n<p>11-16<br>初步完成论文框架思维导图</p>\n<p>修改代码，找到IO瓶颈场景</p>\n<p>在代码中添加上视频分析这个场景</p>\n<p>今天突然想到suprevision是用的什么anchor box，需要将数据下载完成后验证，猜测使用featmap_size??而不是预设的anchor</p>\n<p>总结：<br>看完interviewtop上操作系统的八股文<br>下载coco数据<br>完成一版xmind思路调整<br>查看阿里基础架构面经</p>\n<p>11-17<br>找到io为瓶颈的场景，并进行重要性采样实验<br>目前发现MS比BS精度高</p>\n<p>BS：面临的问题  如何选择阈值 目前：搜索出初始thres_ratio, 之后使用历史+当前thres_ratio调整，//没有被计算的使用远程存储的模型进行计算,以及根据模型能力调整thres_ratio</p>\n<p>MS: recall interval,不同等级之间的recall 时间差距是1 epoch 吗，新划分出来训练的类又如何根据阈值划分呢（等分感觉不科学）//建一个模型自动划分和确定等待的时间  （多个阈值和多个等待时间的确定）</p>\n<p>现在只修改BS (1)实现在存储端计算样本重要性， （2）感觉样本的位置</p>\n<p><a href=\"https://www.sigarch.org/the-new-bottlenecks-of-ml-training-a-storage-perspective/\">https://www.sigarch.org/the-new-bottlenecks-of-ml-training-a-storage-perspective/</a> 这个讲得挺好<br>处理的浏览了一下FreqCheck 的源码 但是每太明白细节上是如何在torch.save()后面封装 fsync(),   以及如何根据runtime overhead的profile结果进行自适应的checkpointing frequency超参数的调节</p>\n<p>目标：弄懂多进程异步/模型的异步训练， 参考autoassist 以及checkFreq，subprocess<br>以及另外开一个进程来进行io带宽的测量(profile)以及未读取数据的重要性更新，另外一个空闲节点</p>\n<p>11-18</p>\n<p>看了autoassist的多进程，但是他们在训练另外一个模型进行样本的现在是训练了另外一个二分模型，这个二分模型的目标是 loss大于均值为target或者target model判断错误的label=1</p>\n<p>我要训练的另外一个模型是在存储节点训练的模型，无需训练只需要将模型每次最新权重穿过来，在checkpoint的时候将模型传给远端; screen 需要同时训练另外一个模型会加重CPU和GPU训练负担，同时也不是很好同步轻量级模型和远程target模型判断样本重要性的差距</p>\n<p>完成另外一个进程异步训练模型的初步代码</p>\n<p>11-22</p>\n<p>完成情况：<br>完成主进程和子进程相互传输重要性分数，invalid list以及模型初步代码</p>\n<p>明天需要解决的问题：<br>1）如果解决模型参数保存的时候使用model.cpu().state_dict() 但是计算的时候需要使用dp 或者cuda, 保存模型这个动作如何转为复制模型参数，而不是真正将模型保存到cpu</p>\n<ol start=\"2\">\n<li>如何减少推理时间太长的问题，如果使用原模型进行不重要样本重要性计算</li>\n</ol>\n<p>3）如果将一个节点转移到两个节点间的数据传输（远端存储系统情况）</p>\n<p>4）把这个解决了，再解决如何修改io module 自定义一个缓冲区，然后在缓冲区/cache中实现TLB表，以及数据从缓冲区中读取</p>\n<p>要解决的问题：1 分布式训练如何将另外一个进程计算得到的uni_score广播给其他进程<br>而且注意是多个分布式训练主进程对应一个子进程，不应该建立多个进行不重要样本重要性计算的子进程</p>\n<p>目前遇到的问题：RuntimeError: module must have its parameters and buffers on device cuda:0 (device_ids[0]) but found one of them on device: cpu–&gt;解决，因为model.cpu().state_dict导致</p>\n<p>11-23</p>\n<p>完成情况：</p>\n<p>1）使用一个copy.deepcopy完成在gpu上模型的拷贝到cpu<br>2) 解决子进程无法正常退出的问题<br>3）初步熟悉dataloader和dataset的代码</p>\n<p>下一步：<br>如何解决判断数据是在缓存， 本地磁盘， 还是远端存储系统呢</p>\n<p>11-24  </p>\n<p>1）调整了lru_cache的逻辑<br>2）但是目前不知道如何将tlb得到的信息转为io_predict_time<br>3）初步使用多进程访问同一个cache,同时记录总访问次数和命中率，因为多进程需要共享一个数据结构，因此使用multiprocessing.Manager 因为LRUcache是自定义的一个数据结构，因此需要使用自定义的manager</p>\n<p>目前发现worker越多，access 缓存次数越多</p>\n<p>worker = 8<br>self.size:256<br>total_access_time:2432, hit_time:128</p>\n<p>worker = 4<br>self.size:256<br>total_access_time:1048, hit_time:128</p>\n<p>worker = 0<br>self.size:128<br>total_access_time:384, hit_time:256</p>\n<p>如何只是对cache的每个变量使用multiprocessing进行加锁的话会导致出现None 结构remove错误，所以对于cache的get set函数都应该是一个原子操作（一个事务），所以需要对cache使用原子操作（加锁），而不仅仅是里面的一个变量加锁就可以了</p>\n<p>11-25</p>\n<p>验证多进程为什么总的访问次数会增加，以及为什么使用缓存的大小增加，但是命中率会减小<br>考虑如何将tlb功能转为IO score的计算<br>如何感知数据的位置，在其他节点的存储中，本地存储中，还是缓存中</p>\n<p>发现：epoch=0和epoch=1的时候多进程取数据hit time=0， cache size=256 但是如果worker=0的话， epoch=1时候的命中率应该为128 cache size=128<br>解释：因为我在执行流程中间break了，但是数据还在提前取后面一轮的，所以导致cache size会满，同时命中率下降；第二轮本来要取的序列就减少了，所以多进程也没有讲缓存的数据冲走；也可以解释第0轮epoch就有2000多次的访问量</p>\n<p>加上缓存：<br>Training done in 0.069387 hours<br>Training  done in 0.068791 hours</p>\n<p>不加缓存：<br>Training  done in 0.017339 hours<br>Training  done in 0.035785 hours<br>Training  done in 0.037956 hours 命中率384</p>\n<p>使用字典进行缓存，随机置换：<br>Training  done in 0.022509 hours<br>Training  done in 0.039637 hours  命中率 224</p>\n<p>pyshmht 为python设计的基于hash表的共享内存</p>\n<p>asyncio</p>\n<p>目前结论：使用一个随机置换策略的缓存相比LRU置换效果更好  或者直接使用coodl的缓存后就固定不变</p>\n<p>感觉应该是LRU每次加锁读写链表</p>\n<p>明日安排：完成整个训练过程加缓存以及如何将缓存的位置转化为IO score</p>\n<p>11-29</p>\n<p>RPC小例子<br><a href=\"https://zhuanlan.zhihu.com/p/136372142\">https://zhuanlan.zhihu.com/p/136372142</a></p>\n<p>了解一下rpc pytorch， 打算使用nfs再使用orangefs来实现两个节点上worker的通信<br>看了两篇论文：1.是分析深度学习不同存储方式的性能 2.运用机器学习判断应用的IO模式，然后自适应的选择相应的优化策略（主要是针对有读写，以及I/O模式在整个应用生命过程中会改变，但深度学习是只读的，I/O模式似乎都是一样的）<br><a href=\"https://github.com/apachecn/apachecn-dl-zh/blob/master/docs/pt-tut-17/65.md\">https://github.com/apachecn/apachecn-dl-zh/blob/master/docs/pt-tut-17/65.md</a></p>\n<p>11-30<br>使用sudo aptitude install nfs-common 选择n y的时候安装失败，导致sudo无法使用，同时机器无法连接，修机器<br>参加rebuttal的会议</p>\n<p>12-1</p>\n<p>问题如何在orangefs上挂imagenet, 挂了之后仍然像ext4文件一样访问 /mnt/orangefs吗， 记得修改默认orangefs 服务器的文件目录，目前默认是/local500/storage-orangefs/吗<br>最后为什么是mount hec09的orangefs 为什么不是local500/storage-orangefs</p>\n<p>12-2 </p>\n<ol>\n<li>完成 rebuttal的提交</li>\n<li>初步在节点hec01 和hec03上实现 rpc测试  学长使用的是不同语言之间相互通信的grpc 先写一个.proto 文件，然后使用一个工具 将他编译为目标py文件或者go文件，然后分别在py和go文件里面使用这个编译好的文件</li>\n</ol>\n<p>在提交英文版本的时候一定要注意英语的拼写问题</p>\n<p>pytorch官网上的rpc网络： <a href=\"https://github.com/pytorch/pytorch/blob/master/docs/source/rpc.rst\">https://github.com/pytorch/pytorch/blob/master/docs/source/rpc.rst</a></p>\n<p>12-3 现在的问题是：worker如何确定当前可以shutdown</p>\n<p>目前遇到的问题是如果是将远程过程调用放在sampler，如果是多进程取sampler的话会导致 出错，因此应该把远程过程调用的逻辑放在主函数里面</p>\n<p>多进程会有多个sampler副本吗  难道是多进程访问sampler会加锁？？</p>\n<p>明天 1.实现在每个epoch前进行重要性计算 train_one_epoch前  2. score通过字典传递，而不是list</p>\n<p>rpc在远程过程调用的时候，如果调用的函数和初始化不在main函数下面py文件(主要的train_main 文件里)内会导致调用函数不一样 本来打算调用worker, 调用到master端</p>\n<p>12-7<br>实现使用nfs， 以及torch.distributed.rpc实现两个任务之间的通信， 阅读grpc 的route_guide example源码， 如果要使用grpc需要使用异步+call back函数，或者使用一个子进程+同步grpc，然后实现主进程和子进程之间通过共享内存实现数据的共享</p>\n<p>12-13</p>\n<p>在hec01使用setattr修改了文件dataset的属性<br>现在的问题是存储单元如何得知自己存储节点的数据，或者假设存储节点非常的近，那么存储节点只需要派一个节点进行训练就好了</p>\n<p>现在可以实现在一个存储单元上挂载orangefs-client查看数据， 之后换到新机器上实验orangefs形式的存储单元和计算单元 通讯和传递消息，目前server端只需要一个节点来进行推理，不需要每个server对每个server端的数据进行推理</p>\n<p>12-14<br>找到一个bug， loss.mean().backward应该在loss.cpu.detach()前面，否则就会训练的时候精度一直为0，怀疑是torch版本的问题<br>打算再新环境中使用orangefs，然后进行通讯任务训练<br>以及考虑加上cache + IO score 预先训练cache中的数据</p>\n<p>今天leetcode练习到532题</p>\n<p>明日安排：</p>\n<ol>\n<li><p>先profile一下cache time 是否真的的比ssd time小很多 </p>\n</li>\n<li><p>同时查看一下是不是每轮epoch 第一个iteration时间最长， 找到网上解答原因</p>\n</li>\n<li><p>multi-criterion到底应该怎么用。</p>\n</li>\n<li><p>写一个简单的用cache的信息加入到multi-criterion计算（不同的优先级给定一个分数），以及在cache中采样第一个batch, 以及随机置换的cache策略，先写一个版本</p>\n</li>\n<li><p>cache size以及cache的转换策略将对io score产生怎样的影响</p>\n</li>\n</ol>\n<p>相同数据每次的load time是不是都是变化很大。我感觉应该用时间近似，而不应该用level,因为不同cache的ssd的远近可能导致这两个时间相差很大，有的ssd读取和cache时间差不多那么io score应该就差不多，否则就应该加大io score的差距</p>\n<p>感觉多进程预取会抵消cache好处？？如果IO是瓶颈的话，那么预取的效果就比从cache中取数据的效果差</p>\n<p>12-15 完成一个简易版本的cache-aware sampling</p>\n<p>主要包含下面三个功能的实现：</p>\n<ol>\n<li>IO score的计算问题 使用profile的cache的时间和ssd时间近似替代训练序列的all_result_list[‘iotime’]</li>\n<li>sampler的序列问题， 先使用cache 里面缓存的序列</li>\n<li>cache的置换问题，初步使用self.vis字典实现先替换cache中vis的序列，但是问题是每个epoch都需要clear一下cache的vis序列</li>\n</ol>\n<p>但是现在还是在注释中</p>\n<p>12-16<br>尝试在8a100上实验，可能会考虑到分布式训练的sampler的修改<br>使之适应于分布式+orangefs这种场景</p>\n<p>完成情况：目前在多GPU上调试了之前hec上面的代码，可以跑通单机多卡加上cache, 和修改了cache time计算方式的代码<br>初步完成昨天1， 2， 3个功能，目前的问题就是DataParallel+ another model in storage side可能会有问题</p>\n<p>发现4 worker的时候 每4个iteration 第一个时间最长， 之后的时间都递减</p>\n<p>明日计划：</p>\n<p>四叉树合集有时间看看</p>\n<p>12-17 数据传输慢是因为传输的带宽被占满了吗？ 是否可以开不同的数据取线程？来为用于级别cache增加命中率<br>为什么4worker时每个iteration 4个中必有一个时间长 （已解决）<br>这个iteration time和worker的设置有关</p>\n<p>12-20<br>TODO: 分布式情况，多个节点得有多个cache, 这样的话在进行取数据的时候首先取cache中缓存的数据就不对，需要通过RDMA 需要直接取其他节点的cache数据才行<br>目前分析原因是消耗比读取快，消耗了一轮回过来，还是没有讲一个batch读完，所以又会在worker1处阻塞住，同时在worker1阻塞的时候，其他worker也在读取，所以表现为每隔一段时间就会出现一个IO时间非常长</p>\n<p>但是如果计算是瓶颈，应该不会出现这个<br>resnet152的时候io_time就能够被计算时间覆盖了，所以所有的iotime大概都是0.0003左右</p>\n<p>那么可以找到一个比较便捷的io瓶颈测量是将，看是否iotime是否随着worker进行周期变化； 但是总体上来说都是第一个iteration的iotime时间最长为1.6左右，因为没有任何计算来对iotime进行覆盖<br>alexnet其他worker每隔一段时间大概为0.5；resnet大概为0.2；其余为0.0003</p>\n<p><a href=\"https://kangsheng.xyz/2020/07/14/pytorch%E4%B8%ADdataloader%E7%9A%84num_workers%E8%AE%BE%E7%BD%AE/\">https://kangsheng.xyz/2020/07/14/pytorch%E4%B8%ADdataloader%E7%9A%84num_workers%E8%AE%BE%E7%BD%AE/</a><br>这里的iotime包括进程开销，以及batch读取+batch处理开销 但是多进程加载数据包括读+处理两个部分， 而不是只读<br>8A100 2个物理CPU, 每个cpu 物理64核， 每个核有两个逻辑处理器；所以两个cpu一起就有256个逻辑处理器（2<em>2</em>64）<br>hec02是8个cpu, 每个cpu上面只有一个核</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/91521705\">https://zhuanlan.zhihu.com/p/91521705</a> 查看dataset多worker加载数据，每个worker负责一个batch,只有在当前batch消耗掉之后才会取下一个分配的任务，而不是一直取数据。同时这个worker取数据包括读+数据增强两个部分</p>\n<blockquote>\n<p>其实各个worker之间读取数据时间差不多，并且由于是多进程任务，所以每次第一个worker读完数据就绪以后其他也准备就绪了，主进程随即开始连续前向传递了，并轮询的向各worker发送读新一批数据的信号，只不过跑完上一轮次所有worker产生的数据（num_workers个batch）后，各worker中新一轮次数据还没就绪，所以阻塞住了。</p>\n</blockquote>\n<p>4worker的情况下；<br>io_time: 0.6680457592010498<br>io_time: 0.00039649009704589844<br>io_time: 0.0004131793975830078<br>io_time: 0.00040602684020996094<br>io_time: 0.7091846466064453</p>\n<p>8worker的情况下：<br>io_time: 0.583601713180542<br>io_time: 0.00048732757568359375<br>io_time: 0.011454343795776367<br>io_time: 0.0005695819854736328<br>io_time: 0.00035643577575683594<br>io_time: 0.0003287792205810547<br>io_time: 0.0004932880401611328<br>io_time: 0.0003211498260498047<br>io_time: 0.5443663597106934</p>\n<p>16worker的时候：<br>io_time: 0.6202142238616943<br>io_time: 0.0005917549133300781<br>io_time: 0.0004055500030517578<br>io_time: 0.00042128562927246094<br>io_time: 0.0004863739013671875<br>io_time: 0.00027370452880859375<br>io_time: 0.0002474784851074219<br>io_time: 0.0002865791320800781<br>io_time: 0.00033855438232421875<br>io_time: 0.00021886825561523438<br>io_time: 0.0002658367156982422<br>io_time: 0.00020456314086914062<br>io_time: 0.0001895427703857422<br>io_time: 0.0005667209625244141<br>io_time: 0.0004878044128417969<br>io_time: 0.013859033584594727</p>\n<p>worker数量越小，出现io_time突然增加的可能性越高<br>现在的问题是：在worker数量不足的时候是否这种用另外的worker去取数据，是否会影响数据加载的性能；相当于增加了线程数量；这好像更多加一个worker，然后多加一个缓存空间，实现超前预取没有实质区别<br>另外一种合理的解释就是说利用data worker取数据的空闲时间来进行cache的换新，但是IO 瓶颈data worker空闲的时间也不多呀；只有计算密集的data worker才会空闲</p>\n<p>而且cache如果这样设计的话和buffer没有什么区别，因为都是取一次用一次，结论在buffer里面实现预取进程无用! 而且可能增加磁盘带宽压力</p>\n<p>coordl又讲使用cache的理由吗？感觉可以直接沿用coordl理由</p>\n<p>Gist：在两次数据利用之间有长时间的gap，因此可以对数据进行压缩，之后要用的时候再解压缩， ==在cache里面对数据进行压缩解压== 问题是data没有稀疏性，如果较好的无损压缩</p>\n<p>12-21<br>目前分别在hec 和 8a100上测试远程过程调用和cache的代码</p>\n<p>看代码的时候注意一下几个方面：<br>1）远程过程调用现在不能使用dataparallel  create_file<br>2) cache代码里面可以使用DP, 需要确定cache大小<br>3）loss.backward一定要在loss.cpu/记录loss 之前，否则会报错<br>4）合起来的时候一定要注意将init_rpc 以及 有关worker和master的代码打开（train_evaluate）<br>5) 感觉增加worker数量就能消除IO瓶颈的问题如何解决</p>\n<p>找到一个bug: 使用dp的时候，batch_size应该*gpu数量，因为是一个batch size拆分，但是ddp不是</p>\n<p>明天任务：<br>如何实现多GPU情况下，多进程共享一个数据结构cache， 因为现在好像是多个进程，每个可能都会创建一个cache这个是不合理的</p>\n<p>12.22 </p>\n<p>看了以及整理了一下括号相关的leetcode题目</p>\n<p>rpc在回调结果的时候遇到一个问题：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">master使用远程过程调用的结果来更新criterion_history_list_dict<br>Traceback (most recent call last):<br>  File <span class=\"hljs-string\">&quot;./imagenet_final_train_master.py&quot;</span>, line <span class=\"hljs-number\">206</span>, <span class=\"hljs-keyword\">in</span> &lt;module&gt;<br>    train_main(args.gpu, ngpus_per_node, args, kwargs)<br>  File <span class=\"hljs-string\">&quot;./imagenet_final_train_master.py&quot;</span>, line <span class=\"hljs-number\">94</span>, <span class=\"hljs-keyword\">in</span> train_main<br>    run_training(model, trainloader, testloader, trainset, testset,  optimizer, criterion, dirs, args.epochs, args, kwargs)<br>  File <span class=\"hljs-string\">&quot;/nfs/home/shu/hushuang_all_files/ImageClassification/8a100-code/IOAS/imagenet/train_evaluate.py&quot;</span>, line <span class=\"hljs-number\">177</span>, <span class=\"hljs-keyword\">in</span> run_training<br>    refresh_uni_list( uni_score_rref, allscore_numpy_dict, args)<br>  File <span class=\"hljs-string\">&quot;/nfs/home/shu/hushuang_all_files/ImageClassification/8a100-code/IOAS/imagenet/rpc_func.py&quot;</span>, line <span class=\"hljs-number\">44</span>, <span class=\"hljs-keyword\">in</span> refresh_uni_list<br>    uni_score_list = uni_score_rref.to_here().numpy().tolist()<br>RuntimeError: RPCErr:<span class=\"hljs-number\">1</span>:RPC ran <span class=\"hljs-keyword\">for</span> more than <span class=\"hljs-built_in\">set</span> timeout (<span class=\"hljs-number\">60000</span> ms) <span class=\"hljs-keyword\">and</span> will now be marked <span class=\"hljs-keyword\">with</span> an error<br><br><span class=\"hljs-comment\"># worker 端</span><br><br>[W tensorpipe_agent.cpp:<span class=\"hljs-number\">498</span>] RPC agent <span class=\"hljs-keyword\">for</span> worker1 encountered error when sending response to request <span class=\"hljs-comment\">#16 to worker0: EOF: end of file</span><br></code></pre></td></tr></table></figure>\n\n\n<p>12.23<br>现在8a100端注释了master的和worker代码就可以实现 存储端计算重要性+主进程端使用cache缓存部分数据</p>\n<p>主要逻辑：（cache 3+ 存储单元 1）</p>\n<ol>\n<li>0epoch冷启动， 在1epoch缓存端已经开始缓存数据， 每轮训练的时候将vis的数据打一个标记，置换策略将vis的数据随机置换出去</li>\n<li>下一轮 sampler返回训练的时候将cache中的数据放在前面</li>\n<li>在重要性采样开始前一轮epoch，开始搜集重要性metric设计的分数，如果有io 分数的话，通过profile 的iotime 来对cache time的ssd load time进行估计（求平均值），同时对下一轮样本的iotime进行预测</li>\n<li>将计算出来的重要的样本下一轮训练，不重要的样本序列通过rpc传给存储端的计算单元，让master和worker分别更新重要的样本和不重要样本的分数。</li>\n<li>然后之后在进行采样的使用用全部更新好的重要性分数，重复排序和训练更新步骤</li>\n</ol>\n<p>解决两个bug:</p>\n<ol>\n<li>之所以8a100上面使用分布式调用不起来，是因为我之前在使用torch.distributed.rpc的时候写了os[‘environment’] =hec01  导致分布式错误</li>\n<li>训练精度很低， 修改criterion<br>criterion = nn.CrossEntropyLoss(reduce=False).cuda(args.gpu) hec02实验<br>目前是用这个解决了，但是assert语句显示一致, 不知道原因</li>\n</ol>\n<p>12-27<br>解决cache在mp.spawn 使用多进程训练的时候导致段错误或者信号接收错误<br>选择启动方式：mp.set_start_method(‘spawn’)</p>\n<p>在进行调试的时候，break不应该放在args,rank==0下面，否则就会卡死</p>\n<p>12-28<br>现在的任务就是看rpc是否能和分布式训练的mp.spawn同时存在, 应该主进程主要负责rpc</p>\n<p>ssh需要输入密码的节点为何无法使用rpc进行通信</p>\n<p>12-29<br>今天主要看了legoos这篇论文， 对调度相关的其他论文也进行了总结和分类，以及看了ppt下面的链接有关内容<br>明日安排，做一下最短路径（单源或者多源情况）， 练习今天学到的有关Dijstra, Bellman-Ford算法以及Floyd算法</p>\n<h4 id=\"2022\"><a href=\"#2022\" class=\"headerlink\" title=\"2022\"></a>2022</h4><p>1-3<br>完成&gt;400目标<br>代码主要就是看分布式+rpc是否能够兼容(+cache目前通过mp.spawn解决)并调试通过，实在ddp+rpc无法完成，就只能使用dp+rpc</p>\n<p>1-6 现在遇到的问题：1.有ssh密码登录的机器，使用rpc无法正常运行， 同时rpc在同一台机器好像也无法正常运行</p>\n<p>解决！<br>注意在rpc中发出rpc_async请求的是worker, 接收请求的是master</p>\n<p>hec上使用pytorch 1.8.1只能在没有gpu的节点上，如果在hec01 hec02上就会报错</p>\n<p>现在问题 8a100和hec06节点连接会报错：<br>aster: ECONNREFUSED: connection refused<br>Failed to respond to ‘Shutdown Proceed’ in time, got error ECONNREFUSED: connection refused<br>Traceback (most recent call last):<br>  File “worker.py”, line 88, in <module><br>    rpc.shutdown()<br>  File “/nfs/home/anaconda3/envs/pytorch-shu/lib/python3.6/site-packages/torch/distributed/rpc/api.py”, line 78, in wrapper<br>    return func(*args, **kwargs)<br>  File “/nfs/home/anaconda3/envs/pytorch-shu/lib/python3.6/site-packages/torch/distributed/rpc/api.py”, line 284, in shutdown<br>    _get_current_rpc_agent().join()<br>RuntimeError: [/opt/conda/conda-bld/pytorch_1607370193460/work/third_party/gloo/gloo/transport/tcp/pair.cc:575] Connection closed by peer [10.5.30.42]:27806</module></p>\n<p>Solution: Edit /etc/hosts and change 127.0.1.1 to your actual ip-address 目前看到的一个答案<br>分析：现在在hec上互相使用rpc（即使有密码）是可以的，但是在8a100就不行，所以现在怀疑的是需要在host里面添加目录，以及需要在两台机器上换成同一个用户才行<br>第二种解决方案，应该使用tpc的init_method，以及使用gloo后端，但是目前试验过，仍然会报错</p>\n<p>感觉在分布式多台机器上训练也会出现相同的问题</p>\n<p>找到的真正的解决方案：backend=rpc.BackendType.PROCESS_GROUP， 不需要加其他的<br>os.environ[‘TF_SOCKET_IFNAME’] = ‘ens3’ (x)<br>os.environ[‘GLOO_SOCKET_IFNAME’] = ‘ens3’ (x)</p>\n<p>寒假安排：</p>\n<ol>\n<li>leetcode争取上500 可以先将宫水三叶的题刷完，应该都是经典题目</li>\n<li>对之前写的leetcode进行总结，整理，转为每个知识点，先放总结的思路，或者针对的题型，然后放相应的例题，没道例题简答写一下解决方案，和总结的思路进行对应</li>\n<li>回归操作系统，计网的基础知识, 转为笔试的xmind (408题目看看)<br>github和牛客网应该有许多资源，多看看多比较; 包括深度学习和目标检测相关的面试题目<br>牛客网上， 网友的总结：(CyC2018)<br>[<a href=\"https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E7%9B%AE%E5%BD%95.md]\">https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E7%9B%AE%E5%BD%95.md]</a></li>\n<li>补充面试的xmind</li>\n<li>有时间学一下grpc</li>\n<li>记得备份一下8a100上面的数据 (目前正在8a100使用rsync进行传输 到hec06 /nfs目录下)<br>7。一些公司名单和深度学习的资料<br><a href=\"https://github.com/amusi/CV-Company-List\">https://github.com/amusi/CV-Company-List</a><br>注意关注一下春招信息，微软已经开始投递了，然后我因为错过了问卷，错过了提前批，之后注意准备面试和之后的问卷</li>\n<li>修改简历，变为项目两个， research两个，将重要性采样自己的工作写上去zzw</li>\n<li>项目一定要非常非常熟悉，整理面试可能问到的每一个问题，和自己优化的思考！！！</li>\n</ol>\n<p>刷完八股之后，进行自测：<a href=\"https://github.com/youngyangyang04/TechCPP\">https://github.com/youngyangyang04/TechCPP</a><br><a href=\"https://github.com/youngyangyang04/leetcode-master\">https://github.com/youngyangyang04/leetcode-master</a></p>\n<p>有关于C++的八股文：<a href=\"https://github.com/Light-City/CPlusPlusThings\">https://github.com/Light-City/CPlusPlusThings</a></p>\n<p>408资料<br><a href=\"https://github.com/CodePanda66/CSPostgraduate-408\">https://github.com/CodePanda66/CSPostgraduate-408</a><br>408历年真题大题查看</p>\n<p>公司：思科，</p>\n<p>别人的面经总结：<br><a href=\"https://prohuper.github.io/2020/04/17/interview_exp2/\">https://prohuper.github.io/2020/04/17/interview_exp2/</a></p>\n<p>推荐资料:<br>力扣1-300题（前300道题非常经典，建议学有余力的同学都刷一刷）<br>力扣HOT100（跟上面有不少是重复的，刷的时候要注意总结）<br>啊哈！算法、大话数据结构（这两本书都是面向新手的图书，图画很多）<br>剑指offer（这本书不需要多做介绍，校招必备）<br>挑战程序设计竞赛（这本书属于进阶一点的算法书籍了，作者是ACM-ICPC全球总冠军，可以说是<br>世界顶级程序设计高手的经验总结了，需要慢慢消化，经典题型太多）<br>程序员代码面试指南（左程云大神的书，我并没有看完，只是看了其中的海量数据处理部分的题<br>目就已经十分受用了，在某大厂三面中就考查到了其中的海量数据集处理的问题）</p>\n<p>按公司分题：<a href=\"https://github.com/afatcoder/LeetcodeTop%EF%BC%88%E9%9D%A2%E8%AF%95%E5%89%8D%E5%88%B7%E4%B8%80%E5%88%B7%EF%BC%89\">https://github.com/afatcoder/LeetcodeTop（面试前刷一刷）</a></p>\n<p><a href=\"https://github.com/HarleysZhang/2021_algorithm_intern_information\">https://github.com/HarleysZhang/2021_algorithm_intern_information</a> 计算机视觉-算法岗位相关<br><a href=\"https://github.com/DWCTOD/interview\">https://github.com/DWCTOD/interview</a></p>\n<p>把leetcode的剑指offer开头 和leetcode全部看一篇</p>\n"},{"title":"C#相关","date":"2022-06-13T02:52:09.000Z","_content":"\n\n### 相关资料\n菜鸟教程+ 微软C#官方文档\nhttps://www.runoob.com/csharp/csharp-indexer.html\nhttps://docs.microsoft.com/zh-cn/dotnet/csharp/tour-of-csharp/\n\n### 目前进展\n下次从C# 高级特性开始看","source":"_posts/项目相关/C#.md","raw":"---\ntitle: C#相关\ncategories:\n  - 项目相关\ndate: 2022-06-13 10:52:09\ntags:\n---\n\n\n### 相关资料\n菜鸟教程+ 微软C#官方文档\nhttps://www.runoob.com/csharp/csharp-indexer.html\nhttps://docs.microsoft.com/zh-cn/dotnet/csharp/tour-of-csharp/\n\n### 目前进展\n下次从C# 高级特性开始看","slug":"项目相关/C#","published":1,"updated":"2023-07-12T11:36:14.861Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clk5ceioe002wjpjb2vp60b4c","content":"<h3 id=\"相关资料\"><a href=\"#相关资料\" class=\"headerlink\" title=\"相关资料\"></a>相关资料</h3><p>菜鸟教程+ 微软C#官方文档<br><a href=\"https://www.runoob.com/csharp/csharp-indexer.html\">https://www.runoob.com/csharp/csharp-indexer.html</a><br><a href=\"https://docs.microsoft.com/zh-cn/dotnet/csharp/tour-of-csharp/\">https://docs.microsoft.com/zh-cn/dotnet/csharp/tour-of-csharp/</a></p>\n<h3 id=\"目前进展\"><a href=\"#目前进展\" class=\"headerlink\" title=\"目前进展\"></a>目前进展</h3><p>下次从C# 高级特性开始看</p>\n","site":{"data":{}},"wordcount":144,"excerpt":"","more":"<h3 id=\"相关资料\"><a href=\"#相关资料\" class=\"headerlink\" title=\"相关资料\"></a>相关资料</h3><p>菜鸟教程+ 微软C#官方文档<br><a href=\"https://www.runoob.com/csharp/csharp-indexer.html\">https://www.runoob.com/csharp/csharp-indexer.html</a><br><a href=\"https://docs.microsoft.com/zh-cn/dotnet/csharp/tour-of-csharp/\">https://docs.microsoft.com/zh-cn/dotnet/csharp/tour-of-csharp/</a></p>\n<h3 id=\"目前进展\"><a href=\"#目前进展\" class=\"headerlink\" title=\"目前进展\"></a>目前进展</h3><p>下次从C# 高级特性开始看</p>\n"},{"title":"System Design","date":"2021-11-24T12:40:15.000Z","_content":"\nlintcode\n\n一致性hash 算法\n分布式场景下\n\nGrokking system design 和数据密集型应用系统设计这两份资料。\n时间不够的话优先看 Grokking system design。重点是掌握系统设计题目的回答套路，如何一步一步地展开自己的系统设计思路以及和面试官提哪些问题来确定设计细节。一定要多和面试官沟通，多提问。\n\n真想入门的话去买个aws solutions architect certificate的课程都比这个要靠谱...书籍的话DDIA(design data intensive application)也只是科普，真想稍微深入点的话先推荐两本书：microservices patterns、guide to reliable distributed systems\n\n需要注意的一些点：\n  Ask before design. 问清楚再动手设计，不要一上来就冲着一个巨牛的方案去设计；\n  No more no less. 不要总想着设计最牛的系统，要设计够用的系统；\n  Work solution first. 先设计一个基本能工作的系统，然后再逐步优化；\n  Analysis is important than solution. 系统设计没有标准答案，记住答案是没用的，通过分析过程展示知识储备，权衡各种设计方式的利弊。\n\nhttps://www.pramp.com/#/ 系统设计模拟面试的网站\n\nhttps://www.1point3acres.com/bbs/thread-827136-1-1.html 视频\n\n问问题的顺序：\n1. 需要设计哪些功能（也可以自己想），需要承受多大的访问量？\n2. 将核心功能拆分为细小的服务，并写出接口\n3. 每个服务选择合适的存储结构\n4. 权衡和扩展\n  1）系统的优化，新功能的拓展\n  2）系统的鲁棒性，如果系统奔溃了怎么办，服务请求量暴增怎么办\n\n#### 例题\n  分布式id生成器\n  雪花算法：41时间戳+10为工作id+12为序列号","source":"_posts/项目相关/system design.md","raw":"---\ntitle: System Design\ncategories:\n  - 项目相关\ndate: 2021-11-24 20:40:15\ntags:\n---\n\nlintcode\n\n一致性hash 算法\n分布式场景下\n\nGrokking system design 和数据密集型应用系统设计这两份资料。\n时间不够的话优先看 Grokking system design。重点是掌握系统设计题目的回答套路，如何一步一步地展开自己的系统设计思路以及和面试官提哪些问题来确定设计细节。一定要多和面试官沟通，多提问。\n\n真想入门的话去买个aws solutions architect certificate的课程都比这个要靠谱...书籍的话DDIA(design data intensive application)也只是科普，真想稍微深入点的话先推荐两本书：microservices patterns、guide to reliable distributed systems\n\n需要注意的一些点：\n  Ask before design. 问清楚再动手设计，不要一上来就冲着一个巨牛的方案去设计；\n  No more no less. 不要总想着设计最牛的系统，要设计够用的系统；\n  Work solution first. 先设计一个基本能工作的系统，然后再逐步优化；\n  Analysis is important than solution. 系统设计没有标准答案，记住答案是没用的，通过分析过程展示知识储备，权衡各种设计方式的利弊。\n\nhttps://www.pramp.com/#/ 系统设计模拟面试的网站\n\nhttps://www.1point3acres.com/bbs/thread-827136-1-1.html 视频\n\n问问题的顺序：\n1. 需要设计哪些功能（也可以自己想），需要承受多大的访问量？\n2. 将核心功能拆分为细小的服务，并写出接口\n3. 每个服务选择合适的存储结构\n4. 权衡和扩展\n  1）系统的优化，新功能的拓展\n  2）系统的鲁棒性，如果系统奔溃了怎么办，服务请求量暴增怎么办\n\n#### 例题\n  分布式id生成器\n  雪花算法：41时间戳+10为工作id+12为序列号","slug":"项目相关/system design","published":1,"updated":"2023-07-10T10:36:19.588Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clk5ceioe0030jpjbduom9y41","content":"<p>lintcode</p>\n<p>一致性hash 算法<br>分布式场景下</p>\n<p>Grokking system design 和数据密集型应用系统设计这两份资料。<br>时间不够的话优先看 Grokking system design。重点是掌握系统设计题目的回答套路，如何一步一步地展开自己的系统设计思路以及和面试官提哪些问题来确定设计细节。一定要多和面试官沟通，多提问。</p>\n<p>真想入门的话去买个aws solutions architect certificate的课程都比这个要靠谱…书籍的话DDIA(design data intensive application)也只是科普，真想稍微深入点的话先推荐两本书：microservices patterns、guide to reliable distributed systems</p>\n<p>需要注意的一些点：<br>  Ask before design. 问清楚再动手设计，不要一上来就冲着一个巨牛的方案去设计；<br>  No more no less. 不要总想着设计最牛的系统，要设计够用的系统；<br>  Work solution first. 先设计一个基本能工作的系统，然后再逐步优化；<br>  Analysis is important than solution. 系统设计没有标准答案，记住答案是没用的，通过分析过程展示知识储备，权衡各种设计方式的利弊。</p>\n<p><a href=\"https://www.pramp.com/#/\">https://www.pramp.com/#/</a> 系统设计模拟面试的网站</p>\n<p><a href=\"https://www.1point3acres.com/bbs/thread-827136-1-1.html\">https://www.1point3acres.com/bbs/thread-827136-1-1.html</a> 视频</p>\n<p>问问题的顺序：</p>\n<ol>\n<li>需要设计哪些功能（也可以自己想），需要承受多大的访问量？</li>\n<li>将核心功能拆分为细小的服务，并写出接口</li>\n<li>每个服务选择合适的存储结构</li>\n<li>权衡和扩展<br>1）系统的优化，新功能的拓展<br>2）系统的鲁棒性，如果系统奔溃了怎么办，服务请求量暴增怎么办</li>\n</ol>\n<h4 id=\"例题\"><a href=\"#例题\" class=\"headerlink\" title=\"例题\"></a>例题</h4><p>  分布式id生成器<br>  雪花算法：41时间戳+10为工作id+12为序列号</p>\n","site":{"data":{}},"wordcount":777,"excerpt":"","more":"<p>lintcode</p>\n<p>一致性hash 算法<br>分布式场景下</p>\n<p>Grokking system design 和数据密集型应用系统设计这两份资料。<br>时间不够的话优先看 Grokking system design。重点是掌握系统设计题目的回答套路，如何一步一步地展开自己的系统设计思路以及和面试官提哪些问题来确定设计细节。一定要多和面试官沟通，多提问。</p>\n<p>真想入门的话去买个aws solutions architect certificate的课程都比这个要靠谱…书籍的话DDIA(design data intensive application)也只是科普，真想稍微深入点的话先推荐两本书：microservices patterns、guide to reliable distributed systems</p>\n<p>需要注意的一些点：<br>  Ask before design. 问清楚再动手设计，不要一上来就冲着一个巨牛的方案去设计；<br>  No more no less. 不要总想着设计最牛的系统，要设计够用的系统；<br>  Work solution first. 先设计一个基本能工作的系统，然后再逐步优化；<br>  Analysis is important than solution. 系统设计没有标准答案，记住答案是没用的，通过分析过程展示知识储备，权衡各种设计方式的利弊。</p>\n<p><a href=\"https://www.pramp.com/#/\">https://www.pramp.com/#/</a> 系统设计模拟面试的网站</p>\n<p><a href=\"https://www.1point3acres.com/bbs/thread-827136-1-1.html\">https://www.1point3acres.com/bbs/thread-827136-1-1.html</a> 视频</p>\n<p>问问题的顺序：</p>\n<ol>\n<li>需要设计哪些功能（也可以自己想），需要承受多大的访问量？</li>\n<li>将核心功能拆分为细小的服务，并写出接口</li>\n<li>每个服务选择合适的存储结构</li>\n<li>权衡和扩展<br>1）系统的优化，新功能的拓展<br>2）系统的鲁棒性，如果系统奔溃了怎么办，服务请求量暴增怎么办</li>\n</ol>\n<h4 id=\"例题\"><a href=\"#例题\" class=\"headerlink\" title=\"例题\"></a>例题</h4><p>  分布式id生成器<br>  雪花算法：41时间戳+10为工作id+12为序列号</p>\n"},{"title":"基本神经网络相关问题","date":"2021-11-13T12:11:27.000Z","category":null,"_content":"1. 滤波和传统的图像算法 e.g. SIFT\n\n2. CNN感受野定义以及计算方式\n感受野指的是一个特定的 CNN 特征（特征图上的某个点）在输入空间所受影响的区域。\n感受野的计算是输出图像的反向过程\nout_put=(iput_size-kernel_size)/stride+1\ninput_size=(out_put-1)*stride+kernel_size\n\n\n3. CNN矩阵乘法原理\n参考链接：[卷积计算](https://shuokay.com/2016/06/08/convolution/)\nimg2col将卷积运算转为矩阵乘法\n其中输入的矩阵：行方向对应特征图不同channel同一视野（位置）的向量展开；列方向代表不同的位置；\nkernel的矩阵：行方向代表代表不同的卷积核，列方向代表一个滤波器每个channel的矩阵->向量，\n输出矩阵\n\n4. BatchNormalization与正则化的区别：\n    BatchNormalization主要是用于将神经网络中间输入特征图的均值和方差进行规范化，使输入分布拉到容易激活后面激活层中，解决梯度消失和梯度爆炸问题问题\n    正则化，通常用于机器学习，在损失函数中加上参数的一阶或者二阶和，防止过拟合\n\n\n5. 产生梯度消失或爆炸的原因：\n网络层数太深而引发的梯度反向传播中的连乘效应\n解决梯度消失或者梯度爆炸问题的解决方案：\n   - batch BatchNormalization\n   - 梯度裁剪\n   - 修改激活函数，比如leaky relu\n   - 残差结构\n   - 每层预训练后微调\n\n\n\n6. 机器学习：多分类如何转为多个二分类问题：需要训练N个分类器\n[参考链接](https://yuanxiaosc.github.io/2018/07/01/%E4%BA%8C%E5%88%86%E7%B1%BB%E3%80%81%E5%A4%9A%E5%88%86%E7%B1%BB%E4%B8%8E%E5%A4%9A%E6%A0%87%E7%AD%BE%E9%97%AE%E9%A2%98%E7%9A%84%E5%8C%BA%E5%88%AB%E2%80%94%E2%80%94%E5%AF%B9%E5%BA%94%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E7%9A%84%E9%80%89%E6%8B%A9/)\n将每一次的一个类作为正例，其余作为反例，总共训练N个分类器。测试的时候若仅有一个分类器预测为正的类别则对应的类别标记作为最终分类结果，若有多个分类器预测为正类，则选择置信度最大的类别作为最终分类结果。\nPS:目标检测的多标签二分类损失函数是使用每个标签的概率的求二分损失函数（逻辑损失）然后求平均值得到整体的损失\n其他方案：\n一对一，建立N(N-1)/2个分类器，然后进行投票\n直接用softmax进行多分类任务训练\n\n\n7. 网络退化以及resnet为什么可以解决梯度消失和网络退化问题：\n首先介绍什么是网络退化问题\n举个例子，假设已经有了一个最优化的网络结构，是18层。当我们设计网络结构的时候，我们并不知道具体多少层次的网络时最优化的网络结构，假设设计了34层网络结构。那么多出来的16层其实是冗余的，我们希望训练网络的过程中，模型能够自己将这16层冗余层训练为恒等映射，也就是经过这层时的输入与输出完全一样。\n但是往往模型很难将这16层恒等映射的参数学习正确，那么就不如最优化的18层网络结构的性能，这就是随着网络深度增加，模型会产生退化现象。它不是由过拟合产生的，而是由冗余的网络层学习了不是恒等映射的参数造成的。\n也就是说神经网络学习恒等映射 F(x)=x 的效果不好，但是加上了skip connection 神经网络就用于学习F(x)=0\n\n8. 链式法则：\n原本y对x求偏导，但是由于过程较为复杂，我们引入了一个中间层z，先利用y对z求偏导，在乘上z对x求偏导，这样会使整个计算更为简单。\n当前error对当前层参数的导数，是error对当前输出（输出特征图）的倒数*当前节点的输入（输入特征图）\n\n\n9. 矩阵的反向传播算法/CNN的反向梯度传播算法\n\n\n\n10. 激活函数sigmoid，tanh，relu. 各自的优点和适用场景\n[参考链接]（https://zhuanlan.zhihu.com/p/71882757）\n激活函数的作用：主要是向神经网络中引入非线性的特征\n- sigmoid函数：主要运用在逻辑二分类中，缺点：计算复杂，不是0均值，同时容易出现梯度饱和，当输入是非常大的正值或者负值的时候，反向传播梯度为0；\n- tanh函数：是0均值，但是计算复杂，同时也容易出现梯度饱和问题\n- relu函数：计算简单，在输入大于0的时候不会出现梯度饱和，但是在输入小于0的时候会出现梯度为0，造成死的神经元，因此参数一直得不到更新\n\n\n11. 常见神经网络的结构特点和结构优势\n\n12. 牛顿法和SGD的各自原理，优势，区别\n\n13. LR的梯度反向传播推导\nhttps://blog.csdn.net/ft_sunshine/article/details/105370528\n\n方程：y=theta*x\n激活函数 h(x)-1/(1+e^(-theta x))\n损失函数 loss=1/m*求和(y^ilog(h(x)) - (1-y^i)log(1-h(x))))\n\n","source":"_posts/项目相关/基本神经网络总结.md","raw":"---\ntitle: 基本神经网络相关问题\ncategories:\n  - 项目相关\ndate: 2021-11-13 20:11:27\ncategory:\ntags:\n---\n1. 滤波和传统的图像算法 e.g. SIFT\n\n2. CNN感受野定义以及计算方式\n感受野指的是一个特定的 CNN 特征（特征图上的某个点）在输入空间所受影响的区域。\n感受野的计算是输出图像的反向过程\nout_put=(iput_size-kernel_size)/stride+1\ninput_size=(out_put-1)*stride+kernel_size\n\n\n3. CNN矩阵乘法原理\n参考链接：[卷积计算](https://shuokay.com/2016/06/08/convolution/)\nimg2col将卷积运算转为矩阵乘法\n其中输入的矩阵：行方向对应特征图不同channel同一视野（位置）的向量展开；列方向代表不同的位置；\nkernel的矩阵：行方向代表代表不同的卷积核，列方向代表一个滤波器每个channel的矩阵->向量，\n输出矩阵\n\n4. BatchNormalization与正则化的区别：\n    BatchNormalization主要是用于将神经网络中间输入特征图的均值和方差进行规范化，使输入分布拉到容易激活后面激活层中，解决梯度消失和梯度爆炸问题问题\n    正则化，通常用于机器学习，在损失函数中加上参数的一阶或者二阶和，防止过拟合\n\n\n5. 产生梯度消失或爆炸的原因：\n网络层数太深而引发的梯度反向传播中的连乘效应\n解决梯度消失或者梯度爆炸问题的解决方案：\n   - batch BatchNormalization\n   - 梯度裁剪\n   - 修改激活函数，比如leaky relu\n   - 残差结构\n   - 每层预训练后微调\n\n\n\n6. 机器学习：多分类如何转为多个二分类问题：需要训练N个分类器\n[参考链接](https://yuanxiaosc.github.io/2018/07/01/%E4%BA%8C%E5%88%86%E7%B1%BB%E3%80%81%E5%A4%9A%E5%88%86%E7%B1%BB%E4%B8%8E%E5%A4%9A%E6%A0%87%E7%AD%BE%E9%97%AE%E9%A2%98%E7%9A%84%E5%8C%BA%E5%88%AB%E2%80%94%E2%80%94%E5%AF%B9%E5%BA%94%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E7%9A%84%E9%80%89%E6%8B%A9/)\n将每一次的一个类作为正例，其余作为反例，总共训练N个分类器。测试的时候若仅有一个分类器预测为正的类别则对应的类别标记作为最终分类结果，若有多个分类器预测为正类，则选择置信度最大的类别作为最终分类结果。\nPS:目标检测的多标签二分类损失函数是使用每个标签的概率的求二分损失函数（逻辑损失）然后求平均值得到整体的损失\n其他方案：\n一对一，建立N(N-1)/2个分类器，然后进行投票\n直接用softmax进行多分类任务训练\n\n\n7. 网络退化以及resnet为什么可以解决梯度消失和网络退化问题：\n首先介绍什么是网络退化问题\n举个例子，假设已经有了一个最优化的网络结构，是18层。当我们设计网络结构的时候，我们并不知道具体多少层次的网络时最优化的网络结构，假设设计了34层网络结构。那么多出来的16层其实是冗余的，我们希望训练网络的过程中，模型能够自己将这16层冗余层训练为恒等映射，也就是经过这层时的输入与输出完全一样。\n但是往往模型很难将这16层恒等映射的参数学习正确，那么就不如最优化的18层网络结构的性能，这就是随着网络深度增加，模型会产生退化现象。它不是由过拟合产生的，而是由冗余的网络层学习了不是恒等映射的参数造成的。\n也就是说神经网络学习恒等映射 F(x)=x 的效果不好，但是加上了skip connection 神经网络就用于学习F(x)=0\n\n8. 链式法则：\n原本y对x求偏导，但是由于过程较为复杂，我们引入了一个中间层z，先利用y对z求偏导，在乘上z对x求偏导，这样会使整个计算更为简单。\n当前error对当前层参数的导数，是error对当前输出（输出特征图）的倒数*当前节点的输入（输入特征图）\n\n\n9. 矩阵的反向传播算法/CNN的反向梯度传播算法\n\n\n\n10. 激活函数sigmoid，tanh，relu. 各自的优点和适用场景\n[参考链接]（https://zhuanlan.zhihu.com/p/71882757）\n激活函数的作用：主要是向神经网络中引入非线性的特征\n- sigmoid函数：主要运用在逻辑二分类中，缺点：计算复杂，不是0均值，同时容易出现梯度饱和，当输入是非常大的正值或者负值的时候，反向传播梯度为0；\n- tanh函数：是0均值，但是计算复杂，同时也容易出现梯度饱和问题\n- relu函数：计算简单，在输入大于0的时候不会出现梯度饱和，但是在输入小于0的时候会出现梯度为0，造成死的神经元，因此参数一直得不到更新\n\n\n11. 常见神经网络的结构特点和结构优势\n\n12. 牛顿法和SGD的各自原理，优势，区别\n\n13. LR的梯度反向传播推导\nhttps://blog.csdn.net/ft_sunshine/article/details/105370528\n\n方程：y=theta*x\n激活函数 h(x)-1/(1+e^(-theta x))\n损失函数 loss=1/m*求和(y^ilog(h(x)) - (1-y^i)log(1-h(x))))\n\n","slug":"项目相关/基本神经网络总结","published":1,"updated":"2023-07-10T10:36:19.588Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clk5ceiof0032jpjb3dbuame4","content":"<ol>\n<li><p>滤波和传统的图像算法 e.g. SIFT</p>\n</li>\n<li><p>CNN感受野定义以及计算方式<br>感受野指的是一个特定的 CNN 特征（特征图上的某个点）在输入空间所受影响的区域。<br>感受野的计算是输出图像的反向过程<br>out_put=(iput_size-kernel_size)/stride+1<br>input_size=(out_put-1)*stride+kernel_size</p>\n</li>\n</ol>\n<ol start=\"3\">\n<li><p>CNN矩阵乘法原理<br>参考链接：<a href=\"https://shuokay.com/2016/06/08/convolution/\">卷积计算</a><br>img2col将卷积运算转为矩阵乘法<br>其中输入的矩阵：行方向对应特征图不同channel同一视野（位置）的向量展开；列方向代表不同的位置；<br>kernel的矩阵：行方向代表代表不同的卷积核，列方向代表一个滤波器每个channel的矩阵-&gt;向量，<br>输出矩阵</p>\n</li>\n<li><p>BatchNormalization与正则化的区别：<br> BatchNormalization主要是用于将神经网络中间输入特征图的均值和方差进行规范化，使输入分布拉到容易激活后面激活层中，解决梯度消失和梯度爆炸问题问题<br> 正则化，通常用于机器学习，在损失函数中加上参数的一阶或者二阶和，防止过拟合</p>\n</li>\n</ol>\n<ol start=\"5\">\n<li>产生梯度消失或爆炸的原因：<br>网络层数太深而引发的梯度反向传播中的连乘效应<br>解决梯度消失或者梯度爆炸问题的解决方案：<ul>\n<li>batch BatchNormalization</li>\n<li>梯度裁剪</li>\n<li>修改激活函数，比如leaky relu</li>\n<li>残差结构</li>\n<li>每层预训练后微调</li>\n</ul>\n</li>\n</ol>\n<ol start=\"6\">\n<li>机器学习：多分类如何转为多个二分类问题：需要训练N个分类器<br><a href=\"https://yuanxiaosc.github.io/2018/07/01/%E4%BA%8C%E5%88%86%E7%B1%BB%E3%80%81%E5%A4%9A%E5%88%86%E7%B1%BB%E4%B8%8E%E5%A4%9A%E6%A0%87%E7%AD%BE%E9%97%AE%E9%A2%98%E7%9A%84%E5%8C%BA%E5%88%AB%E2%80%94%E2%80%94%E5%AF%B9%E5%BA%94%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E7%9A%84%E9%80%89%E6%8B%A9/\">参考链接</a><br>将每一次的一个类作为正例，其余作为反例，总共训练N个分类器。测试的时候若仅有一个分类器预测为正的类别则对应的类别标记作为最终分类结果，若有多个分类器预测为正类，则选择置信度最大的类别作为最终分类结果。<br>PS:目标检测的多标签二分类损失函数是使用每个标签的概率的求二分损失函数（逻辑损失）然后求平均值得到整体的损失<br>其他方案：<br>一对一，建立N(N-1)/2个分类器，然后进行投票<br>直接用softmax进行多分类任务训练</li>\n</ol>\n<ol start=\"7\">\n<li><p>网络退化以及resnet为什么可以解决梯度消失和网络退化问题：<br>首先介绍什么是网络退化问题<br>举个例子，假设已经有了一个最优化的网络结构，是18层。当我们设计网络结构的时候，我们并不知道具体多少层次的网络时最优化的网络结构，假设设计了34层网络结构。那么多出来的16层其实是冗余的，我们希望训练网络的过程中，模型能够自己将这16层冗余层训练为恒等映射，也就是经过这层时的输入与输出完全一样。<br>但是往往模型很难将这16层恒等映射的参数学习正确，那么就不如最优化的18层网络结构的性能，这就是随着网络深度增加，模型会产生退化现象。它不是由过拟合产生的，而是由冗余的网络层学习了不是恒等映射的参数造成的。<br>也就是说神经网络学习恒等映射 F(x)=x 的效果不好，但是加上了skip connection 神经网络就用于学习F(x)=0</p>\n</li>\n<li><p>链式法则：<br>原本y对x求偏导，但是由于过程较为复杂，我们引入了一个中间层z，先利用y对z求偏导，在乘上z对x求偏导，这样会使整个计算更为简单。<br>当前error对当前层参数的导数，是error对当前输出（输出特征图）的倒数*当前节点的输入（输入特征图）</p>\n</li>\n</ol>\n<ol start=\"9\">\n<li>矩阵的反向传播算法/CNN的反向梯度传播算法</li>\n</ol>\n<ol start=\"10\">\n<li>激活函数sigmoid，tanh，relu. 各自的优点和适用场景<br>[参考链接]（<a href=\"https://zhuanlan.zhihu.com/p/71882757%EF%BC%89\">https://zhuanlan.zhihu.com/p/71882757）</a><br>激活函数的作用：主要是向神经网络中引入非线性的特征</li>\n</ol>\n<ul>\n<li>sigmoid函数：主要运用在逻辑二分类中，缺点：计算复杂，不是0均值，同时容易出现梯度饱和，当输入是非常大的正值或者负值的时候，反向传播梯度为0；</li>\n<li>tanh函数：是0均值，但是计算复杂，同时也容易出现梯度饱和问题</li>\n<li>relu函数：计算简单，在输入大于0的时候不会出现梯度饱和，但是在输入小于0的时候会出现梯度为0，造成死的神经元，因此参数一直得不到更新</li>\n</ul>\n<ol start=\"11\">\n<li><p>常见神经网络的结构特点和结构优势</p>\n</li>\n<li><p>牛顿法和SGD的各自原理，优势，区别</p>\n</li>\n<li><p>LR的梯度反向传播推导<br><a href=\"https://blog.csdn.net/ft_sunshine/article/details/105370528\">https://blog.csdn.net/ft_sunshine/article/details/105370528</a></p>\n</li>\n</ol>\n<p>方程：y=theta<em>x<br>激活函数 h(x)-1/(1+e^(-theta x))<br>损失函数 loss=1/m</em>求和(y^ilog(h(x)) - (1-y^i)log(1-h(x))))</p>\n","site":{"data":{}},"wordcount":1769,"excerpt":"","more":"<ol>\n<li><p>滤波和传统的图像算法 e.g. SIFT</p>\n</li>\n<li><p>CNN感受野定义以及计算方式<br>感受野指的是一个特定的 CNN 特征（特征图上的某个点）在输入空间所受影响的区域。<br>感受野的计算是输出图像的反向过程<br>out_put=(iput_size-kernel_size)/stride+1<br>input_size=(out_put-1)*stride+kernel_size</p>\n</li>\n</ol>\n<ol start=\"3\">\n<li><p>CNN矩阵乘法原理<br>参考链接：<a href=\"https://shuokay.com/2016/06/08/convolution/\">卷积计算</a><br>img2col将卷积运算转为矩阵乘法<br>其中输入的矩阵：行方向对应特征图不同channel同一视野（位置）的向量展开；列方向代表不同的位置；<br>kernel的矩阵：行方向代表代表不同的卷积核，列方向代表一个滤波器每个channel的矩阵-&gt;向量，<br>输出矩阵</p>\n</li>\n<li><p>BatchNormalization与正则化的区别：<br> BatchNormalization主要是用于将神经网络中间输入特征图的均值和方差进行规范化，使输入分布拉到容易激活后面激活层中，解决梯度消失和梯度爆炸问题问题<br> 正则化，通常用于机器学习，在损失函数中加上参数的一阶或者二阶和，防止过拟合</p>\n</li>\n</ol>\n<ol start=\"5\">\n<li>产生梯度消失或爆炸的原因：<br>网络层数太深而引发的梯度反向传播中的连乘效应<br>解决梯度消失或者梯度爆炸问题的解决方案：<ul>\n<li>batch BatchNormalization</li>\n<li>梯度裁剪</li>\n<li>修改激活函数，比如leaky relu</li>\n<li>残差结构</li>\n<li>每层预训练后微调</li>\n</ul>\n</li>\n</ol>\n<ol start=\"6\">\n<li>机器学习：多分类如何转为多个二分类问题：需要训练N个分类器<br><a href=\"https://yuanxiaosc.github.io/2018/07/01/%E4%BA%8C%E5%88%86%E7%B1%BB%E3%80%81%E5%A4%9A%E5%88%86%E7%B1%BB%E4%B8%8E%E5%A4%9A%E6%A0%87%E7%AD%BE%E9%97%AE%E9%A2%98%E7%9A%84%E5%8C%BA%E5%88%AB%E2%80%94%E2%80%94%E5%AF%B9%E5%BA%94%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E7%9A%84%E9%80%89%E6%8B%A9/\">参考链接</a><br>将每一次的一个类作为正例，其余作为反例，总共训练N个分类器。测试的时候若仅有一个分类器预测为正的类别则对应的类别标记作为最终分类结果，若有多个分类器预测为正类，则选择置信度最大的类别作为最终分类结果。<br>PS:目标检测的多标签二分类损失函数是使用每个标签的概率的求二分损失函数（逻辑损失）然后求平均值得到整体的损失<br>其他方案：<br>一对一，建立N(N-1)/2个分类器，然后进行投票<br>直接用softmax进行多分类任务训练</li>\n</ol>\n<ol start=\"7\">\n<li><p>网络退化以及resnet为什么可以解决梯度消失和网络退化问题：<br>首先介绍什么是网络退化问题<br>举个例子，假设已经有了一个最优化的网络结构，是18层。当我们设计网络结构的时候，我们并不知道具体多少层次的网络时最优化的网络结构，假设设计了34层网络结构。那么多出来的16层其实是冗余的，我们希望训练网络的过程中，模型能够自己将这16层冗余层训练为恒等映射，也就是经过这层时的输入与输出完全一样。<br>但是往往模型很难将这16层恒等映射的参数学习正确，那么就不如最优化的18层网络结构的性能，这就是随着网络深度增加，模型会产生退化现象。它不是由过拟合产生的，而是由冗余的网络层学习了不是恒等映射的参数造成的。<br>也就是说神经网络学习恒等映射 F(x)=x 的效果不好，但是加上了skip connection 神经网络就用于学习F(x)=0</p>\n</li>\n<li><p>链式法则：<br>原本y对x求偏导，但是由于过程较为复杂，我们引入了一个中间层z，先利用y对z求偏导，在乘上z对x求偏导，这样会使整个计算更为简单。<br>当前error对当前层参数的导数，是error对当前输出（输出特征图）的倒数*当前节点的输入（输入特征图）</p>\n</li>\n</ol>\n<ol start=\"9\">\n<li>矩阵的反向传播算法/CNN的反向梯度传播算法</li>\n</ol>\n<ol start=\"10\">\n<li>激活函数sigmoid，tanh，relu. 各自的优点和适用场景<br>[参考链接]（<a href=\"https://zhuanlan.zhihu.com/p/71882757%EF%BC%89\">https://zhuanlan.zhihu.com/p/71882757）</a><br>激活函数的作用：主要是向神经网络中引入非线性的特征</li>\n</ol>\n<ul>\n<li>sigmoid函数：主要运用在逻辑二分类中，缺点：计算复杂，不是0均值，同时容易出现梯度饱和，当输入是非常大的正值或者负值的时候，反向传播梯度为0；</li>\n<li>tanh函数：是0均值，但是计算复杂，同时也容易出现梯度饱和问题</li>\n<li>relu函数：计算简单，在输入大于0的时候不会出现梯度饱和，但是在输入小于0的时候会出现梯度为0，造成死的神经元，因此参数一直得不到更新</li>\n</ul>\n<ol start=\"11\">\n<li><p>常见神经网络的结构特点和结构优势</p>\n</li>\n<li><p>牛顿法和SGD的各自原理，优势，区别</p>\n</li>\n<li><p>LR的梯度反向传播推导<br><a href=\"https://blog.csdn.net/ft_sunshine/article/details/105370528\">https://blog.csdn.net/ft_sunshine/article/details/105370528</a></p>\n</li>\n</ol>\n<p>方程：y=theta<em>x<br>激活函数 h(x)-1/(1+e^(-theta x))<br>损失函数 loss=1/m</em>求和(y^ilog(h(x)) - (1-y^i)log(1-h(x))))</p>\n"},{"title":"机器学习","date":"2021-11-13T12:11:16.000Z","category":null,"_content":"1. xgboost与GDBT的区别\n\nxgboost属于GDBT的工程实现，但是相比于GDBT有更多的优化\n- 1.两者都是属于boosting方法，就是迭代串行求多个模型，每个模型不同权重，训练过程中样本也具有不同的权重\n- 2.GDBT是使用多个决策树组成的，xgboost可以使用线性模型\n- 3.xgboost使用了代价函数的一阶和二阶信息，同时可以用户自定义代价函数，同时xgboost在代价函数中加入了正则项，用于控制模型的复杂度\n- 4.xgboost能够自动对缺失值进行处理\n","source":"_posts/项目相关/机器学习.md","raw":"---\ntitle: 机器学习\ntags: machine learning\ncategories:\n  - 项目相关\ndate: 2021-11-13 20:11:16\ncategory:\n---\n1. xgboost与GDBT的区别\n\nxgboost属于GDBT的工程实现，但是相比于GDBT有更多的优化\n- 1.两者都是属于boosting方法，就是迭代串行求多个模型，每个模型不同权重，训练过程中样本也具有不同的权重\n- 2.GDBT是使用多个决策树组成的，xgboost可以使用线性模型\n- 3.xgboost使用了代价函数的一阶和二阶信息，同时可以用户自定义代价函数，同时xgboost在代价函数中加入了正则项，用于控制模型的复杂度\n- 4.xgboost能够自动对缺失值进行处理\n","slug":"项目相关/机器学习","published":1,"updated":"2021-11-13T12:27:48.243Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clk5ceiog0034jpjb3479alll","content":"<ol>\n<li>xgboost与GDBT的区别</li>\n</ol>\n<p>xgboost属于GDBT的工程实现，但是相比于GDBT有更多的优化</p>\n<ul>\n<li>1.两者都是属于boosting方法，就是迭代串行求多个模型，每个模型不同权重，训练过程中样本也具有不同的权重</li>\n<li>2.GDBT是使用多个决策树组成的，xgboost可以使用线性模型</li>\n<li>3.xgboost使用了代价函数的一阶和二阶信息，同时可以用户自定义代价函数，同时xgboost在代价函数中加入了正则项，用于控制模型的复杂度</li>\n<li>4.xgboost能够自动对缺失值进行处理</li>\n</ul>\n","site":{"data":{}},"wordcount":229,"excerpt":"","more":"<ol>\n<li>xgboost与GDBT的区别</li>\n</ol>\n<p>xgboost属于GDBT的工程实现，但是相比于GDBT有更多的优化</p>\n<ul>\n<li>1.两者都是属于boosting方法，就是迭代串行求多个模型，每个模型不同权重，训练过程中样本也具有不同的权重</li>\n<li>2.GDBT是使用多个决策树组成的，xgboost可以使用线性模型</li>\n<li>3.xgboost使用了代价函数的一阶和二阶信息，同时可以用户自定义代价函数，同时xgboost在代价函数中加入了正则项，用于控制模型的复杂度</li>\n<li>4.xgboost能够自动对缺失值进行处理</li>\n</ul>\n"},{"title":"笔试","date":"2021-11-13T12:10:47.000Z","category":null,"_content":"\n[Awesome algorithm interview](https://github.com/lcylmhlcy/Awesome-algorithm-interview/blob/master/README.md#1-interview-1)\n\n\n\n#### 计算机网络\n\nTCP连接为什么要三次握手，TCP关闭为什么要4次挥手？\n三次握手是为了防止服务器资源的浪费，因为如何是两次的话，如果客户端发送请求连接，但是不发送请求数据，就可能造成服务器端口占用，资源被浪费；四次回收是因为客户端和服务器可以各自关闭，比如客户端告诉服务器FIN，表示自己不发送数据，但是仍然可以接收数据，因此服务器可以继续发送，服务器将数据发送完了之后，再发出关闭信号，因此四次挥手允许客户端和服务器各自分别关闭\n\n\n#### 操作系统\n\n\n\n#### 数据库\n\n\n\n搜索github 上面的面试八股文\n\nhttps://github.com/cosen1024/Java-Interview java面试小抄书\n\nJVM内存结构，什么是hash 冲突，如何解决\n\n语言/数据结构/操作系统/网络/分布式/系统设计\n\n考研408\n\n\n\n\n\n\n","source":"_posts/项目相关/笔试.md","raw":"---\ntitle: 笔试\ntags: 八股文\ncategories:\n  - 项目相关\ndate: 2021-11-13 20:10:47\ncategory:\n---\n\n[Awesome algorithm interview](https://github.com/lcylmhlcy/Awesome-algorithm-interview/blob/master/README.md#1-interview-1)\n\n\n\n#### 计算机网络\n\nTCP连接为什么要三次握手，TCP关闭为什么要4次挥手？\n三次握手是为了防止服务器资源的浪费，因为如何是两次的话，如果客户端发送请求连接，但是不发送请求数据，就可能造成服务器端口占用，资源被浪费；四次回收是因为客户端和服务器可以各自关闭，比如客户端告诉服务器FIN，表示自己不发送数据，但是仍然可以接收数据，因此服务器可以继续发送，服务器将数据发送完了之后，再发出关闭信号，因此四次挥手允许客户端和服务器各自分别关闭\n\n\n#### 操作系统\n\n\n\n#### 数据库\n\n\n\n搜索github 上面的面试八股文\n\nhttps://github.com/cosen1024/Java-Interview java面试小抄书\n\nJVM内存结构，什么是hash 冲突，如何解决\n\n语言/数据结构/操作系统/网络/分布式/系统设计\n\n考研408\n\n\n\n\n\n\n","slug":"项目相关/笔试","published":1,"updated":"2023-07-10T10:36:19.589Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clk5ceioh0037jpjbcq258lmh","content":"<p><a href=\"https://github.com/lcylmhlcy/Awesome-algorithm-interview/blob/master/README.md#1-interview-1\">Awesome algorithm interview</a></p>\n<h4 id=\"计算机网络\"><a href=\"#计算机网络\" class=\"headerlink\" title=\"计算机网络\"></a>计算机网络</h4><p>TCP连接为什么要三次握手，TCP关闭为什么要4次挥手？<br>三次握手是为了防止服务器资源的浪费，因为如何是两次的话，如果客户端发送请求连接，但是不发送请求数据，就可能造成服务器端口占用，资源被浪费；四次回收是因为客户端和服务器可以各自关闭，比如客户端告诉服务器FIN，表示自己不发送数据，但是仍然可以接收数据，因此服务器可以继续发送，服务器将数据发送完了之后，再发出关闭信号，因此四次挥手允许客户端和服务器各自分别关闭</p>\n<h4 id=\"操作系统\"><a href=\"#操作系统\" class=\"headerlink\" title=\"操作系统\"></a>操作系统</h4><h4 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h4><p>搜索github 上面的面试八股文</p>\n<p><a href=\"https://github.com/cosen1024/Java-Interview\">https://github.com/cosen1024/Java-Interview</a> java面试小抄书</p>\n<p>JVM内存结构，什么是hash 冲突，如何解决</p>\n<p>语言/数据结构/操作系统/网络/分布式/系统设计</p>\n<p>考研408</p>\n","site":{"data":{}},"wordcount":363,"excerpt":"","more":"<p><a href=\"https://github.com/lcylmhlcy/Awesome-algorithm-interview/blob/master/README.md#1-interview-1\">Awesome algorithm interview</a></p>\n<h4 id=\"计算机网络\"><a href=\"#计算机网络\" class=\"headerlink\" title=\"计算机网络\"></a>计算机网络</h4><p>TCP连接为什么要三次握手，TCP关闭为什么要4次挥手？<br>三次握手是为了防止服务器资源的浪费，因为如何是两次的话，如果客户端发送请求连接，但是不发送请求数据，就可能造成服务器端口占用，资源被浪费；四次回收是因为客户端和服务器可以各自关闭，比如客户端告诉服务器FIN，表示自己不发送数据，但是仍然可以接收数据，因此服务器可以继续发送，服务器将数据发送完了之后，再发出关闭信号，因此四次挥手允许客户端和服务器各自分别关闭</p>\n<h4 id=\"操作系统\"><a href=\"#操作系统\" class=\"headerlink\" title=\"操作系统\"></a>操作系统</h4><h4 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h4><p>搜索github 上面的面试八股文</p>\n<p><a href=\"https://github.com/cosen1024/Java-Interview\">https://github.com/cosen1024/Java-Interview</a> java面试小抄书</p>\n<p>JVM内存结构，什么是hash 冲突，如何解决</p>\n<p>语言/数据结构/操作系统/网络/分布式/系统设计</p>\n<p>考研408</p>\n"},{"title":"编程语言","date":"2021-11-13T12:11:07.000Z","category":null,"_content":"\n#### python\n1. python GIL介绍\n\n2. list tuple set的区别\n\n\n3. python迭代器和生成器的区别是什么\n生成器本质上还是一个迭代器，也是用在迭代操作中，因此它有和迭代器一样的特性，唯一的区别在于实现方式上不一样，后者更加简洁；\n生成器只是在需要这个值再生成\n\n4. 迭代器\n迭代器对象要求支持迭代器协议的对象。在Python中，支持迭代器协议就是实现对象的__iter__()和next()方法。\n其中__iter__()方法返回迭代器对象本身；next()方法返回容器的下一个元素，在结尾时引发StopIteration异常。\niter是可迭代对象，可迭代对象才能调用next函数\n\n\n5. 生成器\n生成器(generator)就是一个函数，它提供了一种实现迭代器协议的便捷方式。\n生成器与普通函数的区别在于它包含 yield 表达式，并且不需要定义 __iter__()和__next__()。\n\n\n####  C++\n\n\n##### 1.vector\nfind(vector.begin(), vector.end(), target_val)!=vector.end() find函数返回的是一个迭代器\n\nvector.push_back(i)\nvector.pop_back()\n\nvec1.swap(vec2)//进行vector1和vector2的交换\nvec2(vec1.begin(), vec1.begin()+4)表示截取vector的一部分，并赋值给vec2,注意后面的值表示vec不需要 也就是左闭右开模式\n\nvector最后一个元素，vector.back()\n\nvector.insert(vec.begin()+pos, target); // 将target元素插入到pos位置\n\nauto pos=lower_bound(nums.begin(), nums.end(), target)\nindex = pos-nums.begin() //\n<font color=red>lower_bound返回的是大于等于目标函数的数， upper_bound返回的是大于目标函数的数</font>\n\n注意和set的lower_bound不一样的 \nset.lower_bound(targets) 返回一个迭代器\n\nmp的lower_bound也是不一样的\nauto iter = mp.lower_bound(val)\n\nset和map中的元素都是排好序的\n\n\n##### 2.unordered_set my_set\nmy_set.find(target_value)!=my_set.end() or my_set.count(target_value)!=0\nmy_set.insert(value)\nmy_set.erase(value)A\n\nunordered_set查找元素的两种方式：（1）umap.find(target)!=-1  (2) umap[target]\nunordered_set在进行查找的时候可以直接使用unordered_set[target]即使是target不存在也不会报错，\n但是在vector中查找某一个元素就需要vec.find(target)!=vec.end() \n\n##### 3. priority_queue / queue\nq.push()\nq.pop()\n\n##### 4. set insert(value) erase(value) push pop\n遍历 for(auto iter=set.begin(); iter!=set.end(); iter++)\n\n用vector里面的元素初始化set unordered_set<int> nums_set(nums1.begin(), nums1.end());//其中nums1是vector\n\n##### 5.map\n插入元素：map[key]=value; 或者map.insert(make_pair(key, value))\n删除元素：map.erase(key)//注意不是remove\n\n查找元素：map.find(key)\n\n复制：hash.insert(hash1.begin(), hash1.end())\nPS： vector的复制是 vec.assign(vec1.begin(), vec1.end())\n\n##### 6.其他语法\n判断字符是字母：isalpha()\n\n判断字符是数字：isdigit()\n\n判断字符是字母或数字：isalnum()\n\n同时注意c++中，字符用单引号表示，字符串用双引号表示\n\n注意c++中只有数组能够使用memset，在vector中不能使用\n\n##### 7.string \nfind函数 pos=s.find(target)  pos=s.find(target,0)\n如果没有找到返回s.npos 或者string::npos\n\n原地移除数组上的元素，我们说到了数组上的元素，不能真正的删除，只能覆盖。array.erase(i)的时间复杂度是O(n)\n\n\n\n##### 8.set 数组 map的选择\n主要是看数据的范围，如果数据返回不确定那么尽量选择map or set，如果确定是小写字母的话，也就是26个字母，可以使用数组\nset包含 unordered_set（无序， 哈希表，不能重复， 查询和增删效率O(1)）, multiset（有序，红黑树，可以重复 O(nlogn)）, set(有序， 红黑树，不能重复， O(nlong))； map类似\n三种都是只能erase和insert不能修改数值， map不能修改key但是可以修改value\n\n##### 9. stack\n栈的底层实现可以是vector, dequeue, list\n栈只能获取最后一个元素，无法直接获取第一个元素\ntop()\t返回栈顶元素的引用，类型为 T&，如果栈为空，返回值未定义 \npop()\t栈顶元素出栈\nsize()\t返回栈中元素的个数\nempty()\t栈中没有元素时返回 true\nemplace()\t使用传入的参数调用构造函数，在栈顶生成对象\npush(const T& obj)\t将对象副本压入栈顶，通过调用底层容器的 push_back() 函数实现\npush(T&& obj)\t以移动对象的方式将对象压入栈，通过调用底层容器的有右值引用参数的 push_back() 函数实现\nswap(stack<T> & other_stack)\t将当前栈中的元素和参数中的元素交换，参数所包含元素的类型必须和当前栈的相同，对于 stack 对象有一个特例化的全局函数 swap() 可以使用\n\n可以出一道面试题：栈里面的元素在内存中是连续分布的么？\n\n这个问题有两个陷阱：\n陷阱1：栈是容器适配器，底层容器使用不同的容器，导致栈内数据在内存中是不是连续分布。\n陷阱2：缺省情况下，默认底层容器是deque，那么deque的在内存中的数据分布是什么样的呢？答案是：不连续的，下文也会提到deque。\n\n##### 10.queue 队列\n可以访问队列最后一个元素，但是无法pop最后一个元素\nqueue入队，如例：q.push(x); 将x 接到队列的末端。\n\nqueue出队，如例：q.pop(); 弹出队列的第一个元素，注意，并不会返回被弹出元素的值。\n\n访问queue队首元素，如例：q.front()，即最早被压入队列的元素。\n\n访问queue队尾元素，如例：q.back()，即最后被压入队列的元素。\n\n判断queue队列空，如例：q.empty()，当队列空时，返回true。\n\n##### pair\n\npair<int, int> 访问元素不是用下标而是用first second; 创建一个pair用pair<int, int> res = make_pair<a, b>\n或者用括号 pair<int, int> b(1, 2);\n\n##### multiset/set\n两者都是存储的重复的数据，不一样的是前者可以存储冗余的数据\n删除一个数\nc1.erase(c1.find(x))//删除一个x\nc1.erase(x)//删除所有x元素\n\n##### 新建一个未知长度的数组\nint *queue;\nqueue=new int[k+1] 主要是用于类构建动态数组的这种情况\n\n\n#### 向上取整\n(x+(b-1))/b*b\n\n#### malloc和new的区别\n\n![image-20220122202312622](编程语言/image-20220122202312622.png)\n\n#### hashMap原理\n\n\n\n\n\n","source":"_posts/项目相关/编程语言.md","raw":"---\ntitle: 编程语言\ntags: 'python, C++'\ncategories:\n  - 项目相关\ndate: 2021-11-13 20:11:07\ncategory:\n---\n\n#### python\n1. python GIL介绍\n\n2. list tuple set的区别\n\n\n3. python迭代器和生成器的区别是什么\n生成器本质上还是一个迭代器，也是用在迭代操作中，因此它有和迭代器一样的特性，唯一的区别在于实现方式上不一样，后者更加简洁；\n生成器只是在需要这个值再生成\n\n4. 迭代器\n迭代器对象要求支持迭代器协议的对象。在Python中，支持迭代器协议就是实现对象的__iter__()和next()方法。\n其中__iter__()方法返回迭代器对象本身；next()方法返回容器的下一个元素，在结尾时引发StopIteration异常。\niter是可迭代对象，可迭代对象才能调用next函数\n\n\n5. 生成器\n生成器(generator)就是一个函数，它提供了一种实现迭代器协议的便捷方式。\n生成器与普通函数的区别在于它包含 yield 表达式，并且不需要定义 __iter__()和__next__()。\n\n\n####  C++\n\n\n##### 1.vector\nfind(vector.begin(), vector.end(), target_val)!=vector.end() find函数返回的是一个迭代器\n\nvector.push_back(i)\nvector.pop_back()\n\nvec1.swap(vec2)//进行vector1和vector2的交换\nvec2(vec1.begin(), vec1.begin()+4)表示截取vector的一部分，并赋值给vec2,注意后面的值表示vec不需要 也就是左闭右开模式\n\nvector最后一个元素，vector.back()\n\nvector.insert(vec.begin()+pos, target); // 将target元素插入到pos位置\n\nauto pos=lower_bound(nums.begin(), nums.end(), target)\nindex = pos-nums.begin() //\n<font color=red>lower_bound返回的是大于等于目标函数的数， upper_bound返回的是大于目标函数的数</font>\n\n注意和set的lower_bound不一样的 \nset.lower_bound(targets) 返回一个迭代器\n\nmp的lower_bound也是不一样的\nauto iter = mp.lower_bound(val)\n\nset和map中的元素都是排好序的\n\n\n##### 2.unordered_set my_set\nmy_set.find(target_value)!=my_set.end() or my_set.count(target_value)!=0\nmy_set.insert(value)\nmy_set.erase(value)A\n\nunordered_set查找元素的两种方式：（1）umap.find(target)!=-1  (2) umap[target]\nunordered_set在进行查找的时候可以直接使用unordered_set[target]即使是target不存在也不会报错，\n但是在vector中查找某一个元素就需要vec.find(target)!=vec.end() \n\n##### 3. priority_queue / queue\nq.push()\nq.pop()\n\n##### 4. set insert(value) erase(value) push pop\n遍历 for(auto iter=set.begin(); iter!=set.end(); iter++)\n\n用vector里面的元素初始化set unordered_set<int> nums_set(nums1.begin(), nums1.end());//其中nums1是vector\n\n##### 5.map\n插入元素：map[key]=value; 或者map.insert(make_pair(key, value))\n删除元素：map.erase(key)//注意不是remove\n\n查找元素：map.find(key)\n\n复制：hash.insert(hash1.begin(), hash1.end())\nPS： vector的复制是 vec.assign(vec1.begin(), vec1.end())\n\n##### 6.其他语法\n判断字符是字母：isalpha()\n\n判断字符是数字：isdigit()\n\n判断字符是字母或数字：isalnum()\n\n同时注意c++中，字符用单引号表示，字符串用双引号表示\n\n注意c++中只有数组能够使用memset，在vector中不能使用\n\n##### 7.string \nfind函数 pos=s.find(target)  pos=s.find(target,0)\n如果没有找到返回s.npos 或者string::npos\n\n原地移除数组上的元素，我们说到了数组上的元素，不能真正的删除，只能覆盖。array.erase(i)的时间复杂度是O(n)\n\n\n\n##### 8.set 数组 map的选择\n主要是看数据的范围，如果数据返回不确定那么尽量选择map or set，如果确定是小写字母的话，也就是26个字母，可以使用数组\nset包含 unordered_set（无序， 哈希表，不能重复， 查询和增删效率O(1)）, multiset（有序，红黑树，可以重复 O(nlogn)）, set(有序， 红黑树，不能重复， O(nlong))； map类似\n三种都是只能erase和insert不能修改数值， map不能修改key但是可以修改value\n\n##### 9. stack\n栈的底层实现可以是vector, dequeue, list\n栈只能获取最后一个元素，无法直接获取第一个元素\ntop()\t返回栈顶元素的引用，类型为 T&，如果栈为空，返回值未定义 \npop()\t栈顶元素出栈\nsize()\t返回栈中元素的个数\nempty()\t栈中没有元素时返回 true\nemplace()\t使用传入的参数调用构造函数，在栈顶生成对象\npush(const T& obj)\t将对象副本压入栈顶，通过调用底层容器的 push_back() 函数实现\npush(T&& obj)\t以移动对象的方式将对象压入栈，通过调用底层容器的有右值引用参数的 push_back() 函数实现\nswap(stack<T> & other_stack)\t将当前栈中的元素和参数中的元素交换，参数所包含元素的类型必须和当前栈的相同，对于 stack 对象有一个特例化的全局函数 swap() 可以使用\n\n可以出一道面试题：栈里面的元素在内存中是连续分布的么？\n\n这个问题有两个陷阱：\n陷阱1：栈是容器适配器，底层容器使用不同的容器，导致栈内数据在内存中是不是连续分布。\n陷阱2：缺省情况下，默认底层容器是deque，那么deque的在内存中的数据分布是什么样的呢？答案是：不连续的，下文也会提到deque。\n\n##### 10.queue 队列\n可以访问队列最后一个元素，但是无法pop最后一个元素\nqueue入队，如例：q.push(x); 将x 接到队列的末端。\n\nqueue出队，如例：q.pop(); 弹出队列的第一个元素，注意，并不会返回被弹出元素的值。\n\n访问queue队首元素，如例：q.front()，即最早被压入队列的元素。\n\n访问queue队尾元素，如例：q.back()，即最后被压入队列的元素。\n\n判断queue队列空，如例：q.empty()，当队列空时，返回true。\n\n##### pair\n\npair<int, int> 访问元素不是用下标而是用first second; 创建一个pair用pair<int, int> res = make_pair<a, b>\n或者用括号 pair<int, int> b(1, 2);\n\n##### multiset/set\n两者都是存储的重复的数据，不一样的是前者可以存储冗余的数据\n删除一个数\nc1.erase(c1.find(x))//删除一个x\nc1.erase(x)//删除所有x元素\n\n##### 新建一个未知长度的数组\nint *queue;\nqueue=new int[k+1] 主要是用于类构建动态数组的这种情况\n\n\n#### 向上取整\n(x+(b-1))/b*b\n\n#### malloc和new的区别\n\n![image-20220122202312622](编程语言/image-20220122202312622.png)\n\n#### hashMap原理\n\n\n\n\n\n","slug":"项目相关/编程语言","published":1,"updated":"2023-07-10T10:36:19.589Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clk5ceioi0039jpjbff4fhpcp","content":"<h4 id=\"python\"><a href=\"#python\" class=\"headerlink\" title=\"python\"></a>python</h4><ol>\n<li><p>python GIL介绍</p>\n</li>\n<li><p>list tuple set的区别</p>\n</li>\n</ol>\n<ol start=\"3\">\n<li><p>python迭代器和生成器的区别是什么<br>生成器本质上还是一个迭代器，也是用在迭代操作中，因此它有和迭代器一样的特性，唯一的区别在于实现方式上不一样，后者更加简洁；<br>生成器只是在需要这个值再生成</p>\n</li>\n<li><p>迭代器<br>迭代器对象要求支持迭代器协议的对象。在Python中，支持迭代器协议就是实现对象的__iter__()和next()方法。<br>其中__iter__()方法返回迭代器对象本身；next()方法返回容器的下一个元素，在结尾时引发StopIteration异常。<br>iter是可迭代对象，可迭代对象才能调用next函数</p>\n</li>\n</ol>\n<ol start=\"5\">\n<li>生成器<br>生成器(generator)就是一个函数，它提供了一种实现迭代器协议的便捷方式。<br>生成器与普通函数的区别在于它包含 yield 表达式，并且不需要定义 <strong>iter</strong>()和__next__()。</li>\n</ol>\n<h4 id=\"C\"><a href=\"#C\" class=\"headerlink\" title=\"C++\"></a>C++</h4><h5 id=\"1-vector\"><a href=\"#1-vector\" class=\"headerlink\" title=\"1.vector\"></a>1.vector</h5><p>find(vector.begin(), vector.end(), target_val)!=vector.end() find函数返回的是一个迭代器</p>\n<p>vector.push_back(i)<br>vector.pop_back()</p>\n<p>vec1.swap(vec2)//进行vector1和vector2的交换<br>vec2(vec1.begin(), vec1.begin()+4)表示截取vector的一部分，并赋值给vec2,注意后面的值表示vec不需要 也就是左闭右开模式</p>\n<p>vector最后一个元素，vector.back()</p>\n<p>vector.insert(vec.begin()+pos, target); // 将target元素插入到pos位置</p>\n<p>auto pos=lower_bound(nums.begin(), nums.end(), target)<br>index = pos-nums.begin() //<br><font color=\"red\">lower_bound返回的是大于等于目标函数的数， upper_bound返回的是大于目标函数的数</font></p>\n<p>注意和set的lower_bound不一样的<br>set.lower_bound(targets) 返回一个迭代器</p>\n<p>mp的lower_bound也是不一样的<br>auto iter = mp.lower_bound(val)</p>\n<p>set和map中的元素都是排好序的</p>\n<h5 id=\"2-unordered-set-my-set\"><a href=\"#2-unordered-set-my-set\" class=\"headerlink\" title=\"2.unordered_set my_set\"></a>2.unordered_set my_set</h5><p>my_set.find(target_value)!=my_set.end() or my_set.count(target_value)!=0<br>my_set.insert(value)<br>my_set.erase(value)A</p>\n<p>unordered_set查找元素的两种方式：（1）umap.find(target)!=-1  (2) umap[target]<br>unordered_set在进行查找的时候可以直接使用unordered_set[target]即使是target不存在也不会报错，<br>但是在vector中查找某一个元素就需要vec.find(target)!=vec.end() </p>\n<h5 id=\"3-priority-queue-queue\"><a href=\"#3-priority-queue-queue\" class=\"headerlink\" title=\"3. priority_queue / queue\"></a>3. priority_queue / queue</h5><p>q.push()<br>q.pop()</p>\n<h5 id=\"4-set-insert-value-erase-value-push-pop\"><a href=\"#4-set-insert-value-erase-value-push-pop\" class=\"headerlink\" title=\"4. set insert(value) erase(value) push pop\"></a>4. set insert(value) erase(value) push pop</h5><p>遍历 for(auto iter=set.begin(); iter!=set.end(); iter++)</p>\n<p>用vector里面的元素初始化set unordered_set<int> nums_set(nums1.begin(), nums1.end());//其中nums1是vector</int></p>\n<h5 id=\"5-map\"><a href=\"#5-map\" class=\"headerlink\" title=\"5.map\"></a>5.map</h5><p>插入元素：map[key]=value; 或者map.insert(make_pair(key, value))<br>删除元素：map.erase(key)//注意不是remove</p>\n<p>查找元素：map.find(key)</p>\n<p>复制：hash.insert(hash1.begin(), hash1.end())<br>PS： vector的复制是 vec.assign(vec1.begin(), vec1.end())</p>\n<h5 id=\"6-其他语法\"><a href=\"#6-其他语法\" class=\"headerlink\" title=\"6.其他语法\"></a>6.其他语法</h5><p>判断字符是字母：isalpha()</p>\n<p>判断字符是数字：isdigit()</p>\n<p>判断字符是字母或数字：isalnum()</p>\n<p>同时注意c++中，字符用单引号表示，字符串用双引号表示</p>\n<p>注意c++中只有数组能够使用memset，在vector中不能使用</p>\n<h5 id=\"7-string\"><a href=\"#7-string\" class=\"headerlink\" title=\"7.string\"></a>7.string</h5><p>find函数 pos=s.find(target)  pos=s.find(target,0)<br>如果没有找到返回s.npos 或者string::npos</p>\n<p>原地移除数组上的元素，我们说到了数组上的元素，不能真正的删除，只能覆盖。array.erase(i)的时间复杂度是O(n)</p>\n<h5 id=\"8-set-数组-map的选择\"><a href=\"#8-set-数组-map的选择\" class=\"headerlink\" title=\"8.set 数组 map的选择\"></a>8.set 数组 map的选择</h5><p>主要是看数据的范围，如果数据返回不确定那么尽量选择map or set，如果确定是小写字母的话，也就是26个字母，可以使用数组<br>set包含 unordered_set（无序， 哈希表，不能重复， 查询和增删效率O(1)）, multiset（有序，红黑树，可以重复 O(nlogn)）, set(有序， 红黑树，不能重复， O(nlong))； map类似<br>三种都是只能erase和insert不能修改数值， map不能修改key但是可以修改value</p>\n<h5 id=\"9-stack\"><a href=\"#9-stack\" class=\"headerlink\" title=\"9. stack\"></a>9. stack</h5><p>栈的底层实现可以是vector, dequeue, list<br>栈只能获取最后一个元素，无法直接获取第一个元素<br>top()    返回栈顶元素的引用，类型为 T&amp;，如果栈为空，返回值未定义<br>pop()    栈顶元素出栈<br>size()    返回栈中元素的个数<br>empty()    栈中没有元素时返回 true<br>emplace()    使用传入的参数调用构造函数，在栈顶生成对象<br>push(const T&amp; obj)    将对象副本压入栈顶，通过调用底层容器的 push_back() 函数实现<br>push(T&amp;&amp; obj)    以移动对象的方式将对象压入栈，通过调用底层容器的有右值引用参数的 push_back() 函数实现<br>swap(stack<T> &amp; other_stack)    将当前栈中的元素和参数中的元素交换，参数所包含元素的类型必须和当前栈的相同，对于 stack 对象有一个特例化的全局函数 swap() 可以使用</T></p>\n<p>可以出一道面试题：栈里面的元素在内存中是连续分布的么？</p>\n<p>这个问题有两个陷阱：<br>陷阱1：栈是容器适配器，底层容器使用不同的容器，导致栈内数据在内存中是不是连续分布。<br>陷阱2：缺省情况下，默认底层容器是deque，那么deque的在内存中的数据分布是什么样的呢？答案是：不连续的，下文也会提到deque。</p>\n<h5 id=\"10-queue-队列\"><a href=\"#10-queue-队列\" class=\"headerlink\" title=\"10.queue 队列\"></a>10.queue 队列</h5><p>可以访问队列最后一个元素，但是无法pop最后一个元素<br>queue入队，如例：q.push(x); 将x 接到队列的末端。</p>\n<p>queue出队，如例：q.pop(); 弹出队列的第一个元素，注意，并不会返回被弹出元素的值。</p>\n<p>访问queue队首元素，如例：q.front()，即最早被压入队列的元素。</p>\n<p>访问queue队尾元素，如例：q.back()，即最后被压入队列的元素。</p>\n<p>判断queue队列空，如例：q.empty()，当队列空时，返回true。</p>\n<h5 id=\"pair\"><a href=\"#pair\" class=\"headerlink\" title=\"pair\"></a>pair</h5><p>pair&lt;int, int&gt; 访问元素不是用下标而是用first second; 创建一个pair用pair&lt;int, int&gt; res = make_pair&lt;a, b&gt;<br>或者用括号 pair&lt;int, int&gt; b(1, 2);</p>\n<h5 id=\"multiset-set\"><a href=\"#multiset-set\" class=\"headerlink\" title=\"multiset/set\"></a>multiset/set</h5><p>两者都是存储的重复的数据，不一样的是前者可以存储冗余的数据<br>删除一个数<br>c1.erase(c1.find(x))//删除一个x<br>c1.erase(x)//删除所有x元素</p>\n<h5 id=\"新建一个未知长度的数组\"><a href=\"#新建一个未知长度的数组\" class=\"headerlink\" title=\"新建一个未知长度的数组\"></a>新建一个未知长度的数组</h5><p>int *queue;<br>queue=new int[k+1] 主要是用于类构建动态数组的这种情况</p>\n<h4 id=\"向上取整\"><a href=\"#向上取整\" class=\"headerlink\" title=\"向上取整\"></a>向上取整</h4><p>(x+(b-1))/b*b</p>\n<h4 id=\"malloc和new的区别\"><a href=\"#malloc和new的区别\" class=\"headerlink\" title=\"malloc和new的区别\"></a>malloc和new的区别</h4><p><img src=\"/.com//image-20220122202312622.png\" alt=\"image-20220122202312622\"></p>\n<h4 id=\"hashMap原理\"><a href=\"#hashMap原理\" class=\"headerlink\" title=\"hashMap原理\"></a>hashMap原理</h4>","site":{"data":{}},"wordcount":3206,"excerpt":"","more":"<h4 id=\"python\"><a href=\"#python\" class=\"headerlink\" title=\"python\"></a>python</h4><ol>\n<li><p>python GIL介绍</p>\n</li>\n<li><p>list tuple set的区别</p>\n</li>\n</ol>\n<ol start=\"3\">\n<li><p>python迭代器和生成器的区别是什么<br>生成器本质上还是一个迭代器，也是用在迭代操作中，因此它有和迭代器一样的特性，唯一的区别在于实现方式上不一样，后者更加简洁；<br>生成器只是在需要这个值再生成</p>\n</li>\n<li><p>迭代器<br>迭代器对象要求支持迭代器协议的对象。在Python中，支持迭代器协议就是实现对象的__iter__()和next()方法。<br>其中__iter__()方法返回迭代器对象本身；next()方法返回容器的下一个元素，在结尾时引发StopIteration异常。<br>iter是可迭代对象，可迭代对象才能调用next函数</p>\n</li>\n</ol>\n<ol start=\"5\">\n<li>生成器<br>生成器(generator)就是一个函数，它提供了一种实现迭代器协议的便捷方式。<br>生成器与普通函数的区别在于它包含 yield 表达式，并且不需要定义 <strong>iter</strong>()和__next__()。</li>\n</ol>\n<h4 id=\"C\"><a href=\"#C\" class=\"headerlink\" title=\"C++\"></a>C++</h4><h5 id=\"1-vector\"><a href=\"#1-vector\" class=\"headerlink\" title=\"1.vector\"></a>1.vector</h5><p>find(vector.begin(), vector.end(), target_val)!=vector.end() find函数返回的是一个迭代器</p>\n<p>vector.push_back(i)<br>vector.pop_back()</p>\n<p>vec1.swap(vec2)//进行vector1和vector2的交换<br>vec2(vec1.begin(), vec1.begin()+4)表示截取vector的一部分，并赋值给vec2,注意后面的值表示vec不需要 也就是左闭右开模式</p>\n<p>vector最后一个元素，vector.back()</p>\n<p>vector.insert(vec.begin()+pos, target); // 将target元素插入到pos位置</p>\n<p>auto pos=lower_bound(nums.begin(), nums.end(), target)<br>index = pos-nums.begin() //<br><font color=\"red\">lower_bound返回的是大于等于目标函数的数， upper_bound返回的是大于目标函数的数</font></p>\n<p>注意和set的lower_bound不一样的<br>set.lower_bound(targets) 返回一个迭代器</p>\n<p>mp的lower_bound也是不一样的<br>auto iter = mp.lower_bound(val)</p>\n<p>set和map中的元素都是排好序的</p>\n<h5 id=\"2-unordered-set-my-set\"><a href=\"#2-unordered-set-my-set\" class=\"headerlink\" title=\"2.unordered_set my_set\"></a>2.unordered_set my_set</h5><p>my_set.find(target_value)!=my_set.end() or my_set.count(target_value)!=0<br>my_set.insert(value)<br>my_set.erase(value)A</p>\n<p>unordered_set查找元素的两种方式：（1）umap.find(target)!=-1  (2) umap[target]<br>unordered_set在进行查找的时候可以直接使用unordered_set[target]即使是target不存在也不会报错，<br>但是在vector中查找某一个元素就需要vec.find(target)!=vec.end() </p>\n<h5 id=\"3-priority-queue-queue\"><a href=\"#3-priority-queue-queue\" class=\"headerlink\" title=\"3. priority_queue / queue\"></a>3. priority_queue / queue</h5><p>q.push()<br>q.pop()</p>\n<h5 id=\"4-set-insert-value-erase-value-push-pop\"><a href=\"#4-set-insert-value-erase-value-push-pop\" class=\"headerlink\" title=\"4. set insert(value) erase(value) push pop\"></a>4. set insert(value) erase(value) push pop</h5><p>遍历 for(auto iter=set.begin(); iter!=set.end(); iter++)</p>\n<p>用vector里面的元素初始化set unordered_set<int> nums_set(nums1.begin(), nums1.end());//其中nums1是vector</int></p>\n<h5 id=\"5-map\"><a href=\"#5-map\" class=\"headerlink\" title=\"5.map\"></a>5.map</h5><p>插入元素：map[key]=value; 或者map.insert(make_pair(key, value))<br>删除元素：map.erase(key)//注意不是remove</p>\n<p>查找元素：map.find(key)</p>\n<p>复制：hash.insert(hash1.begin(), hash1.end())<br>PS： vector的复制是 vec.assign(vec1.begin(), vec1.end())</p>\n<h5 id=\"6-其他语法\"><a href=\"#6-其他语法\" class=\"headerlink\" title=\"6.其他语法\"></a>6.其他语法</h5><p>判断字符是字母：isalpha()</p>\n<p>判断字符是数字：isdigit()</p>\n<p>判断字符是字母或数字：isalnum()</p>\n<p>同时注意c++中，字符用单引号表示，字符串用双引号表示</p>\n<p>注意c++中只有数组能够使用memset，在vector中不能使用</p>\n<h5 id=\"7-string\"><a href=\"#7-string\" class=\"headerlink\" title=\"7.string\"></a>7.string</h5><p>find函数 pos=s.find(target)  pos=s.find(target,0)<br>如果没有找到返回s.npos 或者string::npos</p>\n<p>原地移除数组上的元素，我们说到了数组上的元素，不能真正的删除，只能覆盖。array.erase(i)的时间复杂度是O(n)</p>\n<h5 id=\"8-set-数组-map的选择\"><a href=\"#8-set-数组-map的选择\" class=\"headerlink\" title=\"8.set 数组 map的选择\"></a>8.set 数组 map的选择</h5><p>主要是看数据的范围，如果数据返回不确定那么尽量选择map or set，如果确定是小写字母的话，也就是26个字母，可以使用数组<br>set包含 unordered_set（无序， 哈希表，不能重复， 查询和增删效率O(1)）, multiset（有序，红黑树，可以重复 O(nlogn)）, set(有序， 红黑树，不能重复， O(nlong))； map类似<br>三种都是只能erase和insert不能修改数值， map不能修改key但是可以修改value</p>\n<h5 id=\"9-stack\"><a href=\"#9-stack\" class=\"headerlink\" title=\"9. stack\"></a>9. stack</h5><p>栈的底层实现可以是vector, dequeue, list<br>栈只能获取最后一个元素，无法直接获取第一个元素<br>top()    返回栈顶元素的引用，类型为 T&amp;，如果栈为空，返回值未定义<br>pop()    栈顶元素出栈<br>size()    返回栈中元素的个数<br>empty()    栈中没有元素时返回 true<br>emplace()    使用传入的参数调用构造函数，在栈顶生成对象<br>push(const T&amp; obj)    将对象副本压入栈顶，通过调用底层容器的 push_back() 函数实现<br>push(T&amp;&amp; obj)    以移动对象的方式将对象压入栈，通过调用底层容器的有右值引用参数的 push_back() 函数实现<br>swap(stack<T> &amp; other_stack)    将当前栈中的元素和参数中的元素交换，参数所包含元素的类型必须和当前栈的相同，对于 stack 对象有一个特例化的全局函数 swap() 可以使用</T></p>\n<p>可以出一道面试题：栈里面的元素在内存中是连续分布的么？</p>\n<p>这个问题有两个陷阱：<br>陷阱1：栈是容器适配器，底层容器使用不同的容器，导致栈内数据在内存中是不是连续分布。<br>陷阱2：缺省情况下，默认底层容器是deque，那么deque的在内存中的数据分布是什么样的呢？答案是：不连续的，下文也会提到deque。</p>\n<h5 id=\"10-queue-队列\"><a href=\"#10-queue-队列\" class=\"headerlink\" title=\"10.queue 队列\"></a>10.queue 队列</h5><p>可以访问队列最后一个元素，但是无法pop最后一个元素<br>queue入队，如例：q.push(x); 将x 接到队列的末端。</p>\n<p>queue出队，如例：q.pop(); 弹出队列的第一个元素，注意，并不会返回被弹出元素的值。</p>\n<p>访问queue队首元素，如例：q.front()，即最早被压入队列的元素。</p>\n<p>访问queue队尾元素，如例：q.back()，即最后被压入队列的元素。</p>\n<p>判断queue队列空，如例：q.empty()，当队列空时，返回true。</p>\n<h5 id=\"pair\"><a href=\"#pair\" class=\"headerlink\" title=\"pair\"></a>pair</h5><p>pair&lt;int, int&gt; 访问元素不是用下标而是用first second; 创建一个pair用pair&lt;int, int&gt; res = make_pair&lt;a, b&gt;<br>或者用括号 pair&lt;int, int&gt; b(1, 2);</p>\n<h5 id=\"multiset-set\"><a href=\"#multiset-set\" class=\"headerlink\" title=\"multiset/set\"></a>multiset/set</h5><p>两者都是存储的重复的数据，不一样的是前者可以存储冗余的数据<br>删除一个数<br>c1.erase(c1.find(x))//删除一个x<br>c1.erase(x)//删除所有x元素</p>\n<h5 id=\"新建一个未知长度的数组\"><a href=\"#新建一个未知长度的数组\" class=\"headerlink\" title=\"新建一个未知长度的数组\"></a>新建一个未知长度的数组</h5><p>int *queue;<br>queue=new int[k+1] 主要是用于类构建动态数组的这种情况</p>\n<h4 id=\"向上取整\"><a href=\"#向上取整\" class=\"headerlink\" title=\"向上取整\"></a>向上取整</h4><p>(x+(b-1))/b*b</p>\n<h4 id=\"malloc和new的区别\"><a href=\"#malloc和new的区别\" class=\"headerlink\" title=\"malloc和new的区别\"></a>malloc和new的区别</h4><p><img src=\"/.com//image-20220122202312622.png\" alt=\"image-20220122202312622\"></p>\n<h4 id=\"hashMap原理\"><a href=\"#hashMap原理\" class=\"headerlink\" title=\"hashMap原理\"></a>hashMap原理</h4>"},{"title":"面试","date":"2021-11-13T12:10:52.000Z","category":null,"_content":"\n> 回答问题模板：\na) 我为什么要做这个项目？要达到什么目标？\nb) 学术上，或者工业上 有哪些方法？能达到什么目标？这些方法分别有什么优缺点？\nc) 我为什么要选择这个方法？项目上做了哪些取舍？\nd) 这里面，我做了哪些创新点/亮点？为什么我要做这个创新点？\ne) 最后项目达到了什么样的结果\n\n发现、动机、实践和验证\n\n\n#### 计算机视觉\n对于自己的工作，尤其是准备重点介绍的工作，每一个细节都要很熟悉，要能解释清楚做了什么，为什么这么做，效果怎么样。\n对实习能力有哪些要求：自学能力+基础知识扎实\n每个项目都按照STAR法则（背景-任务-行动-结果）的结构都写下来\n\n如何解决小目标问题：\n使用多尺度或者增大输入的scale(在可以选择的scale范围中选择更大的)，以及focal loss\n\n每次面试都需要串一篇检测模型\n\nRCNN/Fast RCNN/Faster RCNN/Mask RCNN\n\nYolov123\n\n##### 首先介绍自己的工作\n1. 熟悉平台和公司内部算法框架\n2. 熟悉数据，了解训练模型的数据处理流程，包括相关标注文档撰写， 数据发标， review, 完善标注质量评估的相关代码\n3. 多任务分类代码阅读理解\n4. 主要是训练一个目标检测模型\n\n##### 实习/项目遇到的问题，是如何解决的？\n\n> 你其实可以运用STAR的总结回答你的问题，项目背景——遇到啥问题——你怎么做——有什么结果？\n  eg:\n  背景：现在要做一个考勤的功能，统计公司人员的打卡情况。\n  问题：在评审会议中涉及考勤的功能时对于统计与开发有不同意见。\n  怎么做：对两种统计结果、开发难度等维度进行分析，形成分析报告，再下次评审中与开发进行沟通处理。\n  结果：达成一致意见，在会后对自己这件事进行复盘总结方法论，避免下次出现该问题\n\n  实习中遇到的困难，如何解决？\n  最开始遇到的困难：\n  1. 训练模型精度不高。排查查看训练输入数据的格式是否正确。数据格式确认后，分析精度主要是因为一类的精度非常小导致的， 之后分析数据发现主要是1）该类数据量非常少 2) 该类的目标框非常小，之后修改损失为focal loss以及多维度输入的时候，尽量选择比较大的scale范围（rescale的时候增大scale）\n  2. 训练模型主要关注的如何调节参数提升模型的精度，参数搜索空间非常大，如何找到一个合适的调节参数的方向；解决：先询问身边的同事，因为他们比我更有经验，一定知道调节什么参数对模型的精度影响更大；第二个在明确大致的参数调节方向后，自己实践，需要用一个表格记录自己所做的实验，方便之后进行结果对比和进一步修正,最终在crop size mAP大概为92%-93% 在原图mAP 95%.\n\n  研究过程中遇到的困难？\n\n  毕业设计/模型量化和剪枝中遇到的困难？\n  1.使用distiller的库的时候，发现剪枝训练精度最后为0，效果突然变差，解决方案。1）是在github issue/ stack overflow 中查找相关问题的解决方案，没有则进行提问\n  2.实验结果不理想和预期差距大。最开始实验的结构化剪枝精度下降会非常快，查看其它文献，分析差距主要在哪里，然后调整自己的实验，最后解决方案：在论文中加入敏感性分析+同时明白结构化剪枝局限性：主要适用于参数量比较多的网络\n\n  新加坡项目遇到的困难？\n  1.实验结果不理想。分析原因，查找数据/代码是否有问题，调整算法实现\n\n\n\n椒盐噪声，怎么处理？\n椒盐噪声就是根据输入的信噪比参数，随机在图像中加入0和225（黑点和白点）\n\n中值滤波是如何做的？\n\n\n一、目标检测\nsuprevision  解决图像太少的问题，混合公开数据集一起训练\n1.faster-RCNN\nfaster-rcnn的整个从输入到输出的框架流程，然后是rpn的原理，列举一下针对小目标的解决措施，如何解决类内的检测，还有项目中有无其他困难\n如何提高小目标检出率（RPN哪里也可以提升小目标检出率）\n\n\n\n\n2.RNN的损失如何求\n\n3.写IOU函数\n\n4. 在suprevision中的anchor 的anchor.ratio是如何产生的，是根据feature size 还是随机产生的\n\n\n\n做了什么优化使 mAP 提高了2个百分点\n\n##### 现有的一些目标检测的算法优缺点对比\nhttps://zhuanlan.zhihu.com/p/354060133?utm_source=wechat_session&utm_medium=social&utm_oi=1113097318299123712&utm_campaign=shareopn\n\n二、图像分类\nvehicle attributes\n多任务共同学习：\n因为训练数据集相对较小，容易产生过拟合，为了避免这种情况的发生，合并多个数据集。\n\n\n\n三、视频分类\n\n#### 模型压缩\n\n1.常用的模型压缩和量化方法\n\n2.知识蒸馏采用的具体方法如下：\n1、训练复杂的教师模型（teacher model）：先用硬目标（hard target），也就是正常的标签（label）训练大模型。\n2、计算软目标（soft target）：利用训练好的大模型来计算软目标（soft target），也就是大模型“软化后”再经过softmax层的输出。\n3、训练小模型，在小模型的基础上再加一个额外的软目标（soft target）的损失函数，通过比例参数来调节两个损失函数的比重。\n4、预测时，将训练好的小模型来进行实验。\n\n#### 其他问题\n在项目中得到了什么提升/相比于本科，研究生阶段有什么新的收获？\n1.代码规范与记录，注意细节，代码的可理解性\n2.实践工程能力与计算机思维，手动思维想自动思维的转换，图形界面转为命令行，计算机专业的人主要就是让更多的手动工作变为一键操作\n3.实际场景的数据可能不是像标准训练数据那样 每个类别都非常均衡，因此在实际场景中要注意类别标签不均衡问题\n4.懂得记录 博客/github上代码整理\n5.更加关注底层和原理，以及现有方法为什么这么做，有什么问题，以及如何改进这些问题\n\n\n#### 开放的针对深度学习的理解的题目\n\n给了一个情景，如何训练模型、调优。（题目很空，主要考察你对深度学习的理解）\n根据需求（前向传播时间、模型大小），确定模型和基础网络，跑第一版模型。（举了个栗子）\n判断模型是否出现过拟合的情况，来决定下一步的优化方向。\n结果分析(confusionMatrix等)，分析问题，将论文中的方法套上去，如果没有自己创造。（又举了个栗子）\n\n#### 凸优化了解吗？ 牛顿法、SGD、最小二乘法，各自的优势。\n\n牛客实习生论坛\n\n\n四、 应用开发\n\n遇到的困难：从bomb请求数据的时候，数据还没有请求得到，已经开始执行后面的语句，无法正确获取到最新的数据并显示，后来发现是异步执行流程的原因导致\n\n\n\n#### 推荐系统算法总结\n\nhttps://cloud.tencent.com/developer/article/1614209 ","source":"_posts/项目相关/面试.md","raw":"---\ntitle: 面试\ncategories:\n  - 项目相关\ndate: 2021-11-13 20:10:52\ncategory:\ntags:\n---\n\n> 回答问题模板：\na) 我为什么要做这个项目？要达到什么目标？\nb) 学术上，或者工业上 有哪些方法？能达到什么目标？这些方法分别有什么优缺点？\nc) 我为什么要选择这个方法？项目上做了哪些取舍？\nd) 这里面，我做了哪些创新点/亮点？为什么我要做这个创新点？\ne) 最后项目达到了什么样的结果\n\n发现、动机、实践和验证\n\n\n#### 计算机视觉\n对于自己的工作，尤其是准备重点介绍的工作，每一个细节都要很熟悉，要能解释清楚做了什么，为什么这么做，效果怎么样。\n对实习能力有哪些要求：自学能力+基础知识扎实\n每个项目都按照STAR法则（背景-任务-行动-结果）的结构都写下来\n\n如何解决小目标问题：\n使用多尺度或者增大输入的scale(在可以选择的scale范围中选择更大的)，以及focal loss\n\n每次面试都需要串一篇检测模型\n\nRCNN/Fast RCNN/Faster RCNN/Mask RCNN\n\nYolov123\n\n##### 首先介绍自己的工作\n1. 熟悉平台和公司内部算法框架\n2. 熟悉数据，了解训练模型的数据处理流程，包括相关标注文档撰写， 数据发标， review, 完善标注质量评估的相关代码\n3. 多任务分类代码阅读理解\n4. 主要是训练一个目标检测模型\n\n##### 实习/项目遇到的问题，是如何解决的？\n\n> 你其实可以运用STAR的总结回答你的问题，项目背景——遇到啥问题——你怎么做——有什么结果？\n  eg:\n  背景：现在要做一个考勤的功能，统计公司人员的打卡情况。\n  问题：在评审会议中涉及考勤的功能时对于统计与开发有不同意见。\n  怎么做：对两种统计结果、开发难度等维度进行分析，形成分析报告，再下次评审中与开发进行沟通处理。\n  结果：达成一致意见，在会后对自己这件事进行复盘总结方法论，避免下次出现该问题\n\n  实习中遇到的困难，如何解决？\n  最开始遇到的困难：\n  1. 训练模型精度不高。排查查看训练输入数据的格式是否正确。数据格式确认后，分析精度主要是因为一类的精度非常小导致的， 之后分析数据发现主要是1）该类数据量非常少 2) 该类的目标框非常小，之后修改损失为focal loss以及多维度输入的时候，尽量选择比较大的scale范围（rescale的时候增大scale）\n  2. 训练模型主要关注的如何调节参数提升模型的精度，参数搜索空间非常大，如何找到一个合适的调节参数的方向；解决：先询问身边的同事，因为他们比我更有经验，一定知道调节什么参数对模型的精度影响更大；第二个在明确大致的参数调节方向后，自己实践，需要用一个表格记录自己所做的实验，方便之后进行结果对比和进一步修正,最终在crop size mAP大概为92%-93% 在原图mAP 95%.\n\n  研究过程中遇到的困难？\n\n  毕业设计/模型量化和剪枝中遇到的困难？\n  1.使用distiller的库的时候，发现剪枝训练精度最后为0，效果突然变差，解决方案。1）是在github issue/ stack overflow 中查找相关问题的解决方案，没有则进行提问\n  2.实验结果不理想和预期差距大。最开始实验的结构化剪枝精度下降会非常快，查看其它文献，分析差距主要在哪里，然后调整自己的实验，最后解决方案：在论文中加入敏感性分析+同时明白结构化剪枝局限性：主要适用于参数量比较多的网络\n\n  新加坡项目遇到的困难？\n  1.实验结果不理想。分析原因，查找数据/代码是否有问题，调整算法实现\n\n\n\n椒盐噪声，怎么处理？\n椒盐噪声就是根据输入的信噪比参数，随机在图像中加入0和225（黑点和白点）\n\n中值滤波是如何做的？\n\n\n一、目标检测\nsuprevision  解决图像太少的问题，混合公开数据集一起训练\n1.faster-RCNN\nfaster-rcnn的整个从输入到输出的框架流程，然后是rpn的原理，列举一下针对小目标的解决措施，如何解决类内的检测，还有项目中有无其他困难\n如何提高小目标检出率（RPN哪里也可以提升小目标检出率）\n\n\n\n\n2.RNN的损失如何求\n\n3.写IOU函数\n\n4. 在suprevision中的anchor 的anchor.ratio是如何产生的，是根据feature size 还是随机产生的\n\n\n\n做了什么优化使 mAP 提高了2个百分点\n\n##### 现有的一些目标检测的算法优缺点对比\nhttps://zhuanlan.zhihu.com/p/354060133?utm_source=wechat_session&utm_medium=social&utm_oi=1113097318299123712&utm_campaign=shareopn\n\n二、图像分类\nvehicle attributes\n多任务共同学习：\n因为训练数据集相对较小，容易产生过拟合，为了避免这种情况的发生，合并多个数据集。\n\n\n\n三、视频分类\n\n#### 模型压缩\n\n1.常用的模型压缩和量化方法\n\n2.知识蒸馏采用的具体方法如下：\n1、训练复杂的教师模型（teacher model）：先用硬目标（hard target），也就是正常的标签（label）训练大模型。\n2、计算软目标（soft target）：利用训练好的大模型来计算软目标（soft target），也就是大模型“软化后”再经过softmax层的输出。\n3、训练小模型，在小模型的基础上再加一个额外的软目标（soft target）的损失函数，通过比例参数来调节两个损失函数的比重。\n4、预测时，将训练好的小模型来进行实验。\n\n#### 其他问题\n在项目中得到了什么提升/相比于本科，研究生阶段有什么新的收获？\n1.代码规范与记录，注意细节，代码的可理解性\n2.实践工程能力与计算机思维，手动思维想自动思维的转换，图形界面转为命令行，计算机专业的人主要就是让更多的手动工作变为一键操作\n3.实际场景的数据可能不是像标准训练数据那样 每个类别都非常均衡，因此在实际场景中要注意类别标签不均衡问题\n4.懂得记录 博客/github上代码整理\n5.更加关注底层和原理，以及现有方法为什么这么做，有什么问题，以及如何改进这些问题\n\n\n#### 开放的针对深度学习的理解的题目\n\n给了一个情景，如何训练模型、调优。（题目很空，主要考察你对深度学习的理解）\n根据需求（前向传播时间、模型大小），确定模型和基础网络，跑第一版模型。（举了个栗子）\n判断模型是否出现过拟合的情况，来决定下一步的优化方向。\n结果分析(confusionMatrix等)，分析问题，将论文中的方法套上去，如果没有自己创造。（又举了个栗子）\n\n#### 凸优化了解吗？ 牛顿法、SGD、最小二乘法，各自的优势。\n\n牛客实习生论坛\n\n\n四、 应用开发\n\n遇到的困难：从bomb请求数据的时候，数据还没有请求得到，已经开始执行后面的语句，无法正确获取到最新的数据并显示，后来发现是异步执行流程的原因导致\n\n\n\n#### 推荐系统算法总结\n\nhttps://cloud.tencent.com/developer/article/1614209 ","slug":"项目相关/面试","published":1,"updated":"2021-12-09T11:19:16.315Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clk5ceioj003cjpjb9id00lnp","content":"<blockquote>\n<p>回答问题模板：<br>a) 我为什么要做这个项目？要达到什么目标？<br>b) 学术上，或者工业上 有哪些方法？能达到什么目标？这些方法分别有什么优缺点？<br>c) 我为什么要选择这个方法？项目上做了哪些取舍？<br>d) 这里面，我做了哪些创新点/亮点？为什么我要做这个创新点？<br>e) 最后项目达到了什么样的结果</p>\n</blockquote>\n<p>发现、动机、实践和验证</p>\n<h4 id=\"计算机视觉\"><a href=\"#计算机视觉\" class=\"headerlink\" title=\"计算机视觉\"></a>计算机视觉</h4><p>对于自己的工作，尤其是准备重点介绍的工作，每一个细节都要很熟悉，要能解释清楚做了什么，为什么这么做，效果怎么样。<br>对实习能力有哪些要求：自学能力+基础知识扎实<br>每个项目都按照STAR法则（背景-任务-行动-结果）的结构都写下来</p>\n<p>如何解决小目标问题：<br>使用多尺度或者增大输入的scale(在可以选择的scale范围中选择更大的)，以及focal loss</p>\n<p>每次面试都需要串一篇检测模型</p>\n<p>RCNN/Fast RCNN/Faster RCNN/Mask RCNN</p>\n<p>Yolov123</p>\n<h5 id=\"首先介绍自己的工作\"><a href=\"#首先介绍自己的工作\" class=\"headerlink\" title=\"首先介绍自己的工作\"></a>首先介绍自己的工作</h5><ol>\n<li>熟悉平台和公司内部算法框架</li>\n<li>熟悉数据，了解训练模型的数据处理流程，包括相关标注文档撰写， 数据发标， review, 完善标注质量评估的相关代码</li>\n<li>多任务分类代码阅读理解</li>\n<li>主要是训练一个目标检测模型</li>\n</ol>\n<h5 id=\"实习-项目遇到的问题，是如何解决的？\"><a href=\"#实习-项目遇到的问题，是如何解决的？\" class=\"headerlink\" title=\"实习/项目遇到的问题，是如何解决的？\"></a>实习/项目遇到的问题，是如何解决的？</h5><blockquote>\n<p>你其实可以运用STAR的总结回答你的问题，项目背景——遇到啥问题——你怎么做——有什么结果？<br>  eg:<br>  背景：现在要做一个考勤的功能，统计公司人员的打卡情况。<br>  问题：在评审会议中涉及考勤的功能时对于统计与开发有不同意见。<br>  怎么做：对两种统计结果、开发难度等维度进行分析，形成分析报告，再下次评审中与开发进行沟通处理。<br>  结果：达成一致意见，在会后对自己这件事进行复盘总结方法论，避免下次出现该问题</p>\n</blockquote>\n<p>  实习中遇到的困难，如何解决？<br>  最开始遇到的困难：</p>\n<ol>\n<li>训练模型精度不高。排查查看训练输入数据的格式是否正确。数据格式确认后，分析精度主要是因为一类的精度非常小导致的， 之后分析数据发现主要是1）该类数据量非常少 2) 该类的目标框非常小，之后修改损失为focal loss以及多维度输入的时候，尽量选择比较大的scale范围（rescale的时候增大scale）</li>\n<li>训练模型主要关注的如何调节参数提升模型的精度，参数搜索空间非常大，如何找到一个合适的调节参数的方向；解决：先询问身边的同事，因为他们比我更有经验，一定知道调节什么参数对模型的精度影响更大；第二个在明确大致的参数调节方向后，自己实践，需要用一个表格记录自己所做的实验，方便之后进行结果对比和进一步修正,最终在crop size mAP大概为92%-93% 在原图mAP 95%.</li>\n</ol>\n<p>  研究过程中遇到的困难？</p>\n<p>  毕业设计/模型量化和剪枝中遇到的困难？<br>  1.使用distiller的库的时候，发现剪枝训练精度最后为0，效果突然变差，解决方案。1）是在github issue/ stack overflow 中查找相关问题的解决方案，没有则进行提问<br>  2.实验结果不理想和预期差距大。最开始实验的结构化剪枝精度下降会非常快，查看其它文献，分析差距主要在哪里，然后调整自己的实验，最后解决方案：在论文中加入敏感性分析+同时明白结构化剪枝局限性：主要适用于参数量比较多的网络</p>\n<p>  新加坡项目遇到的困难？<br>  1.实验结果不理想。分析原因，查找数据/代码是否有问题，调整算法实现</p>\n<p>椒盐噪声，怎么处理？<br>椒盐噪声就是根据输入的信噪比参数，随机在图像中加入0和225（黑点和白点）</p>\n<p>中值滤波是如何做的？</p>\n<p>一、目标检测<br>suprevision  解决图像太少的问题，混合公开数据集一起训练<br>1.faster-RCNN<br>faster-rcnn的整个从输入到输出的框架流程，然后是rpn的原理，列举一下针对小目标的解决措施，如何解决类内的检测，还有项目中有无其他困难<br>如何提高小目标检出率（RPN哪里也可以提升小目标检出率）</p>\n<p>2.RNN的损失如何求</p>\n<p>3.写IOU函数</p>\n<ol start=\"4\">\n<li>在suprevision中的anchor 的anchor.ratio是如何产生的，是根据feature size 还是随机产生的</li>\n</ol>\n<p>做了什么优化使 mAP 提高了2个百分点</p>\n<h5 id=\"现有的一些目标检测的算法优缺点对比\"><a href=\"#现有的一些目标检测的算法优缺点对比\" class=\"headerlink\" title=\"现有的一些目标检测的算法优缺点对比\"></a>现有的一些目标检测的算法优缺点对比</h5><p><a href=\"https://zhuanlan.zhihu.com/p/354060133?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=1113097318299123712&amp;utm_campaign=shareopn\">https://zhuanlan.zhihu.com/p/354060133?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=1113097318299123712&amp;utm_campaign=shareopn</a></p>\n<p>二、图像分类<br>vehicle attributes<br>多任务共同学习：<br>因为训练数据集相对较小，容易产生过拟合，为了避免这种情况的发生，合并多个数据集。</p>\n<p>三、视频分类</p>\n<h4 id=\"模型压缩\"><a href=\"#模型压缩\" class=\"headerlink\" title=\"模型压缩\"></a>模型压缩</h4><p>1.常用的模型压缩和量化方法</p>\n<p>2.知识蒸馏采用的具体方法如下：<br>1、训练复杂的教师模型（teacher model）：先用硬目标（hard target），也就是正常的标签（label）训练大模型。<br>2、计算软目标（soft target）：利用训练好的大模型来计算软目标（soft target），也就是大模型“软化后”再经过softmax层的输出。<br>3、训练小模型，在小模型的基础上再加一个额外的软目标（soft target）的损失函数，通过比例参数来调节两个损失函数的比重。<br>4、预测时，将训练好的小模型来进行实验。</p>\n<h4 id=\"其他问题\"><a href=\"#其他问题\" class=\"headerlink\" title=\"其他问题\"></a>其他问题</h4><p>在项目中得到了什么提升/相比于本科，研究生阶段有什么新的收获？<br>1.代码规范与记录，注意细节，代码的可理解性<br>2.实践工程能力与计算机思维，手动思维想自动思维的转换，图形界面转为命令行，计算机专业的人主要就是让更多的手动工作变为一键操作<br>3.实际场景的数据可能不是像标准训练数据那样 每个类别都非常均衡，因此在实际场景中要注意类别标签不均衡问题<br>4.懂得记录 博客/github上代码整理<br>5.更加关注底层和原理，以及现有方法为什么这么做，有什么问题，以及如何改进这些问题</p>\n<h4 id=\"开放的针对深度学习的理解的题目\"><a href=\"#开放的针对深度学习的理解的题目\" class=\"headerlink\" title=\"开放的针对深度学习的理解的题目\"></a>开放的针对深度学习的理解的题目</h4><p>给了一个情景，如何训练模型、调优。（题目很空，主要考察你对深度学习的理解）<br>根据需求（前向传播时间、模型大小），确定模型和基础网络，跑第一版模型。（举了个栗子）<br>判断模型是否出现过拟合的情况，来决定下一步的优化方向。<br>结果分析(confusionMatrix等)，分析问题，将论文中的方法套上去，如果没有自己创造。（又举了个栗子）</p>\n<h4 id=\"凸优化了解吗？-牛顿法、SGD、最小二乘法，各自的优势。\"><a href=\"#凸优化了解吗？-牛顿法、SGD、最小二乘法，各自的优势。\" class=\"headerlink\" title=\"凸优化了解吗？ 牛顿法、SGD、最小二乘法，各自的优势。\"></a>凸优化了解吗？ 牛顿法、SGD、最小二乘法，各自的优势。</h4><p>牛客实习生论坛</p>\n<p>四、 应用开发</p>\n<p>遇到的困难：从bomb请求数据的时候，数据还没有请求得到，已经开始执行后面的语句，无法正确获取到最新的数据并显示，后来发现是异步执行流程的原因导致</p>\n<h4 id=\"推荐系统算法总结\"><a href=\"#推荐系统算法总结\" class=\"headerlink\" title=\"推荐系统算法总结\"></a>推荐系统算法总结</h4><p><a href=\"https://cloud.tencent.com/developer/article/1614209\">https://cloud.tencent.com/developer/article/1614209</a> </p>\n","site":{"data":{}},"wordcount":2702,"excerpt":"","more":"<blockquote>\n<p>回答问题模板：<br>a) 我为什么要做这个项目？要达到什么目标？<br>b) 学术上，或者工业上 有哪些方法？能达到什么目标？这些方法分别有什么优缺点？<br>c) 我为什么要选择这个方法？项目上做了哪些取舍？<br>d) 这里面，我做了哪些创新点/亮点？为什么我要做这个创新点？<br>e) 最后项目达到了什么样的结果</p>\n</blockquote>\n<p>发现、动机、实践和验证</p>\n<h4 id=\"计算机视觉\"><a href=\"#计算机视觉\" class=\"headerlink\" title=\"计算机视觉\"></a>计算机视觉</h4><p>对于自己的工作，尤其是准备重点介绍的工作，每一个细节都要很熟悉，要能解释清楚做了什么，为什么这么做，效果怎么样。<br>对实习能力有哪些要求：自学能力+基础知识扎实<br>每个项目都按照STAR法则（背景-任务-行动-结果）的结构都写下来</p>\n<p>如何解决小目标问题：<br>使用多尺度或者增大输入的scale(在可以选择的scale范围中选择更大的)，以及focal loss</p>\n<p>每次面试都需要串一篇检测模型</p>\n<p>RCNN/Fast RCNN/Faster RCNN/Mask RCNN</p>\n<p>Yolov123</p>\n<h5 id=\"首先介绍自己的工作\"><a href=\"#首先介绍自己的工作\" class=\"headerlink\" title=\"首先介绍自己的工作\"></a>首先介绍自己的工作</h5><ol>\n<li>熟悉平台和公司内部算法框架</li>\n<li>熟悉数据，了解训练模型的数据处理流程，包括相关标注文档撰写， 数据发标， review, 完善标注质量评估的相关代码</li>\n<li>多任务分类代码阅读理解</li>\n<li>主要是训练一个目标检测模型</li>\n</ol>\n<h5 id=\"实习-项目遇到的问题，是如何解决的？\"><a href=\"#实习-项目遇到的问题，是如何解决的？\" class=\"headerlink\" title=\"实习/项目遇到的问题，是如何解决的？\"></a>实习/项目遇到的问题，是如何解决的？</h5><blockquote>\n<p>你其实可以运用STAR的总结回答你的问题，项目背景——遇到啥问题——你怎么做——有什么结果？<br>  eg:<br>  背景：现在要做一个考勤的功能，统计公司人员的打卡情况。<br>  问题：在评审会议中涉及考勤的功能时对于统计与开发有不同意见。<br>  怎么做：对两种统计结果、开发难度等维度进行分析，形成分析报告，再下次评审中与开发进行沟通处理。<br>  结果：达成一致意见，在会后对自己这件事进行复盘总结方法论，避免下次出现该问题</p>\n</blockquote>\n<p>  实习中遇到的困难，如何解决？<br>  最开始遇到的困难：</p>\n<ol>\n<li>训练模型精度不高。排查查看训练输入数据的格式是否正确。数据格式确认后，分析精度主要是因为一类的精度非常小导致的， 之后分析数据发现主要是1）该类数据量非常少 2) 该类的目标框非常小，之后修改损失为focal loss以及多维度输入的时候，尽量选择比较大的scale范围（rescale的时候增大scale）</li>\n<li>训练模型主要关注的如何调节参数提升模型的精度，参数搜索空间非常大，如何找到一个合适的调节参数的方向；解决：先询问身边的同事，因为他们比我更有经验，一定知道调节什么参数对模型的精度影响更大；第二个在明确大致的参数调节方向后，自己实践，需要用一个表格记录自己所做的实验，方便之后进行结果对比和进一步修正,最终在crop size mAP大概为92%-93% 在原图mAP 95%.</li>\n</ol>\n<p>  研究过程中遇到的困难？</p>\n<p>  毕业设计/模型量化和剪枝中遇到的困难？<br>  1.使用distiller的库的时候，发现剪枝训练精度最后为0，效果突然变差，解决方案。1）是在github issue/ stack overflow 中查找相关问题的解决方案，没有则进行提问<br>  2.实验结果不理想和预期差距大。最开始实验的结构化剪枝精度下降会非常快，查看其它文献，分析差距主要在哪里，然后调整自己的实验，最后解决方案：在论文中加入敏感性分析+同时明白结构化剪枝局限性：主要适用于参数量比较多的网络</p>\n<p>  新加坡项目遇到的困难？<br>  1.实验结果不理想。分析原因，查找数据/代码是否有问题，调整算法实现</p>\n<p>椒盐噪声，怎么处理？<br>椒盐噪声就是根据输入的信噪比参数，随机在图像中加入0和225（黑点和白点）</p>\n<p>中值滤波是如何做的？</p>\n<p>一、目标检测<br>suprevision  解决图像太少的问题，混合公开数据集一起训练<br>1.faster-RCNN<br>faster-rcnn的整个从输入到输出的框架流程，然后是rpn的原理，列举一下针对小目标的解决措施，如何解决类内的检测，还有项目中有无其他困难<br>如何提高小目标检出率（RPN哪里也可以提升小目标检出率）</p>\n<p>2.RNN的损失如何求</p>\n<p>3.写IOU函数</p>\n<ol start=\"4\">\n<li>在suprevision中的anchor 的anchor.ratio是如何产生的，是根据feature size 还是随机产生的</li>\n</ol>\n<p>做了什么优化使 mAP 提高了2个百分点</p>\n<h5 id=\"现有的一些目标检测的算法优缺点对比\"><a href=\"#现有的一些目标检测的算法优缺点对比\" class=\"headerlink\" title=\"现有的一些目标检测的算法优缺点对比\"></a>现有的一些目标检测的算法优缺点对比</h5><p><a href=\"https://zhuanlan.zhihu.com/p/354060133?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=1113097318299123712&amp;utm_campaign=shareopn\">https://zhuanlan.zhihu.com/p/354060133?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=1113097318299123712&amp;utm_campaign=shareopn</a></p>\n<p>二、图像分类<br>vehicle attributes<br>多任务共同学习：<br>因为训练数据集相对较小，容易产生过拟合，为了避免这种情况的发生，合并多个数据集。</p>\n<p>三、视频分类</p>\n<h4 id=\"模型压缩\"><a href=\"#模型压缩\" class=\"headerlink\" title=\"模型压缩\"></a>模型压缩</h4><p>1.常用的模型压缩和量化方法</p>\n<p>2.知识蒸馏采用的具体方法如下：<br>1、训练复杂的教师模型（teacher model）：先用硬目标（hard target），也就是正常的标签（label）训练大模型。<br>2、计算软目标（soft target）：利用训练好的大模型来计算软目标（soft target），也就是大模型“软化后”再经过softmax层的输出。<br>3、训练小模型，在小模型的基础上再加一个额外的软目标（soft target）的损失函数，通过比例参数来调节两个损失函数的比重。<br>4、预测时，将训练好的小模型来进行实验。</p>\n<h4 id=\"其他问题\"><a href=\"#其他问题\" class=\"headerlink\" title=\"其他问题\"></a>其他问题</h4><p>在项目中得到了什么提升/相比于本科，研究生阶段有什么新的收获？<br>1.代码规范与记录，注意细节，代码的可理解性<br>2.实践工程能力与计算机思维，手动思维想自动思维的转换，图形界面转为命令行，计算机专业的人主要就是让更多的手动工作变为一键操作<br>3.实际场景的数据可能不是像标准训练数据那样 每个类别都非常均衡，因此在实际场景中要注意类别标签不均衡问题<br>4.懂得记录 博客/github上代码整理<br>5.更加关注底层和原理，以及现有方法为什么这么做，有什么问题，以及如何改进这些问题</p>\n<h4 id=\"开放的针对深度学习的理解的题目\"><a href=\"#开放的针对深度学习的理解的题目\" class=\"headerlink\" title=\"开放的针对深度学习的理解的题目\"></a>开放的针对深度学习的理解的题目</h4><p>给了一个情景，如何训练模型、调优。（题目很空，主要考察你对深度学习的理解）<br>根据需求（前向传播时间、模型大小），确定模型和基础网络，跑第一版模型。（举了个栗子）<br>判断模型是否出现过拟合的情况，来决定下一步的优化方向。<br>结果分析(confusionMatrix等)，分析问题，将论文中的方法套上去，如果没有自己创造。（又举了个栗子）</p>\n<h4 id=\"凸优化了解吗？-牛顿法、SGD、最小二乘法，各自的优势。\"><a href=\"#凸优化了解吗？-牛顿法、SGD、最小二乘法，各自的优势。\" class=\"headerlink\" title=\"凸优化了解吗？ 牛顿法、SGD、最小二乘法，各自的优势。\"></a>凸优化了解吗？ 牛顿法、SGD、最小二乘法，各自的优势。</h4><p>牛客实习生论坛</p>\n<p>四、 应用开发</p>\n<p>遇到的困难：从bomb请求数据的时候，数据还没有请求得到，已经开始执行后面的语句，无法正确获取到最新的数据并显示，后来发现是异步执行流程的原因导致</p>\n<h4 id=\"推荐系统算法总结\"><a href=\"#推荐系统算法总结\" class=\"headerlink\" title=\"推荐系统算法总结\"></a>推荐系统算法总结</h4><p><a href=\"https://cloud.tencent.com/developer/article/1614209\">https://cloud.tencent.com/developer/article/1614209</a> </p>\n"},{"title":"Review Tips","date":"2022-02-23T08:00:36.000Z","_content":"\n\n实习的时候应该怎么做：\n写实习日记(internship log),记录你每天在工作中做了什么、遇到哪些困难、你是如何解决的;还可以写参加了哪些会议，你在会议上跟着大boss学到了什么(行业的观念，企业发展方向);还有自己悟出来的道理，比如做行业research时，从龙头公司入手而不是小虾米公司入手，这样更有效率。\n\n各个案例支持各种结构化面试的答案，比如你如何克服困难。你可以描述实习中你面对大量数据，不会用excel软件整理数据，是如何自学“从入门到精通”的。于是乎简单的学用办公软件的打杂，也变得高端起来。\n\n面试前好好想想你做过什么、写下来。最好回想一下这些事情，带你的师父教给你了什么?你犯了错误是如何改进的?往往你“犯错-被骂-修改”的这个过程，就是你迅速成长的过程。\n\n有一种可能，就是实习真的啥也没做，在办公室呆了两个月!可是真正求职的时候，这两个月的办公室经验也是可以派得上用场的!辣么，如何把你什么都没干的实习，说得收获很大一样呢?\n你可以结合自己的性格，以及在办公室/行业内所学所见，从侧面推荐自己。比如，你做了销售实习，你跟着你的师父去拜访客户，其实也不是你的事情，其实你们根本就吃了闭门羹，啥也没推销出去。可是这个时候，你可以说，你的实习，磨练了你的耐心和耐性、善于沟通、你知道销售工作的礼仪、你勇于尝试去啃难啃的客户和业务。\n\n就是在一项简单的工作中也要有自己的想法和工作的处理方式，或许在整理资料这样的小事中你也有自己的经验，但是没有提炼成方法论。\n\n总结：\n1. 思考小事后面学到的方法，逻辑，展现自己的学习能力和潜力；提炼一套方法论\n2. 将每件小事写出自己学到了什么；将每件做对的事写出自己的之后如何经一部优化；自己做错的事，下次如何避免改进，进步；遇到困难如何解决\n3. 自学linux, 在pytorch官网上进行留言， 在stackoverflow上寻找答案；rpc自学，自学231n；了解了岗位和业务需求，从需求出发\n4. 项目优缺点\n\n项目如何包装：\n\n\n遇到的最大挑战或者困难，令人印象深刻的项目或者工作经历\n建议围绕“背景—我的定位—主要价值—当时挑战和我的解法”的框架展开，\n\n目标检测任务：\n困难：小目标，目标不均衡，漏检问题和精度较低\n最开始学习和了解目标检测的时候，就要完成这个红绿灯交通标志模型的训练。为了完成这样一个任务，我需要快速上手使用公司内部的算法框架训练一个初步模型，同时通过阅读论文和源码了解目标检测模型训练的一些细节\n在这个过程中因为最初上手公司算法框架和学习目标检测的原因，我也遇到了一些困难，比如最开始的模型训练精度非常差，于是我从数据的输入格式进行检验，从验证输入，到调试查看内部的输入输出是否正常，查找错误的原因，最后发现，因为算法框架内部存在一个错误，内部是硬编码的格式输入，使得传入的参数失效，因此输出结果错误；之后了解到主要还是由于公司并没有将数据处理这块代码进行统一规范化，导致不同人维护一个不同的代码repo，我从仓库里面拷贝的版本是已经过时的，因此在训练会出现这样一个错误。\n除此之外，导致模型精度差的原因主要是由于数据中小目标和数据量差距大，有的类别数量本身就非常少，因此拉低整体训练精度，要解决这个问题，我主要是在模型训练方法进行了改进，我了解到多尺度的输入，以及FPN可以很好解决小目标的问题，focal loss可以解决样本不均衡的问题，因此在训练时候选择了多尺度输入方式，带有FPN网络和focal loss的损失函数来解决这些问题。之后精度上升到一个比较满意的阈值，但是还不够好。最后就是在一些参数的设定上进行微调，找到一个最佳的训练参数。这个我主要是通过先抓住影响精度几个重要参数值，然后在这几个参数上进行尝试调整，使用表格记录+控制变量方式搜索。最后达到一个较为满意的结果。但是我觉得在参数搜索这一块我还可以尝试一些自动化搜索的方式进行进一步优化。\n\n\n\n个人研究方向的挑战：\n样本重要性算法部分的设计：1）如何确定样本的动态变化重要性， 设计了一种基于历史值+异步更新的方式计算样本重要性； 2）缓存的设计主要不是我做的，但是主要的思路是小根堆，同时需要周期更新这个堆，因此样本重要性变化，可能会导致建立的堆无效，使用一种COW的思想，在重建堆的时候还是使用之前的重要性来置换，之后建好了再替换；cache size是一个需要在实验中验证的参数\n\n将重要性采样算法引入IO为瓶颈的场景本身就是一个挑战，这主要是因为目前没有相关在重要性采样结合系统架构的研究工作，现在的算法主要还是关注计算减少量上减少。第二个就是样本的重要性本身就是动态变化的，如果要减少IO就只能尽可能少将数据取到内存进行计算，那么如何更新样本的重要性。这个问题第一个初步解决方案就是使用历史的重要性，就是将之前的重要性延迟更新，这样话的可以提前根据样本的重要性确定样本取不取，但是这种方式也是有局限的，也并没有解决本质问题，而且可能引入新的问题就是历史值使用多久，以及历史值的偏差对精度影响。因此我在此基础上进行改进，使用了一个在存储端计算的思想，就是利用在PFS中，利用近存储端的计算资源进行计算，保障了重要性实时性，同时为IO时间的减少提供了机会。当然这种方法，也会引入存储端模型同步和重要性同步的通信时间，但是通过理论实验数据证明，多数情况下这个时间比重复数据的传输时间小，因此是可以接受的。除此之外，为了解决针对IO的重要性算法适应范围窄的问题，我在此基础上设计了一个自适应选择算法框架，就是将现有的算法融合进来，通过profile确定瓶颈，然后选择对应最佳采样策略，使得算法使用更广。\n\n难点：进行缓存设计的时候，如何让多进程访问缓存，以及在分布式场景中如何设计缓存\n使用rpc进行存储和计算端进程之间的通信\n\n\n\n毕业设计的挑战：\n如何判断哪些参数是冗余的，因此可以删除，哪些是重要的，需要被保留。\n保留精度敬克能不受影响，最大化压缩率\ntraining，pruning，fine-tuning三段式\n这个问题我主要是通过阅读大量相关文献，得到确定参数的一种常用方法，就是使用L1-正则，通过实验我认为这种方法是比较有效的，因此选用了这种方式；第二个就是参数删除的比例，这个我主要是通过敏感性分析的方式，通过固定其他层，调整某一层，查看设置不同比例对精度的影响来确定，然后predifined确定剪枝的参数；还有一种是automatic的方式，比如ADC（Automated deep compression）方法，根据不同需求（如保证精度还是限制计算量），利用强化学习来学习每一层最优的sparsity ratio\n\n其他思考：\n在裁剪后加入可以撤回的这个步骤，那么在精度影响较大的时候，仍然可以恢复回来 （mask/可以扩充的剪枝方案）\n自动剪枝，使用强化学习\n将精度、能量消耗和数据一起作为输入，一次裁剪得到多个合适模型\nhttps://cloud.tencent.com/developer/article/1631704 比较全面介绍+未来方向指明（2020）\n\n\n\nNUS项目设计的挑战：\n确定项目选题，也就是挖掘什么的之间关系是比较困难的，因为挖掘的内容一方面需要有心意，那么选择的可能是看似没有什么有关的项目，一方面就是如何天马星空，就可能最后面临失败的结果\n因此选择的项目必须本身要具有研究的意义\n\n\n#### 1. 面试官在每个环节重点关注的点\n问项目：是否真实，表达能力\n要把细节表达清楚，而不是面试官问啥答啥，因为对方不了解这个工作\n日常多看一下工作中的难点与challenges，变为自己的\n\n做算法：\n正确的思路\ncorner case（易错点）的设计情况，要设想各种可能的情况（一面的面试官比较关注corner case，二面面试官和三面面试官都比较时空复杂度）\n    corner case的设计：\n    有重复无重复元素\n    奇数还是偶数\n    是否需要解决输入空格\n    是否需要解决输入有溢出或者最后的结果有溢出\n    是否需要担心输入包括0 或者负数\n    空链表\n    栈是否为空\n    空/非法/正负/溢出\n\n沟通能力：做算法时要多沟通细节，沟通自己不懂的地方\n代码风格\n\n\nhttps://gxin.yuque.com/docs/share/5eb3fa50-61f3-4b41-ad02-8d88ca29a1d1?# 别人的整理，重点！！！！\n\n\n\n为什么想要加入这个公司\n\n\n在面试得时候一定要思路清晰，在没有想清楚之前不要轻易开口\n\n\n\n\n","source":"_posts/项目相关/面试tips.md","raw":"---\ntitle: Review Tips\ntags: review tips\ncategories:\n  - 项目相关\ndate: 2022-02-23 16:00:36\n---\n\n\n实习的时候应该怎么做：\n写实习日记(internship log),记录你每天在工作中做了什么、遇到哪些困难、你是如何解决的;还可以写参加了哪些会议，你在会议上跟着大boss学到了什么(行业的观念，企业发展方向);还有自己悟出来的道理，比如做行业research时，从龙头公司入手而不是小虾米公司入手，这样更有效率。\n\n各个案例支持各种结构化面试的答案，比如你如何克服困难。你可以描述实习中你面对大量数据，不会用excel软件整理数据，是如何自学“从入门到精通”的。于是乎简单的学用办公软件的打杂，也变得高端起来。\n\n面试前好好想想你做过什么、写下来。最好回想一下这些事情，带你的师父教给你了什么?你犯了错误是如何改进的?往往你“犯错-被骂-修改”的这个过程，就是你迅速成长的过程。\n\n有一种可能，就是实习真的啥也没做，在办公室呆了两个月!可是真正求职的时候，这两个月的办公室经验也是可以派得上用场的!辣么，如何把你什么都没干的实习，说得收获很大一样呢?\n你可以结合自己的性格，以及在办公室/行业内所学所见，从侧面推荐自己。比如，你做了销售实习，你跟着你的师父去拜访客户，其实也不是你的事情，其实你们根本就吃了闭门羹，啥也没推销出去。可是这个时候，你可以说，你的实习，磨练了你的耐心和耐性、善于沟通、你知道销售工作的礼仪、你勇于尝试去啃难啃的客户和业务。\n\n就是在一项简单的工作中也要有自己的想法和工作的处理方式，或许在整理资料这样的小事中你也有自己的经验，但是没有提炼成方法论。\n\n总结：\n1. 思考小事后面学到的方法，逻辑，展现自己的学习能力和潜力；提炼一套方法论\n2. 将每件小事写出自己学到了什么；将每件做对的事写出自己的之后如何经一部优化；自己做错的事，下次如何避免改进，进步；遇到困难如何解决\n3. 自学linux, 在pytorch官网上进行留言， 在stackoverflow上寻找答案；rpc自学，自学231n；了解了岗位和业务需求，从需求出发\n4. 项目优缺点\n\n项目如何包装：\n\n\n遇到的最大挑战或者困难，令人印象深刻的项目或者工作经历\n建议围绕“背景—我的定位—主要价值—当时挑战和我的解法”的框架展开，\n\n目标检测任务：\n困难：小目标，目标不均衡，漏检问题和精度较低\n最开始学习和了解目标检测的时候，就要完成这个红绿灯交通标志模型的训练。为了完成这样一个任务，我需要快速上手使用公司内部的算法框架训练一个初步模型，同时通过阅读论文和源码了解目标检测模型训练的一些细节\n在这个过程中因为最初上手公司算法框架和学习目标检测的原因，我也遇到了一些困难，比如最开始的模型训练精度非常差，于是我从数据的输入格式进行检验，从验证输入，到调试查看内部的输入输出是否正常，查找错误的原因，最后发现，因为算法框架内部存在一个错误，内部是硬编码的格式输入，使得传入的参数失效，因此输出结果错误；之后了解到主要还是由于公司并没有将数据处理这块代码进行统一规范化，导致不同人维护一个不同的代码repo，我从仓库里面拷贝的版本是已经过时的，因此在训练会出现这样一个错误。\n除此之外，导致模型精度差的原因主要是由于数据中小目标和数据量差距大，有的类别数量本身就非常少，因此拉低整体训练精度，要解决这个问题，我主要是在模型训练方法进行了改进，我了解到多尺度的输入，以及FPN可以很好解决小目标的问题，focal loss可以解决样本不均衡的问题，因此在训练时候选择了多尺度输入方式，带有FPN网络和focal loss的损失函数来解决这些问题。之后精度上升到一个比较满意的阈值，但是还不够好。最后就是在一些参数的设定上进行微调，找到一个最佳的训练参数。这个我主要是通过先抓住影响精度几个重要参数值，然后在这几个参数上进行尝试调整，使用表格记录+控制变量方式搜索。最后达到一个较为满意的结果。但是我觉得在参数搜索这一块我还可以尝试一些自动化搜索的方式进行进一步优化。\n\n\n\n个人研究方向的挑战：\n样本重要性算法部分的设计：1）如何确定样本的动态变化重要性， 设计了一种基于历史值+异步更新的方式计算样本重要性； 2）缓存的设计主要不是我做的，但是主要的思路是小根堆，同时需要周期更新这个堆，因此样本重要性变化，可能会导致建立的堆无效，使用一种COW的思想，在重建堆的时候还是使用之前的重要性来置换，之后建好了再替换；cache size是一个需要在实验中验证的参数\n\n将重要性采样算法引入IO为瓶颈的场景本身就是一个挑战，这主要是因为目前没有相关在重要性采样结合系统架构的研究工作，现在的算法主要还是关注计算减少量上减少。第二个就是样本的重要性本身就是动态变化的，如果要减少IO就只能尽可能少将数据取到内存进行计算，那么如何更新样本的重要性。这个问题第一个初步解决方案就是使用历史的重要性，就是将之前的重要性延迟更新，这样话的可以提前根据样本的重要性确定样本取不取，但是这种方式也是有局限的，也并没有解决本质问题，而且可能引入新的问题就是历史值使用多久，以及历史值的偏差对精度影响。因此我在此基础上进行改进，使用了一个在存储端计算的思想，就是利用在PFS中，利用近存储端的计算资源进行计算，保障了重要性实时性，同时为IO时间的减少提供了机会。当然这种方法，也会引入存储端模型同步和重要性同步的通信时间，但是通过理论实验数据证明，多数情况下这个时间比重复数据的传输时间小，因此是可以接受的。除此之外，为了解决针对IO的重要性算法适应范围窄的问题，我在此基础上设计了一个自适应选择算法框架，就是将现有的算法融合进来，通过profile确定瓶颈，然后选择对应最佳采样策略，使得算法使用更广。\n\n难点：进行缓存设计的时候，如何让多进程访问缓存，以及在分布式场景中如何设计缓存\n使用rpc进行存储和计算端进程之间的通信\n\n\n\n毕业设计的挑战：\n如何判断哪些参数是冗余的，因此可以删除，哪些是重要的，需要被保留。\n保留精度敬克能不受影响，最大化压缩率\ntraining，pruning，fine-tuning三段式\n这个问题我主要是通过阅读大量相关文献，得到确定参数的一种常用方法，就是使用L1-正则，通过实验我认为这种方法是比较有效的，因此选用了这种方式；第二个就是参数删除的比例，这个我主要是通过敏感性分析的方式，通过固定其他层，调整某一层，查看设置不同比例对精度的影响来确定，然后predifined确定剪枝的参数；还有一种是automatic的方式，比如ADC（Automated deep compression）方法，根据不同需求（如保证精度还是限制计算量），利用强化学习来学习每一层最优的sparsity ratio\n\n其他思考：\n在裁剪后加入可以撤回的这个步骤，那么在精度影响较大的时候，仍然可以恢复回来 （mask/可以扩充的剪枝方案）\n自动剪枝，使用强化学习\n将精度、能量消耗和数据一起作为输入，一次裁剪得到多个合适模型\nhttps://cloud.tencent.com/developer/article/1631704 比较全面介绍+未来方向指明（2020）\n\n\n\nNUS项目设计的挑战：\n确定项目选题，也就是挖掘什么的之间关系是比较困难的，因为挖掘的内容一方面需要有心意，那么选择的可能是看似没有什么有关的项目，一方面就是如何天马星空，就可能最后面临失败的结果\n因此选择的项目必须本身要具有研究的意义\n\n\n#### 1. 面试官在每个环节重点关注的点\n问项目：是否真实，表达能力\n要把细节表达清楚，而不是面试官问啥答啥，因为对方不了解这个工作\n日常多看一下工作中的难点与challenges，变为自己的\n\n做算法：\n正确的思路\ncorner case（易错点）的设计情况，要设想各种可能的情况（一面的面试官比较关注corner case，二面面试官和三面面试官都比较时空复杂度）\n    corner case的设计：\n    有重复无重复元素\n    奇数还是偶数\n    是否需要解决输入空格\n    是否需要解决输入有溢出或者最后的结果有溢出\n    是否需要担心输入包括0 或者负数\n    空链表\n    栈是否为空\n    空/非法/正负/溢出\n\n沟通能力：做算法时要多沟通细节，沟通自己不懂的地方\n代码风格\n\n\nhttps://gxin.yuque.com/docs/share/5eb3fa50-61f3-4b41-ad02-8d88ca29a1d1?# 别人的整理，重点！！！！\n\n\n\n为什么想要加入这个公司\n\n\n在面试得时候一定要思路清晰，在没有想清楚之前不要轻易开口\n\n\n\n\n","slug":"项目相关/面试tips","published":1,"updated":"2022-03-01T05:52:34.744Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clk5ceiok003fjpjb9nkrcfhr","content":"<p>实习的时候应该怎么做：<br>写实习日记(internship log),记录你每天在工作中做了什么、遇到哪些困难、你是如何解决的;还可以写参加了哪些会议，你在会议上跟着大boss学到了什么(行业的观念，企业发展方向);还有自己悟出来的道理，比如做行业research时，从龙头公司入手而不是小虾米公司入手，这样更有效率。</p>\n<p>各个案例支持各种结构化面试的答案，比如你如何克服困难。你可以描述实习中你面对大量数据，不会用excel软件整理数据，是如何自学“从入门到精通”的。于是乎简单的学用办公软件的打杂，也变得高端起来。</p>\n<p>面试前好好想想你做过什么、写下来。最好回想一下这些事情，带你的师父教给你了什么?你犯了错误是如何改进的?往往你“犯错-被骂-修改”的这个过程，就是你迅速成长的过程。</p>\n<p>有一种可能，就是实习真的啥也没做，在办公室呆了两个月!可是真正求职的时候，这两个月的办公室经验也是可以派得上用场的!辣么，如何把你什么都没干的实习，说得收获很大一样呢?<br>你可以结合自己的性格，以及在办公室/行业内所学所见，从侧面推荐自己。比如，你做了销售实习，你跟着你的师父去拜访客户，其实也不是你的事情，其实你们根本就吃了闭门羹，啥也没推销出去。可是这个时候，你可以说，你的实习，磨练了你的耐心和耐性、善于沟通、你知道销售工作的礼仪、你勇于尝试去啃难啃的客户和业务。</p>\n<p>就是在一项简单的工作中也要有自己的想法和工作的处理方式，或许在整理资料这样的小事中你也有自己的经验，但是没有提炼成方法论。</p>\n<p>总结：</p>\n<ol>\n<li>思考小事后面学到的方法，逻辑，展现自己的学习能力和潜力；提炼一套方法论</li>\n<li>将每件小事写出自己学到了什么；将每件做对的事写出自己的之后如何经一部优化；自己做错的事，下次如何避免改进，进步；遇到困难如何解决</li>\n<li>自学linux, 在pytorch官网上进行留言， 在stackoverflow上寻找答案；rpc自学，自学231n；了解了岗位和业务需求，从需求出发</li>\n<li>项目优缺点</li>\n</ol>\n<p>项目如何包装：</p>\n<p>遇到的最大挑战或者困难，令人印象深刻的项目或者工作经历<br>建议围绕“背景—我的定位—主要价值—当时挑战和我的解法”的框架展开，</p>\n<p>目标检测任务：<br>困难：小目标，目标不均衡，漏检问题和精度较低<br>最开始学习和了解目标检测的时候，就要完成这个红绿灯交通标志模型的训练。为了完成这样一个任务，我需要快速上手使用公司内部的算法框架训练一个初步模型，同时通过阅读论文和源码了解目标检测模型训练的一些细节<br>在这个过程中因为最初上手公司算法框架和学习目标检测的原因，我也遇到了一些困难，比如最开始的模型训练精度非常差，于是我从数据的输入格式进行检验，从验证输入，到调试查看内部的输入输出是否正常，查找错误的原因，最后发现，因为算法框架内部存在一个错误，内部是硬编码的格式输入，使得传入的参数失效，因此输出结果错误；之后了解到主要还是由于公司并没有将数据处理这块代码进行统一规范化，导致不同人维护一个不同的代码repo，我从仓库里面拷贝的版本是已经过时的，因此在训练会出现这样一个错误。<br>除此之外，导致模型精度差的原因主要是由于数据中小目标和数据量差距大，有的类别数量本身就非常少，因此拉低整体训练精度，要解决这个问题，我主要是在模型训练方法进行了改进，我了解到多尺度的输入，以及FPN可以很好解决小目标的问题，focal loss可以解决样本不均衡的问题，因此在训练时候选择了多尺度输入方式，带有FPN网络和focal loss的损失函数来解决这些问题。之后精度上升到一个比较满意的阈值，但是还不够好。最后就是在一些参数的设定上进行微调，找到一个最佳的训练参数。这个我主要是通过先抓住影响精度几个重要参数值，然后在这几个参数上进行尝试调整，使用表格记录+控制变量方式搜索。最后达到一个较为满意的结果。但是我觉得在参数搜索这一块我还可以尝试一些自动化搜索的方式进行进一步优化。</p>\n<p>个人研究方向的挑战：<br>样本重要性算法部分的设计：1）如何确定样本的动态变化重要性， 设计了一种基于历史值+异步更新的方式计算样本重要性； 2）缓存的设计主要不是我做的，但是主要的思路是小根堆，同时需要周期更新这个堆，因此样本重要性变化，可能会导致建立的堆无效，使用一种COW的思想，在重建堆的时候还是使用之前的重要性来置换，之后建好了再替换；cache size是一个需要在实验中验证的参数</p>\n<p>将重要性采样算法引入IO为瓶颈的场景本身就是一个挑战，这主要是因为目前没有相关在重要性采样结合系统架构的研究工作，现在的算法主要还是关注计算减少量上减少。第二个就是样本的重要性本身就是动态变化的，如果要减少IO就只能尽可能少将数据取到内存进行计算，那么如何更新样本的重要性。这个问题第一个初步解决方案就是使用历史的重要性，就是将之前的重要性延迟更新，这样话的可以提前根据样本的重要性确定样本取不取，但是这种方式也是有局限的，也并没有解决本质问题，而且可能引入新的问题就是历史值使用多久，以及历史值的偏差对精度影响。因此我在此基础上进行改进，使用了一个在存储端计算的思想，就是利用在PFS中，利用近存储端的计算资源进行计算，保障了重要性实时性，同时为IO时间的减少提供了机会。当然这种方法，也会引入存储端模型同步和重要性同步的通信时间，但是通过理论实验数据证明，多数情况下这个时间比重复数据的传输时间小，因此是可以接受的。除此之外，为了解决针对IO的重要性算法适应范围窄的问题，我在此基础上设计了一个自适应选择算法框架，就是将现有的算法融合进来，通过profile确定瓶颈，然后选择对应最佳采样策略，使得算法使用更广。</p>\n<p>难点：进行缓存设计的时候，如何让多进程访问缓存，以及在分布式场景中如何设计缓存<br>使用rpc进行存储和计算端进程之间的通信</p>\n<p>毕业设计的挑战：<br>如何判断哪些参数是冗余的，因此可以删除，哪些是重要的，需要被保留。<br>保留精度敬克能不受影响，最大化压缩率<br>training，pruning，fine-tuning三段式<br>这个问题我主要是通过阅读大量相关文献，得到确定参数的一种常用方法，就是使用L1-正则，通过实验我认为这种方法是比较有效的，因此选用了这种方式；第二个就是参数删除的比例，这个我主要是通过敏感性分析的方式，通过固定其他层，调整某一层，查看设置不同比例对精度的影响来确定，然后predifined确定剪枝的参数；还有一种是automatic的方式，比如ADC（Automated deep compression）方法，根据不同需求（如保证精度还是限制计算量），利用强化学习来学习每一层最优的sparsity ratio</p>\n<p>其他思考：<br>在裁剪后加入可以撤回的这个步骤，那么在精度影响较大的时候，仍然可以恢复回来 （mask/可以扩充的剪枝方案）<br>自动剪枝，使用强化学习<br>将精度、能量消耗和数据一起作为输入，一次裁剪得到多个合适模型<br><a href=\"https://cloud.tencent.com/developer/article/1631704\">https://cloud.tencent.com/developer/article/1631704</a> 比较全面介绍+未来方向指明（2020）</p>\n<p>NUS项目设计的挑战：<br>确定项目选题，也就是挖掘什么的之间关系是比较困难的，因为挖掘的内容一方面需要有心意，那么选择的可能是看似没有什么有关的项目，一方面就是如何天马星空，就可能最后面临失败的结果<br>因此选择的项目必须本身要具有研究的意义</p>\n<h4 id=\"1-面试官在每个环节重点关注的点\"><a href=\"#1-面试官在每个环节重点关注的点\" class=\"headerlink\" title=\"1. 面试官在每个环节重点关注的点\"></a>1. 面试官在每个环节重点关注的点</h4><p>问项目：是否真实，表达能力<br>要把细节表达清楚，而不是面试官问啥答啥，因为对方不了解这个工作<br>日常多看一下工作中的难点与challenges，变为自己的</p>\n<p>做算法：<br>正确的思路<br>corner case（易错点）的设计情况，要设想各种可能的情况（一面的面试官比较关注corner case，二面面试官和三面面试官都比较时空复杂度）<br>    corner case的设计：<br>    有重复无重复元素<br>    奇数还是偶数<br>    是否需要解决输入空格<br>    是否需要解决输入有溢出或者最后的结果有溢出<br>    是否需要担心输入包括0 或者负数<br>    空链表<br>    栈是否为空<br>    空/非法/正负/溢出</p>\n<p>沟通能力：做算法时要多沟通细节，沟通自己不懂的地方<br>代码风格</p>\n<p><a href=\"https://gxin.yuque.com/docs/share/5eb3fa50-61f3-4b41-ad02-8d88ca29a1d1#\">https://gxin.yuque.com/docs/share/5eb3fa50-61f3-4b41-ad02-8d88ca29a1d1?#</a> 别人的整理，重点！！！！</p>\n<p>为什么想要加入这个公司</p>\n<p>在面试得时候一定要思路清晰，在没有想清楚之前不要轻易开口</p>\n","site":{"data":{}},"wordcount":3387,"excerpt":"","more":"<p>实习的时候应该怎么做：<br>写实习日记(internship log),记录你每天在工作中做了什么、遇到哪些困难、你是如何解决的;还可以写参加了哪些会议，你在会议上跟着大boss学到了什么(行业的观念，企业发展方向);还有自己悟出来的道理，比如做行业research时，从龙头公司入手而不是小虾米公司入手，这样更有效率。</p>\n<p>各个案例支持各种结构化面试的答案，比如你如何克服困难。你可以描述实习中你面对大量数据，不会用excel软件整理数据，是如何自学“从入门到精通”的。于是乎简单的学用办公软件的打杂，也变得高端起来。</p>\n<p>面试前好好想想你做过什么、写下来。最好回想一下这些事情，带你的师父教给你了什么?你犯了错误是如何改进的?往往你“犯错-被骂-修改”的这个过程，就是你迅速成长的过程。</p>\n<p>有一种可能，就是实习真的啥也没做，在办公室呆了两个月!可是真正求职的时候，这两个月的办公室经验也是可以派得上用场的!辣么，如何把你什么都没干的实习，说得收获很大一样呢?<br>你可以结合自己的性格，以及在办公室/行业内所学所见，从侧面推荐自己。比如，你做了销售实习，你跟着你的师父去拜访客户，其实也不是你的事情，其实你们根本就吃了闭门羹，啥也没推销出去。可是这个时候，你可以说，你的实习，磨练了你的耐心和耐性、善于沟通、你知道销售工作的礼仪、你勇于尝试去啃难啃的客户和业务。</p>\n<p>就是在一项简单的工作中也要有自己的想法和工作的处理方式，或许在整理资料这样的小事中你也有自己的经验，但是没有提炼成方法论。</p>\n<p>总结：</p>\n<ol>\n<li>思考小事后面学到的方法，逻辑，展现自己的学习能力和潜力；提炼一套方法论</li>\n<li>将每件小事写出自己学到了什么；将每件做对的事写出自己的之后如何经一部优化；自己做错的事，下次如何避免改进，进步；遇到困难如何解决</li>\n<li>自学linux, 在pytorch官网上进行留言， 在stackoverflow上寻找答案；rpc自学，自学231n；了解了岗位和业务需求，从需求出发</li>\n<li>项目优缺点</li>\n</ol>\n<p>项目如何包装：</p>\n<p>遇到的最大挑战或者困难，令人印象深刻的项目或者工作经历<br>建议围绕“背景—我的定位—主要价值—当时挑战和我的解法”的框架展开，</p>\n<p>目标检测任务：<br>困难：小目标，目标不均衡，漏检问题和精度较低<br>最开始学习和了解目标检测的时候，就要完成这个红绿灯交通标志模型的训练。为了完成这样一个任务，我需要快速上手使用公司内部的算法框架训练一个初步模型，同时通过阅读论文和源码了解目标检测模型训练的一些细节<br>在这个过程中因为最初上手公司算法框架和学习目标检测的原因，我也遇到了一些困难，比如最开始的模型训练精度非常差，于是我从数据的输入格式进行检验，从验证输入，到调试查看内部的输入输出是否正常，查找错误的原因，最后发现，因为算法框架内部存在一个错误，内部是硬编码的格式输入，使得传入的参数失效，因此输出结果错误；之后了解到主要还是由于公司并没有将数据处理这块代码进行统一规范化，导致不同人维护一个不同的代码repo，我从仓库里面拷贝的版本是已经过时的，因此在训练会出现这样一个错误。<br>除此之外，导致模型精度差的原因主要是由于数据中小目标和数据量差距大，有的类别数量本身就非常少，因此拉低整体训练精度，要解决这个问题，我主要是在模型训练方法进行了改进，我了解到多尺度的输入，以及FPN可以很好解决小目标的问题，focal loss可以解决样本不均衡的问题，因此在训练时候选择了多尺度输入方式，带有FPN网络和focal loss的损失函数来解决这些问题。之后精度上升到一个比较满意的阈值，但是还不够好。最后就是在一些参数的设定上进行微调，找到一个最佳的训练参数。这个我主要是通过先抓住影响精度几个重要参数值，然后在这几个参数上进行尝试调整，使用表格记录+控制变量方式搜索。最后达到一个较为满意的结果。但是我觉得在参数搜索这一块我还可以尝试一些自动化搜索的方式进行进一步优化。</p>\n<p>个人研究方向的挑战：<br>样本重要性算法部分的设计：1）如何确定样本的动态变化重要性， 设计了一种基于历史值+异步更新的方式计算样本重要性； 2）缓存的设计主要不是我做的，但是主要的思路是小根堆，同时需要周期更新这个堆，因此样本重要性变化，可能会导致建立的堆无效，使用一种COW的思想，在重建堆的时候还是使用之前的重要性来置换，之后建好了再替换；cache size是一个需要在实验中验证的参数</p>\n<p>将重要性采样算法引入IO为瓶颈的场景本身就是一个挑战，这主要是因为目前没有相关在重要性采样结合系统架构的研究工作，现在的算法主要还是关注计算减少量上减少。第二个就是样本的重要性本身就是动态变化的，如果要减少IO就只能尽可能少将数据取到内存进行计算，那么如何更新样本的重要性。这个问题第一个初步解决方案就是使用历史的重要性，就是将之前的重要性延迟更新，这样话的可以提前根据样本的重要性确定样本取不取，但是这种方式也是有局限的，也并没有解决本质问题，而且可能引入新的问题就是历史值使用多久，以及历史值的偏差对精度影响。因此我在此基础上进行改进，使用了一个在存储端计算的思想，就是利用在PFS中，利用近存储端的计算资源进行计算，保障了重要性实时性，同时为IO时间的减少提供了机会。当然这种方法，也会引入存储端模型同步和重要性同步的通信时间，但是通过理论实验数据证明，多数情况下这个时间比重复数据的传输时间小，因此是可以接受的。除此之外，为了解决针对IO的重要性算法适应范围窄的问题，我在此基础上设计了一个自适应选择算法框架，就是将现有的算法融合进来，通过profile确定瓶颈，然后选择对应最佳采样策略，使得算法使用更广。</p>\n<p>难点：进行缓存设计的时候，如何让多进程访问缓存，以及在分布式场景中如何设计缓存<br>使用rpc进行存储和计算端进程之间的通信</p>\n<p>毕业设计的挑战：<br>如何判断哪些参数是冗余的，因此可以删除，哪些是重要的，需要被保留。<br>保留精度敬克能不受影响，最大化压缩率<br>training，pruning，fine-tuning三段式<br>这个问题我主要是通过阅读大量相关文献，得到确定参数的一种常用方法，就是使用L1-正则，通过实验我认为这种方法是比较有效的，因此选用了这种方式；第二个就是参数删除的比例，这个我主要是通过敏感性分析的方式，通过固定其他层，调整某一层，查看设置不同比例对精度的影响来确定，然后predifined确定剪枝的参数；还有一种是automatic的方式，比如ADC（Automated deep compression）方法，根据不同需求（如保证精度还是限制计算量），利用强化学习来学习每一层最优的sparsity ratio</p>\n<p>其他思考：<br>在裁剪后加入可以撤回的这个步骤，那么在精度影响较大的时候，仍然可以恢复回来 （mask/可以扩充的剪枝方案）<br>自动剪枝，使用强化学习<br>将精度、能量消耗和数据一起作为输入，一次裁剪得到多个合适模型<br><a href=\"https://cloud.tencent.com/developer/article/1631704\">https://cloud.tencent.com/developer/article/1631704</a> 比较全面介绍+未来方向指明（2020）</p>\n<p>NUS项目设计的挑战：<br>确定项目选题，也就是挖掘什么的之间关系是比较困难的，因为挖掘的内容一方面需要有心意，那么选择的可能是看似没有什么有关的项目，一方面就是如何天马星空，就可能最后面临失败的结果<br>因此选择的项目必须本身要具有研究的意义</p>\n<h4 id=\"1-面试官在每个环节重点关注的点\"><a href=\"#1-面试官在每个环节重点关注的点\" class=\"headerlink\" title=\"1. 面试官在每个环节重点关注的点\"></a>1. 面试官在每个环节重点关注的点</h4><p>问项目：是否真实，表达能力<br>要把细节表达清楚，而不是面试官问啥答啥，因为对方不了解这个工作<br>日常多看一下工作中的难点与challenges，变为自己的</p>\n<p>做算法：<br>正确的思路<br>corner case（易错点）的设计情况，要设想各种可能的情况（一面的面试官比较关注corner case，二面面试官和三面面试官都比较时空复杂度）<br>    corner case的设计：<br>    有重复无重复元素<br>    奇数还是偶数<br>    是否需要解决输入空格<br>    是否需要解决输入有溢出或者最后的结果有溢出<br>    是否需要担心输入包括0 或者负数<br>    空链表<br>    栈是否为空<br>    空/非法/正负/溢出</p>\n<p>沟通能力：做算法时要多沟通细节，沟通自己不懂的地方<br>代码风格</p>\n<p><a href=\"https://gxin.yuque.com/docs/share/5eb3fa50-61f3-4b41-ad02-8d88ca29a1d1#\">https://gxin.yuque.com/docs/share/5eb3fa50-61f3-4b41-ad02-8d88ca29a1d1?#</a> 别人的整理，重点！！！！</p>\n<p>为什么想要加入这个公司</p>\n<p>在面试得时候一定要思路清晰，在没有想清楚之前不要轻易开口</p>\n"},{"title":"常见模板代码","_content":"\n```C++\n#include<iostream>\n#include<unordered_map>\n#include<vector>\nusing namespace std;\nint main(){\n    cout<<\"hello world\"<<endl;\n    return 0;\n}\n```\n\n处理字符串的输入输出\n","source":"_posts/autumn_recruit/美团/important.md","raw":"---\ntitle: 常见模板代码\ncategories:\n  - autumn_recruit\n  - 美团\n---\n\n```C++\n#include<iostream>\n#include<unordered_map>\n#include<vector>\nusing namespace std;\nint main(){\n    cout<<\"hello world\"<<endl;\n    return 0;\n}\n```\n\n处理字符串的输入输出\n","slug":"autumn_recruit/美团/important","published":1,"date":"2022-08-21T13:05:07.000Z","updated":"2023-07-12T10:34:16.050Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clk5ceiol003ijpjbcocnckbn","content":"<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span><span class=\"hljs-meta-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span><span class=\"hljs-meta-string\">&lt;unordered_map&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span><span class=\"hljs-meta-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>&#123;<br>    cout&lt;&lt;<span class=\"hljs-string\">&quot;hello world&quot;</span>&lt;&lt;endl;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>处理字符串的输入输出</p>\n","site":{"data":{}},"wordcount":187,"excerpt":"","more":"<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span><span class=\"hljs-meta-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span><span class=\"hljs-meta-string\">&lt;unordered_map&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span><span class=\"hljs-meta-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>&#123;<br>    cout&lt;&lt;<span class=\"hljs-string\">&quot;hello world&quot;</span>&lt;&lt;endl;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>处理字符串的输入输出</p>\n"},{"title":"about","date":"2021-11-08T07:30:16.000Z","layout":"about","_content":"\nHello, my name is Shuang Hu. I have graduated from Zhejiang University as a postgraduate in March, 2023. Now, I am working at my hometown Chongqing.\n\nI have two-year research experience in the fields of Deep Learning and Software Development. I have worked on several projects in these areas (details in CV), and have gained valuable skills and knowledge along the way.\n\nI am a passionate learner and always eager to expand my knowledge and skills. Besides, I also love to take on new challenges. I believe that every challenge presents an opportunity for growth and development, and I am always ready to step up and take on new tasks and responsibilities.\n\nFinally, I take pride in my work and am fully responsible for every task that I undertake. I expect to have a chance to work with you!\n\n\n","source":"_posts/summer_intern_company/about/index.md","raw":"---\ntitle: about\ndate: 2021-11-08 15:30:16\nlayout: about\n---\n\nHello, my name is Shuang Hu. I have graduated from Zhejiang University as a postgraduate in March, 2023. Now, I am working at my hometown Chongqing.\n\nI have two-year research experience in the fields of Deep Learning and Software Development. I have worked on several projects in these areas (details in CV), and have gained valuable skills and knowledge along the way.\n\nI am a passionate learner and always eager to expand my knowledge and skills. Besides, I also love to take on new challenges. I believe that every challenge presents an opportunity for growth and development, and I am always ready to step up and take on new tasks and responsibilities.\n\nFinally, I take pride in my work and am fully responsible for every task that I undertake. I expect to have a chance to work with you!\n\n\n","slug":"summer_intern_company/about/index","published":1,"updated":"2023-07-10T11:10:22.002Z","comments":1,"photos":[],"link":"","_id":"clk5ceiom003ljpjbemd95l3p","content":"<p>Hello, my name is Shuang Hu. I have graduated from Zhejiang University as a postgraduate in March, 2023. Now, I am working at my hometown Chongqing.</p>\n<p>I have two-year research experience in the fields of Deep Learning and Software Development. I have worked on several projects in these areas (details in CV), and have gained valuable skills and knowledge along the way.</p>\n<p>I am a passionate learner and always eager to expand my knowledge and skills. Besides, I also love to take on new challenges. I believe that every challenge presents an opportunity for growth and development, and I am always ready to step up and take on new tasks and responsibilities.</p>\n<p>Finally, I take pride in my work and am fully responsible for every task that I undertake. I expect to have a chance to work with you!</p>\n","site":{"data":{}},"wordcount":651,"excerpt":"","more":"<p>Hello, my name is Shuang Hu. I have graduated from Zhejiang University as a postgraduate in March, 2023. Now, I am working at my hometown Chongqing.</p>\n<p>I have two-year research experience in the fields of Deep Learning and Software Development. I have worked on several projects in these areas (details in CV), and have gained valuable skills and knowledge along the way.</p>\n<p>I am a passionate learner and always eager to expand my knowledge and skills. Besides, I also love to take on new challenges. I believe that every challenge presents an opportunity for growth and development, and I am always ready to step up and take on new tasks and responsibilities.</p>\n<p>Finally, I take pride in my work and am fully responsible for every task that I undertake. I expect to have a chance to work with you!</p>\n"}],"PostAsset":[{"_id":"source/_posts/工具相关/command-related/image-20211207175530810.png","slug":"image-20211207175530810.png","post":"clk5ceio0001pjpjb0harfmlx","modified":0,"renderable":0},{"_id":"source/_posts/项目相关/编程语言/image-20220122202312622.png","slug":"image-20220122202312622.png","post":"clk5ceioi0039jpjbff4fhpcp","modified":0,"renderable":0}],"PostCategory":[{"post_id":"clk5ceine0009jpjbh97y1n9t","category_id":"clk5ceinb0004jpjb49b53tjn","_id":"clk5ceinj000gjpjb7r0ga7v8"},{"post_id":"clk5cein50001jpjbgl0i7soq","category_id":"clk5ceinb0004jpjb49b53tjn","_id":"clk5ceinl000jjpjbcbxn7wkg"},{"post_id":"clk5ceinf000ajpjb97cs8fcx","category_id":"clk5ceinb0004jpjb49b53tjn","_id":"clk5ceinn000mjpjb07a4fdny"},{"post_id":"clk5ceinh000cjpjb98vb9863","category_id":"clk5ceinb0004jpjb49b53tjn","_id":"clk5ceino000pjpjb11e33v8z"},{"post_id":"clk5cein90003jpjbeljo9bty","category_id":"clk5ceinb0004jpjb49b53tjn","_id":"clk5ceinp000rjpjbgv0j2hnm"},{"post_id":"clk5ceinj000fjpjbbx0y5m51","category_id":"clk5ceinb0004jpjb49b53tjn","_id":"clk5ceinq000vjpjb7tfk5y1y"},{"post_id":"clk5ceink000ijpjbdjhrgk2k","category_id":"clk5ceinb0004jpjb49b53tjn","_id":"clk5ceinr000xjpjb1h3hbw7g"},{"post_id":"clk5ceind0006jpjb2xdhbow5","category_id":"clk5ceinb0004jpjb49b53tjn","_id":"clk5ceins0010jpjb3o4r0qqf"},{"post_id":"clk5ceinl000kjpjbc2270nlk","category_id":"clk5ceinb0004jpjb49b53tjn","_id":"clk5ceint0013jpjbg9tmh9il"},{"post_id":"clk5ceino000ojpjb7nl31coc","category_id":"clk5ceinb0004jpjb49b53tjn","_id":"clk5ceinu0016jpjbhjs94ija"},{"post_id":"clk5ceinp000qjpjb9tvgej5j","category_id":"clk5ceinb0004jpjb49b53tjn","_id":"clk5ceinu0019jpjb3f1qf55b"},{"post_id":"clk5ceinq000tjpjb0rjx1cja","category_id":"clk5ceinb0004jpjb49b53tjn","_id":"clk5ceinv001cjpjb7a4lfugg"},{"post_id":"clk5ceinq000wjpjbf9xo2orz","category_id":"clk5ceinb0004jpjb49b53tjn","_id":"clk5ceinw001fjpjbegl44dhe"},{"post_id":"clk5ceinr000zjpjbc0mqgx23","category_id":"clk5ceinb0004jpjb49b53tjn","_id":"clk5ceinw001hjpjbe4zog38s"},{"post_id":"clk5ceins0012jpjb9b91e836","category_id":"clk5ceinb0004jpjb49b53tjn","_id":"clk5ceinx001ljpjb4dux0sis"},{"post_id":"clk5ceint0015jpjba0pr7rzu","category_id":"clk5ceinb0004jpjb49b53tjn","_id":"clk5ceio0001njpjbat7eaj2t"},{"post_id":"clk5ceinu0018jpjbbrtpgupw","category_id":"clk5ceinb0004jpjb49b53tjn","_id":"clk5ceio1001rjpjbc3ju9z2c"},{"post_id":"clk5ceinv001ajpjbcaqg04so","category_id":"clk5ceinb0004jpjb49b53tjn","_id":"clk5ceio2001tjpjbf3wvhhyo"},{"post_id":"clk5ceinv001ejpjba3xmeusz","category_id":"clk5ceinx001ijpjbhpng3pj9","_id":"clk5ceio3001wjpjb1lhqf872"},{"post_id":"clk5ceinw001gjpjb4c3udy6a","category_id":"clk5ceio1001qjpjbeooq6wz9","_id":"clk5ceio60021jpjbb27rhopg"},{"post_id":"clk5ceinx001mjpjbb2hhbldh","category_id":"clk5ceio4001xjpjbaz797nty","_id":"clk5ceio70027jpjbge1jbdnn"},{"post_id":"clk5ceio50020jpjb3ihv8xj3","category_id":"clk5ceio4001xjpjbaz797nty","_id":"clk5ceio9002ajpjbfc5w0ule"},{"post_id":"clk5ceio60023jpjbhma13mwp","category_id":"clk5ceio4001xjpjbaz797nty","_id":"clk5ceio9002djpjbazmi0otx"},{"post_id":"clk5ceio0001pjpjb0harfmlx","category_id":"clk5ceio4001xjpjbaz797nty","_id":"clk5ceioa002fjpjb0mna80gq"},{"post_id":"clk5ceio80029jpjb1rzzdac7","category_id":"clk5ceio4001xjpjbaz797nty","_id":"clk5ceiob002ijpjbe9ypehcx"},{"post_id":"clk5ceio2001sjpjb3et3gq2z","category_id":"clk5ceio4001xjpjbaz797nty","_id":"clk5ceiob002ljpjb5bkd8hgr"},{"post_id":"clk5ceio9002bjpjbg2ag3u1b","category_id":"clk5ceio4001xjpjbaz797nty","_id":"clk5ceioc002njpjbhluaf1ka"},{"post_id":"clk5ceio2001ujpjbe69j8puk","category_id":"clk5ceio4001xjpjbaz797nty","_id":"clk5ceioc002qjpjb5zg0489g"},{"post_id":"clk5ceiob002mjpjbgdg2flbz","category_id":"clk5ceio4001xjpjbaz797nty","_id":"clk5ceiod002ujpjb6of8hv7i"},{"post_id":"clk5ceioc002ojpjbgqfdhpcy","category_id":"clk5ceio4001xjpjbaz797nty","_id":"clk5ceioe002xjpjb66hy15zc"},{"post_id":"clk5ceiod002tjpjb9xc3g26u","category_id":"clk5ceioe002zjpjb04eahyod","_id":"clk5ceioi003ajpjb7dpl438b"},{"post_id":"clk5ceioh0037jpjbcq258lmh","category_id":"clk5ceiog0035jpjb5sp73q2q","_id":"clk5ceiok003gjpjbgsjz2riz"},{"post_id":"clk5ceioe002wjpjb2vp60b4c","category_id":"clk5ceiog0035jpjb5sp73q2q","_id":"clk5ceiol003jjpjb4oz30303"},{"post_id":"clk5ceioi0039jpjbff4fhpcp","category_id":"clk5ceiog0035jpjb5sp73q2q","_id":"clk5ceiom003mjpjb6lvtg2hd"},{"post_id":"clk5ceioj003cjpjb9id00lnp","category_id":"clk5ceiog0035jpjb5sp73q2q","_id":"clk5ceion003pjpjb9a27dfc6"},{"post_id":"clk5ceioe0030jpjbduom9y41","category_id":"clk5ceiog0035jpjb5sp73q2q","_id":"clk5ceion003rjpjb9gxm0vqa"},{"post_id":"clk5ceiok003fjpjb9nkrcfhr","category_id":"clk5ceiog0035jpjb5sp73q2q","_id":"clk5ceion003ujpjbdd8d2ru2"},{"post_id":"clk5ceiof0032jpjb3dbuame4","category_id":"clk5ceiog0035jpjb5sp73q2q","_id":"clk5ceiop003wjpjbhbc614ey"},{"post_id":"clk5ceiog0034jpjb3479alll","category_id":"clk5ceiog0035jpjb5sp73q2q","_id":"clk5ceiop003yjpjb4zjb88kk"},{"post_id":"clk5ceiol003ijpjbcocnckbn","category_id":"clk5ceion003sjpjb5i158ex7","_id":"clk5ceioq0041jpjba0ll66lm"},{"post_id":"clk5ceiol003ijpjbcocnckbn","category_id":"clk5ceiop003zjpjb6bc1b5m4","_id":"clk5ceioq0042jpjbg5r1ew75"}],"PostTag":[{"post_id":"clk5cein90003jpjbeljo9bty","tag_id":"clk5ceine0007jpjbcur9gw7b","_id":"clk5ceini000ejpjbc7jcdrn2"},{"post_id":"clk5ceinf000ajpjb97cs8fcx","tag_id":"clk5ceini000djpjb5mvxbnm9","_id":"clk5ceino000njpjb97uz8cej"},{"post_id":"clk5ceinh000cjpjb98vb9863","tag_id":"clk5ceinn000ljpjb1f4jg05k","_id":"clk5ceinq000ujpjb2tkn61rf"},{"post_id":"clk5ceinj000fjpjbbx0y5m51","tag_id":"clk5ceinp000sjpjbgy2e1g0a","_id":"clk5ceins0011jpjb3pgic7io"},{"post_id":"clk5ceink000ijpjbdjhrgk2k","tag_id":"clk5ceinr000yjpjbe06gb8p9","_id":"clk5ceinu0017jpjb1khz5g5x"},{"post_id":"clk5ceino000ojpjb7nl31coc","tag_id":"clk5ceint0014jpjbf31z40ao","_id":"clk5ceinv001djpjb8zqwaamw"},{"post_id":"clk5ceinp000qjpjb9tvgej5j","tag_id":"clk5ceinv001bjpjbhtas1jvs","_id":"clk5ceinx001kjpjbdzsh6rw5"},{"post_id":"clk5ceinx001jjpjb4bpf4bc1","tag_id":"clk5ceio0001ojpjbb02tc3xe","_id":"clk5ceio4001yjpjb5qte9ay4"},{"post_id":"clk5ceinx001mjpjbb2hhbldh","tag_id":"clk5ceio3001vjpjbc3gt5a45","_id":"clk5ceio70024jpjb2j1pbbzj"},{"post_id":"clk5ceio60023jpjbhma13mwp","tag_id":"clk5ceio80028jpjb693f5mco","_id":"clk5ceioa002gjpjbefi33jhr"},{"post_id":"clk5ceio9002ejpjbh8yb95as","tag_id":"clk5ceiob002jjpjb8lro03uq","_id":"clk5ceioc002rjpjbd8iodflo"},{"post_id":"clk5ceioa002hjpjb2yf786k5","tag_id":"clk5ceioc002pjpjb67gp6wd6","_id":"clk5ceioe002yjpjb27ga9kbw"},{"post_id":"clk5ceiob002mjpjbgdg2flbz","tag_id":"clk5ceiod002vjpjbc8frehbh","_id":"clk5ceiof0033jpjbcsvp3dy3"},{"post_id":"clk5ceioc002sjpjb9ftq37gz","tag_id":"clk5ceiof0031jpjbdie1at58","_id":"clk5ceioh0038jpjb1v7ch9jb"},{"post_id":"clk5ceiod002tjpjb9xc3g26u","tag_id":"clk5ceioh0036jpjb2tuc7wxp","_id":"clk5ceiok003ejpjb7co3a5dv"},{"post_id":"clk5ceiog0034jpjb3479alll","tag_id":"clk5ceioj003djpjb3rk9fsio","_id":"clk5ceiom003njpjbe5wj365y"},{"post_id":"clk5ceioh0037jpjbcq258lmh","tag_id":"clk5ceiol003kjpjb875xhcv7","_id":"clk5ceion003tjpjbc9dr49td"},{"post_id":"clk5ceioi0039jpjbff4fhpcp","tag_id":"clk5ceion003qjpjbfxux8nq7","_id":"clk5ceiop003xjpjbecsa8h41"},{"post_id":"clk5ceiok003fjpjb9nkrcfhr","tag_id":"clk5ceioo003vjpjb416dd8ri","_id":"clk5ceioq0040jpjb991f1iay"}],"Tag":[{"name":"二分","_id":"clk5ceine0007jpjbcur9gw7b"},{"name":"其他","_id":"clk5ceini000djpjb5mvxbnm9"},{"name":"dp","_id":"clk5ceinn000ljpjb1f4jg05k"},{"name":"栈, 单调栈","_id":"clk5ceinp000sjpjbgy2e1g0a"},{"name":"双指针","_id":"clk5ceinr000yjpjbe06gb8p9"},{"name":"回溯算法, DFS, BFS","_id":"clk5ceint0014jpjbf31z40ao"},{"name":"多线程并发， 信号量， 互斥锁","_id":"clk5ceinv001bjpjbhtas1jvs"},{"name":"Linux command","_id":"clk5ceio0001ojpjbb02tc3xe"},{"name":"conda environment","_id":"clk5ceio3001vjpjbc3gt5a45"},{"name":"typora, md","_id":"clk5ceio80028jpjb693f5mco"},{"name":"scheduler","_id":"clk5ceiob002jjpjb8lro03uq"},{"name":"private","_id":"clk5ceioc002pjpjb67gp6wd6"},{"name":"zplot","_id":"clk5ceiod002vjpjbc8frehbh"},{"name":"vscode python","_id":"clk5ceiof0031jpjbdie1at58"},{"name":"daily task","_id":"clk5ceioh0036jpjb2tuc7wxp"},{"name":"machine learning","_id":"clk5ceioj003djpjb3rk9fsio"},{"name":"八股文","_id":"clk5ceiol003kjpjb875xhcv7"},{"name":"python, C++","_id":"clk5ceion003qjpjbfxux8nq7"},{"name":"review tips","_id":"clk5ceioo003vjpjb416dd8ri"}]}}