<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>hexo + github 博客搭建</title>
      <link href="/2023/11/29/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
      <url>/2023/11/29/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>记录： 相同的错误解决更快；知识点便于之后的复习</li><li>分享： 开源与共享精神</li></ul><h2 id="现有方案"><a href="#现有方案" class="headerlink" title="现有方案"></a>现有方案</h2><ul><li>直接利用：简书，博客园，</li><li>自己搭建：hexo, WordPress, Typecho</li><li>其他笔记工具：Notion, 印象笔记，语雀</li></ul><p>选择hexo原因：</p><blockquote><p>有前端基础，会Markdown、会HTML和CSS，选择 Hexo<br>有Vue基础可以选择 vuePress 或者 vitePress<br>会Go可以选择 Hugo<br>会Rust可以选择 Zola<br>会Ruby可以选择 Jekyll<br>会PHP可以考虑使用 WordPress</p></blockquote><ul><li>简单便捷，上手快</li><li>使用用户多，参考素材多，踩坑解决方案多</li><li>专注博客内容本身，其他比较困难的框架可以之后有需要再看</li></ul><h2 id="hexo-github搭建流程"><a href="#hexo-github搭建流程" class="headerlink" title="hexo+github搭建流程"></a>hexo+github搭建流程</h2><ol><li>git, node, hexo 的安装</li><li>将博客内容部署到github （config配置+安装部署插件+hexo d）</li><li>使用xxx.github.io来访问博客</li><li>页面修改与重新部署</li></ol><p><a href="https://hexo.io/zh-cn/docs/commands.html">hexo常用命令</a>:</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># 创建新页面 </span><br>hexo <span class="hljs-keyword">new</span> <span class="hljs-string">&quot;My New Post&quot;</span><br><span class="hljs-meta"># 清空缓存</span><br>hexo c<br><span class="hljs-meta"># 生成静态页面 </span><br>hexo g <br><span class="hljs-meta"># 本地预览 </span><br>hexo s <br><span class="hljs-meta"># 部署到网站 </span><br>hexo d<br></code></pre></td></tr></table></figure><p><a href="https://markdown.com.cn/basic-syntax/headings.html">Markdown语法</a></p><p><a href="https://zz2summer.github.io/github-hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/">Windows环境下使用hexo搭建个人博客</a><br><a href="https://blog.l3zc.com/2022/05/mac%E7%8E%AF%E5%A2%83%E4%B8%8B%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/">Mac OS环境下使用Hexo搭建个人博客</a></p><h2 id="hexo个性化功能"><a href="#hexo个性化功能" class="headerlink" title="hexo个性化功能"></a>hexo个性化功能</h2><ul><li>更改域名</li><li>修改主题</li><li>自定义界面</li><li>配置到个人服务器<br>….</li></ul><p><a href="https://wty-yy.space/posts/60487/">添加评论功能</a><br><a href="https://zhuanlan.zhihu.com/p/111614119">更改域名和修改主题</a><br><a href="https://hexo.fluid-dev.com/docs/guide/#%E5%85%B3%E4%BA%8E%E6%8C%87%E5%8D%97">hexo fluid 用户手册</a><br><a href="https://hexo.io/themes/index.html">hexo主题</a><br><a href="https://callmelp.online/2022/03/26/hexoToMyServer/">将hexo配置到个人服务器 nginx配置https</a></p><h2 id="案例展示"><a href="#案例展示" class="headerlink" title="案例展示"></a>案例展示</h2><p><a href="https://shu0421.github.io/">我的博客</a></p><p><a href="https://arcsin2.cloud/">简洁例子</a></p><p><a href="https://wty-yy.space/">关于页面</a></p><p><a href="https://202271.xyz/friends">新建友联</a></p><p><a href="https://blog.akimio.top/link/">其他格式</a></p><p><a href="https://www.zywvvd.com/messagebd/">站点分析</a></p><h2 id="常见问题及解决"><a href="#常见问题及解决" class="headerlink" title="常见问题及解决"></a>常见问题及解决</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
      
      
      <categories>
          
          <category> 工具相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K8S学习</title>
      <link href="/2023/11/28/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/k8s/"/>
      <url>/2023/11/28/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/k8s/</url>
      
        <content type="html"><![CDATA[<h2 id="学习打算"><a href="#学习打算" class="headerlink" title="学习打算"></a>学习打算</h2><p>先学习k8s, 在hec06 hec07, hec08上面实验，然后再学习microk8s minik8s, minikube的方式进行kubenetes的学习</p><h2 id="microk8s"><a href="#microk8s" class="headerlink" title="microk8s"></a>microk8s</h2><p>官方安装教程<br><a href="https://kubernetes.io/zh/blog/2019/11/26/%E4%BD%BF%E7%94%A8-microk8s-%E5%9C%A8-linux-%E4%B8%8A%E6%9C%AC%E5%9C%B0%E8%BF%90%E8%A1%8C-kubernetes/">404 Page not found | Kubernetes</a></p><p>给kubectl改别名:<br><code>sudo snap alias microk8s.kubectl kubectl</code> </p><h2 id="原生k8s平台的搭建"><a href="#原生k8s平台的搭建" class="headerlink" title="原生k8s平台的搭建"></a>原生k8s平台的搭建</h2><h2 id="在hec集群上搭建过程"><a href="#在hec集群上搭建过程" class="headerlink" title="在hec集群上搭建过程"></a>在hec集群上搭建过程</h2><h3 id="1-安装kubelet-kubeadm-kubectl"><a href="#1-安装kubelet-kubeadm-kubectl" class="headerlink" title="1. 安装kubelet kubeadm kubectl"></a>1. 安装kubelet kubeadm kubectl</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br>sudo apt-get update &amp;&amp; sudo apt-get install -y apt-transport-https curl<br><span class="hljs-comment"># curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add - </span><br><span class="hljs-comment"># 上面那个命令要翻墙，因此先将apt-get.gpg下载下来，然后使用如下命令替换</span><br>sudo apt-key add apt-key.gpg<br>sudo sh -c <span class="hljs-string">&#x27;echo &quot;deb https://mirrors.aliyun.com/kubernetes/apt kubernetes-xenial main&quot;&gt;/etc/apt/sources.list&#x27;</span><br><br>sudo add-apt-repository --remove  ppa:pascallj/docker.io-clone3 删除ppa<br>或者<span class="hljs-built_in">cd</span> /etc/apt/sources.list.d, 然后进行删除<br><br><span class="hljs-comment"># E: Package &#x27;socat&#x27;/&#x27;conntrack&#x27; has no installation candidate</span><br><span class="hljs-comment"># 在 https://launchpad.net/+search?field.text=conntrack+ppa&amp;field.actions.search=Search </span><br><span class="hljs-comment"># 网站上搜索 conntrack/ socat的 ppa源，然后使用命令, 添加ppa源： </span><br>sudo add-apt-repository ppa:ionel-mc/socat<br>sudo add-apt-repository ppa:brightbox/experimental <br><br>sudo apt-get update<br><br>sudo apt-get install conntrack<br>sudo apt-get install socat<br>sudo apt-get update &amp;&amp; sudo apt-get install docker.io<br><br><span class="hljs-comment"># 最后再运行下面的命令就不会报错了:</span><br>sudo apt-get install -y kubelet=1.15.1-00 kubeadm=1.15.1-00 kubectl=1.15.1-00<br><br></code></pre></td></tr></table></figure><h3 id="2-运行docker"><a href="#2-运行docker" class="headerlink" title="2. 运行docker"></a>2. 运行docker</h3><p>docker需要在每个节点都运行起来：<br>sudo systemctl start docker</p><!-- 没有权限的解决方案 --><p>sudo chmod a+rw /var/run/docker.sock</p><h3 id="3-用-kubeadm-创建-Cluster"><a href="#3-用-kubeadm-创建-Cluster" class="headerlink" title="3. 用 kubeadm 创建 Cluster"></a>3. 用 kubeadm 创建 Cluster</h3><p>在master节点上运行：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo kubeadm reset<br>sudo kubeadm init <span class="hljs-attribute">--apiserver-advertise-address</span>=10.5.26.67 <span class="hljs-attribute">--pod-network-cidr</span>=10.244.0.0/16 <span class="hljs-attribute">--image-repository</span>=registry.aliyuncs.com/google_containers <span class="hljs-attribute">--ignore-preflight-errors</span>=all<br></code></pre></td></tr></table></figure><!-- 其他人的一个例子 --> <!-- sudo kubeadm reset --><!-- sudo kubeadm init \--apiserver-advertise-address=10.5.26.67 \--image-repository registry.aliyuncs.com/google_containers \--kubernetes-version v1.13.3 \--service-cidr=10.1.0.0/16 \--pod-network-cidr=10.244.0.0/16 \--ignore-preflight-errors=all--><p>如果卡住，出现下列报警：[kubelet-check] Initial timeout of 40s passed.</p><p>查看原因：<code>sudo journalctl -u kubelet tail -100f /var/log/messages|grep kub</code></p><p>解决方法：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs awk">修改docker cgroup:<br>sudo vi <span class="hljs-regexp">/etc/</span>docker/daemon.json<br>&#123;<br>  <span class="hljs-string">&quot;exec-opts&quot;</span>: [<br>        <span class="hljs-string">&quot;native.cgroupdriver=systemd&quot;</span><br>  ],<br>  <span class="hljs-string">&quot;log-driver&quot;</span>: <span class="hljs-string">&quot;json-file&quot;</span>,<br>  <span class="hljs-string">&quot;log-opts&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;max-size&quot;</span>: <span class="hljs-string">&quot;100m&quot;</span><br>  &#125;,<br>  <span class="hljs-string">&quot;storage-driver&quot;</span>: <span class="hljs-string">&quot;overlay2&quot;</span>,<br>  <span class="hljs-string">&quot;storage-opts&quot;</span>: [<br>        <span class="hljs-string">&quot;overlay2.override_kernel_check=true&quot;</span><br>  ],<br>  <span class="hljs-string">&quot;registry-mirrors&quot;</span> : [<br>        <span class="hljs-string">&quot;https://ot2k4d59.mirror.aliyuncs.com/&quot;</span><br>  ],<br>  <span class="hljs-string">&quot;graph&quot;</span>: <span class="hljs-string">&quot;/data/docker&quot;</span><br>&#125;<br>sudo systemctl daemon-reload<br>sudo systemctl restart docker <span class="hljs-regexp">//</span>重启docker<br>sudo iptables -F &amp;&amp; sudo iptables -t nat -F &amp;&amp; sudo iptables -t mangle -F &amp;&amp; sudo iptables -X<br>sudo swapoff -a<br>sudo systemctl restart kubelet<br></code></pre></td></tr></table></figure><p>上述问题解决方案的参考链接：<a href="https://stackoverflow.com/questions/67606941/kubeadm-init-failing-while-initializing-a-kubernetes-cluster">kubeadm init failing while initializing a Kubernetes cluster - Stack Overflow</a></p><h3 id="4-为master配置-kubectl"><a href="#4-为master配置-kubectl" class="headerlink" title="4. 为master配置 kubectl"></a>4. 为master配置 kubectl</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo mkdir -p <span class="hljs-variable">$HOME</span>/.kube<br>sudo cp -i <span class="hljs-regexp">/etc/</span>kubernetes<span class="hljs-regexp">/admin.conf $HOME/</span>.kube/config<br>sudo chown $(id -u):$(id -g) <span class="hljs-variable">$HOME</span><span class="hljs-regexp">/.kube/</span>config<br></code></pre></td></tr></table></figure><p>  运行完这三句之后，<code>sudo kubectl version</code>显示正常结果</p><h3 id="5-其他节点加入master节点"><a href="#5-其他节点加入master节点" class="headerlink" title="5. 其他节点加入master节点"></a>5. 其他节点加入master节点</h3><!-- 注意一定要保证服务器和客户端之间的kubectl版本一致sudo apt-get install -y kubelet=1.23.6-00 kubeadm=1.23.6-00 kubectl=1.23.6-00 --><p>先初始化网络：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">kubectl apply -f https:<span class="hljs-regexp">//</span>raw.githubusercontent.com<span class="hljs-regexp">/coreos/</span>flannel<span class="hljs-regexp">/master/</span>Documentation/kube-flannel.yml<br></code></pre></td></tr></table></figure><p>最后得到的token:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim">sudo kubeadm <span class="hljs-keyword">join</span> <span class="hljs-number">10.5</span>.<span class="hljs-number">26.67</span>:<span class="hljs-number">6443</span> --token <span class="hljs-number">9</span>am4ce.fnycv1gi9gx7mbch \<br>    --discovery-token-<span class="hljs-keyword">ca</span>-cert-hash <span class="hljs-built_in">sha256</span>:<span class="hljs-number">3368</span>a9667447c72ab00404ce0ff9b4975e9402b1f86c9afce511d992ecfcd29e --ignore-preflight-errors=<span class="hljs-keyword">all</span><br></code></pre></td></tr></table></figure><h2 id="平台搭建问题及解决方案："><a href="#平台搭建问题及解决方案：" class="headerlink" title="平台搭建问题及解决方案："></a>平台搭建问题及解决方案：</h2><h3 id="1-kubeadm-join超时"><a href="#1-kubeadm-join超时" class="headerlink" title="1. kubeadm join超时"></a>1. kubeadm join超时</h3><p>一直join不了的解决方法和k8s master kubeadm init不了的解决方案相同，见”修改docker cgroup“</p><p>一些误区：<br>节点之间不需要免密登录，也能进行kubectl的通信（kubeadm join）</p><h3 id="2-建立镜像的时候出现docker-build-pip超时，使用国内源仍然无法解决"><a href="#2-建立镜像的时候出现docker-build-pip超时，使用国内源仍然无法解决" class="headerlink" title="2. 建立镜像的时候出现docker build pip超时，使用国内源仍然无法解决"></a>2. 建立镜像的时候出现docker build pip超时，使用国内源仍然无法解决</h3><p>解决方案：在docker build命令后面加上 –network=”host”</p><h3 id="3-安装kubeflow"><a href="#3-安装kubeflow" class="headerlink" title="3.安装kubeflow"></a>3.安装kubeflow</h3><p><a href="https://zhuanlan.zhihu.com/p/368720477">轻量级Kubeflow模型训练 - 知乎</a><br>安装kubeflow遇到的问题：<br><a href="https://stackoverflow.com/questions/69054622/unable-to-install-crds-in-kubernetes-kind">Unable to install CRDs in kubernetes kind - Stack Overflow</a></p><p>降级kubeadm的版本：sudo apt-get install kubeadm=1.20.4-00 kubectl=1.20.4-00 kubelet=1.20.4-00 -y –allow-downgrades 允许降低版本<br>在降低版本之后，需要重新进行kubeadm的init和join， 否则会导致kubectl 客户端和服务器版本不一致的问题</p><h3 id="4-coredns-一直处在containerWaiting的状态"><a href="#4-coredns-一直处在containerWaiting的状态" class="headerlink" title="4. coredns 一直处在containerWaiting的状态"></a>4. coredns 一直处在containerWaiting的状态</h3><p><a href="https://58jb.com/html/k8s_v1.20_coredns_error.html">https://58jb.com/html/k8s_v1.20_coredns_error.html</a><br>注意worker节点上面的10-canal.conflist和calico-kubeconfig删 也要删除！！！1</p><p>// 这个链接没有尝试：<a href="https://bbs.huaweicloud.com/forum/thread-60243-1-1.html">华为云论坛_云计算论坛_开发者论坛_技术论坛-华为云</a></p><p>service/pytorch-operator created<br>deployment.apps/pytorch-operator created</p><p>查看一个运行pod的镜像: kubectl edit pod pytorch-operator-7756f57455-6xj9g -n kubeflow</p><h3 id="5-在安装pytorch-operator的时候出现镜像找不到"><a href="#5-在安装pytorch-operator的时候出现镜像找不到" class="headerlink" title="5.在安装pytorch operator的时候出现镜像找不到"></a>5.在安装pytorch operator的时候出现镜像找不到</h3><p>参考的安装目录： <a href="https://zhuanlan.zhihu.com/p/368720477">轻量级Kubeflow模型训练 - 知乎</a><br>“${MANIFESTS_DIR}/pytorch-job/pytorch-operator/base/“ 里面deployment.yaml的镜像为<br>“registry.cn-shenzhen.aliyuncs.com/shikanon/kubeflow-images-public.pytorch-operator:v1.0.0-rc.0”</p><p>主要参考的替换方法：<a href="https://developer.aliyun.com/article/741640">kubeflow系列(一)：基于国内阿里云镜像解决kubeflow一键安装-阿里云开发者社区</a></p><h3 id="6-现在创建了pytorch-job但是运行不起来，create-之后找不到"><a href="#6-现在创建了pytorch-job但是运行不起来，create-之后找不到" class="headerlink" title="6. 现在创建了pytorch job但是运行不起来，create 之后找不到"></a>6. 现在创建了pytorch job但是运行不起来，create 之后找不到</h3><p><a href="https://github.com/kubeflow/pytorch-operator">GitHub - kubeflow/pytorch-operator: PyTorch on Kubernetes</a>（明天照着这个看看）</p><ul><li>执行以下命令，通过 kubectl 提交该 PyTorch Job：<br>kubectl create -f ./pytorch_job_mnist_nccl.yaml</li><li>执行以下命令，查看该 PyTorch Job：<br>kubectl get -o yaml pytorchjobs pytorch-dist-mnist-nccl</li><li>执行以下命令，查看 PyTorch 任务创建的相关 Pod：<br>kubectl get pods -l pytorch_job_name=pytorch-dist-mnist-nccl  </li></ul><h3 id="7-现在创建local-path-storage的时候遇到错误"><a href="#7-现在创建local-path-storage的时候遇到错误" class="headerlink" title="7. 现在创建local-path-storage的时候遇到错误"></a>7. 现在创建local-path-storage的时候遇到错误</h3><p>换了一个节点hec05,然后在每个节点按照 <a href="https://bbs.huaweicloud.com/forum/thread-60243-1-1.html">华为云论坛_云计算论坛_开发者论坛_技术论坛-华为云</a> 运行命令就可以了<br>然后使用设置为default的local-path</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">kubectl patch storageclass <span class="hljs-keyword">local</span>-path -p &#x27;&#123;<span class="hljs-string">&quot;metadata&quot;</span>: &#123;<span class="hljs-string">&quot;annotations&quot;</span>:&#123;<span class="hljs-string">&quot;storageclass.kubernetes.io/is-default-class&quot;</span>:<span class="hljs-string">&quot;true&quot;</span>&#125;&#125;&#125;&#x27;<br></code></pre></td></tr></table></figure><p>正确的解决的方法应该是每个节点都删除cth0, 主要命令见服务器上的run_update.sh脚本</p><h3 id="8-下载kubeflow的时候cert-manager出现错误"><a href="#8-下载kubeflow的时候cert-manager出现错误" class="headerlink" title="8. 下载kubeflow的时候cert-manager出现错误"></a>8. 下载kubeflow的时候cert-manager出现错误</h3><!-- //下面这个解决方法是错误的，因为for flannel  you must pass 10.244.0.0/16!!!!1kubectl edit cm -n kube-system kube-flannel-cfg将10.244.0.0/16 改为 最开始kubeadm init的值--pod-network-cidr=192.168.0.0/16也可以通过下面命令查看 kubectl get nodes -o jsonpath='{.items[*].spec.podCIDR}' to get pod CIDR --><p>正确的解决的方法应该是每个节点都删除cth0, 主要命令见服务器上的run_update.sh脚本， 同时设置–pod-network-cidr=10.244.0.0/16</p><h3 id="9-ImageBackOff问题"><a href="#9-ImageBackOff问题" class="headerlink" title="9. ImageBackOff问题"></a>9. ImageBackOff问题</h3><p>在执行命令kfctl apply -f kfctl_k8s_istio.v1.2.0.yaml 因为需要下载许多的镜像，所以可能会导致ImageBackOff<br>因此至少需要100G的存储空间，同时需要借助阿里云的镜像来进行所有镜像的下载，然后再执行这个命令，主要参考下面两个链接<br><a href="https://blog.csdn.net/koukouwuwu/article/details/117016360">k8s中的kubeflow1.02安装过程记录_ZhuoJieTech的博客-CSDN博客</a><br><a href="https://blog.csdn.net/qq_46595591/article/details/107765833">【最新】k8s中kubeflow(v1.0)部署全过程+踩坑全集（图文）_kubeflow踩坑-CSDN博客</a></p><p><a href="https://github.com/shikanon/kubeflow-manifests#%E5%AE%89%E8%A3%85kubeflow">GitHub - shikanon/kubeflow-manifests: kubeflow国内一键安装文件</a> 国内环境一键安装kubeflow1.3试试</p><p>查看是否安装好: <code>kubectl -n kubeflow get all</code> </p><h3 id="10-k8s可视化"><a href="#10-k8s可视化" class="headerlink" title="10.  k8s可视化"></a>10.  k8s可视化</h3><ul><li><p>安装过程：<a href="https://www.jianshu.com/p/f4e35abe0462">helm3安装prometheus到K8s集群</a> 通过这个安装grafana和 prometheus<br>(主要安装命令见服务器 install_tools.sh)</p></li><li><p>遇到的问题：无法将localhost:9090添加到grafana的仪表盘</p></li><li><p>主要原因： prometheus开启的时候自环网络，<code>curl localhost:9090</code>成功；但是<code>curl 10.5.26.66:9090</code> 失败；所以用 <code>ssh -L 9090:127.0.0.1:9090 shu@10.5.26.66 -o ProxyCommand=&quot;ssh shu@10.5.26.19 -W %h:%p&quot; </code> 建立隧道也失败</p></li><li><p>解决方案：</p><ol><li>需要在你的prometheus.yml 文件 中监控的localhost 改为你的IP</li><li>grafana改用brower模式，填入htpp://localhost:30090 （也就是prometheus的浏览器地址）</li></ol></li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://github.com/wenbin8/doc/blob/master/%E5%88%86%E5%B8%83%E5%BC%8F/CloudNative/Kubernetes/01-Kubernetes%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA.md">其他人搭建的过程，可借鉴</a></p><h2 id="k8s-其他辅助功能"><a href="#k8s-其他辅助功能" class="headerlink" title="k8s 其他辅助功能"></a>k8s 其他辅助功能</h2><h2 id="1-查看日志"><a href="#1-查看日志" class="headerlink" title="1. 查看日志"></a>1. 查看日志</h2><p>看系统日志</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">cat</span> /<span class="hljs-keyword">var</span>/<span class="hljs-keyword">log</span>/messages<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs xml">用kubectl 查看日志<br><span class="hljs-comment">&lt;!-- 注意：使用Kubelet describe 查看日志，一定要带上 命名空间，否则会报如下错误[root@node2 ~]# kubectl describe pod coredns-6c65fc5cbb-8ntpvError from server (NotFound): pods &quot;coredns-6c65fc5cbb-8ntpv&quot; not found --&gt;</span><br><br>kubectl describe pod kubernetes-dashboard-849cd79b75-s2snt --namespace kube-system<br><br>kubectl logs -f pods/monitoring-influxdb-fc8f8d5cd-dbs7d -n kube-system<br><br>kubectl logs --tail 200 -f kube-apiserver -n kube-system |more<br><br>kubectl logs --tail 200 -f podname -n jenkins<br><br><br><br>用journalctl查看日志非常管用<br><br>journalctl -u kube-scheduler<br><br>journalctl -xefu kubelet  -n 10（主要是这个）<br><br>journalctl -u kube-apiserver<br><br><br>journalctl -u kubelet |tail<br><br>journalctl -xe<br><br><br>用docker查看日志<br><br>docker logs c36c56e4cfa3  (容器id)<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DP问题专栏</title>
      <link href="/2023/11/25/dp%E9%97%AE%E9%A2%98%E4%B8%93%E6%A0%8F/DAG+%E6%A0%91%E7%8A%B6+%E5%85%B6%E4%BB%96dp/"/>
      <url>/2023/11/25/dp%E9%97%AE%E9%A2%98%E4%B8%93%E6%A0%8F/DAG+%E6%A0%91%E7%8A%B6+%E5%85%B6%E4%BB%96dp/</url>
      
        <content type="html"><![CDATA[<h3 id="1-DAG上的dp"><a href="#1-DAG上的dp" class="headerlink" title="1. DAG上的dp"></a>1. DAG上的dp</h3><p>UVa 437 巴比伦塔 The Tower of Babylon</p><p>这道题求最高的塔，其实就是一个记忆化dfs的过程<br>一些需要注意的点：</p><ol><li>因为不可能出现一个立方体同时叠两次，因此不需要vis</li><li>因为有三种叠法，所以需要3个方向</li><li>因为最开始让谁做底部是不清楚的，所以使用循环遍历方法</li><li>因为一个底确定之后的最高是确定的，因此使用记忆化搜索，避免重复计算</li><li>对于这种题情况多，再加上dfs的题，先分析一两个小的情况（if-else, 三个方向分情况讨论）， 再暴力（dfs）， 再优化（记忆化数组）</li><li>类似最长路问题</li></ol><h3 id="2-树状dp-dfs-dp"><a href="#2-树状dp-dfs-dp" class="headerlink" title="2. 树状dp: dfs+dp"></a>2. 树状dp: dfs+dp</h3><p>主要是针对图有层级结构（没有上司的舞会），或者选择课程这样的dp, 主要是背包和树状dp结合<br>使用dfs+dp</p><ul><li>一般解题步骤：</li><li>先使用dfs记录子节点的状态：dp[i][0]/ dp[i][1]/ dp[i][k]</li><li>然后计算当前节点的状态转移 (u是父节点， i是子节点)<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">dp[u][a+b] = <span class="hljs-built_in">max</span>(dp[u][a+b], dp[u][a]+dp[i][b]) <span class="hljs-comment">//课程的转移方程</span><br>或者<br>dp[u][<span class="hljs-number">0</span>] += <span class="hljs-built_in">max</span>(dp[i][<span class="hljs-number">0</span>], dp[i][<span class="hljs-number">1</span>]); <span class="hljs-comment">//上司的转移方程</span><br>dp[u][<span class="hljs-number">1</span>] += dp[i][<span class="hljs-number">0</span>];<br></code></pre></td></tr></table></figure></li></ul><p>例题：洛谷 P2014 CTSC1997 选课 （挺难的）</p><ul><li>加入一门课程，森林转为树，求解dp[0][m+1]</li><li>我们枚举 u点的每个子结点 ，同时枚举以 i 为根的子树选了几门课程，将子树的结果合并到 u 上。注意这个使用a的取值范围随着访问的子树的数量逐渐增加</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> p = <span class="hljs-number">1</span>;<br>  f[u][<span class="hljs-number">1</span>] = s[u];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : e[u]) &#123;<br>    <span class="hljs-keyword">int</span> siz = <span class="hljs-built_in">dfs</span>(v);<br>    <span class="hljs-comment">// 注意下面两重循环的上界和下界</span><br>    <span class="hljs-comment">// 只考虑已经合并过的子树，以及选的课程数超过 m+1 的状态没有意义</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-built_in">min</span>(p, m + <span class="hljs-number">1</span>); i; i--)<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= siz &amp;&amp; i + j &lt;= m + <span class="hljs-number">1</span>; j++)<br>        f[u][i + j] = <span class="hljs-built_in">max</span>(f[u][i + j], f[u][i] + f[v][j]);  <span class="hljs-comment">// 转移方程</span><br>    p += siz; <span class="hljs-comment">//p逐渐增加</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="换根dp"><a href="#换根dp" class="headerlink" title="换根dp"></a>换根dp</h3><ul><li>两次dfs， 找到换根前后dp的转移公式</li><li>树和图dfs不一样，不需要使用vis,只需要记录一下当前index，和当前index的father就能避免访问同一节点</li></ul><h3 id="数位dp"><a href="#数位dp" class="headerlink" title="数位dp"></a>数位dp</h3><p><a href="https://blog.csdn.net/Enjoying_Science/article/details/44082929">不要62（数位DP）-CSDN博客</a> 动态规划<br><a href="https://www.cnblogs.com/wenruo/p/4725005.html">HDU 2089 不要62 (数位DP) - 我不吃饼干呀 - 博客园</a> 动态规划，解释有点问题<br><a href="http://www.calvinneo.com/2017/09/23/HDU2089%E4%B8%8D%E8%A6%8162/">HDU 2089 不要62 数位DP | Calvin’s Marbles</a> dfs<br><a href="https://www.programminghunter.com/article/8939658418/">hdu 2089 不要62【数位dp】 - 编程猎人</a> dfs<br><a href="https://leetcode.cn/problems/non-negative-integers-without-consecutive-ones/">600. 不含连续1的非负整数</a></p>]]></content>
      
      
      <categories>
          
          <category> dp问题专栏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 命令相关</title>
      <link href="/2022/10/17/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/git/"/>
      <url>/2022/10/17/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/git/</url>
      
        <content type="html"><![CDATA[<h3 id="1-git-pull超时，访问缓慢的解决方案"><a href="#1-git-pull超时，访问缓慢的解决方案" class="headerlink" title="1. git pull超时，访问缓慢的解决方案"></a>1. git pull超时，访问缓慢的解决方案</h3><p><a href="https://jasonkayzk.github.io/2019/10/10/%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8Git%E6%97%B6push-pull%E8%B6%85%E6%97%B6-%E4%BB%A5%E5%8F%8AGithub%E8%AE%BF%E9%97%AE%E6%85%A2%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/">参考链接</a></p><p>git超时比较有用的命令：git config –global –add remote.origin.proxy “” </p><p>git 现在不支持密码登陆，只支持token登陆：<br>git remote set-url origin https://<your_token>@github.com/<USERNAME>/<REPO>.git<br>比如：<br>git remote set-url origin <a href="https://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@github.com/SHu0421/DNN_Cplusplus.git">GitHub - SHu0421/DNN_Cplusplus</a></REPO></USERNAME></your_token></p><p><a href="https://hexo.io/zh-cn/docs/github-pages.html#%E7%A7%81%E6%9C%89-Repository">在 GitHub Pages 上部署 Hexo | Hexo</a> hexo+github私有仓库</p><h3 id="2-github-authentication-failed"><a href="#2-github-authentication-failed" class="headerlink" title="2. github authentication failed"></a>2. github authentication failed</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">Missing or invalid credentials.<br>Error: ENOSPC: no space left on device, write<br>    at Object.writeSync (node:fs:884:3)<br>    at Object.writeFileSync (node:fs:2163:26)<br>    at /nfs/home/shu/.vscode-server/bin/64bbfbf67ada9953918d72e1df2f4d8e537d340e/extensions/git/dist/askpass-main.js:1:9371<br><br>fatal: Authentication failed <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;https://github.com/SHu0421/Graduate_Thesis.git/&#x27;</span><br></code></pre></td></tr></table></figure><ul><li>原因一：根目录满了</li><li>原因二：<a href="https://blog.csdn.net/weixin_41010198/article/details/119698015">remote: Support for password authentication was removed on August 13, 2021.-CSDN博客</a><br>当输入github的邮箱和密码的时候，使用git token作为密码，而不是github仓库的密码</li></ul><h3 id="3-使用本地网络在服务器上下载东西"><a href="#3-使用本地网络在服务器上下载东西" class="headerlink" title="3. 使用本地网络在服务器上下载东西"></a>3. 使用本地网络在服务器上下载东西</h3><p>具体见：command-related的第一条-使用网络隧道</p><h3 id="4-github-clone一直卡住"><a href="#4-github-clone一直卡住" class="headerlink" title="4. github clone一直卡住"></a>4. github clone一直卡住</h3><p><a href="https://blog.csdn.net/x763795151/article/details/114903758">git拉取上游代码：LibreSSL SSL_connect: SSL_ERROR_SYSCALL in connection to github.com:443_git libressl ssl_connect:_不识君的荒漠的博客-CSDN博客</a><br>一定要先设置代理后取消，直接取消没有效果</p><h3 id="5-git使用ssh-key的方式连接远程仓库"><a href="#5-git使用ssh-key的方式连接远程仓库" class="headerlink" title="5. git使用ssh key的方式连接远程仓库"></a>5. git使用ssh key的方式连接远程仓库</h3><p>查看remote-url:<br><code>git remote -v </code><br>删除remote-url:<br><code>git remote rm origin</code><br>添加<br><code>git remote add origin git@xxxx </code></p><p>添加和删除可以合并为一个操作<br><code>git remote set-url origin</code></p><h3 id="6-git版本回滚"><a href="#6-git版本回滚" class="headerlink" title="6. git版本回滚"></a>6. git版本回滚</h3><p>如果回滚到上一次提交，删除<code>git add . 和git commit</code>的内容但是本地修改记录不变的话，使用<code>git reset --mixed version_num</code></p><div class="note note-info">            <p>–mixed：为默认值，等同于git reset。作用为：将文件回退到工作区，此时会保留工作区中的文件，但会丢弃暂存区中的文件；<br>–soft：作用为：将文件回退到暂存区，此时会保留工作区和暂存区中的文件（保留git add和git commit内容）；<br>–hard：作用为：将文件回退到修改前，此时会丢弃工作区和暂存区中的文件；</p>          </div><h3 id="7-git新建分支与合并"><a href="#7-git新建分支与合并" class="headerlink" title="7. git新建分支与合并"></a>7. git新建分支与合并</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">新建分支：<br>  git checkout -a dev<br>上传repo: <br>  git add .<br>  git commit -m <span class="hljs-string">&quot;first commit&quot;</span><br>  git push origin dev<br>将<span class="hljs-built_in">source</span>代码合并过来:<br>  git checkout <span class="hljs-built_in">source</span><br>  git pull 和远程分支同步<br>  git checkout dev<br>  git merge <span class="hljs-built_in">source</span> <span class="hljs-comment"># 合并完成后，可能需要解决冲突，然后再提交</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>八股文总结</title>
      <link href="/2022/06/12/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E5%85%AB%E8%82%A1%E6%96%87/"/>
      <url>/2022/06/12/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E5%85%AB%E8%82%A1%E6%96%87/</url>
      
        <content type="html"><![CDATA[<h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><h3 id="C-多态特性"><a href="#C-多态特性" class="headerlink" title="C++ 多态特性"></a>C++ 多态特性</h3><p>虚函数 是在基类中使用关键字 virtual 声明的函数。虚函数允许子类重新定义成员函数，而子类重新定义父类的做法称为覆盖(override)，或者称为重写。C++多态(polymorphism)就是通过虚函数来实现的。<br>纯虚函数 函数虚函数后面有==0。包含纯虚函数的类就是抽象类，这种类不能有对象，比如动物下面有青蛙，狗，但是动物不能有对象</p><p>静态多态性包括 函数重载 运算符重载， 重载就是同一个函数名字，但是不同的参数类型或者参数个数<br>动态多态主要由虚函数实现，也就是子类重写父类的方法</p><h3 id="C-运算符重载"><a href="#C-运算符重载" class="headerlink" title="C++运算符重载"></a>C++运算符重载</h3><ol><li>在类内实现（类成员函数）的运算符重载<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 重载 + 运算符，用于把两个 Box 对象相加</span><br>    Box <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> Box&amp; b) <span class="hljs-comment">//第一个Box代表返回值类型</span><br>    &#123;<br>        Box box;<br>        box.length = <span class="hljs-keyword">this</span>-&gt;length + b.length;<br>        box.breadth = <span class="hljs-keyword">this</span>-&gt;breadth + b.breadth;<br>        box.height = <span class="hljs-keyword">this</span>-&gt;height + b.height;<br>        <span class="hljs-keyword">return</span> box;<br>    &#125;<br></code></pre></td></tr></table></figure></li><li>友元函数实现的运算符重载 (无this指针)<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 友元函数实现运算符重载 类中申明</span><br>    <span class="hljs-keyword">friend</span> Demo &amp; <span class="hljs-keyword">operator</span>+ (Demo &amp; demo, <span class="hljs-keyword">int</span> n);<br><span class="hljs-comment">//类外实现</span><br><br><span class="hljs-comment">// 重载 &quot;+&quot; 运算符</span><br>Demo &amp; <span class="hljs-keyword">operator</span>+ (Demo &amp; demo, <span class="hljs-keyword">int</span> n)<br>&#123;<br>    demo.a += n;<br>    <span class="hljs-keyword">return</span> demo;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ol><p>// C#好像没有this指针，即使是在成员函数实现重载方法，还是会传入两个对象</p><h3 id="C-内存管理和python内存管理"><a href="#C-内存管理和python内存管理" class="headerlink" title="C++内存管理和python内存管理"></a>C++内存管理和python内存管理</h3><ul><li>C++内存结构是 栈 堆 未初始化存储器， 静态/全局变量存储区， 数据段， 代码段<br>  内存分配使用new delete 或者malloc free<br>  new不仅分配内存，还会调用类的构造函数，malloc只分配内存，不会进行类的初始化工作<br>  但是在分配的时候，可能会出现内存泄漏问题，为了防止这样的情况发生，使用智能指针（shared_ptr, strong_ptr, weak_ptr）</li><li>python 内存管理机制<br>  引入了内存池的概念：预先在内存中申请一定数量的，大小相等的内存块留作备用，当有新的内存需求时，就先从内存池中分配内存给这个需求，不够之后再申请新的内存。这样做最显著的优势就是能够减少内存碎片，提升效率。<br>垃圾回收是：采用引用计数机制为主，标记-清除和分代回收机制为辅的策略。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 项目相关 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>图专题</title>
      <link href="/2022/05/05/leetcode/%E5%9B%BE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
      <url>/2022/05/05/leetcode/%E5%9B%BE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="图相关例题"><a href="#图相关例题" class="headerlink" title="图相关例题"></a>图相关例题</h2><h3 id="竞赛第四题-hard-lc2097-合法重新排列数对"><a href="#竞赛第四题-hard-lc2097-合法重新排列数对" class="headerlink" title="竞赛第四题 hard lc2097. 合法重新排列数对"></a>竞赛第四题 hard lc2097. 合法重新排列数对</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    map&lt;<span class="hljs-keyword">int</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; mp;<br>    map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; deg;<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; ans;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sn)</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;e = mp[sn]; <span class="hljs-comment">// 注意这个是引用</span><br>        <span class="hljs-keyword">while</span> (!e.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">int</span> fn = e.<span class="hljs-built_in">back</span>();<br>            e.<span class="hljs-built_in">pop_back</span>();<br>            <span class="hljs-built_in">dfs</span>(fn);<br>            ans.<span class="hljs-built_in">push_back</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;&#123;sn, fn&#125;);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//为什么要先dfs再push_back没看明白</span><br><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">validArrangement</span>(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; pairs) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;pair : pairs) &#123;<br>            mp[pair[<span class="hljs-number">0</span>]].<span class="hljs-built_in">push_back</span>(pair[<span class="hljs-number">1</span>]);<br>            deg[pair[<span class="hljs-number">0</span>]]--; deg[pair[<span class="hljs-number">1</span>]]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = deg.<span class="hljs-built_in">begin</span>(); it != deg.<span class="hljs-built_in">end</span>(); it++) <span class="hljs-keyword">if</span> (it-&gt;second == <span class="hljs-number">-1</span>) <span class="hljs-built_in">dfs</span>(it-&gt;first);<br>        <span class="hljs-keyword">if</span> (ans.<span class="hljs-built_in">empty</span>()) <span class="hljs-built_in">dfs</span>(deg.<span class="hljs-built_in">begin</span>()-&gt;first);<br>        <span class="hljs-built_in">reverse</span>(ans.<span class="hljs-built_in">begin</span>(), ans.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h3 id="有关于有向图和无向图的最短路径，以及有负边和无负边的最短路径"><a href="#有关于有向图和无向图的最短路径，以及有负边和无负边的最短路径" class="headerlink" title="有关于有向图和无向图的最短路径，以及有负边和无负边的最短路径"></a>有关于有向图和无向图的最短路径，以及有负边和无负边的最短路径</h3><ol><li><p>Dijstra算法，适用于单源，有向或者无向的最短路径，不能适用于有负边（注意不是负环，负环情况下，无最短路径）的情况：例子：-1， -5， 2<br>时间复杂度O(n^2))</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><br><br><span class="hljs-keyword">int</span> e[Max][Max];<span class="hljs-comment">//e[i][j]代表从i-&gt;j的距离，不通设为无穷大</span><br><span class="hljs-keyword">int</span> dis[Max];<span class="hljs-comment">//dis[i]代表从起点到i的最短距离</span><br><span class="hljs-keyword">bool</span> book[Max];<span class="hljs-comment">//book[i]代表点i是否在S中</span><br><span class="hljs-keyword">int</span> n;<span class="hljs-comment">//n个顶点</span><br><span class="hljs-keyword">int</span> s;<span class="hljs-comment">//起点</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-comment">//初始化dis数组</span><br>        dis[i]=e[s][i];<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-comment">//初始化book数组</span><br>        book[i]=<span class="hljs-number">0</span>;<br>    dis[s]=<span class="hljs-number">0</span>;<br>    book[s]=<span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n<span class="hljs-number">-1</span>;i++)<span class="hljs-comment">//Dijkstra算法核心语句  注意也是n-1次</span><br>    &#123;<br>        <span class="hljs-keyword">int</span> minDis=INF;<br>        <span class="hljs-keyword">int</span> k;<span class="hljs-comment">//找到与s最近的顶点k</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(book[j]==<span class="hljs-number">0</span> &amp;&amp; dis[j]&lt;minDis)<br>            &#123;<br>                minDis=dis[j];<br>                k=j;<br>            &#125;<br>        &#125;<br>        book[k]=<span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<span class="hljs-comment">//“松弛”过程</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(e[k][j]&lt;INF)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(dis[j]&gt;dis[k]+e[k][j])<br>                    dis[j]=dis[k]+e[k][j];<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>Bellman-ford算法：适用于单源，可有负权，有向或者无向的最短路径 记住只松弛n-1次<br>能够检测出有负环情况<br>dp[i][dst]=min(dp[i][dst], dp[i-1][src]+dist[src][dst]) i==1的时候表示经过的中转站为0</p></li></ol><p>时间复杂度O(n*m)/O(VE)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span>&#123;</span><br>    <span class="hljs-keyword">int</span> u;<span class="hljs-comment">//起</span><br>    <span class="hljs-keyword">int</span> v;<span class="hljs-comment">//终</span><br>    <span class="hljs-keyword">int</span> weight;<span class="hljs-comment">//长度</span><br>&#125;;<br><br>Edge edge[maxm];<span class="hljs-comment">//用来存储所有的边</span><br><span class="hljs-keyword">int</span> dis[maxn];<span class="hljs-comment">//dis[i]表示源点到i的最短距离</span><br><span class="hljs-keyword">int</span> n,m;<span class="hljs-comment">//n个点，m条边</span><br><span class="hljs-keyword">int</span> s;<span class="hljs-comment">//源点</span><br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Bellmen_ford</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-comment">//初始化</span><br>        dis[i]=INF;<br><br>    dis[s]=<span class="hljs-number">0</span>;<span class="hljs-comment">//源节点到自己的距离为0</span><br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)<span class="hljs-comment">//松弛过程，计算最短路径 </span><br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++) <span class="hljs-comment">//m条边</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(dis[edge[j].v]&gt;dis[edge[j].u]+edge[j].weight)<span class="hljs-comment">//比较s-&gt;v与s-&gt;u-&gt;v大小</span><br>                dis[edge[j].v]=dis[edge[j].u]+edge[j].weight;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)<span class="hljs-comment">//判断是否有负边权的边</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(dis[edge[j].v]&gt;dis[edge[j].u]+edge[j].weight)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>SPFA算法：是Bellman-ford算法的队列优化，适用于单源，可有负权，有向或者无向的最短路径 （自身其实无法处理负权）<br>设立一个队列用来保存待优化的点，优化时每次取出队首结点u，并且用u点当前的最短路径估计值对u点所指向的结点v进行松弛操作，如果v点的最短路径估计值有所调整，且v点不在当前的队列中，就将v点放入队尾。这样不断从队列中取出结点来进行松弛操作，直至队列空为止。</li></ol><p>注意，一旦从队列中弹出来，vis就设置为false，感觉负权的情况就会一直循环下去，不会跳出；遍历点，与边无关</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><br><br><span class="hljs-keyword">int</span> dis[MAX];<span class="hljs-comment">//dis[i]表示起点到i的最短距离</span><br><span class="hljs-keyword">bool</span> vis[MAX];<span class="hljs-comment">//是否访问过点i</span><br><span class="hljs-keyword">int</span> e[MAX][MAX];<span class="hljs-comment">//矩阵</span><br><br><span class="hljs-keyword">int</span> n,m;<span class="hljs-comment">//点和边的数量</span><br><span class="hljs-keyword">int</span> s;<span class="hljs-comment">//源点</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SPFA</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-comment">//初始化</span><br>    &#123;<br>        dis[i]=INF;<br>        vis[i]=<span class="hljs-literal">false</span>;<br>    &#125;<br>    queue&lt;<span class="hljs-keyword">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(s);<br>    dis[s]=<span class="hljs-number">0</span>;<br>    vis[s]=<span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        <span class="hljs-keyword">int</span> cur=q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        vis[cur]=<span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-comment">//遍历每一个节点</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(e[cur][i]!=INF&amp;&amp;dis[i]&gt;=dis[cur]+e[cur][i])<br>            &#123;<br>                dis[i]=dis[cur]+e[cur][i];<br>                <span class="hljs-keyword">if</span>(!vis[i])<br>                &#123;<br>                    vis[i]=<span class="hljs-literal">true</span>;<br>                    q.<span class="hljs-built_in">push</span>(i);  <span class="hljs-comment">///之后将start缩小的边才拿出来</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>Floyd算法： Floyd算法是一种利用动态规划思想的计算加权图中多源点之间最短路径的算法。可以正确处理有向图或负权的最短路径问题。</li></ol><p>时间复杂度：O(N^3）</p><p>空间复杂度：O(N^2）</p><p>处理问题：多源、可有负权、有向图、无向图最短路径 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> e[Max][Max];<span class="hljs-comment">//e[i][j]代表从i-&gt;j的距离，不通设为无穷大</span><br><span class="hljs-keyword">int</span> n;<span class="hljs-comment">//n个顶点</span><br><span class="hljs-comment">//Floyd算法</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Floyd</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;k++)<span class="hljs-comment">//遍历所有的中间点</span><br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-comment">//遍历所有的起点</span><br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<span class="hljs-comment">//遍历所有的终点</span><br>            &#123;<br>                <span class="hljs-keyword">if</span> (e[i][j]&gt;e[i][k]+e[k][j])<span class="hljs-comment">//如果当前i-&gt;j的距离大于i-&gt;k-&gt;j的距离之和</span><br>                    e[i][j]=e[i][k]+e[k][j];<span class="hljs-comment">//更新从i-&gt;j的最短路径</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最短路衍生拓展的一类题目"><a href="#最短路衍生拓展的一类题目" class="headerlink" title="最短路衍生拓展的一类题目"></a>最短路衍生拓展的一类题目</h3><h3 id="1-最长路径问题"><a href="#1-最长路径问题" class="headerlink" title="1. 最长路径问题"></a>1. 最长路径问题</h3><p>图不为非负权图：当存在正环时无解。<br>如果不存在正环，边权取负后使用Bellman-Ford算法求最短路。</p><h3 id="2-变形的最长路径"><a href="#2-变形的最长路径" class="headerlink" title="2. 变形的最长路径"></a>2. 变形的最长路径</h3><p>路径长度的计算是权重之间的乘积，而且权重都是0-1之间的值，使用Dijstra算法 （e.g概率最大的路径）<br>Solution:<br>    单独使用Dijstra会导致超时，因此需要结合Dijstra+优先队列<br>    1.现将src点push 到堆进行<br>    2.然后遍历堆中的每个节点，如果当前节点能够松弛它的邻接节点，那么就放入堆中，否则不放入类似于SPFA,但是不同的是，<br>    - 这个使用的优先队列，而SPFA是用的是一般的堆<br>    - 这个不仅仅push了节点，也push了当前节点的最大概率，因此没有vis数组来标记当前节点是否在堆中，因为即使在堆中， 概率也可能是不一样的。<br>    总的来说这道题使用bellman-ford算法更简单，只要当前没有任何松弛的边，那么直接退出循环</p><p>颜色交替的最短路径：使用bellman-ford算法（本质是动态规划）， 只是在距离的转换是需要讨论两种情况<br>dstEndWithRed[end]=min(dstEndWithRed[end], dstEndWithBlue[start]+1);<br>dstEndWithBlue[end]=min(dstEndWithBlue[end], dstEndWithRed[start]+1);</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> edge: redEdges)&#123;<br>        <span class="hljs-keyword">int</span> start=edge[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">int</span> end=edge[<span class="hljs-number">1</span>];<br>        dstEndWithRed[end]=<span class="hljs-built_in">min</span>(dstEndWithRed[end], dstEndWithBlue[start]+<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> edge: blueEdges)&#123;<br>        <span class="hljs-keyword">int</span> start=edge[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">int</span> end=edge[<span class="hljs-number">1</span>];<br>        dstEndWithBlue[end]=<span class="hljs-built_in">min</span>(dstEndWithBlue[end], dstEndWithRed[start]+<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-成语接龙的最长，使用bfs，同时对连接好的成语，再来一次bfs-微软三面"><a href="#3-成语接龙的最长，使用bfs，同时对连接好的成语，再来一次bfs-微软三面" class="headerlink" title="3. 成语接龙的最长，使用bfs，同时对连接好的成语，再来一次bfs (微软三面)"></a>3. 成语接龙的最长，使用bfs，同时对连接好的成语，再来一次bfs (微软三面)</h3><p><font color="red">4. lc787. K 站中转内最便宜的航班</font></p><ul><li>只能最多经过k个中转站的最短路径</li><li>使用bellman-ford算法，k个中转站就是松弛每条边 k+1次(1~k+1)，然后使用dp[i][dst]记录 中转i次的最短路径<br>最后的结果就是在dp[1][dst] 到dp[k+1][dst]中取最小的一个</li></ul><h3 id="4-lc6134-找到离给定两个节点最近的节点"><a href="#4-lc6134-找到离给定两个节点最近的节点" class="headerlink" title="4. lc6134. 找到离给定两个节点最近的节点"></a>4. lc6134. 找到离给定两个节点最近的节点</h3><ul><li>内向基环树</li><li>求出node1 到每个点的距离， 和node2 到每个点的距离，然后取最小 (两次求距离，然后取最小，最后注意返回的是最近的下标，而不是最近的距离)</li></ul><p>PS, 最开始理解的时候，感觉应该用两个节点的最近公共祖先来解决，但是因为图中可能有环，所以不能使用最近公共祖先的栈或者dfs方法解决</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数学相关问题</title>
      <link href="/2022/05/05/leetcode/%E6%95%B0%E5%AD%A6%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
      <url>/2022/05/05/leetcode/%E6%95%B0%E5%AD%A6%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="random类似题目"><a href="#random类似题目" class="headerlink" title="random类似题目"></a>random类似题目</h2><p>rand5 to rand7<br>rand01p to rand6<br>rand1toM to rand1toN<br>1）二维的方式，使得两个调用rand5在二维矩阵上是大于rand7，然后就可以选取7的倍数的一段距离对rand7取模</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">do</span>&#123;<br>    row=<span class="hljs-built_in">rand5</span>()<span class="hljs-number">-1</span>;<br>    col=<span class="hljs-built_in">rand5</span>()<span class="hljs-number">-1</span>;<br>    num=row*<span class="hljs-number">5</span>+col <span class="hljs-comment">//0-24之间</span><br>&#125;<span class="hljs-keyword">while</span>(num&gt;=<span class="hljs-number">21</span>)<br><br><span class="hljs-keyword">return</span> num%<span class="hljs-number">7</span>+<span class="hljs-number">1</span>;<br><br></code></pre></td></tr></table></figure><p>2）首先等概率产生0-1  01 10是等概率残生的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rand01</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">do</span>&#123;<br>        num=<span class="hljs-built_in">rand01p</span>();<br>    &#125;<span class="hljs-keyword">while</span>(num==<span class="hljs-built_in">rand01p</span>());<br>    <span class="hljs-keyword">return</span> num;<br>&#125;<br><br>那么rand03=<span class="hljs-built_in">rand01</span>()*<span class="hljs-number">2</span>+<span class="hljs-built_in">rand01</span>();<br>rand0<span class="hljs-number">-15</span>=<span class="hljs-built_in">rand03</span>()*<span class="hljs-number">4</span>+<span class="hljs-built_in">rand03</span>(); <span class="hljs-comment">//倍数+插空  用进制的方法可以产生rand07()=rand03()+rand01()*4</span><br>那么rand6可由如下产生:<br><span class="hljs-keyword">do</span>&#123;<br>    num=rand0<span class="hljs-number">-15</span>;<br>&#125;<span class="hljs-keyword">while</span>(num&gt;=<span class="hljs-number">12</span>)<br><span class="hljs-keyword">return</span> num%<span class="hljs-number">6</span>+<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>3）k维的方式<br>rand1toM()转为rand1toN()其实就是调用k次（用N的M进制可以求得）的rand1toM, 使得这a* M^(k-1)+b* M^(k-2)+……  +c 比n要小， 然后返回就可以了<br>其实就是用M进制的数来表示N-1，如果随机生成的数是大于N，那么从头进行生成（注意是从头，而不是从当前数重新生成），否则返回这个数<br>步骤：<br>   1、将n-1转换成m进制数，假设结果转换成数组为 k = [a,b,c,d,e]<br>　　2、使用rand1ToM(m)函数产生结果数组 res = [A,B,C,D,E]，如果res所表示的数值大于k所表示的数值，将res丢掉重新随机，直到产生的结果小于或等于k，这时产生的res的范围就在0～n-1之间，但是此时res所表示的数还是m进制的。 //随机生成M进制的每一位数<br>　　3、将res数组转换成10进制整数。<br>　　4、将步骤3的结果加1就是最终的结果。</p><h2 id="数字运算相关例题"><a href="#数字运算相关例题" class="headerlink" title="数字运算相关例题"></a>数字运算相关例题</h2><h3 id="1-求num阶层中最后的包含0的个数"><a href="#1-求num阶层中最后的包含0的个数" class="headerlink" title="1. 求num阶层中最后的包含0的个数"></a>1. 求num阶层中最后的包含0的个数</h3><p>因为包含因子2的个数一定比5多，因此可以直接求包含因子5的个数<br>每5个数有一个5，每25个数中有一个数包含两个5<br>同样下面的模板可以用于求任何因子的个数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(num)&#123;<br>        res+=num/<span class="hljs-number">5</span>;<br>        num=num/<span class="hljs-number">5</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-判断一个点是否在矩形中：叉乘-点乘"><a href="#2-判断一个点是否在矩形中：叉乘-点乘" class="headerlink" title="2. 判断一个点是否在矩形中：叉乘+点乘"></a><font color="blue">2. 判断一个点是否在矩形中：叉乘+点乘</font></h3><p>对角向量叉积的点积&gt;=0,（对角向量的叉积方向相同），使用叉积的原因是：一个点在线外还是在线内，叉积的正负不同<br>使用叉积可以判断方向，A = &lt;a1, a2&gt;，B = &lt;b1, b2&gt;<br>AXB=a1* b2-a2 *b1, 叉积向量的方向为法线的方向，上下为第一个向量指向第二个向量，大手指的方向<br>叉乘加内积</p><p>(p1 p2 X p1 p ) * (p3 p4 X p3 p1)  &gt;= 0  （四个边分成两组，每两个对边一组， 看两边的叉积是否同方向）</p><h3 id="3-相同的题型：判断点是否在三角形中-叉乘"><a href="#3-相同的题型：判断点是否在三角形中-叉乘" class="headerlink" title="3. 相同的题型：判断点是否在三角形中 叉乘"></a><font color="blue">3. 相同的题型：判断点是否在三角形中 叉乘</font></h3><p>1）先判断三个点的顺序是否是逆时针方向:逆时针方向叉积小于0；顺时针方向叉积大于等于（注意顺序可能导致结果不同！！！）；如果是顺时针正方向，那么调整点位置<br>2）然后判断这个点x是否都是在三角形每条边的左边，判断过程：三角形每个顶点和边的叉积小于0</p><p>（逆时针，点左侧；判断逆时针，仍然使用点左侧）</p><p>求三个三角形不推荐，因为double类型可能出现误差</p><p>PS:lc478. 在圆内随机生成点(Pony.AI)</p><ol><li>拒绝采样，在矩形中采样，如果点距离中心的位置大于半径的话，那么就重新采样</li><li>在（0-p^2）中随机采样然后开方，在（0，2*pi）中随机采样，然后使用极坐标 p * cos(theta),p * sin(theta)</li></ol><h3 id="4-路径数组转为统计数组的题目：原地hash-注意以负数作为标记的话，全部的数都需要转为正数"><a href="#4-路径数组转为统计数组的题目：原地hash-注意以负数作为标记的话，全部的数都需要转为正数" class="headerlink" title="4. 路径数组转为统计数组的题目：原地hash, 注意以负数作为标记的话，全部的数都需要转为正数"></a><font color="red">4. 路径数组转为统计数组的题目：原地hash, 注意以负数作为标记的话，全部的数都需要转为正数</font></h3><p>要求额外的空间复杂度为O(1)<br>如果要实现空间复杂度为O(1),那么需要在原来的数据上进行运算，那么每个位置存储跳过来的位置（最开始节点存储为-1），直到当前的数为一个负数（表示已经求过距离），然后跳回去的时候就知道来的位置，同时更新当前的距离，<br>为了区分已经判断过的值和未判断过的值，使用负数；求到距离矩阵之后再计算每个距离出现的次数，仍然是使用跳的方式，开始节点记得赋值为0，表示已经访问计算过</p><p>这种方式也出现在”第一个未出现的正数“这道题解决方案中（值与下标相互映射）</p><h3 id="5-正数数组的最小不可组成和"><a href="#5-正数数组的最小不可组成和" class="headerlink" title="5. 正数数组的最小不可组成和"></a>5. 正数数组的最小不可组成和</h3><p>dp[0][0]=1<br>使用动态规划<br>for j=0; j=arr.size(); j++:<br>    for i = sum to min: //注意反着,因为一个数只能取一次0-1背包<br>        if(i&gt;=arr[j]):<br>            dp[i]=dp[i-arr[j]]?True:dp[i]//注意是dp[i]而不是false,也不是dp[i]=dp[i-arr[i]]//因为可能一个数一种方式可以组成，但是另一种不行</p><p>PS:没有思路就想暴力算法，然后递归考虑是否能转为动态规划，类似背包问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++">dp[i][j]=dp[i<span class="hljs-number">-1</span>][j-arr[i]]||dp[i<span class="hljs-number">-1</span>][j];<br><br><span class="hljs-keyword">for</span> i in min to sum:<br>    <span class="hljs-keyword">if</span> dp[n][i] == <span class="hljs-literal">false</span>:<br>        <span class="hljs-keyword">return</span> i<br></code></pre></td></tr></table></figure><h3 id="6-累加出整个范围最少还需要的数"><a href="#6-累加出整个范围最少还需要的数" class="headerlink" title="6. 累加出整个范围最少还需要的数"></a>6. 累加出整个范围最少还需要的数</h3><p>使用当前可以累加得到的范围，如果范围超过了当前遍历到的arr的第一个数，那么下一个可以累加得到的范围是当前的范围+arr[i];否则下一个差的数应该是touch+1,可以累加得到的数是touch+1+touch</p><p>可以累加得到的数是touch,下一个差的数是touch+1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++">touch=<span class="hljs-number">0</span>;<br>cnt=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;arr.<span class="hljs-built_in">size</span>();i++)&#123;<br>    <span class="hljs-keyword">if</span>(touch+<span class="hljs-number">1</span>&lt;arr[i])&#123;<br>        <span class="hljs-keyword">while</span>(touch&lt;arr[i]+<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//注意这是循环</span><br>            touch+=touch+<span class="hljs-number">1</span>;<br>            cnt++;<br>            <span class="hljs-keyword">if</span>(touch&gt;=range)&#123;<br>                <span class="hljs-keyword">return</span> cnt;<br>            &#125;<br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        touch+=arr[i];<br>        <span class="hljs-keyword">if</span>(touch&gt;=range)&#123;<br>            <span class="hljs-keyword">return</span> cnt;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">while</span>(touch&lt;range)&#123;<br>        touch+=touch+<span class="hljs-number">1</span>;<br>        cnt++;    <br>&#125;<br><br>    <span class="hljs-keyword">return</span> cnt;<br></code></pre></td></tr></table></figure><h3 id="7-一种字符串和数字对应的关系-（lc168-Excel表列名称）"><a href="#7-一种字符串和数字对应的关系-（lc168-Excel表列名称）" class="headerlink" title="7. 一种字符串和数字对应的关系 （lc168. Excel表列名称）"></a>7. 一种字符串和数字对应的关系 （lc168. Excel表列名称）</h3><p>A -&gt; 1<br>B -&gt; 2<br>C -&gt; 3<br>…<br>Z -&gt; 26<br>AA -&gt; 27<br>AB -&gt; 28<br>从 1开始的的 2626 进制转换题。（每一位至少都有1）</p><ul><li><p>方法1：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++">string res=<span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">while</span>(columnNumber&gt;<span class="hljs-number">0</span>)&#123;<br>    columnNumber--;<br>    res+=(columnNumber%<span class="hljs-number">26</span>+<span class="hljs-string">&#x27;A&#x27;</span>);<br>    columnNumber/=<span class="hljs-number">26</span>;<br>&#125;<br><span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>());<br><span class="hljs-keyword">return</span> res;<br></code></pre></td></tr></table></figure></li><li><p>方法2：注意是K伪进制数，也就是每一个伪至少为1不能为0，因此需要先从右往左计算位数（同时每一位分得1, 因为这个规则每一位至少都有1），然后从左往右分剩下的数字 </p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//先从右往左，减掉一轮，再从左往右看补在哪为 进制如果为3：base=1 3 9</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">int2str</span><span class="hljs-params">()</span></span>&#123;<br>    cur=<span class="hljs-number">1</span>;<span class="hljs-comment">//代表进制的基数</span><br>    k=<span class="hljs-number">0</span><span class="hljs-comment">//代表位数</span><br>    base=<span class="hljs-number">3</span><span class="hljs-comment">//代表进制数，多少个字符就是多少进制</span><br>    <span class="hljs-keyword">while</span>(n&gt;=cur)&#123;<br>        k++;<br>        n-=cur;<br>        cur*=base;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> index=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(k)&#123;<br>        cur/=base;<br>        res[index++]=<span class="hljs-built_in">getchar</span>(n/cur);  <span class="hljs-comment">//当前base的数量应该为n/cur+1,对应的下标就是n/cur</span><br>        n=n%cur; <span class="hljs-comment">//剩下的数可以分多少到下一个进制位中</span><br>        k--;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>str2int类似于K进制</p><p>从N个数中等概率打印M个数,空间复杂度为O(1)：将每次打印的数每次交换到整个数组的末尾，然后下次在生成随机数的时候，减少生成范围（1，n-count）</p><h3 id="8-数字的中文表达和英文表达"><a href="#8-数字的中文表达和英文表达" class="headerlink" title="8. 数字的中文表达和英文表达"></a>8. 数字的中文表达和英文表达</h3><ul><li>1.中文表达：对于零特殊处理</li><li>2.英文表达：每三个一组进行处理；使用递归或者迭代。递归方式就是分别求出billion million和thousand三个部分的数字，然后加起来，<br>在求每个部分的时候，先判断百位，如果百位有数字的话，那么加上”hundred“,否则分为数字&lt;=10 &lt;20; &lt;=20 &lt;100 and &lt;10 三种情况进行处理</li></ul><h3 id="9-实现sqrt函数"><a href="#9-实现sqrt函数" class="headerlink" title="9. 实现sqrt函数"></a>9. 实现sqrt函数</h3><ul><li><p>方法一：使用二分算法（一个数的平方根不会大于 n/2+1），标准二分，返回right</p></li><li><p>方法二：牛顿迭代算法： y=f(x0)+k(x-x0)<br>令y=0, 得到 x_i+1=(x_i+ C/x_i)  其中C为要求的目标</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">double</span> C = x, x0 = x;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">double</span> xi = <span class="hljs-number">0.5</span> * (x0 + C / x0);<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(x0 - xi) &lt; <span class="hljs-number">1e-7</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            x0 = xi;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(x0);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><h3 id="10-进制转换"><a href="#10-进制转换" class="headerlink" title="10. 进制转换"></a>10. 进制转换</h3><p>小数的十进制转为二进制是*2 取整数部分，如果整数&gt;=1, 那么num-=1,否则当前位为0， 直到num=0; 也可以1连除2，num如果num&gt;base,那么减去base<br>十进制整数转换为二进制整数采用”除2取余，逆序排列”法<br>十进制小数转换成二进制小数采用”乘2取整，顺序排列”法</p><h3 id="11-全排列问题"><a href="#11-全排列问题" class="headerlink" title="11. 全排列问题"></a>11. 全排列问题</h3><p>使用交换或者vis+回溯，一定要注意是否有重复的字符，如果有重复的字符，那么下一个交换或者选择的数，一定是当前没有选择的 （可以和当前自己位置进行交换）</p><h3 id="12-树状数组例题"><a href="#12-树状数组例题" class="headerlink" title="12. 树状数组例题"></a><font color="red">12. 树状数组例题</font></h3><ul><li><p>数字流的秩 线段树（平衡树+二叉搜索树，需要初始化4*n区间） 使用频繁更新数组的某一位（后面的位数也需要相应修改），以及求前缀和</p></li><li><p>线段树和树状数组的基本功能都是在某一满足结合律的操作(比如加法，乘法，最大值，最小值)下，O(logn)的时间复杂度内修改单个元素并且维护区间信息。不同的是，树状数组只能维护前缀“操作和”(前缀和，前缀积，前缀最大最小)，而线段树可以维护区间操作和。线段数组是真正的数，而树状数组只是一个数组</p></li><li><p>树状数组主要是用于求前缀和，（改变原始然后求前缀和；差分数组适用于，某一段的元素被整体加上或者减去一个元素）</p><ul><li>区间查询：求index的前缀和其实就是不断将index的二进制数的最后一个一个1逐渐变为0 的数据对应的值相加；（x-(x&amp;-x)）//不断地去掉二进制数最右边的一个1 （从x到=n）</li><li>单点修改：更新一个index需要更新的其他下标的值相当于 不断加上最后一个1所代表的数字下标对应的值（x+(x&amp;-x)）//从右边起一系列连续的1变为0，再把这一系列1的前一位0变为1,相当与最后一个1+1，导致连续进位<br>其中存储值的下标从1开始，0下标主要是判断循环的终点，不被用来存储值 （从x到0）</li></ul></li><li><p>树状数组的下标从1开始，常用于频繁更新和频繁求前缀和</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++">建立树状数组：<br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">int</span> a[<span class="hljs-number">1005</span>],c[<span class="hljs-number">1005</span>]; <span class="hljs-comment">//对应原数组和树状数组</span><br><span class="hljs-comment">//范围是[1,n]</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> x&amp;(-x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">updata</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> k)</span></span>&#123;    <span class="hljs-comment">//在i位置加上k</span><br>    <span class="hljs-keyword">while</span>(i &lt;= n)&#123;<br>        c[i] += k;<br>        i += <span class="hljs-built_in">lowbit</span>(i);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getsum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;        <span class="hljs-comment">//求A[1 - i]的和</span><br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i &gt; <span class="hljs-number">0</span>)&#123;<br>        res += c[i];<br>        i -= <span class="hljs-built_in">lowbit</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>树状数组如果输入有0， 那么所有的输入都应该向右边偏移以为（输入x，实际上对应x+1）</p></li></ul><h3 id="lc5999-统计数组中好三元组数目"><a href="#lc5999-统计数组中好三元组数目" class="headerlink" title="lc5999. 统计数组中好三元组数目"></a>lc5999. 统计数组中好三元组数目</h3><p>这道题是求在一个数的左边，同时小于这个数的数量（数量题）<br>lc307. 区域和检索 - 数组可修改</p><ul><li>这道题是，频繁的修改某个下标的元素值+同时求某个范围元素之间的元素和（值题目）</li><li>数组的大小为arr的范围n， 下标对于树状数组的二进制下标</li><li>需要先将num的值插入树状数组中， 然后更新的时候使用newvalue-ori[index]来更新当前节点后面的值，同时一定要记得更新ori[index]=newvalue !!!!</li><li>一定要记得树状数组的下标是从1开始，但是num的下标从0开始；而且区间范围是两边闭合，所以求区间差的时候，left_index应该减1</li></ul><h3 id="lc315-计算右侧小于当前元素的个数（hard）"><a href="#lc315-计算右侧小于当前元素的个数（hard）" class="headerlink" title="lc315. 计算右侧小于当前元素的个数（hard）"></a><font color="red">lc315. 计算右侧小于当前元素的个数（hard）</font></h3><ul><li>注意这道题数据可能为负数，因此需要对数据+10000+1 使数据shift到[1, +无穷]</li><li>使用归并排序，每个i, j 那么num[i]+=j-i-1 (就是在i后面而且比nums[i]小的数的数量)<br>归并排序易错点：需要使用索引数组,同时在进行归并的时候会修改索引数组，一定要记得复制一个新的数组出来，不能使用原来的数组；其次就是注意数组的范围，左右都闭合；归并排序还长用于计算逆序对</li></ul><h3 id="lc493-翻转对-hard"><a href="#lc493-翻转对-hard" class="headerlink" title="lc493. 翻转对(hard)"></a>lc493. 翻转对(hard)</h3><ul><li>归并排序</li><li>范围映射的树状数组（具体代码可见模板代码）</li></ul><h3 id="13-最佳直线，使用暴力枚举的方式，-三重循环"><a href="#13-最佳直线，使用暴力枚举的方式，-三重循环" class="headerlink" title="13. 最佳直线，使用暴力枚举的方式， 三重循环"></a>13. 最佳直线，使用暴力枚举的方式， 三重循环</h3><p>枚举直线两个起始端点(i, j)，后面遍历k是否在直线(i, j)上，在的话计算过得点个数进行更新， 最后判断这条直线上最多有多少个同点<br>时间复杂度：O(n^3)<br>空间复杂度：O(1)O(1)</p><h3 id="14-枚举题"><a href="#14-枚举题" class="headerlink" title="14. 枚举题"></a>14. 枚举题</h3><p>模式匹配问题，暂时未做，主要是通过a和b的数量来枚举a匹配的字符的长度和b字符的长度，主要是注意边界情况应该先于长度的枚举进行判断<br>    example： pattern = “abba”, value = “dogcatcatdog”<br>    注意：pattern只包含字母”a”和”b”两种字符， 而且a或者b可以为空串， 而且a 与b映射的字符串不应该相等<br>    lena lenb都为0; lena为0; lenb为0;lena lenb都不为0时， 他们映射的字符串不应该相等</p><h3 id="15-大数相乘的题目"><a href="#15-大数相乘的题目" class="headerlink" title="15. 大数相乘的题目"></a>15. 大数相乘的题目</h3><ul><li>使用第二个数的每一位数和第一个数相乘&lt;&lt; i 位，然后将求得的结果相加</li><li>使用第一个数的每一位和第二个数相乘，更新结果的 arr[i+k]位</li></ul><h3 id="16-矩形覆盖面积"><a href="#16-矩形覆盖面积" class="headerlink" title="16. 矩形覆盖面积"></a>16. 矩形覆盖面积</h3><ul><li>公式为:<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">area1<span class="hljs-operator">+</span>area2<span class="hljs-operator">-</span>inter_area<br>inter_area <span class="hljs-operator">=</span> <span class="hljs-built_in">max</span>((最小 右上横坐标 <span class="hljs-operator">-</span> 最大左下横坐标), <span class="hljs-number">0</span>)<span class="hljs-operator">*</span> <span class="hljs-built_in">max</span>(（最小右上纵坐标 <span class="hljs-operator">-</span>  最大左下纵坐标, <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure>注意一定要和0进行比较</li></ul><h3 id="16-找众数II"><a href="#16-找众数II" class="headerlink" title="16. 找众数II"></a>16. 找众数II</h3><ul><li>使用hash算法</li><li>使用摩尔投票算法</li></ul><p>找到超过 (n/3) 向下取整的数：数学证明这样的数最多2个，选两个数，如果当前的数都不等于前两个数，那么两个投票数都–<br>这种投票算法同样适用于找到超过 n/2</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">majorityElement</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; ans;<br>        <span class="hljs-keyword">int</span> element1 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> element2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> vote1 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> vote2 = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp; num : nums) &#123;<br>            <span class="hljs-keyword">if</span> (vote1 &gt; <span class="hljs-number">0</span> &amp;&amp; num == element1) &#123; <span class="hljs-comment">//如果该元素为第一个元素，则计数加1</span><br>                vote1++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (vote2 &gt; <span class="hljs-number">0</span> &amp;&amp; num == element2) &#123; <span class="hljs-comment">//如果该元素为第二个元素，则计数加1</span><br>                vote2++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (vote1 == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 选择第一个元素</span><br>                element1 = num;<br>                vote1++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (vote2 == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 选择第二个元素</span><br>                element2 = num;<br>                vote2++;<br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//如果三个元素均不相同，则相互抵消1次</span><br>                vote1--;<br>                vote2--;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> cnt1 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> cnt2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp; num : nums) &#123;<br>            <span class="hljs-keyword">if</span> (vote1 &gt; <span class="hljs-number">0</span> &amp;&amp; num == element1) &#123;<br>                cnt1++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (vote2 &gt; <span class="hljs-number">0</span> &amp;&amp; num == element2) &#123;<br>                cnt2++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 检测元素出现的次数是否满足要求</span><br>        <span class="hljs-keyword">if</span> (vote1 &gt; <span class="hljs-number">0</span> &amp;&amp; cnt1 &gt; nums.<span class="hljs-built_in">size</span>() / <span class="hljs-number">3</span>) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(element1);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (vote2 &gt; <span class="hljs-number">0</span> &amp;&amp; cnt2 &gt; nums.<span class="hljs-built_in">size</span>() / <span class="hljs-number">3</span>) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(element2);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h3 id="17-为运算表达式计算优先级"><a href="#17-为运算表达式计算优先级" class="headerlink" title="17. 为运算表达式计算优先级"></a>17. 为运算表达式计算优先级</h3><p>使用分治算法, 遍历表达式，找到运算符，将结果分成两个部分， 递归查找。类似二叉树的组成方式查找<br>如果求具体的结果，那么需要使用vector将结果进行push_back,否则可以直接使用动态规划，计算总数</p><h3 id="18-摆动序列"><a href="#18-摆动序列" class="headerlink" title="18. 摆动序列"></a>18. 摆动序列</h3><p>如果是需要相邻两个数不能等于的话，只能两个字符串都进行翻转，如果可以相邻等于的话，可以后面的字符串进行翻转就行了 </p><h3 id="19-中文变为阿拉伯数字和阿拉伯数字变为中文"><a href="#19-中文变为阿拉伯数字和阿拉伯数字变为中文" class="headerlink" title="19. 中文变为阿拉伯数字和阿拉伯数字变为中文"></a>19. 中文变为阿拉伯数字和阿拉伯数字变为中文</h3><p>1.中文变为阿拉伯数字<br>使用栈，将文字划分为数字和量纲，遇到量纲，那么从栈中弹出与当前量纲小的数字与当前量纲相乘，然后不断累加，知道栈为空或者栈顶量纲比当前量纲大，然后将当前累加到的数压入栈中；最后的结果就是栈中的数求和</p><p>2.阿拉伯数字变为中文<br>注意：亿，万节之后如果只有0那么不需要输出0，如果千位为0的话那么需要输出0<br>10500，一万零五百， 15000一万五千</p><p>将数组划分为节，然后每节使用一个函数判断<br>如果不是第一节，而且当前的数是大于0，而且小于1000的话那么需要加零</p><h3 id="20-面试题-16-14-最佳直线-149-直线上最多的点数"><a href="#20-面试题-16-14-最佳直线-149-直线上最多的点数" class="headerlink" title="20. 面试题 16.14. 最佳直线/149. 直线上最多的点数"></a>20. 面试题 16.14. 最佳直线/149. 直线上最多的点数</h3><ul><li>暴力方法：使用三重循环，前两个点固定一条直线，后一个点判断是否在直线上，是cnt++,最后找最大的cnt</li><li>hash方法，使用二重循环，遍历两个点，两个点得到一个斜率，然后hash_map中存储该斜率的cnt, 最后取最大值的时候res=max(res, cnt+1)//一定记得+1<br>  因为gcd(5, 0)=5=cd(0, 5) 所以不存在除0情况<br>  斜率为0和正无穷的方法分别特判<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> a = x1 - x2, b = y1 - y2;<br><span class="hljs-keyword">int</span> k = <span class="hljs-built_in">gcd</span>(a, b);<br>String key = (a / k) + <span class="hljs-string">&quot;_&quot;</span> + (b / k); <span class="hljs-comment">//斜率用string存储</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> b == <span class="hljs-number">0</span> ? a : <span class="hljs-built_in">gcd</span>(b, a % b);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="21-阶层之后的零"><a href="#21-阶层之后的零" class="headerlink" title="21. 阶层之后的零"></a>21. 阶层之后的零</h3><ul><li> 方法1， 直接计算，n是5的倍数的个数+25倍数个数+…<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> pow=<span class="hljs-number">5</span>;<br><span class="hljs-keyword">while</span>(n&gt;=pow)&#123;<br>    cnt+=n/pow;<br>    pow=pow*<span class="hljs-number">5</span>;<br>&#125;<br><span class="hljs-keyword">return</span> cnt;<br></code></pre></td></tr></table></figure></li><li>方法2， 对1-n中的每一个数计算，能够拆分为多少个5的因子<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">int</span> tmp=i;<br><span class="hljs-keyword">while</span>(tmp%<span class="hljs-number">5</span>==<span class="hljs-number">0</span>)&#123;<br>    tmp=tmp/<span class="hljs-number">5</span>;<br>    cnt++;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="22-lc277-find-the-celebrity"><a href="#22-lc277-find-the-celebrity" class="headerlink" title="22. lc277. find-the-celebrity"></a>22. lc277. find-the-celebrity</h3><ul><li>所有的人都认识名人，名人谁都不认识，找出名人</li><li>假设法，O(n), 假设0是名人，如果遇到knows(0, i)==true, 说明0不是名人，同时说明[0~i-1]都不是名人，因为他们都不被0知道</li><li>之后再判断一次，如果出现know(ans, i)==true||know(i, ans)==false, 返回-1</li></ul><h3 id="23-欧拉筛法-埃及筛法求n以内的质数的个数-一个数的包含的因数的个数"><a href="#23-欧拉筛法-埃及筛法求n以内的质数的个数-一个数的包含的因数的个数" class="headerlink" title="23. 欧拉筛法/埃及筛法求n以内的质数的个数/一个数的包含的因数的个数"></a>23. 欧拉筛法/埃及筛法求n以内的质数的个数/一个数的包含的因数的个数</h3><p><a href="http://oi-wiki.com/math/number-theory/sieve/#_10">筛法 - OI Wiki</a></p><h2 id="蓄水池抽样算法"><a href="#蓄水池抽样算法" class="headerlink" title="蓄水池抽样算法"></a>蓄水池抽样算法</h2><p>模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Solution</span>(ListNode* head) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;head=head;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getRandom</span><span class="hljs-params">()</span> </span>&#123;<br>        ListNode*cur=<span class="hljs-keyword">this</span>-&gt;head;<br>        <span class="hljs-keyword">int</span> pool=<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(cur)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">rand</span>()%i==<span class="hljs-number">0</span>)pool=cur-&gt;val; <span class="hljs-comment">//只选取一个数的情况</span><br>            i++;<br>            cur=cur-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pool;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    ListNode*head;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>例题：</p><ol><li>链表随机节点</li><li>随机索引数 ，找到target数的随机一个index</li></ol><h2 id="摩尔投票算法"><a href="#摩尔投票算法" class="headerlink" title="摩尔投票算法"></a>摩尔投票算法</h2><h3 id="1-求众数"><a href="#1-求众数" class="headerlink" title="1.求众数"></a>1.求众数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> target_num=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>    <span class="hljs-keyword">if</span>(k==<span class="hljs-number">0</span>)&#123;<br>        target_num=nums[i];<br>        k=<span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">if</span>(nums[i]==target_num)&#123;<br>            k++;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            k--;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//判断target_num的数是否大于n/2;</span><br><span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>    <span class="hljs-keyword">if</span>(nums[i]==target_num)&#123;<br>        cnt++;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">if</span>(cnt&gt;n/<span class="hljs-number">2</span>)&#123;<br>    <span class="hljs-keyword">return</span> target_num;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-求大于n-3-的数"><a href="#2-求大于n-3-的数" class="headerlink" title="2.求大于n/3 的数"></a>2.求大于n/3 的数</h3><p>这样的数最多只有两个</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> k1=<span class="hljs-number">0</span>;<span class="hljs-comment">//投票的数量</span><br><span class="hljs-keyword">int</span> k2=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> target_num1;<span class="hljs-comment">//具体的数</span><br><span class="hljs-keyword">int</span> target_num2;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>    <span class="hljs-keyword">if</span>(k1&gt;<span class="hljs-number">0</span>&amp;&amp;target_num1==nums[i])&#123;<br>        k1++;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(k2&gt;<span class="hljs-number">0</span>&amp;&amp;target_num2==nums[i])&#123;<br>        k2++;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(k1==<span class="hljs-number">0</span>)&#123;<br>        target_num1=nums[i];<br>        k1=<span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(k2==<span class="hljs-number">0</span>)&#123;<br>        target_num2=nums[i];<br>        k2=<span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        k1--;<br>        k2--;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">int</span> cnt1=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> cnt2=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>    <span class="hljs-keyword">if</span>(k1&gt;<span class="hljs-number">0</span>&amp;&amp;nums[i]==target_num1)&#123;<br>        cnt1++;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(k2&gt;<span class="hljs-number">0</span>&amp;&amp;nums[i]==target_num2)&#123;<br>        cnt2++;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">if</span>(cnt1&gt;n/<span class="hljs-number">3</span>)&#123;<br>    res.<span class="hljs-built_in">push_back</span>(target_num1);<br>&#125;<br><span class="hljs-keyword">if</span>(cnt2&gt;n/<span class="hljs-number">3</span>)&#123;<br>    res.<span class="hljs-built_in">push_back</span>(target_num2);<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="3-剑指-Offer-20-表示数值的字符串"><a href="#3-剑指-Offer-20-表示数值的字符串" class="headerlink" title="3. 剑指 Offer 20. 表示数值的字符串"></a>3. 剑指 Offer 20. 表示数值的字符串</h3><ol><li>这道题可以用，先搜索一个整数，然后如果遇到点，搜索一个无符号整数，或者不变；遇到E搜索一个整数<br>然后就实现搜索一个整数和搜索一个无符号整数两个函数就可以了(剑指offer上面的答案)</li><li>第二种方法就是使用<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">bool <span class="hljs-attribute">isE</span>=<span class="hljs-literal">false</span>;<br>bool <span class="hljs-attribute">isNum</span>=<span class="hljs-literal">false</span>;<br>bool <span class="hljs-attribute">isPoint</span>=<span class="hljs-literal">false</span>;<br>bool <span class="hljs-attribute">isSymbol</span>=<span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure>每当遇到. E 判断前面的flag, 同时设置当前的flag</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>除掉最后一个1的方法是： <code>n&amp;(n-1)</code></li><li>只取最后一个1的方法是： <code>n&amp;(~n+1)</code></li></ol>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Zsim编译</title>
      <link href="/2022/04/26/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/zsim%E7%BC%96%E8%AF%91/"/>
      <url>/2022/04/26/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/zsim%E7%BC%96%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<h2 id="服务器环境"><a href="#服务器环境" class="headerlink" title="服务器环境"></a>服务器环境</h2><p>ubuntu18.04下gcc7.5.0</p><h2 id="主要参考文档"><a href="#主要参考文档" class="headerlink" title="主要参考文档"></a>主要参考文档</h2><p>步骤文档：<br><a href="https://blog.csdn.net/yy1348046572/article/details/118194214">ubuntu18.04下gcc7.5.0安装zsim_zsim安装-CSDN博客</a><br>注意使用sudo make &amp;&amp; sudo make install</p><p>安装zsim版本：<a href="https://github.com/SteveY4ng/zsim">GitHub - SteveY4ng/zsim: A fast and scalable x86-64 multicore simulator</a></p><p>除此之外，自己加了一个env.sh文件来添加环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">BASEDIR=$(<span class="hljs-built_in">pwd</span>)<br>PINPATH=<span class="hljs-variable">$BASEDIR</span>/pin-2.14<br>ZSIMPATH=<span class="hljs-variable">$BASEDIR</span>/zsim<br>LIBCONFIGPATH=/nfs/home/siling/zsim/zsim-ubuntu18_04/libconfig-1.7.3<br>HDF5PATH=/nfs/home/siling/zsim/zsim-ubuntu18_04/hdf5-1.12.0<br><span class="hljs-built_in">export</span> CPATH=<span class="hljs-string">&quot;/usr/include/hdf5/serial/&quot;</span><br><span class="hljs-built_in">export</span> ZSIMPATH PINPATH LIBCONFIGPATH POLARSSLPATH<br><span class="hljs-built_in">export</span> CXX=g++ CC=gcc<br></code></pre></td></tr></table></figure><h2 id="遇到的问题及解决方案"><a href="#遇到的问题及解决方案" class="headerlink" title="遇到的问题及解决方案"></a>遇到的问题及解决方案</h2><h3 id="1-在安装hdf5使用源文件，出错，因此使用的命令安装-sudo-apt-get-install-libhdf5-dev"><a href="#1-在安装hdf5使用源文件，出错，因此使用的命令安装-sudo-apt-get-install-libhdf5-dev" class="headerlink" title="1. 在安装hdf5使用源文件，出错，因此使用的命令安装 sudo apt-get install libhdf5-dev"></a>1. 在安装hdf5使用源文件，出错，因此使用的命令安装 sudo apt-get install libhdf5-dev</h3><p><a href="https://blog.csdn.net/tianminggenie/article/details/110921264">ubuntu 16.04 安装 hdf5-1.12  c++库_ubuntu hdf5 c动态库安装-CSDN博客</a></p><h3 id="2-hdf5文件错误1"><a href="#2-hdf5文件错误1" class="headerlink" title="2. hdf5文件错误1"></a>2. hdf5文件错误1</h3><blockquote><p>Can’t find file #include&lt;hdf5.h&gt;</p></blockquote><p>解决方案：<br>在env.sh中加上</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">CPATH</span>=<span class="hljs-string">&quot;/usr/include/hdf5/serial/&quot;</span><br></code></pre></td></tr></table></figure><h3 id="3-hdf5文件错误2"><a href="#3-hdf5文件错误2" class="headerlink" title="3. hdf5文件错误2"></a>3. hdf5文件错误2</h3><blockquote><p>Cannot find -lhdf5_hl and -lhdf5</p></blockquote><p>解决方案：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">cd</span> /usr/lib/x86_64-linux-gnu<br>然后根据情况执行下面两句：<br>sudo <span class="hljs-keyword">ln</span> -s libhdf5_serial.<span class="hljs-keyword">so</span>.<span class="hljs-number">10.1</span>.<span class="hljs-number">0</span> libhdf5.<span class="hljs-keyword">so</span><br>sudo <span class="hljs-keyword">ln</span> -s libhdf5_serial_hl.<span class="hljs-keyword">so</span>.<span class="hljs-number">10.0</span>.<span class="hljs-number">2</span> libhdf5_hl.<span class="hljs-keyword">so</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具相关 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MacOS 环境配置</title>
      <link href="/2022/04/23/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/Macos/"/>
      <url>/2022/04/23/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/Macos/</url>
      
        <content type="html"><![CDATA[<h3 id="1-macos上下载brew"><a href="#1-macos上下载brew" class="headerlink" title="1. macos上下载brew:"></a>1. macos上下载brew:</h3><p><code>/bin/zsh -c &quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot;</code></p><h3 id="2-macos-vscode-配置-opencv-C"><a href="#2-macos-vscode-配置-opencv-C" class="headerlink" title="2. macos vscode 配置 opencv(C++)"></a>2. macos vscode 配置 opencv(C++)</h3><p>切换opencv的版本：<br><a href="https://zhuanlan.zhihu.com/p/121721651">macOS Homebrew 安装 OpenCV 及切换版本 - 知乎</a></p><p>vscode配置opencv4:<br><a href="https://codeantenna.com/a/VAayPeG1xI">MacOS-VScode-opencv4.3-yolov3-C++（测试成功） - CodeAntenna</a></p><h3 id="3-在macos-big-sur的vscode上配置c-c-程序运行和调试工具"><a href="#3-在macos-big-sur的vscode上配置c-c-程序运行和调试工具" class="headerlink" title="3. 在macos big sur的vscode上配置c/c++程序运行和调试工具"></a>3. 在macos big sur的vscode上配置c/c++程序运行和调试工具</h3><p><a href="https://blog.csdn.net/weixin_44881648/article/details/111046381">MacOS安装vs code并且配置C/C++环境2020最新版_mac 升级c++-CSDN博客</a><br>详细步骤如下：</p><ol><li>安装codellb</li><li>设置左边菜单栏：（只能通过放大来设置 ctrl+/-）<br>{<br> “editor.fontSize”: 15,<br> “window.zoomLevel”: 0.5,<br>}</li></ol><ol start="3"><li>coderunner的设置<br>settings.json里面设置<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-string">&quot;code-runner.executorMap&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;c&quot;</span>: <span class="hljs-string">&quot;cd <span class="hljs-subst">$dir</span> &amp;&amp; gcc <span class="hljs-subst">$fileName</span> -o <span class="hljs-subst">$fileNameWithoutExt</span> &amp;&amp; <span class="hljs-subst">$dir</span><span class="hljs-subst">$fileNameWithoutExt</span>&quot;</span>,<br>    <span class="hljs-string">&quot;cpp&quot;</span>: <span class="hljs-string">&quot;cd <span class="hljs-subst">$dir</span> &amp;&amp; g++ -std=c++11 -stdlib=libc++ <span class="hljs-subst">$fileName</span> -o <span class="hljs-subst">$fileNameWithoutExt</span> &amp;&amp; <span class="hljs-subst">$dir</span><span class="hljs-subst">$fileNameWithoutExt</span>&quot;</span><br>&#125;,<br></code></pre></td></tr></table></figure>默认设置（不设置这两句话）运行会报错<blockquote><p>./forward.cpp:185:42: error: a space is required between consecutive right angle brackets (use ‘&gt; &gt;’)</p></blockquote></li></ol><p>下面这个问题是由于运行的不是main函数的文件</p><blockquote><p>Undefined symbols for architecture x86_64:<br>  “_main”, referenced from:<br>     implicit entry/start for main executable<br>ld: symbol(s) not found for architecture x86_64<br>clang: error: linker command failed with exit code 1 (use -v to see invocation)</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具相关 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hard题目集合</title>
      <link href="/2022/04/10/leetcode/hard%E9%A2%98%E7%9B%AE%E5%90%88%E9%9B%86/"/>
      <url>/2022/04/10/leetcode/hard%E9%A2%98%E7%9B%AE%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h3 id="lc6040-花园的最大总美丽值-枚举-二分"><a href="#lc6040-花园的最大总美丽值-枚举-二分" class="headerlink" title="lc6040. 花园的最大总美丽值 (枚举+二分)"></a>lc6040. 花园的最大总美丽值 (枚举+二分)</h3><ul><li>主要是在求partial的最小超时, 还有就是一个long long数据类型注意！！</li><li>法一: 从右到左，先枚举完善花园数目，再计算不完善花园数据可以获得的最大<br>解决方案：使用二分+前缀和来求增加后的最小值，而不是一个一个遍历(空间复杂度O(n))</li></ul><p>-法二: 如果是从左到右计算，可以将空间开销降到O(1)，先计算要让所有的花园变为完善花园还剩下的花的数量（可能为负数），然后遍历的时候一个一个加回去，同时不完善花园数目最小值是逐渐增大，所以可以在之前的结果上累加，不用重头计算</p><ul><li>同样类型的题目，+k使最小的数能够达到的最大值，lc6039. K 次增加后的最大乘积（这道题也可以最小堆+1，一个一个加）</li></ul><h3 id="lc6066-统计区间中的整数数目"><a href="#lc6066-统计区间中的整数数目" class="headerlink" title="lc6066. 统计区间中的整数数目"></a>lc6066. 统计区间中的整数数目</h3><ul><li>区间问题，主要是插入多个区间，如何合并得到最后的不重复的区间</li><li>使用hash start_end，那么每次判断的时候需要和前面一个和后面多个区间进行判断 upper_bound, 前面一个区间就是iter–</li><li>如果使用hash end_start(或者set&lt;pair&lt;end, start&gt;&gt;)那么只需要判断后面的多个可能覆盖的区间   lower_bound， iter++</li><li>每次合并区间，一定记得同时更新l_bound和r_bound</li><li>删除hash中的一个元素，并移动到下一个的正确姿势， hash.erase(iter++);</li><li>加速小技巧：为了不每次count都从头计算一次，可以使用插入的时候维护一个全局ans, 之后count的时候直接返回全局ans就可以了；这种利用先计算打表，后面直接使用的思想在前缀和，hulu面试的（组成平行四边形的个数）也可以体现出来<br>在进行i j两两组合的时候可以将，每组的组合方式求加和提前算出来，之后直接使用前缀和思想减掉0 到 i-1，就是当前i对应的组合方式</li></ul><h3 id="lc6077-巫师的总力量和"><a href="#lc6077-巫师的总力量和" class="headerlink" title="lc6077. 巫师的总力量和"></a>lc6077. 巫师的总力量和</h3><ul><li>子数组+区间问题</li><li>找到每个最小数的管辖区间（使用单调栈，同时为了避免出现数可能相等的情况使用了左边&gt;=, 右边&gt;的情况）</li><li>求管辖区间的每个子区间的sum, 使用前缀和的前缀和方法，也就是将右边放到一起，左边放到一起，将（a1-b1）+(a2-b2)+….+<br>= （a1+a2+…+an）-(b1+b2+….+bn) 其中a和b都是代表的前缀和</li><li>递推公式：</li></ul><img src="/2022/04/10/leetcode/hard%E9%A2%98%E7%9B%AE%E5%90%88%E9%9B%86/image-20220522153532000.png" alt="image-20220522153532000" style="zoom:50%;"><ul><li>补充类似的题目：<br>  lc907. 子数组的最小值之和<br>  lc1856. 子数组最小乘积的最大值<br>  lc2104. 子数组范围和<br>  都是使用单调栈求一个数作为最大值或者最小值的管辖范围（找到该数i左右两边第一个比这个数，或者大的数）然后包含数i的区间就有（r-i）*(i-l)个，其中r,l都是不包含在区间内，所以不需要+1</li></ul><h3 id="lc6094-公司命名"><a href="#lc6094-公司命名" class="headerlink" title="lc6094. 公司命名"></a>lc6094. 公司命名</h3><ul><li><p>题意，从字典中随便找两个单词，如果找到的单词交换首字母后，新单词都没在字典中出现过，那么res++, 问最后的res是多少</p></li><li><p>解决方案：先遍历一次字典每个单词，计算一个数组cnt[i][j], 表示将字典中单词首字母为 i+’a’ 转为j+’a’，且未在字典中出现的个数，那么结果就是再次遍历字典的每个单词, 将首字母换为26个字母中任意一个，如果该单词没在字典中出现过 则res+=cnt[j][i]</p></li><li><p>利用枚举+互补思想，如果一个单词转为另外一个首字母可行，那么就要判断以另外这个字母为首字母的单词，转为当前单词首字母 一共有多少种情况</p></li><li><p>优化点: 在vector O(n)里面查找的时间复杂度远远高于在set O(1)中，所以如果针对频繁在vec中查找的情况，可以将其转到set中查找</p></li></ul><h3 id="lc903-DI-序列的有效排列"><a href="#lc903-DI-序列的有效排列" class="headerlink" title="lc903. DI 序列的有效排列"></a>lc903. DI 序列的有效排列</h3><ul><li>这道题主要的难点在于使用映射，而不是vis数组来表示已经访问的数据</li><li>得到动态转移方程<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span>(s[i<span class="hljs-number">-1</span>]==<span class="hljs-string">&#x27;D&#x27;</span>)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=j;k&lt;i;k++)&#123; <span class="hljs-comment">//注意这是j to i-1 不是j+1到i, 因为i-1的时候是取不到 i的，因为有一个映射</span><br>        dp[i][j]+=dp[i<span class="hljs-number">-1</span>][k];<br>        dp[i][j]%=MOD;<br>    &#125;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;j;k++)&#123;<br>        dp[i][j]+=dp[i<span class="hljs-number">-1</span>][k];<br>        dp[i][j]%=MOD;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="lc730-统计不同回文子序列"><a href="#lc730-统计不同回文子序列" class="headerlink" title="lc730. 统计不同回文子序列"></a>lc730. 统计不同回文子序列</h3><ul><li><p>难点在于使用动态规划找不重复的</p></li><li><p>解决方案：分情况讨论 s[i]， s[j]是否相等 ， 当相等的时候，s[i], s[j]之间有几个和s[i]相同的字符</p><img src="/2022/04/10/leetcode/hard%E9%A2%98%E7%9B%AE%E5%90%88%E9%9B%86/image-20220625120018624.png" class title="image-20220625120018624"></li></ul><h3 id="lc6109-知道秘密的人数-显示为medium，但是我感觉类似hard难度"><a href="#lc6109-知道秘密的人数-显示为medium，但是我感觉类似hard难度" class="headerlink" title="lc6109. 知道秘密的人数(显示为medium，但是我感觉类似hard难度)"></a>lc6109. 知道秘密的人数(显示为medium，但是我感觉类似hard难度)</h3><ul><li>一个人知道密码吼，会在[i+delay, i+foraget-1]区间每个时间都告诉一个人， 问第n天知道密码的人</li><li>解决方法：第i天知道密码的人数=第i天新增人数+第i天还没有忘记秘密的人数(但是不是第i天新增的人数)<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>   <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i+delay;j&lt;=<span class="hljs-built_in">min</span>(i+forget<span class="hljs-number">-1</span>, n);j++)&#123;<br>        dp[j]= (dp[j]+dp[i])%MOD; <span class="hljs-comment">// dp[i]表示第i天新增知道的人数</span><br>    &#125; <br>    <span class="hljs-keyword">if</span>(i+forget<span class="hljs-number">-1</span>&gt;=n )&#123;<br>        cnt_a= (cnt_a+dp[i])%MOD; <span class="hljs-comment">//第n天还没有忘记秘密的人数(包括了第n天新增的人数+前面新增且第n天没有忘记)</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> cnt_a % MOD;<br></code></pre></td></tr></table></figure></li><li>类似前缀和的思想， 时间复杂度O(n^2),空间复杂度O(n)</li></ul><h3 id="lc6115-统计理想数组的数目"><a href="#lc6115-统计理想数组的数目" class="headerlink" title="lc6115. 统计理想数组的数目"></a>lc6115. 统计理想数组的数目</h3><ul><li><p>我的思路：求dp[i][j][len]的总数，也就是首是i， 尾是j，长度为len的方案的总数， 最后的答案就是 len==n的所有方案总和<br>但是因为O(n^3)所以超时,递推公式如下</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">dp[i][j][len%<span class="hljs-number">2</span>] = (dp[i][j][len%<span class="hljs-number">2</span>] + dp[i][j/k][(len<span class="hljs-number">-1</span>)%<span class="hljs-number">2</span>])%MOD; j/k需要j可以被k整除且j/k&gt;=i<br></code></pre></td></tr></table></figure></li><li><p>官方解答：排列组合题目</p><ol><li>先求到以i结尾的长度为j的个数 dp[i][j]+=dp[k][j-1] k能够被i整除</li><li>再求将长度为n包含互不相同的j个数，一共有多少种方案<br>固定第一个数的方案总数：Cn-1 j-1</li><li>总结就是，找序列不同个数， 找序列不同数的排布</li></ol></li><li><p>关键点，在于找不同数</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>多线程</title>
      <link href="/2022/01/26/leetcode/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"/>
      <url>/2022/01/26/leetcode/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="semaphore-信号量"><a href="#semaphore-信号量" class="headerlink" title="semaphore 信号量"></a>semaphore 信号量</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">#<span class="hljs-keyword">include</span> &lt;semaphore.h&gt;<br>sem_t sem1;<span class="hljs-comment">//进行变量申明</span><br><br>sem<span class="hljs-constructor">_init(&amp;<span class="hljs-params">sem1</span>, 1, 0)</span>; <br>第一个参数：指向的信号对象<br>第二个参数：控制信号量的类型，如果其值为<span class="hljs-number">0</span>，就表示信号量是当前进程的局部信号量，否则信号量就可以在多个进程间共享<br>第三个参数：信号量sem的初始值<br><br>sem<span class="hljs-constructor">_post(&amp;<span class="hljs-params">sem1</span>)</span> 信号量值加<span class="hljs-number">1</span><br><br>sem<span class="hljs-constructor">_wait(&amp;<span class="hljs-params">sem1</span>)</span> 信号量值减<span class="hljs-number">1</span><br><br>sem<span class="hljs-constructor">_destroy(&amp;<span class="hljs-params">sem1</span>)</span> 信号量销毁<br></code></pre></td></tr></table></figure><h2 id="互斥锁和条件变量（可以实现一个进程打印5次，另外一个进程打印1次的场景）"><a href="#互斥锁和条件变量（可以实现一个进程打印5次，另外一个进程打印1次的场景）" class="headerlink" title="互斥锁和条件变量（可以实现一个进程打印5次，另外一个进程打印1次的场景）"></a>互斥锁和条件变量（可以实现一个进程打印5次，另外一个进程打印1次的场景）</h2><p>C++： condition_variable C: pthread_cond_t<br>条件变量的一个例子，讲得很详细：<a href="https://blog.csdn.net/jinking01/article/details/110362483">C++中的条件变量_c++条件变量-CSDN博客</a></p><p>讲述conditon_variable的一个例子：<a href="https://segmentfault.com/a/1190000006679917">https://segmentfault.com/a/1190000006679917</a> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++">伪代码<br>condition_variable cond;<br>mutex p_lock;<br><span class="hljs-keyword">int</span> count=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">process1</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *args)</span></span>&#123;<br>  <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>    p_lock.<span class="hljs-built_in">lock</span>();<br>    count++;<br>    <span class="hljs-keyword">if</span>(count%<span class="hljs-number">5</span>==<span class="hljs-number">0</span>)&#123;<br>      cond.<span class="hljs-built_in">cond_signal</span>(&amp;cond);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>      <span class="hljs-built_in">printFunction</span>(<span class="hljs-string">&quot;this is process 1&quot;</span>);<br>    &#125;<br>    p_lock.<span class="hljs-built_in">unlock</span>();<br><br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">process2</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *args)</span></span>&#123;<br>  <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        p_lock.<span class="hljs-built_in">lock</span>();<br>        <span class="hljs-built_in">cond_wait</span>(&amp;cond);<span class="hljs-comment">//锁内部</span><br>        <span class="hljs-built_in">printFunction</span>(<span class="hljs-string">&quot;this is process 2&quot;</span>);<br>        p_lock.<span class="hljs-built_in">unlock</span>();t<br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>生产者-消费者问题<br>读者-写者问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">sem_t</span> full;<br><span class="hljs-keyword">sem_t</span> empty;<br><span class="hljs-keyword">sem_t</span> mutex;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Producer</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>      <span class="hljs-built_in">down</span>(&amp;empty);<br>      <span class="hljs-built_in">down</span>(&amp;mutex);<br>      <span class="hljs-built_in">produce_item</span>();<br>      <span class="hljs-built_in">up</span>(&amp;mutex);<br>      <span class="hljs-built_in">up</span>(&amp;full);<br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Consumer</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>      <span class="hljs-built_in">down</span>(&amp;full);<br>      <span class="hljs-built_in">down</span>(&amp;mutex);<br>      <span class="hljs-built_in">produce_item</span>();<br>      <span class="hljs-built_in">up</span>(&amp;mutex);<br>      <span class="hljs-built_in">up</span>(&amp;empty);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>读者-写者问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">sem_t</span> data_mutex;<br><span class="hljs-keyword">sem_t</span> count_mutex;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Reader</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>      <span class="hljs-built_in">down</span>(&amp;count_mutex);<br>      count++;<br>      <span class="hljs-keyword">if</span>(count==<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-built_in">down</span>(&amp;data_mutex);<br>      &#125;<br>      <span class="hljs-built_in">up</span>(&amp;count_mutex);<br><br>      <span class="hljs-built_in">read</span>();<span class="hljs-comment">//没有单独加数据锁</span><br><br>      <span class="hljs-built_in">down</span>(&amp;count_mutex);<br>      count--;<br>      <span class="hljs-keyword">if</span>(count==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">up</span>(&amp;data_mutex);<br>      &#125;<br>      <span class="hljs-built_in">up</span>(&amp;count_mutex);<br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">riter</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>      <span class="hljs-built_in">down</span>(&amp;data_mutex);<br>      <span class="hljs-built_in">produce_item</span>();<br>      <span class="hljs-built_in">up</span>(&amp;data_mutex);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>1.<br>引入条件变量一个就是为了避免为了查看条件是否成立而不断轮询的情况<br>总结：互斥锁实现的是线程之间的互斥，条件变量实现的是线程之间的同步。<br>初始化条件变量<br>pthread_cond_t cond = PTHREAD_COND_INITIALIZER;</p><p>该函数用来在一个ConditionVariable上阻塞等待，做以下三步操作：①释放Mutex；②阻塞等待；③当被唤醒时，重新获得Mutex并返回。<br>int pthread_cond_wait(pthread_cond_t &amp;cond_name, pthread_mutex_t &amp;mutex_name);</p><p>唤醒等待线程<br>pthread_cond_signal()：用于唤醒在该条件变量下等待的一个线程，至于哪个被唤醒，取决于线程的优先级和调度策略。<br>pthread_cond_broadcast()：用于唤醒在某个ConditionVariable 上等待的所有线程。使用这种方法时，瞬间唤醒的线程数过多，资源请求过大，容易导致系统不稳定。<br>int pthread_cond_signal(pthread_cond_t &amp;cond_name);<br>int pthread_cond_broadcast(pthread_cond_t &amp;cond_name);</p><ol start="2"><li>和信号量的区别：<br>条件变量的提出是为了解决互斥锁中的循环等待问题，其希望引入一种挂起、唤醒的机制来实现cpu的高效利用<br>（1）使用条件变量可以一次唤醒所有等待者，而这个信号量没有的功能，感觉是最大区别。<br>（2）信号量是有一个值（状态的），而条件变量是没有的，没有地方记录唤醒（发送信号）过多少次，也没有地方记录唤醒线程（wait返回）过多少次。</li></ol><ol start="3"><li>注意！！！！<br>条件变量被通知后，挂起的线程就被唤醒，但是唤醒也有可能是假唤醒，或者是因为超时等异常情况，所以被唤醒的线程仍要检查条件是否满足，所以 wait 是放在条件循环里面。cv.wait(lock, [] { return ready; }); 相当于：while (!ready) { cv.wait(lock); }。</li></ol><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><ol><li>为了实现两个函数的交替打印，可以使用信号量，也可以使用交替锁</li><li>交替打印 FooBar</li></ol><p>solution 1:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++">func1:<br><span class="hljs-built_in">sem_wait</span>(&amp;sem_foo);<br><span class="hljs-built_in">printFoo</span>();<br><span class="hljs-built_in">sem_post</span>(&amp;sem_bar);<br><br><span class="hljs-function">func2</span><br><span class="hljs-function"><span class="hljs-title">sem_wait</span><span class="hljs-params">(&amp;sem_bar)</span></span>;<br><span class="hljs-built_in">printBar</span>();<br><span class="hljs-built_in">sem_post</span>(&amp;sem_foo);<br></code></pre></td></tr></table></figure><p>solution 2 互斥锁（不建议用这种解法，在不同线程加锁解锁确实会出问题）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++">func1:<br>mutex lock1, lock2; <span class="hljs-comment">//这里锁类似条件变量</span><br><br>lock1.<span class="hljs-built_in">lock</span>();<br><span class="hljs-built_in">printFoo</span>();<br>lock2.<span class="hljs-built_in">unlock</span>();<br><br>func2<br>lock2.<span class="hljs-built_in">lock</span>();<br><span class="hljs-built_in">printBar</span>();<br>lock1.<span class="hljs-built_in">unlock</span>();<br></code></pre></td></tr></table></figure><ol start="2"><li>实现一个线程安全的队列<br>在多个线程进行push的时候需要加锁，在push的时候通知pop的线程可以pop<br>使用trypop，如果加锁，判断队列为空，那么直接返回，否则调用pop //不用try pop那么可能出现阻塞<br>pop函数使用使用条件锁 m_cond, 在pop的时候也需要加锁 //在多进程需要使用条件变量，虽然判断了是否为empty再进入的pop，因为可能时间片被其他线程占用导致当前没有元素pop<br>empty(), 加锁判断队列里面是否有元素</li></ol><p>使用条件变量判断队列里面是否有元素，才能pop</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>生成者-消费者需要两个信号量用于同步，一个用于给数据加锁<br>条件变量主要是用于达到了某个条件通知另外的进程可以做某件事（5对1，或者队列pop push）<br>读者-写者，写者加数据锁（信号量），读者只需要加count锁，因为多个读者可以同时读<br>队列这种，pop先判断是否为空，为空直接返回；不为空还需要等待条件变量，放置pop的时候被其他pop抢占，或者多个同时判断不为空，但是只有一个元素情况</p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程并发， 信号量， 互斥锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式训练</title>
      <link href="/2022/01/26/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%AD%E7%BB%83/"/>
      <url>/2022/01/26/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%AD%E7%BB%83/</url>
      
        <content type="html"><![CDATA[<h2 id="资料："><a href="#资料：" class="headerlink" title="资料："></a>资料：</h2><p>一个pytorch 分布式 单机多卡/多机多卡的例子<br><a href="https://github.com/lesliejackson/PyTorch-Distributed-Training">GitHub - lesliejackson/PyTorch-Distributed-Training: Example of PyTorch DistributedDataParallel</a></p><p>常见分布式训练讲解，但是主要命令是启动单机多卡，而不是多机多卡 包括slum, apex, horovod<br><a href="https://github.com/tczhangzhi/pytorch-distributed">GitHub - tczhangzhi/pytorch-distributed: A quickstart and benchmark for pytorch distributed training.</a> </p><p>pytorch DDP介绍<br><a href="https://zhuanlan.zhihu.com/p/76638962">Pytorch 分布式训练 - 知乎</a></p><p><a href="https://github.com/richardkxu/distributed-pytorch">GitHub - richardkxu/distributed-pytorch: Distributed, mixed-precision training with PyTorch</a> （也有多机多卡的命令）</p><p>可能会用到：<br>两个机器之间相互免密登录：<a href="https://blog.csdn.net/u010391029/article/details/51126210">多台Linux服务器SSH相互访问无需密码-CSDN博客</a></p><p>DDP time breakdown<br><a href="https://discuss.pytorch.org/t/how-to-measure-ddp-time-breakdown/78925">How to measure DDP time breakdown? - distributed - PyTorch Forums</a><br><a href="https://discuss.pytorch.org/t/how-to-measure-ddp-time-breakdown/78925">How to measure DDP time breakdown? - distributed - PyTorch Forums</a><br><a href="https://discuss.pytorch.org/t/calculating-flops-of-a-given-pytorch-model/3711/4">Calculating flops of a given pytorch model - #4 by warmspringwinds - PyTorch Forums</a> FLOPS计算</p><p>多进程logging和mkdir设置，分布式inferenc/ 分布式训练的一些小技巧</p><p><a href="https://zhuanlan.zhihu.com/p/250471767">[原创][深度][PyTorch] DDP系列第三篇：实战与技巧 - 知乎</a> </p><blockquote><p>包括的内容1. 在DDP中引入SyncBN<br>2. DDP下的Gradient Accumulation的进一步加速<br>3. 多机多卡环境下的inference加速<br>4. 保证DDP性能：确保数据的一致性<br>5. 和DDP有关的小技巧<br>6. 1. 控制不同进程的执行顺序<br>   2. 避免DDP带来的冗余输出</p></blockquote><p>Ray分布式执行框架  PyTorch + Ray Tune 调参<br><a href="https://blog.csdn.net/tszupup/article/details/112059788">PyTorch + Ray Tune 调参_pytorch ray tune_烟雨风渡的博客-CSDN博客</a></p><p>分布式相关论文源码<br><a href="https://github.com/msr-fiddle/pipedream">GitHub - msr-fiddle/pipedream</a>  pipedream源码 mini-bath parallism<br><a href="https://github.com/kakaobrain/torchgpipe">GitHub - kakaobrain/torchgpipe: A GPipe implementation in PyTorch</a></p><p>pytorch分布式训练的时候保存一定要用model.module<br><a href="https://blog.csdn.net/comway_Li/article/details/107531165">pytorch 分布式多卡训练DistributedDataParallel 踩坑记_加载多卡训练的预训练模型default process group has not been ini-CSDN博客</a> 一些需要注意的地方</p><p>horovod多机多卡<br><a href="http://chaopeng.name/2020/01/03/horovod%E5%A4%9A%E6%9C%BA%E5%A4%9A%E5%8D%A1%E5%90%AF%E5%8A%A8%E6%8C%87%E5%8D%97/">horovod多机多卡启动指南 | 技术自留地</a></p><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ol><li>DP和DDP区别<br>DP是单进程多线程数据并行，将模型copy到每个设备，scatter数据到每个设备进行计算后，将多个GPU输出传到master device(一般为设备0)进行损失计算，（可以优化一下：将loss作为forward 一部分，这样的话每个GPU上自行计算loss，而不用进行模型输出的传输）将损失结果（分发的是各个GPU分别对应的loss）传给每个设备进行反向传播，每个设备将反向传播后的梯度到主设备进行汇聚求平均，然后replicate一份模型的参数到每个设备中，重复上诉的训练过程。</li></ol><ol start="2"><li><p>DDP中all reduce与PS<br> DDP （all reduce）同步的是梯度，不是参数<br> PS，传给master的是梯度，返回的是参数</p><p> 思考：对不重要的梯度进行累积后同步/直接不同步（会不会造成模型的不一致）</p></li><li><p>同步代码<br>分布式训练源代码解读：<a href="https://zhuanlan.zhihu.com/p/343951042">PyTorch 源码解读之 DP &amp; DDP：模型并行和分布式训练解析 - 知乎</a></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">手动同步梯度<br><span class="hljs-keyword">for</span> param <span class="hljs-keyword">in</span> ddp_model.parameters<span class="hljs-literal">()</span>: <br>dist.all<span class="hljs-constructor">_reduce(<span class="hljs-params">param</span>.<span class="hljs-params">grad</span>.<span class="hljs-params">data</span>, <span class="hljs-params">op</span>=<span class="hljs-params">dist</span>.<span class="hljs-params">reduce_op</span>.SUM)</span><br>    param.grad.data /= world_size <br><br>手动同步参数：<br>在不重要的样本反向传播后但是不同步参数后，同步梯度<br><span class="hljs-keyword">for</span> param <span class="hljs-keyword">in</span> ddp_model.parameters<span class="hljs-literal">()</span>: <br>dist.all<span class="hljs-constructor">_reduce(<span class="hljs-params">param</span>.<span class="hljs-params">data</span>, <span class="hljs-params">op</span>=<span class="hljs-params">dist</span>.<span class="hljs-params">reduce_op</span>.SUM)</span><br>    param.data /= world_size <br></code></pre></td></tr></table></figure></li></ol><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="solution-1-atom版本"><a href="#solution-1-atom版本" class="headerlink" title="solution 1 - atom版本"></a>solution 1 - atom版本</h3><p>裸机 多节点 atom平台</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /workspace/mnt/storage/anchao/ac_file/traffic_iteration/SupreVision &amp;&amp; \<br>./install.sh &amp;&amp; \<br>python -m torch.distributed.launch \<br>        --nnode=4 \<br>        --node_rank=0 \<br>        --nproc_per_node=8 \<br>        --master_addr=<span class="hljs-string">&quot;10.244.55.30&quot;</span> \<br>        --master_port=23467 \<br>        tools/train.py \<br>        --config_file configs/YOLOv3/opencv_pelee_reorg.yml \<br>        SOLVER.IMS_PER_BATCH <span class="hljs-string">&quot;16&quot;</span> \<br>        MODEL.DEVICE_ID <span class="hljs-string">&quot;(&#x27;0,1,2,3,4,5,6,7&#x27;)&quot;</span> \<br>        &gt; detection0.log 2&gt;&amp;1<br></code></pre></td></tr></table></figure><p>单机多卡</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /workspace/mnt/storage/anchao/ac_file/traffic_iteration/SupreVision &amp;&amp; \<br>./install.sh &amp;&amp; \<br>CUDA_VISIBLE_DEVICES=3,4,5,6 python -m torch.distributed.launch \<br>                --nproc_per_node=2 \<br>                --master_port=$((RANDOM + <span class="hljs-number">20000</span>)) \<br>                ./imagenet_final_train_master.py \<br>                --config_file configs/YOLOv3/opencv_pelee_reorg.yml \<br>                &gt; detection0.log 2&gt;&amp;1<br></code></pre></td></tr></table></figure><h3 id="solution-2-简洁版"><a href="#solution-2-简洁版" class="headerlink" title="solution 2 - 简洁版"></a>solution 2 - 简洁版</h3><p>多机多卡<br>suppose we have two machines and one machine have 4 gpus<br>In multi machine multi gpu situation, you have to choose a machine to be master node.<br>we named the machines A and B, and set A to be master node</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">script run at A<br><br>python -m torch.distributed.launch --nproc_per_node=4 --nnode=2 --node_rank=0 --master_addr=A_ip_address master_port=29500 main.py ... <br><br>script run at B<br><br>python -m torch.distributed.launch --nproc_per_node=4 --nnode=2 --node_rank=1 --master_addr=A_ip_address master_port=29500 main.py ... <br></code></pre></td></tr></table></figure><p>单机多卡</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python -m torch.distributed.launch --nproc_per_node=ngpus --master_port=29500 main.py ... <br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>md语法相关</title>
      <link href="/2022/01/20/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/md%E8%AF%AD%E6%B3%95%E7%9B%B8%E5%85%B3/"/>
      <url>/2022/01/20/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/md%E8%AF%AD%E6%B3%95%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h3 id="1-对代码块进行折叠"><a href="#1-对代码块进行折叠" class="headerlink" title="1. 对代码块进行折叠"></a>1. 对代码块进行折叠</h3><p>代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">details</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">summary</span>&gt;</span>点击时的区域标题<span class="hljs-tag">&lt;/<span class="hljs-name">summary</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span><br><br>内容<br><br><span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">details</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果：</p><details>  <summary>点击时的区域标题</summary><pre><p>内容</p></pre></details>]]></content>
      
      
      <categories>
          
          <category> 工具相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> md语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统设计相关题目</title>
      <link href="/2022/01/19/leetcode/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
      <url>/2022/01/19/leetcode/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p><a href="https://github.com/donnemartin/system-design-primer">GitHub - donnemartin/system-design-primer: Learn how to design large-scale systems. Prep for the system design interview.  Includes Anki flashcards.</a></p><h2 id="题型"><a href="#题型" class="headerlink" title="题型"></a>题型</h2><h3 id="1-标准布隆过滤器hash函数的设置"><a href="#1-标准布隆过滤器hash函数的设置" class="headerlink" title="1.标准布隆过滤器hash函数的设置"></a>1.标准布隆过滤器hash函数的设置</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashFunction</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> cap, seed;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">HashFunction</span>(<span class="hljs-keyword">int</span> cap, <span class="hljs-keyword">int</span> seed) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;cap = cap;<br>        <span class="hljs-keyword">this</span>-&gt;seed = seed;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(string&amp; value)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> n = value.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            ret += seed * ret + value[i];<br>            ret %= cap;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StandardBloomFilter</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> k;<br>    vector&lt;HashFunction*&gt; hashFunc;<br>    bitset&lt;200000&gt; bits;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">StandardBloomFilter</span>(<span class="hljs-keyword">int</span> k) &#123;<br>        <span class="hljs-comment">// initialize your data structure here</span><br>        <span class="hljs-keyword">this</span>-&gt;k = k;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i)<br>            hashFunc.<span class="hljs-built_in">push_back</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">HashFunction</span>(<span class="hljs-number">100000</span> + i, <span class="hljs-number">2</span> * i + <span class="hljs-number">3</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>每个字符串通过这个hash函数可以得到一个值（position），然后将bit[200000]中该位置为1，多个函数，那么就会有多个位置为1;判断某一个字符串是否存在，就是判断多个函数计算出来值是否都在bit中位1，如果有一个不为1，说明该字符串不在</p><h3 id="2-序列化Trie树-Lintcode"><a href="#2-序列化Trie树-Lintcode" class="headerlink" title="2. 序列化Trie树(Lintcode)"></a>2. 序列化Trie树(Lintcode)</h3><p> 这个模板一定要记住，不要用自己的方法，用模板<br> 同类型题目：二叉树的序列化和反序列化， n叉数的序列化和反序列化<br>注意这道题</p><ul><li>在进行序列化：使用dfs, 在遍历完所有的chidren后，加上‘/‘表示退出当前循环</li><li>在进行反序列化时： 使用全局index, index在进入下一层循环和退出循环(注意这里和二叉树不同，有两处)之前都需要+1， 其余情况index保持不变</li><li>注意:<br>(1)在退出训练时候不是返回null, 而是返回一个Trie对象的指针！！！<br>(2)因为一个节点有多个节点，而不是只有二叉树的left和right节点，因此需要使用while判断，如果data[index]==’/‘的时候退出while循环<br>(3)<figure class="highlight c++"><figcaption><span>right</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">TrieNode* tmp=<span class="hljs-keyword">new</span> <span class="hljs-built_in">TrieNode</span>(); <span class="hljs-comment">//注意区分类和结构体</span><br>map&lt;<span class="hljs-keyword">char</span>, TrieNode*&gt; &amp;childs=tmp-&gt;children;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><figcaption><span>wrong</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">TrieNode* tmp; <span class="hljs-comment">//注意区分类和类指针，这里直接申明一个空指针是不对的, 即使是结构体也应该是student s;</span><br>map&lt;<span class="hljs-keyword">char</span>, TrieNode*&gt; childs;<br>tmp-&gt;children=childs;<br></code></pre></td></tr></table></figure></li></ul><p>官方题解使用的<data> 进行序列化+栈的方式进行反序列化：&lt;将当前current入栈 &gt;将栈顶出栈 其余：新建一个Trie对象(current)，将当前data[index]指向这个对象</data></p><p>下面模板代码可以用作n叉树的遍历或者trie树遍历，下面的这种方式会将空字符串用&lt;&gt;，如果想要空字符串没有，可以使用dfs2</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition of TrieNode:</span><br><span class="hljs-comment"> * class TrieNode &#123;</span><br><span class="hljs-comment"> * public:</span><br><span class="hljs-comment"> *     TrieNode() &#123;&#125;</span><br><span class="hljs-comment"> *     map&lt;char, TrieNode*&gt; children;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-comment">//适用于n叉数的遍历， 但是这种方式在进行反序列化的时候，每次从栈中弹出一个元素前，需要将栈顶赋值给cur</span><br> <span class="hljs-comment">//&lt;1&lt;3&lt;5&gt;&lt;6&gt;&gt;&lt;2&gt;&lt;4&gt;&gt; null节点无&lt;&gt;</span><br><span class="hljs-comment">//  lc428 每个节点都被&lt;&gt;分开，即使是同一层</span><br><span class="hljs-function">string <span class="hljs-title">dfs</span><span class="hljs-params">(Node* root)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br>    string data;<br>    <span class="hljs-keyword">int</span> size=root-&gt;children.<span class="hljs-built_in">size</span>();<br>    data+=<span class="hljs-built_in">to_string</span>(root-&gt;val);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>        data+=<span class="hljs-built_in">dfs</span>(root-&gt;children[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;&quot;</span>+data+<span class="hljs-string">&quot;&gt;&quot;</span>;<br>&#125;<br><br><span class="hljs-comment">//&lt;a&lt;b&lt;e&lt;&gt;&gt;c&lt;&gt;d&lt;f&lt;&gt;&gt;&gt;&gt; 节点之间可能没有&lt;&gt;分开</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * This method will be invoked first, you should design your own algorithm </span><br><span class="hljs-comment">     * to serialize a trie which denote by a root node to a string which</span><br><span class="hljs-comment">     * can be easily deserialized by your own &quot;deserialize&quot; method later.</span><br><span class="hljs-comment">     */</span><br>     <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(TrieNode* root)</span></span>&#123;<br>        <span class="hljs-function">string <span class="hljs-title">dfs</span><span class="hljs-params">(Node* root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        string data;<br>        <span class="hljs-keyword">int</span> size=root-&gt;children.<span class="hljs-built_in">size</span>();<br>        data+=<span class="hljs-built_in">to_string</span>(root-&gt;val);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>            data+=<span class="hljs-built_in">dfs</span>(root-&gt;children[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;&quot;</span>+data+<span class="hljs-string">&quot;&gt;&quot;</span>;<br>    &#125;<br>    <br>    <span class="hljs-function">string <span class="hljs-title">serialize</span><span class="hljs-params">(TrieNode* root)</span> </span>&#123;<br>        <span class="hljs-comment">// Write your code here</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        string data;<br>        <span class="hljs-keyword">for</span> (map&lt;<span class="hljs-keyword">char</span>, TrieNode*&gt;::iterator it = root-&gt;children.<span class="hljs-built_in">begin</span>();<br>             it != root-&gt;children.<span class="hljs-built_in">end</span>(); ++it) &#123;<br>            data += it-&gt;first;<br>            data += <span class="hljs-built_in">serialize</span>(it-&gt;second);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;&quot;</span> + data + <span class="hljs-string">&quot;&gt;&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * This method will be invoked second, the argument data is what exactly</span><br><span class="hljs-comment">     * you serialized at method &quot;serialize&quot;, that means the data is not given by</span><br><span class="hljs-comment">     * system, it&#x27;s given by your own serialize method. So the format of data is</span><br><span class="hljs-comment">     * designed by yourself, and deserialize it here as you serialize it in </span><br><span class="hljs-comment">     * &quot;serialize&quot; method.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">TrieNode* <span class="hljs-title">deserialize</span><span class="hljs-params">(string data)</span> </span>&#123;<br>        <span class="hljs-comment">// Write your code here</span><br>        <span class="hljs-keyword">if</span> (data.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>        TrieNode* head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TrieNode</span>();<br>        TrieNode* current = head;<br>        stack&lt;TrieNode*&gt; path;<br>        <span class="hljs-keyword">int</span> len = data.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;<br>            <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (data[i]) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>:<br>                    path.<span class="hljs-built_in">push</span>(current);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>:<br>                    <span class="hljs-comment">//如果是null节点无&lt;&gt;情况，那么需要在这里赋值cur=path.top()</span><br>                    path.<span class="hljs-built_in">pop</span>();<br>                    <br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">default</span>:<br>                    current = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TrieNode</span>();<br>                    path.<span class="hljs-built_in">top</span>()-&gt;children[data[i]] = current;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="3-Trie树构建"><a href="#3-Trie树构建" class="headerlink" title="3. Trie树构建"></a>3. Trie树构建</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">class <span class="hljs-title">Trie</span><span class="hljs-params">()</span></span>&#123;<br>    vector&lt;Trie*&gt; children;<br>    <span class="hljs-keyword">bool</span> isEnd;<br>    <span class="hljs-built_in">Trie</span>()&#123;<br>        <span class="hljs-keyword">this</span>-&gt;child = vector&lt;Trie*&gt;(<span class="hljs-number">26</span>,<span class="hljs-literal">nullptr</span>); <span class="hljs-comment">//一定要记得初始化26个节点，而且都为null</span><br>        <span class="hljs-keyword">this</span>-&gt;isEnd = <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-built_in">search</span>(string s)&#123;<br>        Trie* root=<span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(root-&gt;children[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>]==<span class="hljs-literal">NULL</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            root= root-&gt;children[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> root-&gt;isEnd;<br>    &#125;<br>    <span class="hljs-built_in">insert</span>(string s)&#123;<br>        Trie* root=<span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(root-&gt;children[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>]==<span class="hljs-literal">NULL</span>)&#123;<br>                root-&gt;children[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>]=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Trie</span>();<br>            &#125;<br>            root= root-&gt;children[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        root-&gt;isEnd=<span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>二叉树的序列化和反序列可以使用前序遍历实现</p><h3 id="4-lc355-设计推特"><a href="#4-lc355-设计推特" class="headerlink" title="4. lc355. 设计推特"></a>4. lc355. 设计推特</h3><ul><li>需要实现4个功能: 关注， 取消关注， 发表博客， 列出userid和userid最近发表的10条博客</li><li>实现关注和取消关注使用unordered_map&lt;int, unordered_set<int>&gt; hash</int></li><li>发表博客使用unordered_map&lt;int, node*&gt; , 其中node记录<br>node{<br>  tuiteid, //充当时间戳<br>  userid, //发表用户<br>  node* next; //指向下一个node, 类似于LRU，方便使用头插入方法<br>}</li><li> 列出userid和userid最近发表的10条博客， 使用K个链表的合并，找出前M个数</li><li>为什么使用链表，这样的话扩展非常方便，如果不使用，那么在删除博客的时候就比较麻烦</li></ul><h3 id="5-单词自动补全系统"><a href="#5-单词自动补全系统" class="headerlink" title="5. 单词自动补全系统"></a>5. 单词自动补全系统</h3><ul><li>题意：1. 初始化系统，包括一些句子和句子最初始的频率，一个句子之间可能小写字符或者空格 2. 每次input一个字符应该接着上一个字符，同时输出‘#’表示输出的末尾，这时候需要初始化data=””, cur=root（全局变量）, 更新句子的频率</li><li>解决方案：</li><li><ol><li>使用前缀树+hash(存储句子+频率) 前缀树的每个节点，应该存储一个vector<string> 表示走到这个节点的下面所有字符</string></li></ol></li><li><ol start="2"><li>注意字符串在进行查找如果cur==null, 那么直接返回空，否则一直在cur的基础上走一步 cur=cur-&gt;children[c]//unordered_map&lt;char, TrieNode*&gt; children;</li></ol></li><li><ol start="3"><li>如果走到‘#’，表示走到了末尾，这时候需要初始化data=””, cur=root, 同时更新句子的频率 +1（句子频率会更新）</li></ol></li><li>参考答案: <a href="https://aaronice.gitbook.io/lintcode/data_structure/design-search-autocomplete-system">Design Search Autocomplete System - LintCode &amp; LeetCode</a><br><a href="https://zhuanlan.zhihu.com/p/99499171">642. Design Search Autocomplete System - 知乎</a> (有点问题，不应该在每个节点里面记录节点的频率，因为这个随时更新，之后就不准确，应该用一个单独的hashmap来记录)</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>一般是有关于系统， 多个函数的整体设计题目<br>比如：GeoHash, GFS, 布隆过滤器， 心跳设计， 缓存系统， LRU cache设计，二叉树的序列化和反序列化等<br>还有新定义一种数据结构，嵌套返回list leetcode-扁平化嵌套列表迭代器 使用递归方式分解</p></li><li><p>为了在vector里面删除元素更快，可以再配合使用一个dict (map)映射特定值对应的index。注意在进行删除元素的时候，除了交换vector中最后一个元素和当前元素，还需要修改hash最后一个元素映射的下标为当前index+从hash中删除key</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Zplot画图</title>
      <link href="/2022/01/04/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/zplot/"/>
      <url>/2022/01/04/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/zplot/</url>
      
        <content type="html"><![CDATA[<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">Zplot-<span class="hljs-built_in">folder</span><br>|<span class="hljs-comment">--breakdown</span><br>    |<span class="hljs-comment">--Makefile</span><br>    |<span class="hljs-comment">--breakdown1.py</span><br>    |<span class="hljs-comment">--breakdown1.data</span><br>    |<span class="hljs-comment">--breakdown2.py</span><br>    |<span class="hljs-comment">--breakdown2.data</span><br>|<span class="hljs-comment">--eval_lineplot</span><br>    |<span class="hljs-comment">--Makefile</span><br>|<span class="hljs-comment">--...</span><br>|<span class="hljs-comment">--makefig.sh</span><br></code></pre></td></tr></table></figure><h2 id="使用注意事项"><a href="#使用注意事项" class="headerlink" title="使用注意事项"></a>使用注意事项</h2><ol><li><p>每次运行的时候只需要运行makefig文件就可以了，如果要修改所有生成的pdf在的目录，直接修改makefig.sh</p></li><li><p> Makefile里面的文件主要是运行当前py文件生成eps文件，然后使用ps2pdf转为pdf并使用pdf2crop对生成的pdf文件进行裁剪<br>PS：一定要注意python文件的名字一定要和data文件名字相同，否则会报错</p></li></ol><h3 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install zplot <br><span class="hljs-comment">#注意可能会出现list错误，可能是由于python2 和python3的不兼容原因，只需要将zplot.py里面的ListType改为list就可以了</span><br><br>sudo apt-get install texlive-extra-utils  <br></code></pre></td></tr></table></figure><h3 id="Makefile文件分析"><a href="#Makefile文件分析" class="headerlink" title="Makefile文件分析"></a>Makefile文件分析</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash">PY=python<br>EPS2PDF=ps2pdf<br>CROP=pdfcrop<br><br>SRC := $(wildcard *.py) <span class="hljs-comment">#列出所有文件对应的py文件</span><br>SRC := $(filter-out zplot.py, $(SRC))<br>EPS = $(patsubst %.py,%.eps,$(SRC))<br>PDF = $(patsubst %.py,%.pdf,$(SRC)) <span class="hljs-comment">#列出所有文件对应的eps和pdf文件</span><br><br>all: $(EPS) $(PDF)<br><br>%.eps: %.py  <span class="hljs-comment"># 目标文件： 源文件</span><br>$(PY) $&lt; eps  <span class="hljs-comment">#$&lt; 表示源文件  $@表示目标文件//官方解释： $&lt; 表示第一个依赖文件， $@ 表示目标集</span><br><br>%.pdf: %.eps<br>$(EPS2PDF) $&lt;<br>$(CROP) <span class="hljs-variable">$@</span> <span class="hljs-variable">$@</span><br>rm -rf $&lt;<br><br>fig:<br><span class="hljs-comment"># mv -f *.pdf ../../../fig/ #将所有的文件都转移到zplot对应的root目录下面</span><br>mv -f *.pdf ../../<br>rm -rf *.eps *.pdf<br></code></pre></td></tr></table></figure><p>makefile语法的参考链接： <a href="https://seisman.github.io/how-to-write-makefile/rules.html">书写规则 — 跟我一起写Makefile 1.0 文档</a> </p><p>makefig.sh文件分析</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>rm -rf *.pdf <span class="hljs-comment">#这是我自己家的，在执行生成之前，现将之前生成的pdf文件删除，应该是也不用</span><br><br><span class="hljs-keyword">for</span>  dir  <span class="hljs-keyword">in</span>  `find .  -name Makefile`  <span class="hljs-comment">#找到包含Makefile文件的dir</span><br><span class="hljs-keyword">do</span><br>path=`dirname <span class="hljs-variable">$dir</span>` <span class="hljs-comment">#找到dir对应的路径path</span><br>    <span class="hljs-comment"># echo $path</span><br>    <span class="hljs-comment"># echo $dir</span><br><span class="hljs-keyword">if</span>  [ <span class="hljs-variable">$path</span>  !=  . ]<br><span class="hljs-keyword">then</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$path</span> <span class="hljs-comment">#打印出path的路径</span><br><span class="hljs-built_in">cd</span> <span class="hljs-variable">$path</span>  <br>make    <span class="hljs-comment">#执行make和makefig命令</span><br>make fig<br><span class="hljs-built_in">cd</span>  -<br><span class="hljs-keyword">fi</span><br><span class="hljs-keyword">done</span><br><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zplot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Anaconda环境搭建</title>
      <link href="/2021/12/15/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/anaconda%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%BB%8E%E9%9B%B6%E5%88%B0%E4%B8%80/"/>
      <url>/2021/12/15/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/anaconda%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%BB%8E%E9%9B%B6%E5%88%B0%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="任务描述"><a href="#任务描述" class="headerlink" title="任务描述"></a>任务描述</h2><p>一个服务器上已经搭建好的环境，但是需要换另一台机器，或者另外的用户需要访问这个环境， 如果另一台服务器上没有anaconda环境就需要从0开始进行搭建，然后再进行环境的迁移</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ol><li>安装anaconda3<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">wget</span> https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda<span class="hljs-number">3</span>-<span class="hljs-number">5</span>.<span class="hljs-number">3</span>.<span class="hljs-number">1</span>-Linux-x<span class="hljs-number">86</span>_<span class="hljs-number">64</span>.sh<br><span class="hljs-attribute">bash</span> Anaconda<span class="hljs-number">3</span>-<span class="hljs-number">5</span>.<span class="hljs-number">3</span>.<span class="hljs-number">1</span>-Linux-x<span class="hljs-number">86</span>_<span class="hljs-number">64</span>.sh<br></code></pre></td></tr></table></figure></li></ol><p>一般情况下安装是默认设置，在安装vscode的时候可以根据需要选择no或者yes<br>注意在安装installer的时候需要选择yes, 如果选择了no<br>那么可以自行添加环境:<br><a href="https://zhuanlan.zhihu.com/p/64930395">Linux-Centos7下安装Anaconda（2019年新版） - 知乎</a>（也就是激活环境中的方法二）</p><ol start="2"><li>激活环境<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 方法一失效</span><br>输入命令打开配置文件：vim ~/.bashrc<br>在最后添加语句：export PATH=<span class="hljs-regexp">/root/</span>xxx<span class="hljs-regexp">/anaconda3/</span>bin:<span class="hljs-variable">$PATH</span> （<span class="hljs-regexp">/root/</span>xxx 为安装路径）<br>最后输入如下命令，更新配置文件即可：source ~/.bashrc<br><br><span class="hljs-comment">#方法二有效：</span><br>如果conda的初始化时选择了no，则需要自行配置环境变量。<br><br>打开profile文件：<br><br>vi <span class="hljs-regexp">/etc/</span>profile<br>在文件最后加入如下语句（路径需要根据自己的安装位置更改）：<br><br>PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-regexp">/opt/</span>anaconda3/bin<br>export PATH<br>保存文件并退出。最后使用如下命令刷新环境变量即可：<br><br>source <span class="hljs-regexp">/etc/</span>profile<br>echo <span class="hljs-variable">$PATH</span><br></code></pre></td></tr></table></figure></li></ol><p>PS: 如果conda名称弹出问题，使用<code>sudo vi ~/.bashrc</code>查看conda路径是否正确</p><ol start="3"><li>conda相关命令<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs applescript">conda <span class="hljs-built_in">list</span> 查看安装包<br>conda info <span class="hljs-comment">--envs 查看环境</span><br>conda <span class="hljs-built_in">activate</span> XXX 激活环境 （XXX 为环境名称）<br>python -V 检查Python版本<br><br>如果需要卸载anaconda的话，只需要删除anaconda目录即可:<br>rm -rf /root/xxx/anaconda3<br></code></pre></td></tr></table></figure></li><li>使用conda-pack迁移环境</li></ol><p>在源机器：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">conda pack -n env-<span class="hljs-built_in">name</span> <span class="hljs-comment">--ignore-editable-packages（如果没有后面这个会报错）</span><br>得到一个env_name.tar.gz压缩文件<br></code></pre></td></tr></table></figure><p>在目标机器：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">cd ~<span class="hljs-regexp">/anaconda3/</span>envs;<br>mkdir env_name<br>tar -xzvf env_name.tar.gz -C <span class="hljs-regexp">/home/</span>root_name<span class="hljs-regexp">/anaconda3/</span>envs/env_name<br></code></pre></td></tr></table></figure><ol start="5"><li>使用环境<br><code>source activate attnGAN</code></li></ol><p>注意使用conda activate会报错<br>目前找到一个解决方案：<br><a href="https://blog.csdn.net/qq_43828332/article/details/114235922">转载：conda activate和source activate 的命令区别_你倒是点菜啊的博客-CSDN博客</a></p><p>总共耗时 1个半小时左右~</p><h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><ol><li><a href="https://blog.csdn.net/lwgkzl/article/details/89329383">两行代码下载安装Anaconda（linux环境）-CSDN博客</a></li><li><a href="https://www.jianshu.com/p/1fddd11bcd25">Linux安装Anaconda3</a></li><li><a href="https://blog.csdn.net/ds1302__/article/details/120027173">使用conda pack进行环境迁移（步骤很详细）_小舟%的博客-CSDN博客</a></li></ol><p>注意之江实验室hec anaconda3的安装路径是：/nfs/home </p><h2 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h2><p>在终端输入conda info –envs检验anaconda是否安装成功，发现报错：conda: command not found</p><p>原因是因为~/.bashrc文件没有配置好</p><p>解决方案：<br>sudo vim ~/.bashrc<br>在最后一行加上<br>export PATH=$PATH:/home/vincent/anaconda3/bin</p>]]></content>
      
      
      <categories>
          
          <category> 工具相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> conda environment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RPC related</title>
      <link href="/2021/12/03/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/rpc/"/>
      <url>/2021/12/03/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/rpc/</url>
      
        <content type="html"><![CDATA[<h3 id="1-gRPC"><a href="#1-gRPC" class="headerlink" title="1. gRPC"></a>1. gRPC</h3><ul><li><p>使用步骤：<br>gRPC 可以保证不同语言之间的通讯<br>编写.proto文件，生成指定语言源代码。<br>编写服务端代码<br>编写客户端代码<br><a href="https://www.liwenzhou.com/posts/Go/gRPC/">一个pytho客户端和go服务端的例子</a></p></li><li><p>源文件解析：<br>route_guide_client文件主要是通过stub 和传入的参数调用server的函数<br>route_guide_server里面主要是编写得到输入服务器处理函数逻辑<br>route_guide_pb2_grpc，类似于头文件，定义Stub类和Servicer类，每个类只是定义函数，但不进行具体的实现； 以及一个add_RouteGuideServicer_to_server的函数</p></li></ul><h3 id="2-pytorch提供的rpc框架"><a href="#2-pytorch提供的rpc框架" class="headerlink" title="2. pytorch提供的rpc框架"></a>2. pytorch提供的rpc框架</h3><p>rpc常见方法<br>rpc_sync同步远程调用、rpc_async异步远程调用、remote异步远程调用。</p><p>rpc.init_rpc 初始化rpc，需要在master和worker都进行初始化，方便之后的通讯<br>rpc.rpc_sync  worker端调用在master上进行执行的方法<br>rpc.rpc_async<br>rpc.remote</p><p>dist_autograd.get_gradient(cid) 目前猜测在rpc场景进行前向传播，的梯度反向传播需要使用dist_grad</p><p>TrainNet是worker调用的假的网络，实际的网络是在Net里面调用，每次worker里面数据的前向传播，实际上都是在master里面的调用net进行前向传播</p><h3 id="3-分析rpc-parameter-server代码"><a href="#3-分析rpc-parameter-server代码" class="headerlink" title="3. 分析rpc_parameter_server代码"></a>3. 分析rpc_parameter_server代码</h3><p>master和worker都需要init_rpc</p><p>worker里面主要执行TrainNet：初始化的时候得到远程parameterServer的引用，然后包含二个函数 get_global_param_rref 以及forward函数(均要调用remote_method)<br>master里面执行parameterServer类，：初始的时候，得到真实训练的model, 同时实现三个函数, 对模型参数加上的引用rpc.RRef，使用dist_autograd得到模型参数，以及对输入数据进行前向传播</p><p>在master中加上 uni_sample_score_rref</p><h3 id="4-go语言"><a href="#4-go语言" class="headerlink" title="4. go语言"></a>4. go语言</h3><ul><li><p>前置安装要求</p><ul><li><p>安装go，和protocol buffer编译器<br><a href="https://grpc.io/docs/languages/go/quickstart/#prerequisites">https://grpc.io/docs/languages/go/quickstart/#prerequisites</a></p></li><li><p>go command not found<br>使用export， 重启一个控制台窗口就找不到这个命令了<br>需要使用vim <del>/.bashrc写入文件 将这个命令写进去，然后使用source ~/.bashrc<br>(</del>/.bashrc:是用户相关的终端（shell）的环境设置，通常打开一个新终端时，默认会load里面的设置，在这里的设置不影响其它人。<br>/etc/profile会影响所有的用户)</p></li><li><p>go download超时解决：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">GOPROXY</span>=https://goproxy.cn<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="5-go-软件的安装"><a href="#5-go-软件的安装" class="headerlink" title="5. go 软件的安装"></a>5. go 软件的安装</h3><ol><li><p>直接使用 <code>tar -C /usr/local -xzf go1.4.7.linux-amd64.tar.gz</code> 解压到 local 目录 设置PATH，<code>export PATH=$PATH:/usr/local/go/bin</code></p></li><li><p>假定你想要安装Go的目录为 <code>$GO_INSTALL_DIR</code>，后面替换为相应的目录路径。 解压缩tar.gz包到安装目录下：<code>tar zxvf go1.14.7.linux-amd64.tar.gz -C $GO_INSTALL_DIR</code><br>设置PATH:<code>export PATH=$PATH:$GO_INSTALL_DIR/go/bin</code><br>如果修改用户环境变量：设置 <code>vim ~/.bash_profile</code><br>如果修改系统环境变量：设置 <code>vim /etc/profile</code></p></li><li><p><a href="https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/01.1.md">go安装的三种方法</a></p></li></ol><ol start="4"><li><p>go的插件在vscode命令行中显示失败 i/o time out<br>解决方法：GO111MODULE=on GOPROXY=<a href="https://goproxy.cn,direct/">https://goproxy.cn,direct</a> go install </p></li><li><p>vscode下载go 包的时候一个failed的解决方案（和第4个有点雷同）<br><a href="https://www.cnblogs.com/marshhu/p/11848020.html">golang之vscode环境配置 - 我没有领悟 - 博客园</a></p></li></ol><h3 id="6-利用gRPC通信-一端使用go-一端使用python"><a href="#6-利用gRPC通信-一端使用go-一端使用python" class="headerlink" title="6. 利用gRPC通信 一端使用go 一端使用python"></a>6. 利用gRPC通信 一端使用go 一端使用python</h3><p>一个python小例子：<a href="https://grpc.io/docs/languages/python/quickstart/">Quick start | Python | gRPC</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rpc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>orangefs</title>
      <link href="/2021/12/01/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/orangefs/"/>
      <url>/2021/12/01/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/orangefs/</url>
      
        <content type="html"><![CDATA[<h2 id="orangefs"><a href="#orangefs" class="headerlink" title="orangefs"></a>orangefs</h2><h3 id="1-genconfig"><a href="#1-genconfig" class="headerlink" title="1. genconfig"></a>1. genconfig</h3><p>genconfig是一个go语言文件，它有一个可选参数oranges-server.conf</p><h3 id="2-init-start-all-sh"><a href="#2-init-start-all-sh" class="headerlink" title="2. init_start_all.sh"></a>2. init_start_all.sh</h3><p>init_start_all.sh相比start_all.sh 多了一个/local500G/orange_store/ 以及多了一条有-f命令的语句 应该是在服务器节点启动pvfs-server<br>orangefs默认的服务器的文件系统挂载的目录是在oranges-server.conf里面进行配置<code>（/nfs/home/yfwang/orangefs/install/etc/oranges-server.conf）</code></p><p>加上f的原因： 第一次启动PVFS2服务要首先分配空间，添加参数-f：<br><code>root@ubuntu:~# pvfs2-server /etc/pvfs2-fs.conf -f</code><br>其后启动服务则不需加参数，或使用-d使得服务运行于前台（占用当前终端窗口，终端窗口关闭后服务终止）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> host <span class="hljs-keyword">in</span> `cat /nfs/home/yfwang/orangefs/install/nodelist`<br><span class="hljs-keyword">do</span><br><span class="hljs-comment">#       ssh -t -t -o StrictHostKeyChecking=no -o PasswordAuthentication=no $USER@$host sudo rm -rf /local500G/orange_store/*</span><br>        ssh -t -t -o StrictHostKeyChecking=no -o PasswordAuthentication=no <span class="hljs-variable">$USER</span>@<span class="hljs-variable">$host</span> sudo /nfs/home/yfwang/orangefs/install/sbin/pvfs2-server -f /nfs/home/yfwang/orangefs/install/etc/oranges-server.conf<br>        ssh -t -t -o StrictHostKeyChecking=no -o PasswordAuthentication=no <span class="hljs-variable">$USER</span>@<span class="hljs-variable">$host</span> sudo /nfs/home/yfwang/orangefs/install/sbin/pvfs2-server /nfs/home/yfwang/orangefs/install/etc/oranges-server.conf<br><span class="hljs-keyword">done</span> <br></code></pre></td></tr></table></figure><h3 id="3-stop-all-sh"><a href="#3-stop-all-sh" class="headerlink" title="3. stop_all.sh"></a>3. stop_all.sh</h3><p>stop_all.sh 停止所有的pvfs-server</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> host <span class="hljs-keyword">in</span> `cat /nfs/home/yfwang/orangefs/install/nodelist`<br><span class="hljs-keyword">do</span><br>        ssh -t -t -o StrictHostKeyChecking=no -o PasswordAuthentication=no <span class="hljs-variable">$USER</span>@<span class="hljs-variable">$host</span> sudo killall pvfs2-server<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><h3 id="4-start-client-sh"><a href="#4-start-client-sh" class="headerlink" title="4. start_client.sh"></a>4. start_client.sh</h3><p>start_client.sh启动客户端orangefs-client， 同时将服务器任意一个节点的位置暴露为客户端，例子是hec09</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo /nfs/home/yfwang/orangefs/install/sbin/pvfs2-client -f -p /nfs/home/yfwang/orangefs/install/sbin/pvfs2-client-core<br>sudo mount -t pvfs2 tcp://hec09:3334/orangefs /mnt/orangefs<br></code></pre></td></tr></table></figure><h3 id="5-nodelist"><a href="#5-nodelist" class="headerlink" title="5. nodelist"></a>5. nodelist</h3><p>nodelist 里面直接写hec10 hec11</p><p><a href="https://github.com/waltligon/orangefs/wiki/Distributions-and-Layouts">Distributions and Layouts · waltligon/orangefs Wiki · GitHub</a> 设置数据不同的放置策略,一个文件放在一个节点使用basic方式 distribution</p><p><a href="https://github.com/waltligon/orangefs/wiki/Programming-Guide">Programming Guide · waltligon/orangefs Wiki · GitHub</a></p><p><code>setfattr -n &quot;user.pvfs2.dist_name&quot; -v &quot;basic_dist&quot; /mnt/pvfs2/directory</code><br><code>./bin/pvfs2-xattr -s -k &quot;user.pvfs2.dist_name&quot; -v &quot;basic-dist&quot; /mnt/shu-orangefs/dataset </code></p><p>orangefs里面有一个PINT_dist函数<br><a href="https://www.mcs.anl.gov/~robl/pvfs2/pvfs2-dox/html/pint-distribution_8c.html#a2">pvfs2: pint-distribution.c File Reference</a></p><h3 id="6-将文件保存在orangefs中一个服务器的方案："><a href="#6-将文件保存在orangefs中一个服务器的方案：" class="headerlink" title="6. 将文件保存在orangefs中一个服务器的方案："></a>6. 将文件保存在orangefs中一个服务器的方案：</h3><p><a href="https://stackoverflow.com/questions/64923445/how-to-configure-orangefs-save-the-file-into-the-same-server-not-split-it">filesystems - How to configure orangefs save the file into the same server, not split it? - Stack Overflow</a><br>使用命令：setfattr -n “user.pvfs2.num_dfiles” -v “1” /mnt/orangefs<br>如果按照这种方式设置会报错：setfattr -n “user.pvfs2.dist_name” -v “basic_dist” /mnt/pvfs2/directory 传输数据会报错</p><h2 id="配置教程"><a href="#配置教程" class="headerlink" title="配置教程"></a>配置教程</h2><p>安装server<br>拷贝已经编译好的程序</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cp -r <span class="hljs-regexp">/nfs/</span>home<span class="hljs-regexp">/yfwang/</span>orangefs<span class="hljs-regexp">/install /</span>nfs<span class="hljs-regexp">/home/</span>weijian<span class="hljs-regexp">/orangefs_install/</span><br></code></pre></td></tr></table></figure><p>配置server</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">.<span class="hljs-regexp">/bin/</span>pvfs2-genconfig <span class="hljs-regexp">/nfs/</span>home<span class="hljs-regexp">/weijian/</span>orangefs_install<span class="hljs-regexp">/install/</span>orangefs-server.conf<br></code></pre></td></tr></table></figure><p>具体的配置项，自己可以先记录下来</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">tcp<br><span class="hljs-number">3336</span><br><span class="hljs-regexp">/local500G/</span>wj-fast<span class="hljs-regexp">/storage/</span>data<br><span class="hljs-regexp">/local500G/</span>wj-fast<span class="hljs-regexp">/storage/m</span>eta<br><span class="hljs-regexp">/var/</span>log/orangefs-server.log<br>hec08,hec09<br></code></pre></td></tr></table></figure><p>配置完成时可以<code>cat /nfs/home/weijian/orangefs_install/install/orangefs-server.conf</code>查看配置项是否符合需求<br>到各个server上，各自初始化存储目录</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">sudo ./sbin/pvfs2-<span class="hljs-keyword">server</span> -f orangefs-<span class="hljs-keyword">server</span>.conf -a &lt;<span class="hljs-keyword">server</span> <span class="hljs-keyword">alias</span>&gt;<br></code></pre></td></tr></table></figure><p>到各个server上，启动服务</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo .<span class="hljs-regexp">/sbin/</span>pvfs2-server  orangefs-server.conf<br></code></pre></td></tr></table></figure><p>安装client<br>拷贝已经编译好的程序（如果已经可以访问就不需要拷贝了）</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">scp -r weijian<span class="hljs-variable">@hec08</span><span class="hljs-symbol">:/nfs/home/yfwang/orangefs/install/</span> /nfs/home/weijian/orangefs_install/<br></code></pre></td></tr></table></figure><p>向内核加载orangefs模块</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo modprobe orangefs</span><br></code></pre></td></tr></table></figure><p>创建挂载点</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo mkdir <span class="hljs-regexp">/mnt/</span>wj-fast-orangefs<br></code></pre></td></tr></table></figure><p>写配置文件</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo sh -c “echo ‘tcp:<span class="hljs-regexp">//</span>hec08:<span class="hljs-number">3336</span><span class="hljs-regexp">/orangefs /m</span>nt<span class="hljs-regexp">/wj-fast-orangefs pvfs2’ &gt;&gt; /</span>etc/pvfs2tab”<br></code></pre></td></tr></table></figure><p>测试与server是否连通</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">.<span class="hljs-regexp">/bin/</span>pvfs2-ping -m <span class="hljs-regexp">/mnt/</span>wj-fast-orangefs<br></code></pre></td></tr></table></figure><p>启动client客户端</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo .<span class="hljs-regexp">/sbin/</span>pvfs2-client -p .<span class="hljs-regexp">/sbin/</span>pvfs2-client-core<br></code></pre></td></tr></table></figure><p>挂载</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo mount -t pvfs2 tcp:<span class="hljs-regexp">//</span>hec08:<span class="hljs-number">3336</span><span class="hljs-regexp">/orangefs /m</span>nt/wj-fast-orangefs<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> orangefs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树</title>
      <link href="/2021/11/23/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2021/11/23/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="1-验证二叉树的前序序列化"><a href="#1-验证二叉树的前序序列化" class="headerlink" title="1. 验证二叉树的前序序列化"></a>1. 验证二叉树的前序序列化</h3><p>观察规律题或者建树题<br>我的思路是直接建立一颗二叉树，但是建立树代码可以不写；最后树是正确的就是中间不会访问到cur==size的情况，同时最后循环完之后不会再出现#或者数字<br>官方题解是：通过槽位计数，如果遍历到最后槽位为0说明正确，如果中间槽位为0，说明出错<br>因为加上一个#槽位数会–，如果加上一个数字那么槽位数会++（-1+2）<br>注意这道题的易错点是: 字符串中包含’,’而且可能数字包含两个字符 98,7,#</p><h3 id="2-二叉树的宽度"><a href="#2-二叉树的宽度" class="headerlink" title="2. 二叉树的宽度"></a>2. 二叉树的宽度</h3><p> 宽度应该包含一层的节点之间夹杂的空字符，所以为了得到一层的宽度，应该在栈中压入每个节点的下标(左边：2 * pos, 右边：2 * pos+1)，而不是具体的二叉树ListNode</p><h3 id="3-两个子节点的最近公共父节点"><a href="#3-两个子节点的最近公共父节点" class="headerlink" title="3. 两个子节点的最近公共父节点"></a>3. 两个子节点的最近公共父节点</h3><p>如果一个节点为target_one或者target_two那么直接返回当前节点，否则进行dfs, dfs返回的左右节点都是非NULL那么就返回当前节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">ListNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(ListNode* root, ListNode* node1, ListNode* node2)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>||root==p||root==q) <span class="hljs-keyword">return</span> root;<br>    <span class="hljs-keyword">if</span>(root==node1||root==node2)&#123;<br>        <span class="hljs-keyword">return</span> cur;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        ListNode *left=<span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left, node1, node2);<br>        ListNode *right=<span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right, node1, node2);<br>        <span class="hljs-keyword">if</span>(left&amp;&amp;right)&#123;<br>            <span class="hljs-keyword">return</span> cur;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left)&#123;<br>            <span class="hljs-keyword">return</span> left;<br>        &#125;<br>        <span class="hljs-keyword">return</span> right;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>一种离线求多个查询的公共父节点是使用Tarjan离线算法：<a href="https://www.cnblogs.com/wkfvawl/p/9415280.html">LCA最近公共祖先（Tarjan离线算法） - 王陸 - 博客园</a><br>主要思想是使用并查集+dfs, 将每个节点的祖先节点设置为当前的父节点，并且一个节点的所有子节点都dfs完成之后，就将当前节点的父节点标记为上一个节点，遍历与当前节点相关的所有查询：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-number">1</span> <span class="hljs-built_in">Tarjan</span>(u)<span class="hljs-comment">//marge和find为并查集合并函数和查找函数</span><br> 　　<span class="hljs-number">2</span> &#123;<br> 　　<span class="hljs-number">3</span>     <span class="hljs-function"><span class="hljs-keyword">for</span> <span class="hljs-title">each</span><span class="hljs-params">(u,v)</span>    <span class="hljs-comment">//访问所有u子节点v</span></span><br><span class="hljs-function"> 　　4     </span>&#123;<br>　　 <span class="hljs-number">5</span>         <span class="hljs-built_in">Tarjan</span>(v);        <span class="hljs-comment">//继续往下遍历</span><br>　　 <span class="hljs-number">6</span>         <span class="hljs-built_in">marge</span>(u,v);    <span class="hljs-comment">//合并v到u上</span><br>　　 <span class="hljs-number">7</span>         标记v被访问过;<br>　　 <span class="hljs-number">8</span>     &#125;<br>　　 <span class="hljs-number">9</span>     <span class="hljs-function"><span class="hljs-keyword">for</span> <span class="hljs-title">each</span><span class="hljs-params">(u,e)</span>    <span class="hljs-comment">//访问所有和u有询问关系的e</span></span><br><span class="hljs-function">　　10     </span>&#123;<br>　　<span class="hljs-number">11</span>         如果e被访问过;<br>　　<span class="hljs-number">12</span>          u,e的最近公共祖先为<span class="hljs-built_in">find</span>(e);<br>　　<span class="hljs-number">13</span>     &#125;<br>　　<span class="hljs-number">14</span> &#125;<br></code></pre></td></tr></table></figure><h3 id="4-从二叉树一个节点到另一个节点每一步的方向"><a href="#4-从二叉树一个节点到另一个节点每一步的方向" class="headerlink" title="4. 从二叉树一个节点到另一个节点每一步的方向"></a>4. 从二叉树一个节点到另一个节点每一步的方向</h3><p>方法，通过dfs找到根到达startValue和dstValue的具体路径，然后删除路径前面相同的部分，然后到达startValue剩余的size都加上U， 到达dstValue剩余的都加上dst剩余的路径</p><h3 id="5-寻找重复的树，"><a href="#5-寻找重复的树，" class="headerlink" title="5. 寻找重复的树，"></a>5. 寻找重复的树，</h3><p>解决方案：序列化+hash判断子树是否唯一，序列化只能使用# ，以及前序和后序遍历</p><ul><li>注意这道题需要记录空节点，同时，只能使用前序或者后序遍历 唯一判定两棵子树是否相同，而不能使用中序遍历。而且数据与数据应该用，隔开，因为222可以理解为2+2+2也可以理解为2+22 </li><li> ==加上#的这种情况，只有后序遍历和前序遍历能够唯一确定一课子树。中序遍历不行==  </li><li>同样这道题使用二叉树的序列化和反序列化, 因为前序和后序都可以知道根节点，但是中序不行</li></ul><h3 id="6-最长同值路径"><a href="#6-最长同值路径" class="headerlink" title="6. 最长同值路径"></a>6. 最长同值路径</h3><ul><li>和二叉树的直径类似，不过这里需要判断值是否相等，多了一个条件</li><li>为了区分left+right+1 left+1 right+1三种情况，可以使用一个left_mark 如果左边和root相等那么==left_val+1否则为0。那么最后的结果都是left_mark+right_mark+1， 解决了三种情况 返回max(left_mark, right_mark)+1</li></ul><h3 id="7-二叉树中所有距离为-K-的结点"><a href="#7-二叉树中所有距离为-K-的结点" class="headerlink" title="7. 二叉树中所有距离为 K 的结点"></a>7. 二叉树中所有距离为 K 的结点</h3><p>先通过dfs找到每个节点的父节点，然后再对target节点进行dfs 左右和父节点 (或者bfs+vis)</p><h3 id="8-二叉树寻路，使用数学方法"><a href="#8-二叉树寻路，使用数学方法" class="headerlink" title="8. 二叉树寻路，使用数学方法"></a>8. 二叉树寻路，使用数学方法</h3><p>1.先求每个数正常的父亲，然后再对不同的层进行修改<br>2.在进行修改的时候抓住对称的点的和是相同的<br>3.如果层数是偶数，那么只需要修改奇数层的值；如果层数是奇数，那么需要修改偶数层的数据</p><h3 id="9-二叉树中两个节点间的距离"><a href="#9-二叉树中两个节点间的距离" class="headerlink" title="9. 二叉树中两个节点间的距离"></a>9. 二叉树中两个节点间的距离</h3><p>先求两个节点的最近公共祖先，然后从最近公共祖先出发，求祖先节点分别到两个节点的距离(使用dfs两次，target==p||q)，距离之和就是两个节点的最短路径<br>代码：<a href="https://www.jianshu.com/p/cec33f514f69">LeetCode 第 B 题：二叉树任意两节点之间的最短路径 - 简书</a></p><h3 id="10-树的直径问题"><a href="#10-树的直径问题" class="headerlink" title="10. 树的直径问题"></a>10. 树的直径问题</h3><p>任意选择一个节点为根，然后找到离他最远的节点a，然后找到离a最远的节点b，那么a-&gt;b就是最远的路径（树的直径）<br>如果是二叉树有指针的情况可以使用递归</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> result=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxDistance</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> leftLength=<span class="hljs-built_in">maxDistance</span>(root-&gt;left);<br>    <span class="hljs-keyword">int</span> rightLenght=<span class="hljs-built_in">maxDistance</span>(root-&gt;right);<br>    result=<span class="hljs-built_in">max</span>(leftLength+rightLenght+<span class="hljs-number">1</span>, result);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(leftLength, rightLenght)+<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">diameterOfBinaryTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-built_in">maxDistance</span>(root);<br>    <span class="hljs-keyword">return</span> result<span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果是无向图：<br>算法思想<br>①从任意一点P出发，通过DFS寻找离它最远的点Q。<br>②再次从点Q出发，通过DFS寻找离它最远的W。<br>③直径即为WQ。<br>证明：<a href="https://zhuanlan.zhihu.com/p/115966044">【朝夕的ACM笔记】树上问题-树的直径 - 知乎</a></p><p>两次dfs</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> st)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;edge[st].<span class="hljs-built_in">size</span>();i++)<br>    &#123;<br>        <span class="hljs-keyword">int</span> to=edge[st][i];<br>        <span class="hljs-keyword">if</span>(!vis[to])<br>        &#123;<br>            vis[to]=<span class="hljs-number">1</span>;<br>            dis[to]=dis[st]+<span class="hljs-number">1</span>;<span class="hljs-comment">//注意，本代码计算的是无权树的直径，所以边权为1</span><br>            <span class="hljs-comment">//如果是有权树，则这里的1要改为边权</span><br>            <span class="hljs-built_in">dfs</span>(to);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>求最长就是求最大的dis，两次dfs中间需要重新初始化dis=0</p><p><font color="blue">多叉树的直径问题：lc6073. 相邻字符不同的最长路径（hard,周赛题目）</font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> maxlen=<span class="hljs-number">1</span>;<span class="hljs-comment">//根节点</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;vec[index].<span class="hljs-built_in">size</span>();i++)&#123;<br>    <span class="hljs-keyword">int</span> len=<span class="hljs-built_in">dfs</span>(vec[index][i], vec, s); <br>    <span class="hljs-keyword">if</span>(s[vec[index][i]]!=s[index])&#123;<br>        res=<span class="hljs-built_in">max</span>(res, maxlen+len);<span class="hljs-comment">//更新直径</span><br>        maxlen=<span class="hljs-built_in">max</span>(maxlen, len+<span class="hljs-number">1</span>);<span class="hljs-comment">//更新最大</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">return</span> maxlen;<br></code></pre></td></tr></table></figure><p><font color="red">参数一定要记得使用引用，否则就会超时</font></p><h3 id="11-具有所有最深节点的最小子树"><a href="#11-具有所有最深节点的最小子树" class="headerlink" title="11. 具有所有最深节点的最小子树"></a>11. 具有所有最深节点的最小子树</h3><p>在深度优先搜索的时候同时返回结果和计算深度，返回的是一个结构体 node{root, dist}.<br>1)获取当前节点的左右子树的最大深度<br>2)如果两边最大深度相同，则这个节点就是结果<br>3)不相等，那返回深度大的子树的root信息</p><h3 id="12-205-同构字符串-890-查找和替换模式"><a href="#12-205-同构字符串-890-查找和替换模式" class="headerlink" title="12. 205. 同构字符串/890. 查找和替换模式"></a>12. 205. 同构字符串/890. 查找和替换模式</h3><p>查找和对应模式一致的字符串，abb模式。<br>使用双hash,也就是两边都没有映射，才建立映射，或者两边都有映射且未对方，那么continue,否则说明出处</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span>(s2t.<span class="hljs-built_in">find</span>(s[i])==s2t.<span class="hljs-built_in">end</span>()&amp;&amp;t2s.<span class="hljs-built_in">find</span>(t[i])==t2s.<span class="hljs-built_in">end</span>())&#123;<br>    s2t[s[i]]=t[i];<br>    t2s[t[i]]=s[i];<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s2t[s[i]]=t[i]&amp;&amp;t2s[t[i]]==s[i])&#123;<br>    <span class="hljs-keyword">continue</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="13-二叉树的遍历"><a href="#13-二叉树的遍历" class="headerlink" title="13.二叉树的遍历"></a>13.二叉树的遍历</h3><p> 前后序遍历中空间复杂度为O(1)的Morris Traval方法（主要是利用叶子节点的空指针进行映射到下一个节点）<br>    <a href="https://www.cnblogs.com/AnnieKim/archive/2013/06/15/MorrisTraversal.html">Morris Traversal方法遍历二叉树（非递归，不用栈，O(1)空间） - AnnieKim - 博客园</a></p><ul><li><strong>前序遍历</strong><br>  根左右<ol><li>如果当前节点的左孩子为空，那么输出当前节点，并将当前节点设置为当前节点的右孩子</li><li>一个节点的左孩子不为空，那么在当前节点的左子树找到这个节点的前驱节点(左边的最后面一个节点)<br> 如果这个前驱节点的右孩子为空，那么设置右孩子为当前节点，==输出当前节点==（于中序的唯一不同），并当前节点更新为当前节点左孩子<br> 如果这个前驱节点的右孩子为当前节点，那么将右孩子重新设置为空。并更新当前节点为当前节点的右孩子。</li></ol></li></ul><ul><li><strong>中序遍历</strong><br>  左根右<ol><li>如果当前节点的左孩子为空，那么输出当前节点，并将当前节点设置为当前节点的右孩子</li><li>一个节点的左孩子不为空，那么在当前节点的左子树找到这个节点的前驱节点<br> 如果这个前驱节点的右孩子为空，那么设置右孩子为当前节点，并当前节点更新为当前节点左孩子<br> 如果这个前驱节点的右孩子为当前节点，那么将右孩子重新设置为空。<strong>输出当前节点</strong>， 并更新当前节点为当前节点的右孩子<br> 与前序遍历相比一个是回来之后再输出(else)，一个是建立前驱到根节点关系后输出（if）</li></ol></li></ul><ul><li><strong>后序遍历</strong><br>  <strong>需要建立一个临时节点dump</strong>，使该节点的左子树等于root<ol><li>如果当前节点的左孩子为空，那么则将其右孩子作为当前节点</li><li>一个节点的左孩子不为空，那么在当前节点的左子树找到这个节点的前驱节点<br>如果这个前驱节点的右孩子为空，那么设置右孩子为当前节点, 并当前节点更新为当前节点左孩子<br>如果这个前驱节点的右孩子为当前节点，那么还原前驱右孩子为null, ==同时逆序输出从当前节点左孩子到前驱节点的路==，并更新当前节点为右孩子</li></ol></li></ul><p>总结：建立关系后，到左孩子；为空或者一圈回来后到右孩子<br>    一圈回来后，还原关系</p><h3 id="14-将子数组重新排序得到同一个二叉查找树的方案数"><a href="#14-将子数组重新排序得到同一个二叉查找树的方案数" class="headerlink" title="14.  将子数组重新排序得到同一个二叉查找树的方案数"></a>14.  将子数组重新排序得到同一个二叉查找树的方案数</h3><p>题意，交换插入序列，但是得到的二叉搜索树最后的结果相同的序列共有多少个<br>解决：抓住，先插左还是右的顺序是可以变的，但是在插入单边的时候，根节点的插入顺序是不可以变的</p><ul><li>排列组合+dfs</li><li>求排列组合的时候，其实用动态规划的思想 C(n,k)=C(n-1, k-1)+C(n-1,k)</li><li>node-&gt;ans = (long long)c[lsize + rsize][lsize] % mod * lans % mod * rans % mod;</li><li>在使用dfs的时候，使用一个全局的res变量，每次乘以（all, less)的组合结果；划分less, greater的时候，可以用一个新的vector来记录左右子树的节点</li><li>也可以先建立一棵树，使用递归左右指针的方式，树的信息需要包含size ,ans等一些信息<br>另一种出题的方式：<br>  一个数组入栈顺序定了，有多少种出栈的顺序<br>  f(n)=f(1)* f(n-1) + f(2) * f(n-2)+…..f(n-1) f(1);<br>  递推公式的解为：h(n)=c(2n,n)-c(2n,n+1)(n=1,2,3,…)</li></ul><h3 id="15-二叉搜索树删除一个节点"><a href="#15-二叉搜索树删除一个节点" class="headerlink" title="15. 二叉搜索树删除一个节点"></a>15. 二叉搜索树删除一个节点</h3><p>递归删除<br>易错点：<br>    1. 可以根据二叉搜索树的性质，选择向左右递归<br>    2. 找到该节点，如果是叶节点直接删除，如果只有左右子树，也可以直接返回左右子树，否则找到左边最小，然后赋值到当前值，然后递归删除<br>    3. 注意递归删除的的时候，一定要注意返回值，一定要赋值给当前节点的左指针或者右指针; 否则会造成树在中间断裂</p><h3 id="16-lc987-二叉树的垂序遍历"><a href="#16-lc987-二叉树的垂序遍历" class="headerlink" title="16. lc987. 二叉树的垂序遍历"></a>16. lc987. 二叉树的垂序遍历</h3><ul><li>dfs 遍历nodes 记录下每个节点的行号row，列号 col 以及值 value。<br>在遍历完成后，我们按照 col 为第一关键字升序，row 为第二关键字升序，value 为第三关键字升序，对所有的节点进行排序即可。 遍历时将同一col的放到同一vector中</li><li>也可以使用map&lt;int, vector<node>&gt; 这样的话就不用手动分每一个col</node></li></ul><h3 id="17-lc979-在二叉树中分配硬币"><a href="#17-lc979-在二叉树中分配硬币" class="headerlink" title="17. lc979. 在二叉树中分配硬币"></a><font color="red">17. lc979. 在二叉树中分配硬币</font></h3><ul><li>第一种方法：可以考虑后序遍历理解；需要从父节点得到或者获取 root-&gt;val-1个节点，<br>ans+=abs(root-&gt;val-1); return root-&gt;val-1//返回可能是负数</li><li>第二种方法：转为在子树中分配硬币<br>dfs(root)表示root这棵子树冗余的节点数<br>return root-&gt;val+dfs(root-&gt;left)+dfs(root-&gt;right)-1;//自己送给父节点的<br>ans+=abs(dfs(root-&gt;left))+abs(dfs(root-&gt;right)); // 左右节点送给自己的</li></ul><p>其实也可以直接这样：<br>ans+=abs(root-&gt;val+left_val+right_val-1);<br>return root-&gt;val+left_val+right_val-1;</p><h3 id="18-lc99-恢复二叉搜索树"><a href="#18-lc99-恢复二叉搜索树" class="headerlink" title="18.  lc99. 恢复二叉搜索树"></a>18.  lc99. 恢复二叉搜索树</h3><ul><li>二叉树出现位置交换会出现两种情况<br>两次逆序：记录前面x和后面y， 第二次更新y<br>一次逆序：记录前面x和后面y</li><li>时间O(n),空间O(1)</li></ul><h3 id="19-Find-Leaves-of-Binary-Tree-e"><a href="#19-Find-Leaves-of-Binary-Tree-e" class="headerlink" title="19.  Find Leaves of Binary Tree e"></a>19.  Find Leaves of Binary Tree e</h3><ul><li>题意：类似剥洋葱一样，将二叉树从最外到最内</li><li>重新定义二叉树的深度为左右的最大值加一，然后res[depth].push_back(root-&gt;val)<br>if (depth &gt;= res.size()) res.resize(depth + 1);//因为最开始不知道最大的深度，因此不知道如何初始化，所以在最深一层初始化大小</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>主要考察前中后序遍历， 子树（序列化+hash）, 直径(自底向上判断，左右返回最大一个，同时更新结果为根)， 宽度（BFS）， 二叉树的左右节点（index*2, index *2）, 二叉搜索树相关（删除节点）， 自顶向下和自底向上递归</li><li>主要关联的数据结构有栈，队列（BFS/DFS）， hash, 字符串等</li><li>求总数的时候可能会涉及排列组合的知识， </li><li>判断当前子树是否为BST, 不能仅仅靠当前节点的值大于左边最大和右边最小就可以，还需要左右两边都是BST（lc333-最大BST子树）</li><li>注意删除元素的时候记得 节点的值需要更新  node=remove(xx) 防止树之间的连接断掉</li></ol>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>链表</title>
      <link href="/2021/11/16/leetcode/%E9%93%BE%E8%A1%A8/"/>
      <url>/2021/11/16/leetcode/%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="1-扁平化多级双向链表"><a href="#1-扁平化多级双向链表" class="headerlink" title="1. 扁平化多级双向链表"></a>1. 扁平化多级双向链表</h3><h3 id="2-有序数组或者链表转为二叉搜索树lc109"><a href="#2-有序数组或者链表转为二叉搜索树lc109" class="headerlink" title="2. 有序数组或者链表转为二叉搜索树lc109"></a>2. 有序数组或者链表转为二叉搜索树lc109</h3><ul><li>常规解法：找到中间节点为当前根节点，分别建立左右子树</li><li>链表找中位数，需要使用快慢指针和断开链表</li><li>为了解决链表找中位数耗时比较大，同时不使用额外空间（不转为数组方法）的方法就是使用中序遍历建树方法：</li><li>我们没有必要“先”找到中间节点：我们可以先构建了左子树，建立结束后，指针自然指向中间结点。那么如何构建左子树呢？其实我们只需要确定子树的大小就可以。所以先用O(n)的时间计算链表长度，之后用中序遍历。当然，指针需要是“引用”。</li><li>为什么要使用指针：因为使用了递归，如果不使用指针，那么递归返回，head就不会被修改，而实际上我们是像达到一个全局变量向前走的效果，因此需要使用指针引用 ListNode* &amp;head</li></ul><h3 id="3-二叉树的最小深度（简单）"><a href="#3-二叉树的最小深度（简单）" class="headerlink" title="3. 二叉树的最小深度（简单）"></a>3. 二叉树的最小深度（简单）</h3><ul><li>注意是叶节点返回1，root==null 返回0， 但是在更新内部节点要判断左右是否为空，若任意一边为空，那么那一边不能加入计算中</li></ul><h3 id="4-二叉树展开为链表"><a href="#4-二叉树展开为链表" class="headerlink" title="4. 二叉树展开为链表"></a>4. 二叉树展开为链表</h3><p>先展开左右两边，然后如果展开的左边不为空，那么将左边展开后返回的头结点插入root-&gt;right, 同时设置root-&gt;left=null, 然后循环找到之前左边（现在右边）中最下面那个点，连接展开的右边返回的头节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">TreeNode* <span class="hljs-title">flattenFunc2</span><span class="hljs-params">(TreeNode *root)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    TreeNode* f_left = <span class="hljs-built_in">flattenFunc2</span>(root-&gt;left);<br>    TreeNode* f_right = <span class="hljs-built_in">flattenFunc2</span>(root-&gt;right);<br>    root-&gt;left=<span class="hljs-literal">nullptr</span>;<br>    TreeNode* res=root; <span class="hljs-comment">//一定要记得记录最开始的头结点</span><br>    <span class="hljs-keyword">if</span>(f_left!=<span class="hljs-literal">nullptr</span>)&#123; <span class="hljs-comment">//1. 左边不为空插入根和右边之间</span><br>        root-&gt;right=f_left;<br>        <span class="hljs-keyword">while</span>(root-&gt;right!=<span class="hljs-literal">nullptr</span>)&#123;<br>            root=root-&gt;right; <span class="hljs-comment">//改变了头结点</span><br>        &#125;<br>        root-&gt;right=f_right;<br>    &#125;<span class="hljs-keyword">else</span>&#123;  <span class="hljs-comment">//2. 否则直接连接根和右边</span><br>        root-&gt;right=f_right;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-lc1019-链表中的下一个更大节点"><a href="#5-lc1019-链表中的下一个更大节点" class="headerlink" title="5. lc1019. 链表中的下一个更大节点"></a>5. lc1019. 链表中的下一个更大节点</h3><ul><li>题意：求链表中每个元素下一个更大的值</li><li>方法1.单独一个vector来记录，单调递减栈下标（从左到右，需要知道前面元素的下标）</li><li>方法2.进行链表的翻转，得到list的len， 同时使用单调递减值栈 (从右到左， 不需要知道下标，只需要存储值)</li></ul><h3 id="6-lc143-重排链表"><a href="#6-lc143-重排链表" class="headerlink" title="6. lc143. 重排链表"></a>6. lc143. 重排链表</h3><ul><li>找到链表终点，后面的链表翻转，链表merge</li><li>这道题既考了快慢指针查找链表中点，还考了链表翻转以及链表merge 字节+阿里面试题</li></ul><h3 id="7-易错点"><a href="#7-易错点" class="headerlink" title="7. 易错点"></a>7. 易错点</h3><ul><li> 判断head是否为null</li><li> 在使用tmp-&gt;next 或者tmp-&gt;prev 一定要注意判断当前节点不能为null<br>也就是if(tmp){</li></ul><p>}</p><ul><li><p>双向链表在进行删除某个节点的时候，先固定前面和后面的关系都可以；但是在插入一个节点的时候一定要先固定后面的</p></li><li><p>LRU cache易错点：再删除需要指针+hash都需要消除，cache.erase(lastNode-&gt;key); delete lastNode;<br>可以用hash.size()定位cache元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"> LRU cache（一个双向链表，一个hash）<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LinkNode</span>&#123;</span><br>    <span class="hljs-keyword">int</span> key,val;<br>    LinkNode* next;<br>    LinkNode* pre;<br>    <span class="hljs-built_in">LinkNode</span>()&#123;<br>        next=<span class="hljs-literal">nullptr</span>;<br>        pre=<span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>LRU： 使用一个双向链表+unordered_map(数组/(key-&gt;*node))</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">unordered_map&lt;<span class="hljs-keyword">int</span>,Node*&gt; cache;<br></code></pre></td></tr></table></figure></li><li><p>LFU, 需要使用双向链表List(key-&gt;*node/ freq_list: (freq-&gt; 链表list头节点，也就是nodelist双向链表))+unordered_map</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">map&lt;<span class="hljs-keyword">int</span>, Node*&gt; key2node;<br>map&lt;<span class="hljs-keyword">int</span>, NodeList*&gt; freq2List;<br></code></pre></td></tr></table></figure></li><li><p>判断两个链表是否相交问题<br><a href="https://blog.csdn.net/jikuidongke5461/article/details/110160868">寻找两个链表相交节点方法（可以是有环链表）-CSDN博客</a><br>两个链表是否同时有环<br>  都有环（入环节点是否相等）<br>  都无环 （栈或者长链表先走lena-lenb）<br>  一个有一个无 (肯定不相交)</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>注意root=null 特殊情况</li><li>在调整树结构的时候一定要注意，返回节点，否则就可能链表断掉</li><li>充分利用二叉搜索树这些信息</li><li>有序链表的合并，一定要注意判断两个链表是否相交，或者链表是否有环的情况，如果遇到这两种情况要特殊处理</li></ol>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基本神经网络相关问题</title>
      <link href="/2021/11/13/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E5%9F%BA%E6%9C%AC%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/"/>
      <url>/2021/11/13/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E5%9F%BA%E6%9C%AC%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h3 id="1-滤波和传统的图像算法-e-g-SIFT"><a href="#1-滤波和传统的图像算法-e-g-SIFT" class="headerlink" title="1. 滤波和传统的图像算法 e.g. SIFT"></a>1. 滤波和传统的图像算法 e.g. SIFT</h3><h3 id="2-CNN感受野定义以及计算方式"><a href="#2-CNN感受野定义以及计算方式" class="headerlink" title="2. CNN感受野定义以及计算方式"></a>2. CNN感受野定义以及计算方式</h3><p>感受野指的是一个特定的 CNN 特征（特征图上的某个点）在输入空间所受影响的区域。<br>感受野的计算是输出图像的反向过程</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">out_put=(iput_size-kernel_size)/stride+<span class="hljs-number">1</span><br>input_size=(out_put-<span class="hljs-number">1</span>)*stride+kernel_size<br></code></pre></td></tr></table></figure><h3 id="3-CNN矩阵乘法原理"><a href="#3-CNN矩阵乘法原理" class="headerlink" title="3. CNN矩阵乘法原理"></a>3. CNN矩阵乘法原理</h3><p>参考链接：<a href="https://shuokay.com/2016/06/08/convolution/">卷积计算</a><br>img2col将卷积运算转为矩阵乘法<br>其中输入的矩阵：行方向对应特征图不同channel同一视野（位置）的向量展开；列方向代表不同的位置；<br>kernel的矩阵：行方向代表代表不同的卷积核，列方向代表一个滤波器每个channel的矩阵-&gt;向量，<br>输出矩阵</p><h3 id="4-BatchNormalization与正则化的区别："><a href="#4-BatchNormalization与正则化的区别：" class="headerlink" title="4. BatchNormalization与正则化的区别："></a>4. BatchNormalization与正则化的区别：</h3><ul><li>BatchNormalization主要是用于将神经网络中间输入特征图的均值和方差进行规范化，使输入分布拉到容易激活后面激活层中，解决梯度消失和梯度爆炸问题问题</li><li>正则化，通常用于机器学习，在损失函数中加上参数的一阶或者二阶和，防止过拟合</li></ul><h3 id="5-产生梯度消失或爆炸的原因："><a href="#5-产生梯度消失或爆炸的原因：" class="headerlink" title="5. 产生梯度消失或爆炸的原因："></a>5. 产生梯度消失或爆炸的原因：</h3><ul><li>网络层数太深而引发的梯度反向传播中的连乘效应</li><li>解决梯度消失或者梯度爆炸问题的解决方案：<ul><li>batch BatchNormalization</li><li>梯度裁剪</li><li>修改激活函数，比如leaky relu</li><li>残差结构</li><li>每层预训练后微调</li></ul></li></ul><h3 id="6-机器学习：多分类如何转为多个二分类问题：需要训练N个分类器"><a href="#6-机器学习：多分类如何转为多个二分类问题：需要训练N个分类器" class="headerlink" title="6. 机器学习：多分类如何转为多个二分类问题：需要训练N个分类器"></a>6. 机器学习：多分类如何转为多个二分类问题：需要训练N个分类器</h3><p><a href="https://yuanxiaosc.github.io/2018/07/01/%E4%BA%8C%E5%88%86%E7%B1%BB%E3%80%81%E5%A4%9A%E5%88%86%E7%B1%BB%E4%B8%8E%E5%A4%9A%E6%A0%87%E7%AD%BE%E9%97%AE%E9%A2%98%E7%9A%84%E5%8C%BA%E5%88%AB%E2%80%94%E2%80%94%E5%AF%B9%E5%BA%94%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E7%9A%84%E9%80%89%E6%8B%A9/">参考链接</a><br>将每一次的一个类作为正例，其余作为反例，总共训练N个分类器。测试的时候若仅有一个分类器预测为正的类别则对应的类别标记作为最终分类结果，若有多个分类器预测为正类，则选择置信度最大的类别作为最终分类结果。<br>PS:目标检测的多标签二分类损失函数是使用每个标签的概率的求二分损失函数（逻辑损失）然后求平均值得到整体的损失<br>其他方案：<br>一对一，建立N(N-1)/2个分类器，然后进行投票<br>直接用softmax进行多分类任务训练</p><h3 id="7-网络退化以及resnet为什么可以解决梯度消失和网络退化问题："><a href="#7-网络退化以及resnet为什么可以解决梯度消失和网络退化问题：" class="headerlink" title="7. 网络退化以及resnet为什么可以解决梯度消失和网络退化问题："></a>7. 网络退化以及resnet为什么可以解决梯度消失和网络退化问题：</h3><p>首先介绍什么是网络退化问题<br>举个例子，假设已经有了一个最优化的网络结构，是18层。当我们设计网络结构的时候，我们并不知道具体多少层次的网络时最优化的网络结构，假设设计了34层网络结构。那么多出来的16层其实是冗余的，我们希望训练网络的过程中，模型能够自己将这16层冗余层训练为恒等映射，也就是经过这层时的输入与输出完全一样。<br>但是往往模型很难将这16层恒等映射的参数学习正确，那么就不如最优化的18层网络结构的性能，这就是随着网络深度增加，模型会产生退化现象。它不是由过拟合产生的，而是由冗余的网络层学习了不是恒等映射的参数造成的。<br>也就是说神经网络学习恒等映射 F(x)=x 的效果不好，但是加上了skip connection 神经网络就用于学习F(x)=0</p><h3 id="8-链式法则"><a href="#8-链式法则" class="headerlink" title="8. 链式法则"></a>8. 链式法则</h3><p>原本y对x求偏导，但是由于过程较为复杂，我们引入了一个中间层z，先利用y对z求偏导，在乘上z对x求偏导，这样会使整个计算更为简单。<br>当前error对当前层参数的导数，是error对当前输出（输出特征图）的倒数*当前节点的输入（输入特征图）</p><h3 id="9-矩阵的反向传播算法-CNN的反向梯度传播算法"><a href="#9-矩阵的反向传播算法-CNN的反向梯度传播算法" class="headerlink" title="9. 矩阵的反向传播算法/CNN的反向梯度传播算法"></a>9. 矩阵的反向传播算法/CNN的反向梯度传播算法</h3><h3 id="10-激活函数sigmoid，tanh，relu-各自的优点和适用场景"><a href="#10-激活函数sigmoid，tanh，relu-各自的优点和适用场景" class="headerlink" title="10. 激活函数sigmoid，tanh，relu. 各自的优点和适用场景"></a>10. 激活函数sigmoid，tanh，relu. 各自的优点和适用场景</h3><p>[参考链接]（<a href="https://zhuanlan.zhihu.com/p/71882757">温故知新——激活函数及其各自的优缺点 - 知乎</a>）<br>激活函数的作用：主要是向神经网络中引入非线性的特征</p><ul><li>sigmoid函数：主要运用在逻辑二分类中，缺点：计算复杂，不是0均值，同时容易出现梯度饱和，当输入是非常大的正值或者负值的时候，反向传播梯度为0；</li><li>tanh函数：是0均值，但是计算复杂，同时也容易出现梯度饱和问题</li><li>relu函数：计算简单，在输入大于0的时候不会出现梯度饱和，但是在输入小于0的时候会出现梯度为0，造成死的神经元，因此参数一直得不到更新</li></ul><h3 id="11-常见神经网络的结构特点和结构优势"><a href="#11-常见神经网络的结构特点和结构优势" class="headerlink" title="11. 常见神经网络的结构特点和结构优势"></a>11. 常见神经网络的结构特点和结构优势</h3><h3 id="12-牛顿法和SGD的各自原理，优势，区别"><a href="#12-牛顿法和SGD的各自原理，优势，区别" class="headerlink" title="12. 牛顿法和SGD的各自原理，优势，区别"></a>12. 牛顿法和SGD的各自原理，优势，区别</h3><h3 id="13-LR的梯度反向传播推导"><a href="#13-LR的梯度反向传播推导" class="headerlink" title="13. LR的梯度反向传播推导"></a>13. LR的梯度反向传播推导</h3><p><a href="https://blog.csdn.net/ft_sunshine/article/details/105370528">逻辑回归（LR）公式推导及代码实现_lr推导过程-CSDN博客</a></p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs isbl">方程：<span class="hljs-variable">y</span>=<span class="hljs-variable">theta</span>*<span class="hljs-variable">x</span><br>激活函数 <span class="hljs-function"><span class="hljs-title">h</span>(<span class="hljs-variable">x</span>)-<span class="hljs-number">1</span>/(<span class="hljs-number">1</span>+<span class="hljs-variable">e</span>^(-<span class="hljs-variable">theta</span> <span class="hljs-variable">x</span>))</span><br>损失函数 <span class="hljs-variable">loss</span>=<span class="hljs-number">1</span>/<span class="hljs-variable">m</span>*求和(<span class="hljs-variable">y</span>^<span class="hljs-function"><span class="hljs-title">ilog</span>(<span class="hljs-title">h</span>(<span class="hljs-variable">x</span>)) - (<span class="hljs-number">1</span>-<span class="hljs-variable">y</span>^<span class="hljs-variable">i</span>)<span class="hljs-title">log</span>(<span class="hljs-number">1</span>-<span class="hljs-title">h</span>(<span class="hljs-variable">x</span>))))</span><br></code></pre></td></tr></table></figure><h3 id="14-反向传播的手动推导"><a href="#14-反向传播的手动推导" class="headerlink" title="14. 反向传播的手动推导"></a>14. 反向传播的手动推导</h3><p>两个非常重要的链接：<br><a href="https://wiki.eecs.yorku.ca/course_archive/2011-12/F/4403/_media/backpropagation.pdf">Backpropagation-pdf</a></p><p><a href="https://mlln.cn/2018/02/27/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9CBP%E7%AE%97%E6%B3%95%E6%B1%82%E5%AF%BC-%E6%89%8B%E5%8A%A8%E6%8E%A8%E5%AF%BC/">神经网络BP算法求导-手动推导 - DataSense</a> (感觉有点问题)</p><p>主要是在最后损失层（平方误差和交叉熵误差）使得最后一层不同<br>平方误差的话</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">loss</span>=<span class="hljs-number">1</span>/<span class="hljs-number">2</span>*(output-target)^<span class="hljs-number">2</span>  delta(output)=output-target<br></code></pre></td></tr></table></figure><p>二分交叉熵的话</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">loss</span>=-Y<span class="hljs-number">1</span>(logy<span class="hljs-number">1</span>)-(<span class="hljs-number">1</span>-Y<span class="hljs-number">0</span>)log(<span class="hljs-number">1</span>-y<span class="hljs-number">0</span>)  delta(y<span class="hljs-number">0</span>)= y<span class="hljs-number">0</span>-Y<span class="hljs-number">0</span> delta(y<span class="hljs-number">1</span>)= y<span class="hljs-number">1</span>-Y<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 项目相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DNN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习</title>
      <link href="/2021/11/13/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
      <url>/2021/11/13/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="1-xgboost与GDBT的区别"><a href="#1-xgboost与GDBT的区别" class="headerlink" title="1. xgboost与GDBT的区别"></a>1. xgboost与GDBT的区别</h3><p>xgboost属于GDBT的工程实现，但是相比于GDBT有更多的优化</p><ul><li>1.两者都是属于boosting方法，就是迭代串行求多个模型，每个模型不同权重，训练过程中样本也具有不同的权重</li><li>2.GDBT是使用多个决策树组成的，xgboost可以使用线性模型</li><li>3.xgboost使用了代价函数的一阶和二阶信息，同时可以用户自定义代价函数，同时xgboost在代价函数中加入了正则项，用于控制模型的复杂度</li><li>4.xgboost能够自动对缺失值进行处理</li></ul>]]></content>
      
      
      <categories>
          
          <category> 项目相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> machine learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编程语言</title>
      <link href="/2021/11/13/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
      <url>/2021/11/13/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><p><a href="https://www.i4k.xyz/article/qq_38992249/119968248">python八股</a></p><h3 id="1-python-GIL介绍"><a href="#1-python-GIL介绍" class="headerlink" title="1. python GIL介绍"></a>1. python GIL介绍</h3><h3 id="2-list-tuple-set的区别"><a href="#2-list-tuple-set的区别" class="headerlink" title="2. list tuple set的区别"></a>2. list tuple set的区别</h3><h3 id="3-python迭代器和生成器的区别是什么"><a href="#3-python迭代器和生成器的区别是什么" class="headerlink" title="3. python迭代器和生成器的区别是什么"></a>3. python迭代器和生成器的区别是什么</h3><p>生成器本质上还是一个迭代器，也是用在迭代操作中，因此它有和迭代器一样的特性，唯一的区别在于实现方式上不一样，后者更加简洁；<br>生成器只是在需要这个值再生成</p><h3 id="4-迭代器"><a href="#4-迭代器" class="headerlink" title="4. 迭代器"></a>4. 迭代器</h3><p>迭代器对象要求支持迭代器协议的对象。在Python中，支持迭代器协议就是实现对象的__iter__()和next()方法。<br>其中__iter__()方法返回迭代器对象本身；next()方法返回容器的下一个元素，在结尾时引发StopIteration异常。<br>iter是可迭代对象，可迭代对象才能调用next函数</p><h3 id="5-生成器"><a href="#5-生成器" class="headerlink" title="5. 生成器"></a>5. 生成器</h3><p>生成器(generator)就是一个函数，它提供了一种实现迭代器协议的便捷方式。<br>生成器与普通函数的区别在于它包含 yield 表达式，并且不需要定义 <strong>iter</strong>()和__next__()。</p><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><h3 id="1-vector"><a href="#1-vector" class="headerlink" title="1.vector"></a>1.vector</h3><p>查找元素，find函数返回的是一个迭代器</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">find</span>(vector.<span class="hljs-built_in">begin</span>(), vector.<span class="hljs-built_in">end</span>(), target_val)!=vector.<span class="hljs-built_in">end</span>() <br></code></pre></td></tr></table></figure><p>插入删除元素</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">vector.push<span class="hljs-constructor">_back(<span class="hljs-params">i</span>)</span><br>vector.pop<span class="hljs-constructor">_back()</span><br></code></pre></td></tr></table></figure><p>进行vector1和vector2的交换:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">vec1</span>.swap(vec<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>截取vector的一部分，并赋值给vec2,注意后面的值表示vec不需要 也就是左闭右开模式:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">vec2</span><span class="hljs-params">(vec1.begin()</span></span>, vec1<span class="hljs-selector-class">.begin</span>()+<span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><p>vector最后一个元素</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">vector.<span class="hljs-keyword">back</span>()<br></code></pre></td></tr></table></figure><p>将target元素插入到pos位置</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">vector.<span class="hljs-built_in">insert</span>(vec.<span class="hljs-built_in">begin</span>()+pos, target)<br></code></pre></td></tr></table></figure><p>找到大于或大于等于目标的数<br><font color="red">lower_bound返回的是大于等于目标函数的数， upper_bound返回的是大于目标函数的数</font></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">auto pos=lower<span class="hljs-constructor">_bound(<span class="hljs-params">nums</span>.<span class="hljs-params">begin</span>()</span>, nums.<span class="hljs-keyword">end</span><span class="hljs-literal">()</span>, target)<br>index = pos-nums.<span class="hljs-keyword">begin</span><span class="hljs-literal">()</span> <span class="hljs-comment">//</span><br></code></pre></td></tr></table></figure><p>注意和set的lower_bound不一样的<br>set.lower_bound(targets) 返回一个迭代器</p><p>mp的lower_bound也是不一样的<br>auto iter = mp.lower_bound(val)</p><p>set和map中的元素都是排好序的</p><h3 id="2-unordered-set-my-set"><a href="#2-unordered-set-my-set" class="headerlink" title="2.unordered_set my_set"></a>2.unordered_set my_set</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">my_set.<span class="hljs-built_in">find</span>(target_value)!=my_set.<span class="hljs-built_in">end</span>() <span class="hljs-keyword">or</span> my_set.<span class="hljs-built_in">count</span>(target_value)!=<span class="hljs-number">0</span><br>my_set.<span class="hljs-built_in">insert</span>(value)<br>my_set.<span class="hljs-built_in">erase</span>(value)<br></code></pre></td></tr></table></figure><p>unordered_set查找元素的两种方式：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">（<span class="hljs-number">1</span>）umap.find(<span class="hljs-keyword">target</span>)!=<span class="hljs-number">-1</span>  (<span class="hljs-number">2</span>) umap[<span class="hljs-keyword">target</span>]<br></code></pre></td></tr></table></figure><p>unordered_set在进行查找的时候可以直接使用unordered_set[target]即使是target不存在也不会报错，<br>但是在vector中查找某一个元素就需要</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">vec.<span class="hljs-built_in">find</span>(target)!=vec.<span class="hljs-built_in">end</span>() <br></code></pre></td></tr></table></figure><h3 id="3-priority-queue-queue"><a href="#3-priority-queue-queue" class="headerlink" title="3. priority_queue / queue"></a>3. priority_queue / queue</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">q</span><span class="hljs-selector-class">.push</span>()<br><span class="hljs-selector-tag">q</span><span class="hljs-selector-class">.pop</span>()<br></code></pre></td></tr></table></figure><h3 id="4-set-insert-value-erase-value-push-pop"><a href="#4-set-insert-value-erase-value-push-pop" class="headerlink" title="4. set insert(value) erase(value) push pop"></a>4. set insert(value) erase(value) push pop</h3><p>遍历元素</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> iter=set.<span class="hljs-built_in">begin</span>(); iter!=set.<span class="hljs-built_in">end</span>(); iter++)<br></code></pre></td></tr></table></figure><p>用vector里面的元素初始化</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function">set unordered_set&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">nums_set</span><span class="hljs-params">(nums1.begin(), nums1.end())</span></span>;<br>其中nums1是vector<br></code></pre></td></tr></table></figure><h3 id="5-map"><a href="#5-map" class="headerlink" title="5.map"></a>5.map</h3><p>插入元素：</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="hljs-keyword">map</span><span class="hljs-built_in">[key</span>]=<span class="hljs-keyword">value</span>; 或者<span class="hljs-keyword">map</span>.<span class="hljs-keyword">insert</span>(make_pair<span class="hljs-built_in">(key</span>, <span class="hljs-keyword">value</span>))<br></code></pre></td></tr></table></figure><p>删除元素：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">map</span>.erase(<span class="hljs-built_in">key</span>)//注意不是<span class="hljs-built_in">remove</span><br></code></pre></td></tr></table></figure><p>查找元素：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">map.<span class="hljs-built_in">find</span>(key)<br></code></pre></td></tr></table></figure><p>复制元素：</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sas">hash.<span class="hljs-meta">insert</span>(hash1.beg<span class="hljs-meta">in(</span>), hash1.<span class="hljs-meta">end</span>())<br>PS： vector的复制是 vec.a<span class="hljs-meta">ssign(</span>vec1.beg<span class="hljs-meta">in(</span>), vec1.<span class="hljs-meta">end</span>())<br></code></pre></td></tr></table></figure><h3 id="6-其他语法"><a href="#6-其他语法" class="headerlink" title="6.其他语法"></a>6.其他语法</h3><p>判断字符是字母：<code>isalpha()</code></p><p>判断字符是数字：<code>isdigit()</code></p><p>判断字符是字母或数字：<code>isalnum()</code></p><p>同时注意c++中，字符用单引号表示，字符串用双引号表示</p><p>注意c++中只有数组能够使用memset，在vector中不能使用</p><h3 id="7-string"><a href="#7-string" class="headerlink" title="7.string"></a>7.string</h3><p>find函数 </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">pos</span>=s.find(target)  <span class="hljs-attribute">pos</span>=s.find(target,0)<br></code></pre></td></tr></table></figure><p>如果没有找到返回<code>s.npos</code> 或者<code>string::npos</code></p><p>原地移除数组上的元素，我们说到了数组上的元素，不能真正的删除，只能覆盖。<code>array.erase(i)</code>的时间复杂度是O(n)</p><h3 id="8-set-数组-map的选择"><a href="#8-set-数组-map的选择" class="headerlink" title="8.set 数组 map的选择"></a>8.set 数组 map的选择</h3><p>主要是看数据的范围，如果数据返回不确定那么尽量选择map or set，如果确定是小写字母的话，也就是26个字母，可以使用数组<br>set包含 unordered_set（无序， 哈希表，不能重复， 查询和增删效率O(1)）, multiset（有序，红黑树，可以重复 O(nlogn)）, set(有序， 红黑树，不能重复， O(nlong))； map类似<br>三种都是只能erase和insert不能修改数值， map不能修改key但是可以修改value</p><h3 id="9-stack"><a href="#9-stack" class="headerlink" title="9. stack"></a>9. stack</h3><p>栈的底层实现可以是<code>vector, dequeue, list</code><br>栈只能获取最后一个元素，无法直接获取第一个元素<br><code>top()</code>    返回栈顶元素的引用，类型为 T&amp;，如果栈为空，返回值未定义<br><code>pop()</code>    栈顶元素出栈<br><code>size()</code>    返回栈中元素的个数<br><code>empty()</code>    栈中没有元素时返回 true<br><code>emplace()</code>    使用传入的参数调用构造函数，在栈顶生成对象<br><code>push(const T&amp; obj)</code> 将对象副本压入栈顶，通过调用底层容器的 <code>push_back() </code> 函数实现<br><code>push(T&amp;&amp; obj)</code>    以移动对象的方式将对象压入栈，通过调用底层容器的有右值引用参数的 push_back() 函数实现<br><code>swap(stack&lt;T&gt; &amp; other_stack)</code>    将当前栈中的元素和参数中的元素交换，参数所包含元素的类型必须和当前栈的相同，对于 stack 对象有一个特例化的全局函数 <code>swap()</code>可以使用</p><p>一道面试题：栈里面的元素在内存中是连续分布的么？</p><p>这个问题有两个陷阱：<br>陷阱1：栈是容器适配器，底层容器使用不同的容器，导致栈内数据在内存中是不是连续分布。<br>陷阱2：缺省情况下，默认底层容器是deque，那么deque的在内存中的数据分布是什么样的呢？答案是：不连续的，下文也会提到deque。</p><h3 id="10-queue-队列"><a href="#10-queue-队列" class="headerlink" title="10.queue 队列"></a>10.queue 队列</h3><p>可以访问队列最后一个元素，但是无法pop最后一个元素<br>queue入队，如例：<code>q.push(x)</code>; 将x 接到队列的末端。</p><p>queue出队，如例：<code>q.pop()</code>; 弹出队列的第一个元素，注意，并不会返回被弹出元素的值。</p><p>访问queue队首元素，如例：<code>q.front()</code>，即最早被压入队列的元素。</p><p>访问queue队尾元素，如例：<code>q.back()</code>，即最后被压入队列的元素。</p><p>判断queue队列空，如例：<code>q.empty()</code>，当队列空时，返回true。</p><h3 id="11-pair"><a href="#11-pair" class="headerlink" title="11. pair"></a>11. pair</h3><p><code>pair&lt;int, int&gt; </code>访问元素不是用下标而是用first second<br>创建一个pair用<br><code>pair&lt;int, int&gt; res = make_pair&lt;a, b&gt;</code><br>或者用括号<br><code>pair&lt;int, int&gt; b(1, 2);</code></p><h3 id="12-multiset-set"><a href="#12-multiset-set" class="headerlink" title="12. multiset/set"></a>12. multiset/set</h3><p>两者都是存储的重复的数据，不一样的是前者可以存储冗余的数据<br>删除一个数</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-keyword">c</span><span class="hljs-number">1</span>.erase(<span class="hljs-keyword">c</span><span class="hljs-number">1</span>.find(<span class="hljs-keyword">x</span>))//删除一个<span class="hljs-keyword">x</span><br><span class="hljs-keyword">c</span><span class="hljs-number">1</span>.erase(<span class="hljs-keyword">x</span>)//删除所有<span class="hljs-keyword">x</span>元素<br></code></pre></td></tr></table></figure><h3 id="13-新建一个未知长度的数组"><a href="#13-新建一个未知长度的数组" class="headerlink" title="13. 新建一个未知长度的数组"></a>13. 新建一个未知长度的数组</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> *queue;<br>queue=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[k+<span class="hljs-number">1</span>] 主要是用于类构建动态数组的这种情况<br></code></pre></td></tr></table></figure><h3 id="14-向上取整"><a href="#14-向上取整" class="headerlink" title="14. 向上取整"></a>14. 向上取整</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">(x+(<span class="hljs-selector-tag">b</span>-<span class="hljs-number">1</span>))/<span class="hljs-selector-tag">b</span>*<span class="hljs-selector-tag">b</span><br></code></pre></td></tr></table></figure><h3 id="15-malloc和new的区别"><a href="#15-malloc和new的区别" class="headerlink" title="15. malloc和new的区别"></a>15. malloc和new的区别</h3><img src="/2021/11/13/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/image-20220122202312622.png" class title="image-20220122202312622"><h3 id="16-hashMap原理"><a href="#16-hashMap原理" class="headerlink" title="16. hashMap原理"></a>16. hashMap原理</h3><h3 id="17-C-模板的使用方法"><a href="#17-C-模板的使用方法" class="headerlink" title="17. C++模板的使用方法"></a>17. C++模板的使用方法</h3><p><a href="https://blog.csdn.net/qq_35637562/article/details/55194097">参考链接</a></p><h3 id="18-struct的class的区别："><a href="#18-struct的class的区别：" class="headerlink" title="18. struct的class的区别："></a>18. struct的class的区别：</h3><ul><li>class继承的权限默认是private, struct继承的权限是public</li><li>class可以作为模板的参数，但是struct不行</li><li>class不能使用{}进行初始化，struct在没有虚函数的时候可以使用{}进行初始化</li></ul>]]></content>
      
      
      <categories>
          
          <category> 项目相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python, C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈希与前缀和</title>
      <link href="/2021/11/13/leetcode/%E5%93%88%E5%B8%8C%E7%9B%B8%E5%85%B3/"/>
      <url>/2021/11/13/leetcode/%E5%93%88%E5%B8%8C%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="前缀和-hash"><a href="#前缀和-hash" class="headerlink" title="前缀和 + hash"></a>前缀和 + hash</h2><p>一定要注意先判断hash[presum-target]是否存在并更新结果，再更新hash[presum]++， 因为可能nums[i]=0</p><h3 id="1-面试题-17-05-字母与数字"><a href="#1-面试题-17-05-字母与数字" class="headerlink" title="1. 面试题 17.05.  字母与数字"></a>1. 面试题 17.05.  字母与数字</h3><p>要求字母和数字个数相同，那么就是将字母转为1， 数字转为-1的时候，前缀和为0的最长序列；<br>另外使用这种思想是的”和等于 k 的最长子数组长度“ ”和等于k子数组“ （hash+前缀和）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//hash+前缀和的模板代码</span><br>hash[<span class="hljs-number">0</span>]=<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();++i)&#123;<br>    sum += nums[i];<br>    <span class="hljs-keyword">if</span>(hash.<span class="hljs-built_in">count</span>(sum-k))  res= <span class="hljs-built_in">max</span>(res,i-hash[sum-k]);<br>    <span class="hljs-keyword">if</span>(!hash.<span class="hljs-built_in">count</span>(sum)) hash[sum]=i; <span class="hljs-comment">// 因为要的是第一次出现的值</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="2-lc1371-每个元音包含偶数次的最长子字符串"><a href="#2-lc1371-每个元音包含偶数次的最长子字符串" class="headerlink" title="2. lc1371. 每个元音包含偶数次的最长子字符串:"></a><font color="red">2. lc1371. 每个元音包含偶数次的最长子字符串</font>:</h3><p>题解：为了表明每个元音出现了偶数次，可以使用二进制数，如果一个位经过一轮之后仍然为当前的值，那么说明这个位出现了偶数次或者没出现过，<br>通过这种方法可以类推到特定字符出现k数次，那么就使用k进制；同时注意是每个元音出现偶数次，而不是元音总个数为偶数次，如果是第二种情况<br>可以使用元音为奇数表示，sum%2==0表示元音个数为偶数）<br>    k进制的加法过程类似于大数相加</p><h3 id="3-连续的子数组和"><a href="#3-连续的子数组和" class="headerlink" title="3. 连续的子数组和"></a>3. 连续的子数组和</h3><p>注意这道题不是说连续的子数组为目标数，而是为目标数的倍数，但是仍然可以用这种方法来做，因为为目标数的倍数，意味着前缀和%该数得到的余数相同，因为可以用hash记录第一次出现该余数的下标，然后再次出现时，判断数组长度是否大于等于2， 一定要注意在开始的时候hash[0]=-1!!!</p><h3 id="4-连续数组"><a href="#4-连续数组" class="headerlink" title="4. 连续数组"></a>4. 连续数组</h3><p>相同的0和1的个数，其实也是前缀和，只不过遇到0变为-1</p><h3 id="5-和相同的二元子数组"><a href="#5-和相同的二元子数组" class="headerlink" title="5. 和相同的二元子数组"></a>5. 和相同的二元子数组</h3><p>这道题是统计个数，之前是求最长为目标和的连续子数组，所有hash映射为sum的个数<br>注意一定要先查找hash[presum-target]，更新hash[presum]++<br>主要是针对0的情况，如果先更新hash就会报错<br>注意最开始要设置hash[0]要为1个</p><h3 id="6-统计「优美子数组」"><a href="#6-统计「优美子数组」" class="headerlink" title="6. 统计「优美子数组」"></a>6. 统计「优美子数组」</h3><p>将奇数转为1， 偶数转为0， 然后求和为k的子数组个数</p><h3 id="7-Range-Sum-Query-2D-Mutable-二维区域和检索-可变"><a href="#7-Range-Sum-Query-2D-Mutable-二维区域和检索-可变" class="headerlink" title="7. Range Sum Query 2D - Mutable 二维区域和检索 - 可变"></a>7. Range Sum Query 2D - Mutable 二维区域和检索 - 可变</h3><ul><li><p>方法1：树状数组</p></li><li><p>求列的前缀和，然后更新的某一个元素的时候是需要更新那一列的前缀和，然后求区域的和就是将范围列的前缀和求和<br><a href="https://developer.aliyun.com/article/346620">[LeetCode] Range Sum Query 2D - Mutable 二维区域和检索 - 可变-阿里云开发者社区</a></p></li><li><p>区分：线段树是一颗树，每个节点上记录所有子节点元素的和，树状数组是一个数组，通过累加lowbit来更新它的左右</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i+<span class="hljs-number">1</span>;j&lt;=n;j+=<span class="hljs-built_in">lowbit</span>(j))&#123;<br>       arr[j]+=nums[i];<br>   &#125;<br>&#125;         <br></code></pre></td></tr></table></figure><p><a href="https://oi-wiki.org/ds/fenwick/">https://oi-wiki.org/ds/fenwick/</a></p></li></ul><h2 id="前缀和-单调栈"><a href="#前缀和-单调栈" class="headerlink" title="前缀和+单调栈"></a>前缀和+单调栈</h2><h3 id="1-leetcode-1124表现良好的最长时间段"><a href="#1-leetcode-1124表现良好的最长时间段" class="headerlink" title="1. leetcode 1124表现良好的最长时间段"></a><font color="red">1. leetcode 1124表现良好的最长时间段</font></h3><p>题意就是转化为1， -1的数组，和大于0的最长连续子数组 （注意是和大于0，不是和最大）<br>解决方案： 整体思路：前缀和，对于每一个下标对应的当前的前缀和，应该求比他小的前缀和的下标最小的一个+这是1， -1的数组，因此前缀和应该是连续的<br>如果前缀和大于0，那么一定是从下标0到当前的数的长度最长<br>如果前缀和小于0，那么就是当前前缀和-1到当前的长度最长<br>先顺序遍历，如果当前数小于栈顶就push,否则continue(因为当前值不可能为最优)，然后逆序遍历，如果当前的前缀和大于栈顶，那么循环弹出，同时还需要更新最大结果，直到当前的前缀和不大于栈顶；遍历下一个数</p><h3 id="2-类似的一个题目：lc962-最大宽度坡-单调栈比较经典的题目"><a href="#2-类似的一个题目：lc962-最大宽度坡-单调栈比较经典的题目" class="headerlink" title="2. 类似的一个题目：lc962. 最大宽度坡 - 单调栈比较经典的题目"></a><font color="red">2. 类似的一个题目：lc962. 最大宽度坡 - 单调栈比较经典的题目</font></h3><ul><li>这道题除了用正序单减栈+逆序遍历外，还可以用排序方法</li><li>排序方法：用结构体存储值和下标，然后按照值排序后，针对每个元素，找到它左边的元素中（都比他小），最小的下标（i - min(indexes_previously_written)） O(nlogn)</li></ul><h2 id="hash-双指针"><a href="#hash-双指针" class="headerlink" title="hash + 双指针"></a>hash + 双指针</h2><p>一定要注意返回的是元素还是元素的下标，一个可以排序使用指针，一个不能使用指针<br>两数之和：用双指针只能针对已经排好序的数组，没有排好序的数组，但是要求要返回下标，那么就用hash (unordered_set)<br>三数之和<br>四数之和：三重循环，因此有是三个去重的部分，不要只去重最后一层循环，忘了i j 层循环的去重</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h3><ol><li>hash方法是不能去重的，要去重只能使用循环+双指针；同时返回坐标不能用双指针，返回值才能使用双指针</li><li>去重放在==target的if语句之内（==循环去重==），同时可以用一些剪枝策略，但是要记得四个数相加可能出现溢出，所以如果要剪枝，记得强转为long型<figure class="highlight c++"><figcaption><span>去重模板</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">while</span>(i &lt; j &amp;&amp; nums[i] == nums[++i]);<span class="hljs-keyword">while</span>(i &lt; j &amp;&amp; nums[j] == nums[--j]);<br></code></pre></td></tr></table></figure></li><li>数组不一定是排好序的，因此需要先对数组进行排序</li></ol><h3 id="变形："><a href="#变形：" class="headerlink" title="变形："></a>变形：</h3><p>数组中的k-diff数对，这里只是换成了绝对值差，而不是目标值; 而且因为数组中存在重复的数字，因此需要先用set记录结果，然后再返回set.size<br>这道题也可以用排序+二分查找（找到目标的k+nums[i]），同时需要过滤掉已经找的数据</p><h3 id="拓展："><a href="#拓展：" class="headerlink" title="拓展："></a>拓展：</h3><p>注意前面三个题是可能包含重复的元素，但是需要返回不重复的元组对，下面这个题是找出所有的元组对，因此是包含重复的元组对的<br><font color="red">题目：三数之和的多种可能</font><br>解决方案：仍然是三数之和的方法的，但是在进行计算的时候， 需要判断左右指针指向的数是否相等，来计算可能组成的相同数对的个数<br>如果<code>arr[left]!=arr[right]</code>那么<code>res+=hash[left]*hash[right]</code> (用while循环找到hash[left]-相同数的数量，或者提前计算)<br>如果<code>arr[left]==arr[right]</code> <code>res+=(right-left+1)*(right-left)/2</code></p><h3 id="代码模板（去重-找四数之和为target）"><a href="#代码模板（去重-找四数之和为target）" class="headerlink" title="代码模板（去重+找四数之和为target）"></a>代码模板（去重+找四数之和为target）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> size=nums.<span class="hljs-built_in">size</span>();<br><span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-3</span>;i++)&#123;<br>    <span class="hljs-keyword">while</span>(i<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>&amp;&amp;nums[i]==nums[i<span class="hljs-number">-1</span>])&#123;<br>        <span class="hljs-keyword">continue</span>; <span class="hljs-comment">//去重</span><br>    &#125;<br>    <span class="hljs-keyword">if</span>((<span class="hljs-keyword">long</span>) nums[i]+nums[i+<span class="hljs-number">1</span>]+nums[i+<span class="hljs-number">2</span>]+nums[i+<span class="hljs-number">3</span>]&gt;target)&#123;<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>((<span class="hljs-keyword">long</span>) nums[i]+nums[size<span class="hljs-number">-3</span>]+nums[size<span class="hljs-number">-2</span>]+nums[size<span class="hljs-number">-1</span>]&lt;target)&#123;<br>            <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i+<span class="hljs-number">1</span>;j&lt;nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-2</span>;j++)&#123;<br>        <span class="hljs-keyword">if</span> (j &gt; i + <span class="hljs-number">1</span> &amp;&amp; nums[j] == nums[j - <span class="hljs-number">1</span>]) &#123;<br>                    <span class="hljs-keyword">continue</span>; <span class="hljs-comment">//去重</span><br>        &#125;<br>        <span class="hljs-keyword">if</span>((<span class="hljs-keyword">long</span>) nums[i]+nums[j]+nums[j+<span class="hljs-number">1</span>]+nums[j+<span class="hljs-number">2</span>]&gt;target)&#123;<br>                <span class="hljs-keyword">break</span>; <span class="hljs-comment">//注意是break不是continue</span><br>        &#125;<br>        <span class="hljs-keyword">if</span>((<span class="hljs-keyword">long</span>) nums[i]+nums[j]+nums[size<span class="hljs-number">-2</span>]+nums[size<span class="hljs-number">-1</span>]&lt;target)&#123;<br>                <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> k=j+<span class="hljs-number">1</span>, q=size<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">int</span> find_num=target-nums[i]-nums[j];<br>        <span class="hljs-keyword">while</span>(k&lt;q)&#123; <span class="hljs-comment">//双指针</span><br>            <span class="hljs-keyword">if</span>(nums[k]+nums[q]&gt;find_num)&#123;<br>                q--;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[k]+nums[q]&lt;find_num)&#123;<br>                k++;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[k]+nums[q]==find_num)&#123;<br>                res.<span class="hljs-built_in">push_back</span>(&#123;nums[i], nums[j], nums[q], nums[k]&#125;);<br>                k++;<br>                q--;<br>                <span class="hljs-keyword">while</span>(k&lt;q&amp;&amp;nums[k]==nums[k<span class="hljs-number">-1</span>])&#123; <span class="hljs-comment">//去重</span><br>                    k++;<br>                &#125;<br>                <span class="hljs-keyword">while</span>(k&lt;q&amp;&amp;nums[q]==nums[q+<span class="hljs-number">1</span>])&#123;<br>                q--;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>参考链接：<a href="https://leetcode-cn.com/problems/4sum/solution/si-shu-zhi-he-by-leetcode-solution/">四数之和答案</a></p></blockquote><h2 id="前缀和和差分数组"><a href="#前缀和和差分数组" class="headerlink" title="前缀和和差分数组"></a>前缀和和差分数组</h2><p>一般是有关于矩阵的一维前缀和， 二维前缀和， 一维差分数组和二维差分数组<br>如果要计算差分数组和前缀和数组最好是将坐标转为 1-n，更好计算；不然<code>sum i j</code>对应的grid为<code>i-1,j-1</code></p><p>一维差分数组中，如果数组中一段数据加上或者减去某一个元素，在差分数组中只有两头的元素进行了修改，中间的元素都没有修改<br>二维差分数组中，如果包含左上角（x1, y1）, 右下角（x2, y2）这一部分都+C, 那么对应的差分数组<code>d[x1][y1]+c d[x2+1][y2+1]+c d[x1][y1+1]-c d[x2+1][y1]-c</code><br>(上升的对角线两端元素-c, 下降的对角线元素+c)</p><p>二维差分数组公式:</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">nums<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>-nums<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[j]</span>-nums<span class="hljs-comment">[i]</span><span class="hljs-comment">[j-1]</span>+nums<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[j-1]</span>=d<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span><br></code></pre></td></tr></table></figure><p>从差分数组还原原来的数组</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">nums<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>=nums<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[j]</span>+nums<span class="hljs-comment">[i]</span><span class="hljs-comment">[j-1]</span>-nums<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[j-1]</span>+d<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span><br></code></pre></td></tr></table></figure><h3 id="1-5931-用邮票贴满网格图-hard-周赛题目"><a href="#1-5931-用邮票贴满网格图-hard-周赛题目" class="headerlink" title="1. 5931. 用邮票贴满网格图 (hard-周赛题目)"></a>1. 5931. 用邮票贴满网格图 (hard-周赛题目)</h3><p>方法一: 使用二维前缀和，对原来矩阵中每个左上角为0，且邮票区域都为0的位置（二维区域前缀和为0），贴上邮票，为了减少贴这个过程的时间开销，使用二元差分数组<br>贴完后，对二元差分数组进行还原，如果仍然遇到为0的位置，那么返回false<br>注意这道题没必要求差分数组，差分数组可以全部直接初始化为0， 那么还原回来的也是填充数组<br>方法二: 不使用二维差分数组，使用另外一个数组，标记贴邮票的左上角，然后针对每个grid中为0的位置，计算邮票部分区域（注意是贴了邮票的矩阵，是另一个矩阵）的前缀和，如果为0，表示这个区域没有被贴上邮票，返回false</p><h3 id="2-航班预订统计-middle"><a href="#2-航班预订统计-middle" class="headerlink" title="2. 航班预订统计 (middle)"></a>2. 航班预订统计 (middle)</h3><p>一维差分数组的题目<br>如果原来数组的下标就是1-n的话，那么修改n-m部分的数据， 就会修改等差数列的d[n]和d[m+1]两个端点的数据</p><h3 id="3-拼车"><a href="#3-拼车" class="headerlink" title="3. 拼车"></a>3. 拼车</h3><p>这道题类似于天际线问题，使用hash, 左断点加入m个人，右端点减去m个人<br>然后遍历hash的每个key,如果有个时刻是大于capacity, 那么返回false</p><h3 id="4-lc995-K-连续位的最小翻转次数（hard）"><a href="#4-lc995-K-连续位的最小翻转次数（hard）" class="headerlink" title="4. lc995. K 连续位的最小翻转次数（hard）"></a>4. lc995. K 连续位的最小翻转次数（hard）</h3><ul><li>从左到右遍历，遇到0就进行翻转，使用差分数组进行假意翻转，通过presum累加来求得当前翻转的次数</li></ul><h3 id="5-自己实现一个hashMap"><a href="#5-自己实现一个hashMap" class="headerlink" title="5. 自己实现一个hashMap"></a>5. 自己实现一个hashMap</h3><ul><li>使用指针数组，而不是结构体数组<br>HashNode *table[t_size]</li><li>可以考虑使用模板，这样key value的类型都可以不确定<br>template&lt;typename K, typename V&gt;<br>hashMap&lt;K, V&gt;(key, value)<br>代码例子：<br><a href="https://github.com/aozturk/HashMap/blob/master/hashmap/HashMap.h">https://github.com/aozturk/HashMap/blob/master/hashmap/HashMap.h</a></li></ul><h3 id="6-1074-元素和为目标值的子矩阵数量"><a href="#6-1074-元素和为目标值的子矩阵数量" class="headerlink" title="6. 1074. 元素和为目标值的子矩阵数量"></a>6. 1074. 元素和为目标值的子矩阵数量</h3><ul><li>二重循环枚举矩阵的上下边界，然后转为一维数组中求等于target的数量，使用hash</li></ul><h2 id="前缀异或值"><a href="#前缀异或值" class="headerlink" title="前缀异或值"></a>前缀异或值</h2><p>在求前缀异或的时候，结果数组可以从1开始取，这样的话就不用对边缘单独进行赋值操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++j) &#123;<br>        pre[i][j] = pre[i - <span class="hljs-number">1</span>][j] ^ pre[i][j - <span class="hljs-number">1</span>] ^ pre[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] ^ matrix[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>        results.<span class="hljs-built_in">push_back</span>(pre[i][j]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="hash-动态规划"><a href="#hash-动态规划" class="headerlink" title="hash+动态规划"></a>hash+动态规划</h2><h3 id="1-最长定差子序列"><a href="#1-最长定差子序列" class="headerlink" title="1. 最长定差子序列"></a>1. 最长定差子序列</h3><p>转移方程： dp[arr[i]]=dp[arr[i]-diff]+1<br>因为不知道arr[i]的最大值，以及可能出现负数的下标， 所以直接使用hash，而不是数组<br>dp[x] 表示以 x 结尾的最长等差子序列的长度；</p><h2 id="前缀和和差分数组相关"><a href="#前缀和和差分数组相关" class="headerlink" title="前缀和和差分数组相关"></a>前缀和和差分数组相关</h2><p>一般是有关于矩阵的一维前缀和， 二维前缀和， 一维差分数组和二维差分数组<br>如果要计算差分数组和前缀和数组最好是将坐标转为 1-n，更好计算；不然sum i j对应的grid为i-1,j-1</p><p>一维差分数组中，如果数组中一段数据加上或者减去某一个元素，在差分数组中只有两头的元素进行了修改，中间的元素都没有修改<br>二维差分数组中，如果包含左上角（x1, y1）, 右下角（x2, y2）这一部分都+C, 那么对应的差分数组d[x1][y1]+c d[x2+1][y2+1]+c d[x1][y1+1]-c d[x2+1][y1]-c<br>(上升的对角线两端元素-c, 下降的对角线元素+c)</p><p>二维差分数组公式:<br>nums[i][j]-nums[i-1][j]-nums[i][j-1]+nums[i-1][j-1]=d[i][j]<br>从差分数组还原原来的数组<br>nums[i][j]=nums[i-1][j]+nums[i][j-1]-nums[i-1][j-1]+d[i][j]</p><h3 id="1-5931-用邮票贴满网格图-hard-周赛题目-1"><a href="#1-5931-用邮票贴满网格图-hard-周赛题目-1" class="headerlink" title="1. 5931. 用邮票贴满网格图 (hard-周赛题目)"></a>1. 5931. 用邮票贴满网格图 (hard-周赛题目)</h3><p>方法一: 使用二维前缀和，对原来矩阵中每个左上角为0，且邮票区域都为0的位置（二维区域前缀和为0），贴上邮票，为了减少贴这个过程的时间开销，使用二元差分数组<br>贴完后，对二元差分数组进行还原，如果仍然遇到为0的位置，那么返回false<br>注意这道题没必要求差分数组，差分数组可以全部直接初始化为0， 那么还原回来的也是填充数组<br>方法二: 不使用二维差分数组，使用另外一个数组，标记贴邮票的左上角，然后针对每个grid中为0的位置，计算邮票部分区域（注意是贴了邮票的矩阵，是另一个矩阵）的前缀和，如果为0，表示这个区域没有被贴上邮票，返回false</p><h3 id="2-航班预订统计-middle-1"><a href="#2-航班预订统计-middle-1" class="headerlink" title="2. 航班预订统计 (middle)"></a>2. 航班预订统计 (middle)</h3><p>一维差分数组的题目<br>如果原来数组的下标就是1-n的话，那么修改n-m部分的数据， 就会修改等差数列的d[n]和d[m+1]两个端点的数据</p><h3 id="3-拼车-1"><a href="#3-拼车-1" class="headerlink" title="3. 拼车"></a>3. 拼车</h3><p>这道题类似于天际线问题，使用hash, 左断点加入m个人，右端点减去m个人<br>然后遍历hash的每个key,如果有个时刻是大于capacity, 那么返回false</p><h3 id="4-lc995-K-连续位的最小翻转次数（hard）-1"><a href="#4-lc995-K-连续位的最小翻转次数（hard）-1" class="headerlink" title="4. lc995. K 连续位的最小翻转次数（hard）"></a>4. lc995. K 连续位的最小翻转次数（hard）</h3><ul><li>从左到右遍历，遇到0就进行翻转，使用差分数组进行假意翻转，通过presum累加来求得当前翻转的次数</li></ul><h2 id="前缀异或值-1"><a href="#前缀异或值-1" class="headerlink" title="前缀异或值"></a>前缀异或值</h2><p>在求前缀异或的时候，结果数组可以从1开始取，这样的话就不用对边缘单独进行赋值操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++j) &#123;<br>        pre[i][j] = pre[i - <span class="hljs-number">1</span>][j] ^ pre[i][j - <span class="hljs-number">1</span>] ^ pre[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] ^ matrix[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>        results.<span class="hljs-built_in">push_back</span>(pre[i][j]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="HashMap的底层实现（java）"><a href="#HashMap的底层实现（java）" class="headerlink" title="HashMap的底层实现（java）"></a>HashMap的底层实现（java）</h2><h3 id="源代码分析"><a href="#源代码分析" class="headerlink" title="源代码分析"></a>源代码分析</h3><p>JDK1.7 的底层是数组加链表，而 JDK1.8 的底层是数组加链表加红黑树，红黑树相对于AVL树来说，牺牲了部分平衡性以换取插入/删除操作时少量的旋转操作，整体来说性能要优于AVL树。</p><p>使用hash函数（hash算法： index = HashCode（Key） &amp; （Length - 1）），将数据放在数组中，如果数组已经将要放的位置满了，就使用链表链接在那个位置的后面；使用树是为了防止链表过长,设定阈值为8，那么大于这个阈值就将这个链表转为红黑树，小于6的时候链化， 避免查询时间过长。（8树化、6链化），而且设置为8个节点时，红黑树的性能优势也会开始展现出来，因此8是一个较合理的数字。</p><p>hashmap初始长度是16，每次扩展或者手动初始化必须是2的幂：是为了服务从key到index的hash算法：index = HashCode（Key） &amp; （Length - 1），使得使用位运算计算的结果等同于取模（x mod 2^n = x &amp; (2^n - 1)），也就是只取决于hashcode的二进制后面几位，只要HashCode本身分布均匀，Hash算法的结果就是均匀的，从而大大提高性能。</p><p>高并发情况下，hashmap可能会出现死锁<br>JDK1.7以及前是在头结点插入的，在JDK1.8之后是在尾节点插入的。，因为JDK1.7在多进程的情况下可能会出现死循环，由循环链表造成（rehash的时候，一个进程在e, next的时候挂起，另外一个进程已经将数据都扩容好，进程1又开始扩容），但是JDK1.8仍然可能会出现数据丢失（进程1要在插入时候，时间片用完，进程2插入元素在一个相同位置，进程1就会直接将进程2插入的元素覆盖），并发下扩容数据丢失</p><h3 id="hash冲突"><a href="#hash冲突" class="headerlink" title="hash冲突"></a>hash冲突</h3><p><font color="red">避免hash冲突的方法：</font></p><ul><li><p>开放定址法（再hash）</p><ul><li>线性探查：可能会出现大量的错误</li><li>平方探查</li><li>二次散列/平方探查：导致hash表空间利用率很低，出现大量重复</li></ul><p>  优点：存储结构连续，因此查找的IO开销更小<br>  缺点：1）在插入的元素大于hash表的时候，需要扩容 2）hash表存储空间利用率低 3）删除操作的时间复杂度高，因为不能直接删除，因为它的后面可能有数据，因此需要设置删除标记，需要额外的空间 4）探查序列如何设计比较复杂可能会降低hash的性能</p></li><li><p>拉链法：<br>  可能导致数据存储的物理空间不连续导致大量I/O开销</p><p>  优点：1）对于记录总数是动态变化的情况比较好，不需要频繁扩容 2）存储空间动态分配，因此hash的空间利用率高 3）删除记录也比较方便<br>  缺点：1）因为使用的链表，因此在查询记录时，相比结构紧凑的数据类型（比如数组），哈希表的跳转访问会带来额外的时间开销 2） 由于使用指针，记录不容易进行序列化（serialize）操作</p></li></ul><h3 id="lc706-设计哈希映射"><a href="#lc706-设计哈希映射" class="headerlink" title="lc706. 设计哈希映射"></a>lc706. 设计哈希映射</h3><ul><li>使用链地址法实现，每个节点除了key val, 还需要一个next域, 然后使用vector充当数组</li><li>易错点：<ol><li>删除的时候需要判断删除这个节点是否是头节点，和尾结点</li><li>插入的时候需要判断key是不是本身在hash中</li><li>指针在进行取值或者取下一个值（cur-&gt;key||cur-&gt;next）的时候，一定要保证这个指针(cur)不为NULL, 否则会报错</li></ol></li></ul><h3 id="lc705-设计哈希集合"><a href="#lc705-设计哈希集合" class="headerlink" title="lc705. 设计哈希集合"></a>lc705. 设计哈希集合</h3><ul><li>这个和上面一题一样，不同的是这个不需要val字段，其余都相同</li></ul><h2 id="分布式一致性hash算法"><a href="#分布式一致性hash算法" class="headerlink" title="分布式一致性hash算法"></a>分布式一致性hash算法</h2><p>针对的问题是如何将数据均匀的分布在key-value的分布式缓存中，如果使用mod方法，均匀但是可能导致插入删除节点，所有的数据需要重新hash</p><ul><li>第一种是将存储节点和数据都映射到一个首尾相连的hash环上，数据存储在hash环上顺时针的第一个节点，插入节点就只影响相邻节点的后续节点，对其他节点没有影响。但是可能造成不均衡的局面，</li><li>因此改进就是对一个存储节点使用虚拟节点，映射在环上的多个位置</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>最长类似题目，可以使用dp, 前缀和，双指针，以及单栈+逆序遍历</p></li><li><p>前缀和+hash可以做数组最长题目或者为目标类的连续子数组的个数，一个hash用来记录之前前缀和的下标，一个用来记录前缀和为sum的个数<br>（个数和长度问题）</p></li><li><p>注意可能会考实现某一个数据结构，比如说实现hashMap, LRU, 跳表<br>实现跳表的方法：<a href="https://blog.csdn.net/weixin_44387066/article/details/90766034">跳表 （Skip List） C++ 实现_skiplist析构-CSDN博客</a></p></li></ol><ul><li>主要是跳表的每个节点可以包含一个key, val, vector&lt;node*&gt; next;</li><li>在插入一个值的时候，随机生成他的层数</li><li>主要是需要实现insert（先find, 再update后者insert）, find（需要找到第0层来进行判断）, delete(先find在delete)函数</li></ul>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>回溯_DFS_BFS</title>
      <link href="/2021/11/13/leetcode/%E5%9B%9E%E6%BA%AF_DFS_BFS/"/>
      <url>/2021/11/13/leetcode/%E5%9B%9E%E6%BA%AF_DFS_BFS/</url>
      
        <content type="html"><![CDATA[<h2 id="常见例题"><a href="#常见例题" class="headerlink" title="常见例题"></a>常见例题</h2><h3 id="1-字符串的转换路径问题"><a href="#1-字符串的转换路径问题" class="headerlink" title="1. 字符串的转换路径问题"></a>1. 字符串的转换路径问题</h3><p>单词接龙I:只返回最短转换序列的长度（使用BFS）<br>单词接龙II：返回所有最短转换序列具体是什么<br>标准答案是既用到了深度优先搜索，也用到了宽度优先搜索<br>（最短距离）<br>首先判断endWord是否在字典中，不在的话直接返回空<br>在进行单词找相邻，可以遍历单词每个字符，判断与当前是否只有一个不相等（O(mn)）；或者将当前单词的每一位替换成 26 个小写英文字母，查找是否在字典中（推荐）(O(26n));一定要注意改变了某一个位之后要记得还原该位！！！！！！<br>方法1：</p><ul><li>使用BFS建立每个单词的前向节点，需要使用steps[nextWord] 记录每个单词到start的最短。<br>如果steps[nextWord]==step,那么from[nextWord].insert(currentWord), 然后判断nextWord是否被vis, 或者是否还在dict中，如果在，加入队列中，进行下列操作；如果不在(已经加入过队列中或者被访问过)，直接continue<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 如果从一个单词扩展出来的单词以前遍历过，距离一定更远，为了避免搜索到已经遍历到，且距离更远的单词，需要将它从 dict 中删除</span><br>dict.<span class="hljs-built_in">erase</span>(nextWord); <span class="hljs-comment">//删除或者设置vis</span><br><span class="hljs-comment">// 这一层扩展出的单词进入队列</span><br>q.<span class="hljs-built_in">push</span>(nextWord);<br><span class="hljs-comment">// 记录 nextWord 从 currWord 而来</span><br>from[nextWord].<span class="hljs-built_in">insert</span>(currWord);<br><span class="hljs-comment">// 记录 nextWord 的 step</span><br>steps[nextWord] = step;<br></code></pre></td></tr></table></figure></li><li>DFS （从endWord到startWord）反向求具体路径，同时在进入下层循环是需要判断，当前的距离是不是当前节点到start的最短距离，如果是进入循环，否则剪枝</li></ul><p>方法2：</p><ul><li>使用BFS求最短路，同时建立每个单词的pre单词，因为同一层两个单词可能到一个单词的距离相等，因此需要每层元素遍历完了之后再vis, 以及再队列push next_element<br>next_ele.erase(unique(next_ele.begin(), next_ele.end()), next_ele.end()); //也可以直接用set来去重</li><li>反向DFS求具体路径</li></ul><h3 id="2-单词转换"><a href="#2-单词转换" class="headerlink" title="2. 单词转换"></a>2. 单词转换</h3><p><a href="https://leetcode-cn.com/problems/word-transformer-lcci/solution/c-python3-dfsbu-neng-hui-su-yin-wei-bu-s-u45m/">leetcode链接</a><br>求其中一条路径使用DFS （因为没说要最短）<br>求所有的路径使用BFS+DFS 在一轮访问完之后再赋值vis以及去重/或者记录每个节点d, 然后dfs的时候判断到这个节点的d时候是当前的深度对应<br>求最短的路径，用BFS</p><p>PS: 其他解决字符串的相关问题的方案<br>使用动态规划+Trie树，或者暴力string find，或者转为数组（数字）等等，</p><p>PS类似的题目： 单词接龙和最小基因变化， 最小基因变化的这道题在进行单词转换的时候，找相邻的两种方式：(1)对每个字符，4种情况 ACGT都进行测试（也就是每个字符需要验证4n次）， (2)在单词库中查找只有一个字符变化的</p><h3 id="3-组合总数-：一定要注意如果给出的列表中包含重复的数据的话，一定要记得去重，以及通过一些条件可以提前剪枝"><a href="#3-组合总数-：一定要注意如果给出的列表中包含重复的数据的话，一定要记得去重，以及通过一些条件可以提前剪枝" class="headerlink" title="3. 组合总数 ：一定要注意如果给出的列表中包含重复的数据的话，一定要记得去重，以及通过一些条件可以提前剪枝"></a><font color="red">3. 组合总数 ：一定要注意如果给出的列表中包含重复的数据的话，一定要记得去重，以及通过一些条件可以提前剪枝</font></h3><p>组合总数I， II, III, VI 在进行回溯的时候需要注意的几个点：</p><ul><li>每类的数据是否可以重复选择，如果可以重复选择，那么需要在递归到某一个类的时候，将这个类的所有的数据（一个或者target/candidate[i]个）都选择完</li><li>是只求总数还是求所有的序列，如果只求总数可以使用动态规划（一定要注意if和else的状态转移情况都要考虑到），如果求序列需要使用递归回溯剪枝</li><li>相同结果不用元素组合算一种还是多种（2，2，3）和（2，2，3） 原数据为（2，2，2，2，3）</li><li>给的列表是否包含重复的数据，如果包含需要对数据进行排序后，再进行回溯</li><li>给的列表是否可以重复取，如果可以那么 改为 dfs(candidates,target-k*candidates[i],i+1,count);其中count[i]=k<br>为了防止递归层数太深；同时一定要递归到最后pos==size&amp;&amp;target==0才代表找到了这样一个序列（以为count需要修改）</li><li>如果每个数都只能取一次，而且取的个数一定要是相等的话，可以使用二进制位进行枚举具体的序列</li></ul><h3 id="4-将数组拆分为斐波拉切数列-枚举最开始的a-b，求出c判断后面的字符是不是c"><a href="#4-将数组拆分为斐波拉切数列-枚举最开始的a-b，求出c判断后面的字符是不是c" class="headerlink" title="4. 将数组拆分为斐波拉切数列  枚举最开始的a b，求出c判断后面的字符是不是c"></a>4. 将数组拆分为斐波拉切数列  枚举最开始的a b，求出c判断后面的字符是不是c</h3><ul><li><p>可以使用stoi将字符串转为整数（一定要注意stoi字符溢出的问题， 以及stol溢出可能性）</p><p>long long tmp=stoi(a)+stoi(b) 如果整数相加超过了INT_MAX还是会报错，所以左边的写法是错误的，应该写为 long long tmp=stol(a)+stol(b)</p></li><li><p>也可以使用 回溯一个字符一个字符的累加，如果size&gt;2的情况下计算当前数+pre是否能够达到target,如果小于那么继续循环，如果大于那么退出循环 cur = cur*10 + S[i] - ‘0’;</p></li></ul><h3 id="5-求图长度，或者多叉树的树高"><a href="#5-求图长度，或者多叉树的树高" class="headerlink" title="5. 求图长度，或者多叉树的树高"></a>5. 求图长度，或者多叉树的树高</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//注意开始遍历每个节点的时候，一定要记得将根节点设置为vis</span><br>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cur, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; graph, vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;vis)</span></span>&#123;<br>          <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;<br>          <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;graph[cur].<span class="hljs-built_in">size</span>();i++)&#123;<br>              <span class="hljs-keyword">if</span>(!vis[graph[cur][i]])&#123;<br>                  vis[graph[cur][i]]=<span class="hljs-number">1</span>;<br>                  ans= <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">dfs</span>(graph[cur][i], graph, vis));<br>              &#125;<br>          &#125;<br>          <span class="hljs-keyword">return</span> ans+<span class="hljs-number">1</span>;<br>      &#125;<br><br></code></pre></td></tr></table></figure><h3 id="6-最小高度树（有两个类似的题目）"><a href="#6-最小高度树（有两个类似的题目）" class="headerlink" title="6. 最小高度树（有两个类似的题目）"></a>6. 最小高度树（有两个类似的题目）</h3><p>让根节点是排序数组的中点<br>使用的是拓扑排序，如果求以每个节点为根节点的树，会导致超出时间限制，因此需要使用拓扑排序，每次删除叶节点（degrees[i] ），求到最中间的几个点</p><h3 id="7-水壶问题，使用深度优先搜索，或者数学推导"><a href="#7-水壶问题，使用深度优先搜索，或者数学推导" class="headerlink" title="7. 水壶问题，使用深度优先搜索，或者数学推导"></a>7. 水壶问题，使用深度优先搜索，或者数学推导</h3><p>深度优先搜索，因为超过了系统的搜索的层数，所以需要自己模拟压栈和出栈， 同时需要知道当前状态可以转化为其他状态，其他状态包括，将X倒满，将Y倒满，将X倒空，将Y倒空，将x的水导入Y中，将Y的水倒数X中 6种撞他<br>或者使用数学方式解决，每次水的变化量（X+Y）一定是X或者Y, 那么有不等式 ax+by=z; 那么z一定x和y最小公因数的倍数</p><h3 id="8-字典序-或者-全排列使用深度优先搜索"><a href="#8-字典序-或者-全排列使用深度优先搜索" class="headerlink" title="8. 字典序 或者 全排列使用深度优先搜索"></a><font color="red">8. 字典序 或者 全排列使用深度优先搜索</font></h3><p>字典序返回[1-n]所有整数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> cur, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; res)</span></span>&#123;<br>      <span class="hljs-keyword">if</span>(cur&gt;n)&#123;<br>          <span class="hljs-keyword">return</span>;<br>      &#125;<br>      res.<span class="hljs-built_in">push_back</span>(cur);<span class="hljs-comment">//在dfs的同时push</span><br>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">9</span>;i++)&#123;<br>          <span class="hljs-built_in">dfs</span>(n, cur*<span class="hljs-number">10</span>+i, res);<br>      &#125;<br>  &#125;<br>  <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">lexicalOrder</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>      vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">9</span>;i++)&#123;<br>          <span class="hljs-built_in">dfs</span>(n, i, res);<br>      &#125;<br>      <span class="hljs-keyword">return</span> res;<br>  &#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><figcaption><span>无重复数字的全排列</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++">方法<span class="hljs-number">1</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">all_permute</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums,vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; &amp;result,<span class="hljs-keyword">int</span> cur )</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> size=nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">if</span>(cur==size<span class="hljs-number">-1</span>)&#123;<br>        result.<span class="hljs-built_in">push_back</span>(nums);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=cur;i&lt;size;i++)&#123;<br>        <span class="hljs-built_in">swap</span>(nums[cur], nums[i]);<br>        <span class="hljs-built_in">all_permute</span>(nums, result, cur+<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">swap</span>(nums[cur], nums[i]);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//方法2：</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, string &amp;S, string &amp;path, vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;used)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> size=S.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(index==size)&#123;<br>        res.<span class="hljs-built_in">push_back</span>(path);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>        <span class="hljs-keyword">if</span>(used[i])&#123; <span class="hljs-comment">//最重要的两个if判断</span><br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        path.<span class="hljs-built_in">push_back</span>(S[i]);<br>        used[i]=<span class="hljs-literal">true</span>;<br>        <span class="hljs-built_in">dfs</span>(index+<span class="hljs-number">1</span>, S, path, used);<br>        used[i]=<span class="hljs-literal">false</span>;<br>        path.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><font color="red"> 有重复数字的全排列</font><br>答案解析：lc:全排列II</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">sort</span>(S.<span class="hljs-built_in">begin</span>(), S.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">//在主函数进行排序， 同时使用used数组，判断S中的某个字符是否被用过， 用一个string path，表示现在拼起来的字符</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, string &amp;S, string &amp;path, vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;used)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> size=S.<span class="hljs-built_in">size</span>();<br>     <span class="hljs-keyword">if</span>(index==size)&#123;<br>        res.<span class="hljs-built_in">push_back</span>(path);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>        <span class="hljs-keyword">if</span>(used[i])&#123; <span class="hljs-comment">//最重要的两个if判断</span><br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i!=<span class="hljs-number">0</span>&amp;&amp;S[i]==S[i<span class="hljs-number">-1</span>]&amp;&amp;!used[i<span class="hljs-number">-1</span>])&#123; <span class="hljs-comment">//注意这一层的判断</span><br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        path.<span class="hljs-built_in">push_back</span>(S[i]);<br>        used[i]=<span class="hljs-literal">true</span>;<br>        <span class="hljs-built_in">dfs</span>(index+<span class="hljs-number">1</span>, S, path, used);<br>        used[i]=<span class="hljs-literal">false</span>;<br>        path.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>扩展：排列中的下一个排列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//先找一个一个顺序相邻， 然后交换当前数和为后面第一个大于它的数，然后让后面的数递增；注意特殊情况，如果当前数已经是全排雷的最后一个，那么直接返回第一个排列</span><br>    <span class="hljs-keyword">int</span> i=nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-2</span>;<br>    <span class="hljs-keyword">while</span>(i&gt;=<span class="hljs-number">0</span>&amp;&amp;nums[i]&gt;=nums[i+<span class="hljs-number">1</span>])&#123;<br>        i--;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(i&gt;=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">int</span> j=nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(nums[i]&gt;=nums[j])&#123;<br>            j--;<br>        &#125;<br>        <span class="hljs-built_in">swap</span>(nums[i],nums[j]);<br>        <span class="hljs-built_in">reverse</span>(nums.<span class="hljs-built_in">begin</span>()+i+<span class="hljs-number">1</span>,nums.<span class="hljs-built_in">end</span>());<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">reverse</span>(nums.<span class="hljs-built_in">begin</span>()+i+<span class="hljs-number">1</span>,nums.<span class="hljs-built_in">end</span>());<br>    &#125;<br></code></pre></td></tr></table></figure><p>lc60. 排列序列 （hard）<br>求全排列的第k个排列<br>易错点：需要最开始使用k–;因为第k个排列前面有k-1个排列<br>然后计算当前每一位应该放哪个第一位 前面的数为num = k/(n-1)! ，固定了第一个位, 之后更新k=k%(n-1)!<br>第二个位，前面的数 num = k/(n-2)! ，固定了第一个位, 之后更新k=k%(n-2)!，同时使用了一个数，需要标记为访问<br>重复这样的过程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++">string res;<br>k--; <span class="hljs-comment">//非常重要</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>    <span class="hljs-keyword">int</span> num=k/frac[n-j]; <span class="hljs-comment">//前面的数</span><br>    num++; <span class="hljs-comment">//当前应该选择的数</span><br>    <span class="hljs-comment">// cout&lt;&lt;num&lt;&lt;endl;</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(!vis[i])&#123;<br>            num--;<br>            <span class="hljs-keyword">if</span>(num==<span class="hljs-number">0</span>)&#123;<br>                vis[i]=<span class="hljs-number">1</span>;<br>                res+=i+<span class="hljs-string">&#x27;0&#x27;</span>;<br>            &#125;<br>        &#125;<br>        <br>    &#125;<br>    k=k%frac[n-j];<br>&#125;<br><span class="hljs-keyword">return</span> res;<br></code></pre></td></tr></table></figure><p>lc90, 子集II</p><ul><li>题意：求有重复数据数列的所有子集</li><li>使用dfs+去重+路径中一直push到res中<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">dfs</span>():<br>    res.<span class="hljs-built_in">push_back</span>(path);<br>    <span class="hljs-keyword">if</span>(index&gt;=size)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=index;i&lt;size;i++)&#123;<br>        <span class="hljs-keyword">if</span>(i!=index&amp;&amp;nums[i]==nums[i<span class="hljs-number">-1</span>])&#123; <span class="hljs-comment">//去重方式和四数之和一样</span><br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>        <span class="hljs-built_in">dfs</span>(i+<span class="hljs-number">1</span>, nums, path);<br>        path.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="9-01矩阵-多源BFS"><a href="#9-01矩阵-多源BFS" class="headerlink" title="9. 01矩阵 多源BFS"></a>9. 01矩阵 <font color="blue">多源BFS</font></h3><p>找到1距离0的距离是从0开始进行bfs，而不是从1开始<br>解法：<br>    - 广度优先搜索+记忆数组（将为0的点放入队列中，然后一层层向外扩散，记得访问过的点记得标记为visit, 或者用matrix !=-1来判定该点时候被访问过）<br>    - 左上到右下；再从右下到左上</p><h3 id="10-大礼包"><a href="#10-大礼包" class="headerlink" title="10. 大礼包"></a>10. 大礼包</h3><ul><li>这道题可以学习的是状态的记忆过程，使用map&lt;vector<int>, int&gt;, 当然这道题直接用dfs搜索每一个状态也是可以的</int></li><li>这道题在dfs的时候，除了要循环选择每个大礼包，退出循环后，还要判断当前计算值和==全部不用大礼包==谁更小！！！</li><li>无法使用完全背包+dp解决，因为dp的内层循环无法枚举，因为是一个vector, 而不是一个简单的int</li></ul><h3 id="11-划分为k个相同的子集"><a href="#11-划分为k个相同的子集" class="headerlink" title="11. 划分为k个相同的子集"></a><font color="red">11. 划分为k个相同的子集</font></h3><p>这道题既可以使用状态压缩的dp也可以使用回溯+贪心<br>方法一：</p><ul><li>需要对数组排序，从大的数最开始进行匹配，贪心策略（这样压栈次数会更少）</li><li>使用回溯的时候需要使用一个vis数组，如果当前值小于target 那么继续向前遍历；如果==target那么从头开始遍历，同时k-1;如果大于target,那么循环内部判断数组下一个数是否合适  (循环数组的时候多次dfs 判断是否都能凑出&lt;=target)<br><a href="https://zhuanlan.zhihu.com/p/78031844">leetcode No.698 划分为k个相等的子集 - 知乎</a></li></ul><p>方法二：</p><ul><li>建立n个桶，然后判断每个数应该放在哪个桶内(只用记录桶中总数，不用记录具体放到什么)；如果当前这个数放在哪个桶都不行，那么当前循环return false；仍然使用贪心减少遍历次数</li><li><a href="https://leetcode-cn.com/problems/partition-to-k-equal-sum-subsets/solution/liang-chong-bu-tong-de-hui-su-si-lu-cong-5rnw/">力扣（LeetCode）官网 - 全球极客挚爱的技术成长平台</a></li></ul><h3 id="12-地图分析，多源BFS的例题"><a href="#12-地图分析，多源BFS的例题" class="headerlink" title="12. 地图分析，多源BFS的例题"></a><font color="blue">12. 地图分析，多源BFS的例题</font></h3><p>和正向题目描述的思路反过来，从为1的陆地出发，而不是从每个海洋出发求最短距离。先将所有为1的节点的位置放在队列中，每访问一个节点，就修改节点位置的值，那么就不需要使用vis数组</p><h3 id="13-组合总数II"><a href="#13-组合总数II" class="headerlink" title="13. 组合总数II"></a>13. 组合总数II</h3><p>因为这个是要求具体的组合，用dfs,同时注意去重</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=index;i&lt;size;i++)&#123;<br>    <span class="hljs-keyword">if</span>(i&gt;index&amp;&amp;candidates[i]==candidates[i<span class="hljs-number">-1</span>])&#123;<span class="hljs-comment">//去重</span><br>        <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    path.<span class="hljs-built_in">push_back</span>(candidates[i]);<br>    <span class="hljs-built_in">dfs</span>(candidates, target-candidates[i], i+<span class="hljs-number">1</span>, path);<br>    path.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-comment">// dfs(candidates, target, i+1, path); //注意这个一定不能要</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="14-面试题-16-22-兰顿蚂蚁"><a href="#14-面试题-16-22-兰顿蚂蚁" class="headerlink" title="14. 面试题 16.22. 兰顿蚂蚁"></a>14. 面试题 16.22. 兰顿蚂蚁</h3><p>类似于走地图的题目，是一个模拟题<br>因为x, y的坐标可能为负数，因此使用map&lt; pair&lt;int, int&gt;, char&gt; matrix; (使用unordered_map会报错)<br>同时在进行打印的时候，应该y在外层，x在内层；如果map中没有找到这个坐标，那么应该打印出“_”, 记录当前地图的左上和右下坐标</p><h3 id="15-双向BFS"><a href="#15-双向BFS" class="headerlink" title="15. 双向BFS"></a>15. 双向BFS</h3><ul><li>使用两个队列， 每次更新一个size比较小的队列里面的所有元素，同时使用两个unordered_map记录走到某个字符串/位置，走的步数（同时有vis数组的功能）。 如果当前更新的字符串，在另外一个队列的map中也能找到记录说明两个队列相遇了， 返回step + 1 + other[copy];</li></ul><h3 id="16-逃脱迷宫需要移除的最少砖头数量"><a href="#16-逃脱迷宫需要移除的最少砖头数量" class="headerlink" title="16. 逃脱迷宫需要移除的最少砖头数量"></a><font color="red">16. 逃脱迷宫需要移除的最少砖头数量</font></h3><ul><li> 使用BFS+优先队列+vis， 队列里面存放到x, y, 和到每个节点的最少要移除的砖头数量， 循环在nextx nexty=n-1的时候返回结果， 具体代码实现看模板代码/逃脱迷宫</li><li> 不能使用dfs+记忆化数组+vis，因为到达当前节点的时候，前面vis 路径不一定是最优的，导致计算出来d不一定是最佳的，从而之后的计算都出现错误； 记忆化数组可以使用场景就是，之前的选择不会对之后的选择造成影响， 或者需要另外用一个状态位运算来记录之前走的路径到底是怎样的（见lc980, 下面有分析）</li><li>这道题的思路和lc752: 打开转盘锁一样，不能走回头路，lc752可以使用双端BFS，感觉这个不适合双堆队列，因为map里面的数据并不都是同一层，同时两个队列size感觉都是一样的，从两个对角线出发；这道题使用优先队列更佳</li><li> 不一样的是这个每走一步不一定+1， 队列数据不一定在同一层（因此需要使用优先队列）， 但是逃脱迷宫是每走一步都+1， 队列里面的数据都在同一层，使用普通队列</li><li>总结，使用bfs查找从源到目的节点的最短路径<ol><li>将源节点压入队列中，同时设置为vis</li><li>如果一层的cost一样，那么每层进行遍历（否则需要压入的时候，记录压入节点的cost）,计算当前节点的下一个节点，判断下一个节点的合理性（vis和index边缘）</li><li>如果合理，那么判断下一个节点是否是目标节点，如果是直接返回step+1,否则向队列中压入下一个节点</li><li>重复上述过程，知道队列为空</li><li>如果队列空都没有找到，说明源节点无法到达目标节点</li></ol></li></ul><h3 id="17-克隆图"><a href="#17-克隆图" class="headerlink" title="17. 克隆图"></a>17. 克隆图</h3><ul><li>使用BFS</li><li>这个题类似于 剑指 Offer 35. 复杂链表的复制，需要建立原始node和新node之间的映射, 同时这个hash也能充当vis数组，判断当前节点是否被访问过；复杂链表复制那道题只需要顺序两次遍历链表就可以了，不需要vis或者bfs</li></ul><p><font color="red">16. 给表达式添加运算符（hard）</font><br>使用回溯<br>易错点：<br>    1. 乘法是有优先级的，因此之前计算dfs计算的结果有可能是需要回退一个数组，然后再进行计算<br>    2. 每次压入的数字可能是包含多个位的<br>    3. 不能包含前导0，但是这个数又不是0的情况<br>    <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span>(i!=index&amp;&amp;num[index]==<span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>    4. 回溯是时候一定要记得将符号pop_back!!!!</p><h3 id="18-lc980-不同路径-III"><a href="#18-lc980-不同路径-III" class="headerlink" title="18. lc980. 不同路径 III"></a>18. lc980. 不同路径 III</h3><ul><li>求从起点到终点，经过二维矩阵的每个空方格（注意是每个都要走一次，而且不能重复），的不同路径总数</li><li>使用记忆化的dfs 因为到达每个点前面的路径是不一定相同的，因此需要使用dp[i][j][i*C+j^之前的路径] 表示到达当前的状态之前走过的路径是怎样的<br>注意题目表示1 &lt;= grid.length * grid[0].length &lt;= 20，才能使用这种位运算来记录矩阵的状态（状态压缩的条件）</li></ul><h3 id="19-单词拆分II"><a href="#19-单词拆分II" class="headerlink" title="19. 单词拆分II"></a>19. 单词拆分II</h3><ul><li>需要找到所有拆分的具体方案</li><li>为了减少回溯的重复，使用一个hash&lt;int, vector<string>&gt; 将以i下标为开始后面形成的所有可能都存储下来，这样之后寻找的时候就不用重复判断 （类似二叉搜索树的所有可能那种题目）， 记忆化dfs</string></li></ul><h3 id="20-lc741-摘樱桃-hard"><a href="#20-lc741-摘樱桃-hard" class="headerlink" title="20. lc741. 摘樱桃(hard)"></a>20. lc741. 摘樱桃(hard)</h3><ul><li>这道题用dp理解起来比较困难，所以使用记忆化dfs</li><li>易错点：贪心，第一次选最大+第二次选剩下的最大不一定是最优解</li><li>正确方法，需要dfs，然后需要有两条路径，就相当于同时对<strong>两个点进行dfs</strong>, 这两个点x1+y1=x2+y2 (有关系)然后需要判断这两个是不是同一个点，如果是，那么+grid[x1][y1]， 否则+grid[x1][y1]+grid[x2][y2]</li></ul><h3 id="21-lc934-Shortest-Bridge-最短的桥梁"><a href="#21-lc934-Shortest-Bridge-最短的桥梁" class="headerlink" title="21. lc934. Shortest Bridge 最短的桥梁"></a>21. lc934. Shortest Bridge 最短的桥梁</h3><ul><li>使用多源最短路径，两个技巧：先dfs找到岛屿上的所有点，并将将访问过的岛屿转为2；2. BFS使用层次bfs, 因为修改了访问的点为2，所以不用使用vis数组</li></ul><h3 id="22-lc5289-公平分发饼干"><a href="#22-lc5289-公平分发饼干" class="headerlink" title="22. lc5289. 公平分发饼干"></a>22. lc5289. 公平分发饼干</h3><ul><li>题意就是如何将数组划分为k份（可以不连续）能够使得最大值最小</li><li>最开始以为是背包，一直找不到解法； 之后解析发现，因为数据范围比较小（数组长度最大为8），可以直接暴力应该将数组当前index的值放在哪个包里面，dfs遍历完成求最大值，和全局的最小值进行比较。</li></ul><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><h3 id="1-剑指-Offer-II-115-重建序列"><a href="#1-剑指-Offer-II-115-重建序列" class="headerlink" title="1. 剑指 Offer II 115. 重建序列"></a>1. 剑指 Offer II 115. 重建序列</h3><ul><li>对于数组有顺序的这种题目，使用拓扑排序</li><li>这道题判断是否是唯一的最短序列，就是找拓扑排序的题目，在加上每次队列长度是否为1的判断</li></ul><h3 id="2-lc6150-根据模式串构造最小数字"><a href="#2-lc6150-根据模式串构造最小数字" class="headerlink" title="2. lc6150. 根据模式串构造最小数字"></a>2. lc6150. 根据模式串构造最小数字</h3><ul><li>三种解法</li><li>使用拓扑排序，首先通过数字之间的增减关系构建图，然后将入度为0的放入堆中，然后选择下标最小的赋值为当前的最小数字（因此需要使用优先队列）</li><li>使用dfs, 判断当前应该放的最小数字， 返回true or false</li><li>使用贪心算法，将I和D分成两个段，如果是I就直接ans[i++]=index++， 如果是D那么就找到分段的地方，从后往前遍历，然后ans[j–]=index++; 注意：除了最开始，k个I对应append k-1 个数，k个D，对应append k+1个数</li></ul><h3 id="3-lc886-可能的二分法"><a href="#3-lc886-可能的二分法" class="headerlink" title="3. lc886. 可能的二分法"></a>3. lc886. 可能的二分法</h3><ul><li>使用二分着色或者并查集的方法</li><li>不喜欢的两个人一定是不同的颜色+dfs</li><li>并查集，讲一个人不喜欢的所有人先放在一个集合，然后判断是否会出现一个人不喜欢的人和当前这个人在 一个集合，如何出现返回false</li></ul><h2 id="递归-表达式相关问题"><a href="#递归-表达式相关问题" class="headerlink" title="递归-表达式相关问题"></a>递归-表达式相关问题</h2><h3 id="1-迷你语法分析器："><a href="#1-迷你语法分析器：" class="headerlink" title="1. 迷你语法分析器："></a>1. 迷你语法分析器：</h3><p>注意在进行递归的时候， 递归进去直接初始化一个NestInterger res, 来加入[]里面的数字， 遇到循环递归调用，然后返回时直接res.add<br>另外一个易错点是，注意负数的处理</p><h3 id="表达式可用解法"><a href="#表达式可用解法" class="headerlink" title="表达式可用解法"></a>表达式可用解法</h3><ol><li>单调栈</li><li>递归</li><li>DFS</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>注意dfs和回溯还是有区别的，dfs，遇到不合适的条件可以直接退出，但是回溯，退出前要将之前的状态修改； BFS常用于求最短路径，或者最少xxxx(结合优先队列)</p></li><li><p>dfs和记忆化搜索和dp都有联系，有时候一道题这两种方法都可以用<br>例如：</p></li></ol><ul><li>分汤(因为都是25的倍数，所以n可以直接/25+1(如果余数不为0), 分配操作同样变为-4、-2、-1<br>dfs如果状态比较多，可以使用记忆化数组，同时如果状态都是某一个数的倍数，那么可以对数据进行归一化后再进行dfs<br>这样的话记忆化搜索的状态数量就会减少<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">double</span> ans = <span class="hljs-number">0.0</span>;<br>               <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) ans = <span class="hljs-number">1.0</span>;<br>               <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> &amp;&amp; j == <span class="hljs-number">0</span>) ans = <span class="hljs-number">0.5</span>;<br>               <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; j &gt; <span class="hljs-number">0</span>) &#123;<br>                   ans = <span class="hljs-number">0.25</span> * (memo[<span class="hljs-built_in">M</span>(i<span class="hljs-number">-4</span>)][j] + memo[<span class="hljs-built_in">M</span>(i<span class="hljs-number">-3</span>)][<span class="hljs-built_in">M</span>(j<span class="hljs-number">-1</span>)] +<br>                                 memo[<span class="hljs-built_in">M</span>(i<span class="hljs-number">-2</span>)][<span class="hljs-built_in">M</span>(j<span class="hljs-number">-2</span>)] + memo[<span class="hljs-built_in">M</span>(i<span class="hljs-number">-1</span>)][<span class="hljs-built_in">M</span>(j<span class="hljs-number">-3</span>)]);<br>               &#125;<br></code></pre></td></tr></table></figure></li><li>类似的概率转移dfs/dp有leet935. 马”在棋盘上的概率（可以最后/pow(8,N), 不用每次/8）</li></ul><ol start="3"><li><p>如果要求岛屿的形状相同，那么可以将岛屿的位置使用string的形式存储下来，然后使用set<string>来存储，返回size就是形状不同的岛屿（忽略翻折和旋转）</string></p></li><li><p>递归转为非递归的方式，使用堆或者栈（lc100.相同的数（dfs/宽度优先遍历））</p></li><li><p>注意如果dfs中数据包含重复，一定要记得去重（如排列，组合）</p></li><li><p>如果数据范围比较小的情况，可以直接dfs 暴力每种情况求答案 （lc5289.公平分发饼干）</p></li><li><p>回溯一定要记得使用visit数组</p></li><li><p>很多看起来想DFS的题目可以使用并查集来做，或者树的题目可以向并查集和dfs考虑（hard 6191. 好路径的数目）</p></li><li><p>回溯也可以用于情况比较少的暴力破解+局部优化题目：<br>lc679. 24 点游戏</p></li></ol><ul><li>这道题就是每次从当前list中选两个数，然后进行+ - * /然后将结果加到list中，然后回溯。注意除法使用实数记录，结果只需要1e-6就可以了</li><li>优化就是+ * 不考虑顺序</li></ul>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯, DFS, BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串问题</title>
      <link href="/2021/11/13/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2021/11/13/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="字符串问题解决套路"><a href="#字符串问题解决套路" class="headerlink" title="字符串问题解决套路"></a>字符串问题解决套路</h2><ol><li><a href="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%A2%98%E5%9E%8B.md">用动态规划求解</a></li><li><a href="./%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.md">用滑动窗口求解</a></li><li><a href="./%E5%8F%8C%E6%8C%87%E9%92%88.md">用双指针求解</a></li><li><a href="./%E5%9B%9E%E6%BA%AF_DFS_BFS.md">使用DFS/BFS求一个字符串转为另外一个字符串的路径问题</a></li></ol><h2 id="字符串hash"><a href="#字符串hash" class="headerlink" title="字符串hash"></a>字符串hash</h2><p><code>abcde</code>转为为多项式</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">f</span>(<span class="hljs-number">5</span>)= a* p^<span class="hljs-number">5</span> + b*p^<span class="hljs-number">4</span> +c *p^<span class="hljs-number">3</span> +d *p^<span class="hljs-number">2</span> +e *p^<span class="hljs-number">1</span><br><span class="hljs-attribute">f</span>(<span class="hljs-number">3</span>)= a* p^<span class="hljs-number">3</span> + b*p^<span class="hljs-number">2</span> +c *p^<span class="hljs-number">1</span><br><span class="hljs-attribute">f</span>(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>)=f(<span class="hljs-number">5</span>)-f(<span class="hljs-number">3</span>)*p^(<span class="hljs-number">5</span>-<span class="hljs-number">4</span>+<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>c++用unsigned long long 自然溢出，可以不用取模，如果使用取模方式可能会导致溢出</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++">p[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>h[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;size;i++)&#123;<br>  h[i]=h[i<span class="hljs-number">-1</span>]*p+s[i<span class="hljs-number">-1</span>]; <span class="hljs-comment">//0到i-1之间的hash值</span><br>  p[i]=p[i<span class="hljs-number">-1</span>]*p;  <span class="hljs-comment">//不同长度字符串的p值</span><br>&#125;<br><br>hash_val_m_n=h[m]-h[n<span class="hljs-number">-1</span>]*p[m-n+<span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure><p>最长重复子串（hard）<br>使用字符串hash+二分寻找长度，如果hash的key是字符串的话，时间复杂度为O(n*len))， 只有key为整数类型，时间复杂度才为 O(n))</p><h2 id="常见题型"><a href="#常见题型" class="headerlink" title="常见题型"></a>常见题型</h2><h3 id="1-最大数"><a href="#1-最大数" class="headerlink" title="1. 最大数"></a>1. 最大数</h3><p>注意使用str.substr以及位移操作时候一定要记得赋值，否则结果是不会改变的 res=res.substr(start, len), 以及注意最后的结果包含首0的情况，一定要记得去除首零</p><h3 id="2-最大单词长度乘积"><a href="#2-最大单词长度乘积" class="headerlink" title="2. 最大单词长度乘积"></a>2. 最大单词长度乘积</h3><p>使用掩码判断字符串是否有相似的字符，然后掩码&amp;</p><h3 id="3-打开转盘锁"><a href="#3-打开转盘锁" class="headerlink" title="3. 打开转盘锁"></a>3. 打开转盘锁</h3><p>使用bfs<br>值得学习的地方：</p><ol><li><p>使用unordered_set代替vector<br>主要在判断一个字符之前是否在一个集合中, 使用unordered_set比vector更快 if(!set.count())  表示集合中没有这个元素</p></li><li><p>在查找当前字符变形后的字符，一定要及得保留当前的字符再做修改！！</p></li><li><p>匹配子序列的单词数<br>查看多个字符串中，有几个是字符串s的子序列<br>使用二分查找，先通过hash，将不同字符对应的下标值进行存储，然后遍历需要查询的每个字符串，分别从hash里面多个vector进行查找，同时下次查找的下标，应该比当前下标至少+1</p></li></ol><h3 id="4-反转每对括号间的子串-华为机试"><a href="#4-反转每对括号间的子串-华为机试" class="headerlink" title="4. 反转每对括号间的子串 (华为机试)"></a><font color="red">4. 反转每对括号间的子串 (华为机试)</font></h3><p><strong>字符串+栈</strong><br>注意这道题我最开始还没想出来</p><ul><li>解决方案：<br>str为最后的结果<br>遇到（ 那么将str的元素压入栈中，然后str转为“”<br>遇到）那么将str元素翻转，<strong>如果栈不为空, 将栈顶元素弹出</strong>, str=s.top()+str; s.pop()<br>其余的字符直接追加在str后面<br>最后返回str</li><li>也就是拼接好的字符串直接放在str中，不需要再压入栈中, 多了一个 “每次遇到]将当前字符串reverse 并加在栈顶元素的后面” 的步骤</li></ul><p>PS：类似的一道题: 字符串解码 (2021年4399后端开发笔试原题)</p><ul><li>仍然使用栈, 思路和4相似，只不过多了一个数字 （左括号不会被压入栈中）</li><li>另一种解法：数字存放在数字栈，字符串存放在字符串栈，遇到右括号时候弹出一个数字栈，字母栈弹到左括号为止。（左括号会压入栈中）</li></ul><h3 id="5-lc2157字符串分组-hard"><a href="#5-lc2157字符串分组-hard" class="headerlink" title="5. lc2157字符串分组(hard)"></a><font color="red">5. lc2157字符串分组(hard)</font></h3><ul><li>(lc49字符串异位词分组) 用string或者vector<int> 作为hash的key</int></li><li>并查集对字符串进行分组和记录组数（带size的并查集，同时要考虑可能存在相同字符串的情况， size[x]&gt;1 group–，同时合并的时候， group也会–），状态压缩+位运算实现字符串关联判断和查找</li><li>如果直接枚举任意两个字符串并判断是否关联，并以此得到图上所有的边，时间复杂度至少为 O(n^2), 会超出时间限制。因此对每个字符串进行变换</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> ch: word) &#123;<br>    x |= <span class="hljs-number">1</span> &lt;&lt; (ch - <span class="hljs-string">&#x27;a&#x27;</span>); <span class="hljs-comment">// 计算 word 的二进制表示</span><br>&#125;<br><br><span class="hljs-keyword">for</span> x := range fa &#123; <span class="hljs-comment">// 枚举所有字符串（二进制表示）</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++ &#123;<br><span class="hljs-built_in">merge</span>(x, x^<span class="hljs-number">1</span>&lt;&lt;i) <span class="hljs-comment">// 添加或删除字符 i  0变为1， 1变为0</span><br><span class="hljs-keyword">if</span> x&gt;&gt;i&amp;<span class="hljs-number">1</span> == <span class="hljs-number">1</span> &#123; <span class="hljs-comment">//找到一个1， 0对 翻转</span><br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">26</span>; j++ &#123;<br><span class="hljs-keyword">if</span> x&gt;&gt;j&amp;<span class="hljs-number">1</span> == <span class="hljs-number">0</span> &#123;<br><span class="hljs-built_in">merge</span>(x, x^<span class="hljs-number">1</span>&lt;&lt;i|<span class="hljs-number">1</span>&lt;&lt;j) <span class="hljs-comment">// 替换字符 i 为 j</span><br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="6-最长的美好子字符串"><a href="#6-最长的美好子字符串" class="headerlink" title="6. 最长的美好子字符串"></a>6. 最长的美好子字符串</h3><ul><li>枚举，i， j, 表示字符串左右，两重循环</li><li>然后使用两个二进制代替两个数组，判断是否大小写都有，如果有数量就不能使用两个数来代替，只有这种有或没有可以<br>也是使用二进制对字符串进行压缩<br>枚举/分治/枚举typenum(至少有K个重复字符的最长子串, 不建议用这种方法，因为比较难)</li></ul><h3 id="7-不同字符的最小子序列"><a href="#7-不同字符的最小子序列" class="headerlink" title="7. 不同字符的最小子序列"></a>7. 不同字符的最小子序列</h3><p>去除重复的字符串，使得子序列包含所有的字符，每个字符一次，同时字典序有最少<br>solution:<br>需要有一个hash来记录一个字符的剩余出现次数<br>如果栈中没找到，从栈中弹出剩余出现次数大于0，而且大于当前字符的字符，然后压入当前字符<br>如果栈中找到，直接将num[当前字符]–, 不push进入栈中</p><h3 id="8-序列自动机"><a href="#8-序列自动机" class="headerlink" title="8.序列自动机"></a><font color="red">8.序列自动机</font></h3><p>字符串dp<br>在进行判断一个字符串a是否是另外一个字符串b的子序列的时候，可以使用双指针，判断a的指针是否能走到末尾<br>也可以使用dp<br>dp[i][j]=i  s[i]==j （表示s从i开始第一个等于字符j的下标）<br>dp[i][j]=dp[i+1][j]  s[i]!=j<br>从后往前更新</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"> Arrays.fill(f[m], m);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = m - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">26</span>; ++j) &#123;<span class="hljs-comment">//只包含小写字符</span><br><span class="hljs-keyword">if</span> (s.charAt(i) == (<span class="hljs-keyword">char</span>) (<span class="hljs-string">&#x27;a&#x27;</span> + j)) &#123;<br>f[i][j] = i;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>f[i][j] = f[i + <span class="hljs-number">1</span>][j];<br>&#125;<br>&#125;<br>&#125;<br>String res = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">for</span> (String t : dictionary) &#123;<br><span class="hljs-keyword">boolean</span> match = <span class="hljs-keyword">true</span>;<br><span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; t.length(); ++i) &#123;<br><span class="hljs-keyword">if</span> (f[j][t.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>] == m) &#123;<br>match = <span class="hljs-keyword">false</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>j = f[j][t.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>] + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (match) &#123;<br><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-KMP算法"><a href="#9-KMP算法" class="headerlink" title="9. KMP算法"></a>9. KMP算法</h3><p>主要是求next的数组，以及在循环退出之后判断字符是否相等，进行k的判断或者next数组的赋值<br>代码模板：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">findnext</span><span class="hljs-params">(string pattern, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; next)</span></span>&#123;<br>       <span class="hljs-keyword">int</span> size = pattern.<span class="hljs-built_in">size</span>();<br>       <span class="hljs-keyword">int</span> k = <span class="hljs-number">-1</span>;<br>       next[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;<span class="hljs-comment">//代表已经匹配的下标</span><br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; size; i++)<br>       &#123;<br>           <span class="hljs-keyword">while</span>(k!=<span class="hljs-number">-1</span>&amp;&amp;pattern[i]!=pattern[k+<span class="hljs-number">1</span>])&#123;<br>                   k = next[k];<br>           &#125;<span class="hljs-comment">//因为跳出循环后还需要判断相等，因此将判断相等放在while的后面而不是前面</span><br>           <span class="hljs-keyword">if</span>(pattern[i]==pattern[k+<span class="hljs-number">1</span>])&#123;<br>               k++;<br>           &#125;<br><br>           next[i] = k;<br>       &#125;<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">strStr</span><span class="hljs-params">(string haystack, string needle)</span> </span>&#123;<br>   <span class="hljs-comment">// int KMP(string target, string pattern)&#123;</span><br>       string target=haystack;<br>       string pattern=needle;<br>       <span class="hljs-keyword">int</span> size = target.<span class="hljs-built_in">size</span>();<br>       <span class="hljs-keyword">int</span> k = <span class="hljs-number">-1</span>;<br>       <span class="hljs-keyword">if</span>(pattern==<span class="hljs-string">&quot;&quot;</span>)&#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>       &#125;<br>       <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">next</span><span class="hljs-params">(pattern.size())</span></span>;<br>       <span class="hljs-built_in">findnext</span>(pattern, next);<br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)<br>       &#123;<br>           <span class="hljs-keyword">while</span>(k!=<span class="hljs-number">-1</span>&amp;&amp;target[i]!=pattern[k+<span class="hljs-number">1</span>])&#123;<br>                   k = next[k];<br>           &#125;<br>           <span class="hljs-keyword">if</span>(target[i]==pattern[k+<span class="hljs-number">1</span>])&#123;<br>               k++;<br>               <span class="hljs-keyword">if</span>(k==pattern.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>)&#123;<br>                   <span class="hljs-keyword">return</span> i - k ; <span class="hljs-comment">//返回匹配字符串的头位置</span><br>               &#125;<br>           &#125;<br><br>       &#125;<br>       <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="10-字符串翻转"><a href="#10-字符串翻转" class="headerlink" title="10. 字符串翻转"></a>10. 字符串翻转</h3><p>“leetcode i” –&gt; “i leetcode”<br>思路：1. 使用栈<br>2. 先整个字符串翻转，去空格+原位翻转（双指针）+删除后面多余的字符 //空间复杂度O(1)</p><h3 id="11-实现-atoi-字符串转数字"><a href="#11-实现-atoi-字符串转数字" class="headerlink" title="11. 实现 atoi() 字符串转数字"></a>11. 实现 atoi() 字符串转数字</h3><p>注意这几个测试用例：<br>  a. 包含非法字符，返回 error 或者 0<br>  b. 要考虑正负号<br>  c. 要考虑溢出的情况。直接按照字典序，比较输入字符串和 TMin、TMax 的字符串就可以了，不需要在转换过程中判断是否溢出</p><h3 id="12-lc115-不同的子序列-字符串匹配问题"><a href="#12-lc115-不同的子序列-字符串匹配问题" class="headerlink" title="12. lc115. 不同的子序列(字符串匹配问题)"></a>12. lc115. 不同的子序列(字符串匹配问题)</h3><ul><li> 这道题主要是求一个字符串s中可以找到多少个字符串t(只变了一个字符也是一种新的情况) (见8.序列自动机)</li><li> 使用dp[i][j]表示字符串s前i个，和字符串t前j个进行匹配的个数，那么状态转移方程为 （下面展示的是从前往后，从后往前也是可以的）<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;s1;i++)&#123;  <span class="hljs-comment">//注意这里的初始化非常重要</span><br>    dp[i][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;s1;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;s2;j++)&#123;<br>        <span class="hljs-keyword">if</span>(s[i]==t[j])&#123;<br>            dp[i][j]=dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+dp[i<span class="hljs-number">-1</span>][j];   <span class="hljs-comment">//相同可以与当前t匹配，也可以不匹配</span><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            dp[i][j]=dp[i<span class="hljs-number">-1</span>][j];<br>        &#125;<br>        dp[i][j]=<span class="hljs-built_in">min</span>(dp[i][j],<span class="hljs-number">1LL</span>*<span class="hljs-number">1000000000000000</span>); <span class="hljs-comment">//这里是为了防止long long型超出范围</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li> 其他注意的地方：自左向右和从右到左都会爆 long long超出范围，使用记忆化搜索不会。同时一定要记得初始化，没有与模式字符串匹配的时候，都需要赋值为1 dp[i][0]=1</li></ul><h3 id="13-Trie树的实现"><a href="#13-Trie树的实现" class="headerlink" title="13. Trie树的实现"></a>13. Trie树的实现</h3><p>具体实现见系统设计中的Trie树专题</p><h3 id="14-单词搜索"><a href="#14-单词搜索" class="headerlink" title="14. 单词搜索"></a>14. 单词搜索</h3><ul><li>Trie树+回溯<br>先将要字典中的单词建立一颗Trie树，然后枚举矩阵中的每个点，进行dfs, 在进行dfs的时候，只对Trie树中有的边进行dfs, 如果当前走到isEnd=True的情况，那么就直接压入结果，同时这个时候不能直接退出，还可以继续dfs,因为字典中的单词可能是存在相互包含的关系的（dfs剪枝）</li></ul><h3 id="15-最长回文前缀"><a href="#15-最长回文前缀" class="headerlink" title="15. 最长回文前缀"></a><font color="red">15. 最长回文前缀</font></h3><p>lc214. 最短回文串<br>求s的最长回文前缀，其实就是求str = s+”#”+rev_s的最长公共前后缀，使用KMP算法求next数组，然后返回next[str.size()-1]，就是最长的回文前缀</p><p>一个字符串的最长前后缀为，这个字符串求next数组，返回next[size-1]</p><p>马拉车算法：<a href="https://www.acwing.com/file_system/file/content/whole/index/content/446985/">Manacher 算法详解 - AcWing</a></p><h3 id="16-lc321-拼接最大数-hard"><a href="#16-lc321-拼接最大数-hard" class="headerlink" title="16. lc321. 拼接最大数 (hard)"></a><font color="red">16. lc321. 拼接最大数 (hard)</font></h3><ul><li>题意：从两个数组中共选择k个数，是的数最大</li><li>第一步是枚举每个数组中取数据的个数</li><li>第二步分别从两个数组中得到指定长度的最大子序列</li><li>第三步是将两个最大子序列合并。（一定要注意合并！！！！ 可能会遇到相同的情况，不是随便选一个，而是要找到他们后面第一个不相等的进行比较）<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">bool</span> flag=<span class="hljs-literal">true</span>; <span class="hljs-comment">//第一个数组++</span><br><span class="hljs-keyword">while</span>(index1&lt;m&amp;&amp;index2&lt;n)&#123;<br>    <span class="hljs-keyword">if</span>(arr1[index1]&gt;arr2[index2])&#123;<br>        flag==<span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr1[index1]&lt;arr2[index2])&#123;<br>        flag=<span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    index1++;<br>    index2++;<br>&#125;<br><span class="hljs-keyword">if</span>(index1==m)&#123;<br>    flag=<span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="17-lc792-匹配子序列的单词数"><a href="#17-lc792-匹配子序列的单词数" class="headerlink" title="17. lc792. 匹配子序列的单词数"></a>17. lc792. 匹配子序列的单词数</h3><ul><li>判断字典里面的每个字符串是否是s的子序列，使用双指针会超时</li><li>方法一：使用字符串dp, dp[i][j]表示s从index下标开始，找到的第一个字母j的下标</li><li>方法二：使用map&lt;int, vector<int>&gt; 记录下每个字母在字符串中下标的位置，然后使用二分查找</int></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>在对字符串进行操作通常可以朝栈，递归， bfs等方向思考<br> 尤其是左右括号对应的这种情况-&gt; 栈和递归</p></li><li><p>状态压缩：如果字符串的每一个字符串都至多包含每个字母一次，并且字母的顺序无关紧要，因此我们可以使用一个 262的二进制数 mask 表示一个字符串。<br>同时如何两两判断两个字符串是否有关联的时间复杂度太高O(n^2^len(str)), 那么可以转为「枚举一个节点」+「枚举可能的相邻节点」+「使用哈希表判断相邻节点是否真正存在」的方法得到所有关联的边，（也就是猜测字符串的每个数的时间复杂度可能小于两层循环遍历+判断）</p></li><li><p>注意在进行字符串比较的时候是比较多次，但是在进行数字比较的时候是比较一次,所以hash的key存int比存string更高效</p></li><li><p>char a可以使用a++，变为另外一个字符 ‘A’-&gt;’B’<br>但是string s类型，即使只有一个字符，也必须使用s[0]++, 不能使用s++</p></li><li><p>如果出现反复将一个字符串的子串和字典中的每个字符比对的题目，可以使用Trie树，或者使用动态规划（True/False类型），提前判断某一个子字符串是否在字典中 （PS: 动态规划中也有这句话的总结）</p></li><li><p>Trie树，通常是将字典里面的字符串构建一个trie数，然后在进行查询的时候，就相当于直接在字典中（多个字符串同时）查找，而不是和字典中的每个字符串进行对比<br>例题：lc: 面试题 17.17. 多次搜索(KMP/ Trie数)</p></li><li><p>字符串匹配问题:求个数，求是否匹配，求删除字符的最小数量，都是使用的动态规划，定义的dp[i][j]都是让s前i个字符和t前j个字符匹配的xxxx， 一般都是将s[i]和t[j]是否相等分成两种情况，并分别求对应的状态转移</p></li><li><p>有时候有字典的这种情况会考虑到建立前缀树，也可以考虑使用逆向思维，将字典树加密的所有字符串提前求出来，然后使用打表方法<br>lc5302. 加密解密字符串（周赛hard）</p></li><li><p>求所有子字符串的分数（要求连续类问题） 可以转为每个字母对于包含它的每个子字符串的贡献 求和，将二重循环转为一重循环<br>（周赛：6050. 字符串的总引力）</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>位运算</title>
      <link href="/2021/11/13/leetcode/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
      <url>/2021/11/13/leetcode/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="1-使用位运算来判断a-b的大小（注意出现溢出的情况）"><a href="#1-使用位运算来判断a-b的大小（注意出现溢出的情况）" class="headerlink" title="1. 使用位运算来判断a b的大小（注意出现溢出的情况）"></a>1. 使用位运算来判断a b的大小（注意出现溢出的情况）</h3><p>位运算可以用来判断a b的正负，以及a-b的正负，因此分情况讨论a b的符号是否相等，如果相等，a-c大于0返回a;如果不等，a的符号大于0返回a<br>其余情况(flip(return A))返回B</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">flip</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a^<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-用位运算实现加减法：注意不用区分正负"><a href="#2-用位运算实现加减法：注意不用区分正负" class="headerlink" title="2. 用位运算实现加减法：注意不用区分正负"></a>2. 用位运算实现加减法：注意不用区分正负</h3><p>左移，正负数都是右边添加0（也就是负数左移，是会移走最左边的符号位）<br>右移若干位，正数左补0，负数左补1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(a, b)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> sum=a;<br>    <span class="hljs-keyword">while</span>(b!=<span class="hljs-number">0</span>)&#123;<br>        sum=a^b;<br>        b= (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)(a&amp;b)&lt;&lt;<span class="hljs-number">1</span>; <span class="hljs-comment">//unsigned int非常重要</span><br>        a=sum;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">neg</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">add</span>(~a, <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sub</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">add</span>(a, <span class="hljs-built_in">neg</span>(b));<br>&#125;<br><br>用位运算实现乘除法：<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">multi</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(b!=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">if</span>((b&amp;<span class="hljs-number">1</span>)!=<span class="hljs-number">0</span>)&#123;<br>             res=<span class="hljs-built_in">add</span>(res, a);<br>        &#125;<br>        a=a&lt;&lt;<span class="hljs-number">1</span>;<br>        b=b&gt;&gt;<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//注意div考虑如果是负数是INT_MIN如何处理，不能直接转为整数</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sign</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a&lt;<span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">div</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> x=<span class="hljs-built_in">sign</span>(a)? <span class="hljs-built_in">neg</span>(a):a;<br>    <span class="hljs-keyword">int</span> y=<span class="hljs-built_in">sign</span>(b)? <span class="hljs-built_in">neg</span>(a):a;  <span class="hljs-comment">//转为整数进行运算</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">31</span>;i&gt;=<span class="hljs-number">0</span>;<span class="hljs-built_in">sub</span>(i, <span class="hljs-number">1</span>))&#123;<br>        <span class="hljs-keyword">if</span>((x&gt;&gt;i)&gt;=y)&#123; <span class="hljs-comment">//注意这里不是y&lt;&lt;i  因为可能出现溢出</span><br>            res|= （<span class="hljs-number">1</span>&lt;&lt;i）;<br>            x = <span class="hljs-built_in">sub</span>(x, y&lt;&lt;i);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sign</span>(a)^<span class="hljs-built_in">sign</span>(b)? <span class="hljs-built_in">neg</span>(res): res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(b==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> error;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a==INT_MIN&amp;&amp;b==INT_MIN)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(b==INT_MIN||a==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a==INT_MIN)&#123;<br>        <span class="hljs-keyword">int</span> tmp=<span class="hljs-built_in">div</span>(<span class="hljs-built_in">add</span>(a, <span class="hljs-number">1</span>),b);<br>        <span class="hljs-keyword">int</span> rest=<span class="hljs-built_in">div</span>(<span class="hljs-built_in">sub</span>(a, <span class="hljs-built_in">mul</span>(tmp, b)), b);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">add</span>(tmp, rest); <span class="hljs-comment">//相当于分成两个部分计算</span><br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">div</span>(a, b);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="3-一些位运算技巧"><a href="#3-一些位运算技巧" class="headerlink" title="3. 一些位运算技巧"></a>3. 一些位运算技巧</h3><ul><li><p>移除最右边的1<br><code>n = n&amp;(n-1)</code></p></li><li><p>得到最右边的1<br><code>n &amp; (~n + 1)</code></p></li><li><p>用位运算计算一个二进制数的1个数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(n!=<span class="hljs-number">0</span>)&#123;<br>    n=n&amp;(n<span class="hljs-number">-1</span>);<span class="hljs-comment">//不断消掉右边的1，但是问题是当n=-INT_MIN n-1不会溢出么，那么如何计算最左边的1呢</span><br>    res+=<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-使用位运算实现八皇后"><a href="#4-使用位运算实现八皇后" class="headerlink" title="4. 使用位运算实现八皇后"></a>4. 使用位运算实现八皇后</h3></li></ul><h3 id="5-绘制直线"><a href="#5-绘制直线" class="headerlink" title="5. 绘制直线"></a>5. 绘制直线</h3><p>bit计算对应的int数组的下标(求得每个像素点对应的数的位数)</p><h3 id="6-两整数之和"><a href="#6-两整数之和" class="headerlink" title="6. 两整数之和"></a>6. 两整数之和</h3><p>不使用+实现两个整数之和 使用异或以及与运算，一定要注意 carry要使用unsigned int 使用int会报错</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>) carry=(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>) (a&amp;b)&lt;&lt;<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="7-数组中两个数的最大异或值"><a href="#7-数组中两个数的最大异或值" class="headerlink" title="7. 数组中两个数的最大异或值"></a><font color="red">7. 数组中两个数的最大异或值</font></h3><ul><li>方法一：31位的每一位只有两种情况，因此可以猜测执行<br>  对异或结果的每一位(32位，从31-0)从大到小进行猜测可以取到的数1或者0 运用了a^b=x 那么x^a=b,也就是查看猜测的这个数和集合里面的进行异或是否能够在集合里面找到另外一个数 （31*n的时间复杂度仍然是O(n)）</li><li>方法二：使用字典树，然后遍历每个数，得到针对这个数可以取到的异或最大值i，然后取最大；（这里的trie树是一颗二叉树）</li></ul><h3 id="8-lc201-数字范围按位与"><a href="#8-lc201-数字范围按位与" class="headerlink" title="8. lc201. 数字范围按位与"></a>8. lc201. 数字范围按位与</h3><ul><li>转为求左右的公共前缀</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>位运算优先级注意, 同时一定要注意INT_MAX或者INT_MIN可能会导致左移/右移 /-1溢出</p></li><li><p>位运算实现加减乘除</p></li><li><p>在有的题目中取最右边的1的时候使用<code>x^(~x+1)</code>可能出现溢出，因此使用<code>tmp=1; while((tmp&amp;xore)==0) tmp=(tmp&lt;&lt;1);</code> 找最右边的1（lc260. 只出现一次的数字 III）</p></li><li><p>注意位运算的优先级问题：使用位运算一定要多打括号</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 错误写法</span><br><span class="hljs-keyword">if</span> (a &amp; b == <span class="hljs-number">0</span>) &#123;<br>    ...;<br>&#125;<br><br><span class="hljs-comment">// 正确写法</span><br><span class="hljs-keyword">if</span> ((a &amp; b) == <span class="hljs-number">0</span>) &#123;<br>    ...;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p> a + (b&amp;c) 不管是+/-/*/ 还是==， 只要和位运算在一起，位运算都应该打括号！！！！</p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>贪心算法</title>
      <link href="/2021/11/13/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
      <url>/2021/11/13/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="常见例题"><a href="#常见例题" class="headerlink" title="常见例题"></a>常见例题</h2><h3 id="1-摆动序列"><a href="#1-摆动序列" class="headerlink" title="1. 摆动序列"></a>1. 摆动序列</h3><p>使用贪心算法，或者动态规划 当前状态可以用前面的一个状态转移过来（可以证明得到，down是由up转移过来，up是由down转移过来），所以时间复杂度只有O(1)<br>或者使用diff来进行理解，当前的diff一定要和前一个diff相反<br>注意和最长上升子序列的区别，最长上升子序列，当前的状态不能从上一个状态转移过来，所以只能使用内外循环</p><p>其实摆动序列也属于动态规划  down[i], up[i]: 0-i之间的最后为up的最长序列，和最后为down的最长序列;一定要注意<br>down[i]=max(down[i-1], up[i-1]+1)//一定要记得和down[i-1]进行比较</p><h3 id="2-最大子序列和"><a href="#2-最大子序列和" class="headerlink" title="2. 最大子序列和"></a>2. 最大子序列和</h3><h3 id="3-加油站"><a href="#3-加油站" class="headerlink" title="3. 加油站"></a>3. 加油站</h3><h3 id="4-买卖股票最佳时机-（也属于动态规划）-两状态目标规划问题"><a href="#4-买卖股票最佳时机-（也属于动态规划）-两状态目标规划问题" class="headerlink" title="4. 买卖股票最佳时机 （也属于动态规划） - 两状态目标规划问题"></a>4. 买卖股票最佳时机 （也属于动态规划） - 两状态目标规划问题</h3><p>  买卖股票最佳时机I:只买卖一次，当前最大-之前最小<br>  买卖股票最佳时机II:买卖多次，贪心，向上就+，向下就不加<br>  买卖股票最佳时机III, IV:最多买卖k次，使用动态规划，需要分两个数组，因为卖出必须在买入后，因此注意最开始初始化buy[0][1]=-prices[0], 否则就会出现在index0/最开始交易就卖出的情况。<br>  在0的时候卖出k次，仍然是-卖出一次的价钱 所有需要出示化所有buy[0][k]=-prices[0]<br>  因为当前i的状态都是依赖i-1的状态，因此可以使用一维数组，进行状态压缩</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; ++i) &#123;<br>     buy[i] = -prices[<span class="hljs-number">0</span>];<br>     sell[i]=<span class="hljs-number">0</span>;<br> &#125;<br> buy[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br> <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<span class="hljs-comment">//i表示i时刻</span><br>     sell[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= k; ++j) &#123;<br>         buy[j] = <span class="hljs-built_in">max</span>(buy[j], sell[j<span class="hljs-number">-1</span>] - prices[i]);<br>         sell[j] = <span class="hljs-built_in">max</span>(sell[j], buy[j] + prices[i]);   <br>     &#125;<br> &#125;<br> <span class="hljs-keyword">return</span> *<span class="hljs-built_in">max_element</span>(sell.<span class="hljs-built_in">begin</span>(), sell.<span class="hljs-built_in">end</span>());<br></code></pre></td></tr></table></figure><p>  买卖股票的最佳时机含手续费： 可以买卖无限次，但是每买入卖出一次都会收取一次的手续费用，使用dp, 在卖出的时候-fee<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">buy[i]=<span class="hljs-built_in">max</span>(buy[i<span class="hljs-number">-1</span>],sell[i<span class="hljs-number">-1</span>]-prices[i]);<br>sell[i]=<span class="hljs-built_in">max</span>(sell[i<span class="hljs-number">-1</span>],buy[i]+prices[i]-fee);<br><span class="hljs-keyword">return</span> sell[size<span class="hljs-number">-1</span>];<br></code></pre></td></tr></table></figure></p><ul><li>类似的一个多状态的动态规划问题:lc801. 使序列递增的最小交换次数</li><li>两个长度相等的数组，使得两个数组相等的最小交换次数</li><li>题解：当发生错位的时候，可以当前位置交换，也可以前一个位置交换，因此进行分类讨论，用0 1分别表示两种状态（当前位交换，或者当前位不交换）；同时因为当前位只和上一个位置有关，因此可以使用两个数组before和cur就可以了，不用使用一个二维数组</li></ul><h3 id="5-跳跃游戏"><a href="#5-跳跃游戏" class="headerlink" title="5. 跳跃游戏"></a>5. 跳跃游戏</h3><h3 id="6-区间相关的题目"><a href="#6-区间相关的题目" class="headerlink" title="6. 区间相关的题目"></a>6. 区间相关的题目</h3><p>主要是判断如何对区间进行排序（左区间还是右区间，遇到重叠该如何处理）</p><h3 id="7-用最少数量的箭引爆气球"><a href="#7-用最少数量的箭引爆气球" class="headerlink" title="7. 用最少数量的箭引爆气球"></a>7. 用最少数量的箭引爆气球</h3><p>先按照气球的右区间对气球的进行排序，如果遍历到的当前左区间小于end,那么continue；否则更新end, res++</p><h3 id="8-划分字母区间"><a href="#8-划分字母区间" class="headerlink" title="8. 划分字母区间"></a>8. 划分字母区间</h3><p>注意读懂题意: 是同一个字母最多出现在一个区间，而不是一个字母只出现在一个区间！！<br>用hash统计一个字母的最后位置，当当前遍历的位置==之前区间达到的最大位置，说明需要划分一个区间了</p><p>有点类似跳跃游戏, 跳跃游戏多维护了一个end</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> end=<span class="hljs-number">0</span>, maxPos=<span class="hljs-number">0</span>, step=<span class="hljs-number">0</span>;<br> <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i++)&#123;<br>     maxPos=<span class="hljs-built_in">max</span>(nums[i]+i,maxPos);<br>     <span class="hljs-keyword">if</span>(i==end)&#123;<br>         end=maxPos;<br>         step++;<br>     &#125;<br> &#125;<br> <span class="hljs-keyword">return</span> step;<br></code></pre></td></tr></table></figure><h3 id="9-无重叠区间"><a href="#9-无重叠区间" class="headerlink" title="9. 无重叠区间"></a>9. 无重叠区间</h3><p>需要以右边界排序，在两个区间重叠的时候，保留右边界更小的区间</p><h3 id="10-合并区间"><a href="#10-合并区间" class="headerlink" title="10. 合并区间"></a>10. 合并区间</h3><p>以左边界进行排序，注意在修改vector back的右边界的时候可以不用pop_back 然后push_back可以直接使用<code>vec.back()[1]=interval[i][1]</code></p><h3 id="11-分割数组为连续子序列"><a href="#11-分割数组为连续子序列" class="headerlink" title="11. 分割数组为连续子序列"></a>11. 分割数组为连续子序列</h3><p>关键点，每次往前往后看是否能凑齐一个最小合格序列<br>两种解法：</p><ul><li><p>使用优先队列的方式，用一个map记录以x结尾的序列（使用优先队列存放，unordered_map&lt;int, priority_queue&lt;int, vector<int>,greater<int>&gt;&gt; mp），同时这个序列需要根据长度从小到大进行排序，就是说相同的长度末尾，更倾向于将当前的x追加到长度更短的以x-1的序列上</int></int></p></li><li><p>如果使用贪心算法，那就是用两个hash表，一个表记录数据的个数，另外一个表记录以某一个数结尾的合格序列个数。每次都先凑齐一个合格序列，然后在判断后面的数， 首先看有没有x-1的合格序列，有就当前数-1， valid[x-1]–, valid[x]++;否则从当前数开始从后面凑齐一个合格序列</p></li></ul><h3 id="12-环形子数组的最大值"><a href="#12-环形子数组的最大值" class="headerlink" title="12. 环形子数组的最大值"></a>12. 环形子数组的最大值</h3><p>分为两种情况，一个区间加起来最大，或者左右两端加起来最大<br>那么就是 max(res1, total-res2) res1是中间加起来最大， res2的中间加起来最小<br>但是注意！！！ 当total==res2的时候，直接返回res1, 不应该返回max(res1, total-res2) </p><h3 id="13-使数组唯一的最小增量"><a href="#13-使数组唯一的最小增量" class="headerlink" title="13.  使数组唯一的最小增量"></a>13.  使数组唯一的最小增量</h3><p>有点偏向找规律，使得数组中数据各不相同的最小操作次数（加的次数）<br>方法一：可以将多余的数，变为它==后面==相同个数个没有vis的数，返回结果其实就是没有vis数之和-多余数之和<br>方法二：先排序，再依次遍历数组元素，若当前元素小于等于它前一个元素，则将其变为前一个数 +1。</p><h3 id="14-吃苹果的最大数目"><a href="#14-吃苹果的最大数目" class="headerlink" title="14. 吃苹果的最大数目"></a>14. 吃苹果的最大数目</h3><p>注意这个和跳跃问题不一样<br>[2,1,10] [2,10,1] 答案是4<br>第四天可以吃第2天产的苹果，如果是跳跃的话，答案为3<br>使用贪心+优先队列<br>最先吃掉最先腐烂的水果，在前n个水果，因为每天可能会产生新的水果，最先腐烂的水果会改变，所以i一天一天相加；在n之后因为不会产生新的水果，所以i+=min(水果个数，腐烂截止-当前天数</p><p>优先队列的一些操作：q.top(), q.push() q.pop()<br>注意不能直接修改优先队列元素的值，比如q.top().num– 的操作是错误</p><h2 id="区间相关问题"><a href="#区间相关问题" class="headerlink" title="区间相关问题"></a>区间相关问题</h2><p>区间子数组个数 一共有n个数的子区间个数是1+2+3+…+n 也就是(1+n)*n/2<br>这道题是最大值在[left, right]的区间个数，可以找到每个数都是&lt;=right的区间个数-每个数都是&lt; left的区间个数</p><h3 id="lc352-将数据流变为多个不相交区间（hard）"><a href="#lc352-将数据流变为多个不相交区间（hard）" class="headerlink" title="lc352. 将数据流变为多个不相交区间（hard）"></a>lc352. 将数据流变为多个不相交区间（hard）</h3><ul><li>题意：添加num, getInterval返回合并了的区间</li><li>解决方案: 使用map&lt;int, int&gt; 分别记录区间的左右，然后在插入一个val, 找到这个val左右两边最近的区间（使用一个upper_bound, 然后prev(iter) 如果iter不是hash.begin()）如果这个值在前面这个区间内或者边缘的话，直接返回；否则分四种情况判断，左右边缘衔接处，左边缘，右边缘，或者都不是，分别进行处理，最后遍历map并打印出来就可以了</li><li>可以学习的地方，为了减少if里面的判断逻辑，可以单独提取出来放在一个bool变量中</li><li>和周赛lc统计区间中的整数数目 非常类似，左边最多和一个区间交，右边可能多个；如果是end-&gt;start, 那么左边都不用判断</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//找到区间的左右两个区间iter</span><br><span class="hljs-keyword">auto</span> pre_iter = (cur_iter == intervals.<span class="hljs-built_in">begin</span>() ? intervals.<span class="hljs-built_in">end</span>() : <span class="hljs-built_in">prev</span>(cur_iter));<br><span class="hljs-keyword">auto</span> next_iter = <span class="hljs-built_in">next</span>(cur_iter);<br><span class="hljs-keyword">bool</span> left_aside = (pre_iter != intervals.<span class="hljs-built_in">end</span>() &amp;&amp; index2char[pre_iter-&gt;second] == index2char[cur_iter-&gt;second]);<br><span class="hljs-keyword">bool</span> right_aside = (next_iter != intervals.<span class="hljs-built_in">end</span>() &amp;&amp; index2char[next_iter-&gt;second] == index2char[cur_iter-&gt;second]);<br></code></pre></td></tr></table></figure><h3 id="lc6030-由单个字符重复的最长子字符串（周赛hard）"><a href="#lc6030-由单个字符重复的最长子字符串（周赛hard）" class="headerlink" title="lc6030. 由单个字符重复的最长子字符串（周赛hard）"></a>lc6030. 由单个字符重复的最长子字符串（周赛hard）</h3><p>这道题可以学习的一个点是将结构体进行拆分， 区间头尾放在map, 区间长度放在multiset, 两者各自进行排序<br>题解：</p><ol><li>先找到这个要修改下标对应的区间</li><li>如果要修改的字符和区间字符不一样就删除原来区间，并对原区间进行拆分，同时插入这个新的只有一个字符的区间</li><li>否则，就不拆分(不进入if内)</li><li>然后判断这个区间前面的区间字符是否和当前要修改的一样，是就合并（同时修改当前指针指向的区间为新的合并后这个前面区间！！！！！，方便后面的合并）</li><li>同样判断右侧的</li><li>使用multiset单独存储长度（自动排序），map单独存储&lt; start, end&gt; ，这样可以直接知道目前最长区间为mullti-set的尾部值* set.rbegin()</li></ol><ul><li>和上面一题一样，同时使用map来记录区间左右</li></ul><h3 id="lc1642-可以到达的最远建筑"><a href="#lc1642-可以到达的最远建筑" class="headerlink" title="lc1642. 可以到达的最远建筑"></a>lc1642. 可以到达的最远建筑</h3><ul><li>m个梯子，k个砖头，所能到达的最高墙</li><li>使用贪心算法，梯子对应的一定是最高前m个墙，那么就用一个m size小根堆, 如果大于m，那么弹出最小的使用砖头 （用梯子应对最大跨度）</li></ul><h3 id="lc605-种花问题-easy"><a href="#lc605-种花问题-easy" class="headerlink" title="lc605. 种花问题 (easy)"></a>lc605. 种花问题 (easy)</h3><ul><li>贪心，遇到0就判断能不能种花<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span>(flowerbed[i]==<span class="hljs-number">0</span>)&#123;<br>      <span class="hljs-keyword">if</span>((i==<span class="hljs-number">0</span>||flowerbed[i<span class="hljs-number">-1</span>]==<span class="hljs-number">0</span>)&amp;&amp;(i==size<span class="hljs-number">-1</span>||flowerbed[i+<span class="hljs-number">1</span>]==<span class="hljs-number">0</span>))&#123; <span class="hljs-comment">//边界处理，可以在两边加0或者分情况判断</span><br>          cnt++;<br>      &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="lc630-课程表-III（hard）"><a href="#lc630-课程表-III（hard）" class="headerlink" title="lc630. 课程表 III（hard）"></a>lc630. 课程表 III（hard）</h3><ul><li>使用优先队列 + 贪心算法：1. 优先学习更早结束的课程 2. 如果total_time+当前课程&lt;=当前课程的结束时间，那么直接学习这个课程就可以了；否则在选择的课程中选择时长最大的课程，如果找到课程时间&gt;当前课程，那么就和当前课程进行交换</li><li>难点在于区间可以移动，不是固定的</li></ul><h3 id="lc849-到最近的人的最大距离"><a href="#lc849-到最近的人的最大距离" class="headerlink" title="lc849. 到最近的人的最大距离"></a>lc849. 到最近的人的最大距离</h3><ul><li>只在一群已经坐好的人中间添加一个人</li></ul><h3 id="lc855-考场就座"><a href="#lc855-考场就座" class="headerlink" title="lc855. 考场就座"></a>lc855. 考场就座</h3><ul><li>在座位中中间添加多个人，同时可以删除人</li><li>题解：使用贪心算法，始终选择空格最大的中间就坐，同时要考虑边缘没有人的情况下，直接坐在两边</li><li>使用set维护已经分配的座位，注意set不能用下标来进行元素的访问，可以通过for(auto cur_val: arr_set) 或者iter的方式来进行访问， *arr_set.begin(), *arr_set.rbegin()//最后一个元素</li></ul><h3 id="lc-会议室IV"><a href="#lc-会议室IV" class="headerlink" title="lc. 会议室IV"></a>lc. 会议室IV</h3><ul><li><p>题意，选择多个不重复区间，使得最后的收益最大</p></li><li><p>动态规划。这其实是个0 − 1 背包问题，每个会议只有参加和不参加两种选择。首先将会议按照结束时间！！！！！！排序，当前区间有两种情况：</p><ol><li>不选择该区间<code>dp[i]=dp[i-1]</code></li><li>选择该区间 <code>dp[i]=max(dp[i-1], dp[idx]+value[i])</code>, 其中idx为结束时间早于当前会议开始时间的最后一个会议下标，使用二分搜索可以找到</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++">    <span class="hljs-comment">// 找到最后一个结束的且结束时间小于等于当前会议开始时间的会议的下标</span><br>        <span class="hljs-keyword">int</span> idx = <span class="hljs-built_in">binarySearch</span>(list, i - <span class="hljs-number">1</span>, cur.start);<br>        <span class="hljs-comment">// 如果没找到，说明当前会议和所有前面的会议都冲突，</span><br>        <span class="hljs-comment">// 所以将当前会议和前面会议的方案取一个最大；</span><br>        <span class="hljs-comment">// 否则找到那个最后结束的与当前会议不冲突的会议下标，</span><br>        <span class="hljs-comment">// 那么现在两种选择，其一是不参加当前会议，则答案是dp[i - 1]，如果参加，答案就是当前会议价值加上dp[idx]</span><br>        <span class="hljs-keyword">if</span> (idx == <span class="hljs-number">-1</span>) &#123;<br>            dp[i] = Math.<span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>], cur.value);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            dp[i] = Math.<span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>], dp[idx] + cur.value);<br>        &#125;<br>=<br></code></pre></td></tr></table></figure></li></ul><h3 id="lc2311-小于等于-K-的最长二进制子序列"><a href="#lc2311-小于等于-K-的最长二进制子序列" class="headerlink" title="lc2311. 小于等于 K 的最长二进制子序列"></a>lc2311. 小于等于 K 的最长二进制子序列</h3><ul><li>先选择所有的 0，再从低位到高位地贪心选择所有的 1，直到所构成的数超出 k</li><li>也就是1一定是全选右边的，不会出现选中间的，得到的结果更优</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>贪心算法就是知道当前能够如何优先选择，使得最后的结果不会比当前的结果差</li><li>常见的题型：区间，优先队列，背包其实也是一种贪心</li><li>在使用优先队列的时候，通常可以直接push进去，只有取的时候才判断，队首的这个符不符合条件，不符合直接弹出</li><li>贪心总结: <a href="https://leetcode-cn.com/problems/course-schedule-iii/solution/gong-shui-san-xie-jing-dian-tan-xin-yun-ghii2/">力扣（LeetCode）官网 - 全球极客挚爱的技术成长平台</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>并查集、数组、模拟和分而治之问题</title>
      <link href="/2021/11/13/leetcode/%E5%85%B6%E4%BB%96/"/>
      <url>/2021/11/13/leetcode/%E5%85%B6%E4%BB%96/</url>
      
        <content type="html"><![CDATA[<h2 id="数组相关"><a href="#数组相关" class="headerlink" title="数组相关"></a>数组相关</h2><p>主要问题：要将数字放在对应的位置上，使用原地交换的方式</p><h3 id="1-旋转矩阵"><a href="#1-旋转矩阵" class="headerlink" title="1. 旋转矩阵"></a>1. 旋转矩阵</h3><p>这个不能直接原地交换，需要记录交换过来的值的同时，记录交换过来的下标</p><h3 id="2-自然数数组的排序"><a href="#2-自然数数组的排序" class="headerlink" title="2. 自然数数组的排序"></a>2. 自然数数组的排序</h3><h3 id="3-奇数下标是奇数，偶数下标是偶数"><a href="#3-奇数下标是奇数，偶数下标是偶数" class="headerlink" title="3. 奇数下标是奇数，偶数下标是偶数"></a>3. 奇数下标是奇数，偶数下标是偶数</h3><ul><li>第一种方法，使用一个环来进行数据的交换</li><li>第二种方法，每个数据与当前的数据进行交换，然后判断当前交换过来的数据应该放到的位置，重复这样的过程，知道当前交换过来的数是应该放置的数</li></ul><p>举个例子：<br>//如果下标i应该放的数据是 i+1 index和value之间存在映射</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++">tmp=a[i];<br><span class="hljs-keyword">while</span>(a[i]!=i+<span class="hljs-number">1</span>)&#123;<br>    <span class="hljs-keyword">int</span> next=a[tmp<span class="hljs-number">-1</span>];<br>    a[tmp<span class="hljs-number">-1</span>]=tmp;<br>    tmp=next;<br>&#125;<br><br><span class="hljs-keyword">while</span>(a[i]!=i+<span class="hljs-number">1</span>)&#123;<br>    <span class="hljs-built_in">swap</span>(a[i], a[a[i]<span class="hljs-number">-1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-最大子矩阵的和转为最大子数组的和"><a href="#4-最大子矩阵的和转为最大子数组的和" class="headerlink" title="4. 最大子矩阵的和转为最大子数组的和"></a>4. 最大子矩阵的和转为最大子数组的和</h3><p>枚举每一行开始  i从0 ~ n-1,每次换开始的时候重新初始化数组s; j从i ~ n-1<br>二维转为一维</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;matrix.<span class="hljs-built_in">size</span>();i++)&#123; <span class="hljs-comment">//枚举row1</span><br>    <span class="hljs-keyword">int</span> s[matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i;j&lt;matrix.<span class="hljs-built_in">size</span>();j++)&#123; <span class="hljs-comment">//枚举row2</span><br>        <span class="hljs-keyword">int</span> cur=<span class="hljs-number">0</span>;<span class="hljs-comment">//从头开始</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();k++)&#123; <span class="hljs-comment">//转为最大子数组和</span><br>            s[k]+=matrix[j][k];<br>            cur+=s[k]; <span class="hljs-comment">//利用之前加的值，加上现在的值</span><br>            res=<span class="hljs-built_in">max</span>(res, cur);<br>            <span class="hljs-keyword">if</span>(cur&lt;<span class="hljs-number">0</span>)&#123;<br>                cur=<span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-边界都是1的最大正方形："><a href="#5-边界都是1的最大正方形：" class="headerlink" title="5. 边界都是1的最大正方形："></a>5. 边界都是1的最大正方形：</h3><p>这种问题先想个暴力算法，然后考虑如何用空间换时间，加速判断的过程</p><ul><li>1.先循环，找到每个点的right down数组，注意边界要单独赋值，从右往左，从下网上计算</li><li>2.遍历size（最开始初始化为m.size()和m[0].size()的最小值）, 每个size下遍历每个点，看左右边长以及右上角和左下角的right down是否都大于size,<br>如果是返回true,否则返回false</li></ul><h3 id="6-数组partition的调整"><a href="#6-数组partition的调整" class="headerlink" title="6. 数组partition的调整"></a>6. 数组partition的调整</h3><p>使用双指针，一个指针指向排序好的末尾，一个指针指向待排序序列的头结点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> left=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> right=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(right&lt;length)&#123;<br>    <span class="hljs-keyword">if</span>(arr[left]!=arr[right])&#123;<br>        left++;<br>        <span class="hljs-built_in">swap</span>(arr[left], arr[right]);<br>        right++;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此类型的拓展问题，红蓝白球的排序，以及 0 1 2的排序<br>解决方案：记录一个左节点（初始化-1）右节点（length）中间节点：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> left=<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">int</span> right=length;<span class="hljs-comment">//排好序的头</span><br><span class="hljs-keyword">int</span> index=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(index&lt;right)&#123;<br>    <span class="hljs-keyword">if</span>(arr[index]==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">swap</span>(arr[++left], arr[index]);<br>        index++;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr[index]==<span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-built_in">swap</span>(arr[--right], arr[index]);<span class="hljs-comment">//注意这种情况index还要继续判断，因此不能index++</span><br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        index++;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="7-网格中的最短路径和最短通路"><a href="#7-网格中的最短路径和最短通路" class="headerlink" title="7. 网格中的最短路径和最短通路"></a>7. 网格中的最短路径和最短通路</h3><ul><li>1.一定要分清楚是用dp还是bfs</li><li>2.如果是只能从左上往右下走，那么是dp,否则应该用bfs,同时因为是路径，因此需要一个额外的二维数组判断到当前节点需要的步数，或者另外申明一个node,<br>这个node里面记录到这个节点的步数</li></ul><h3 id="8-缺失的第一个正数：-引申缺失的最大负数（原位hash或者置换）"><a href="#8-缺失的第一个正数：-引申缺失的最大负数（原位hash或者置换）" class="headerlink" title="8. 缺失的第一个正数： /引申缺失的最大负数（原位hash或者置换）"></a><font color="red">8. 缺失的第一个正数： /引申缺失的最大负数（原位hash或者置换）</font></h3><ul><li>方法一：如何在原数组上进行hash,但是保留那个位置的数不变使用- 符号；(负数 0全部变为size)<br>同时如果原来有符号，那么为了避免混淆，将原来为符号的数变为我们不关心的正数</li><li>方法二：使用置换的方式，这种方式一定要注意进入死循环的方式因此在交换的时候判断。nums[nums[i]-1]!=nums[i]</li></ul><h3 id="9-交换数据的位置"><a href="#9-交换数据的位置" class="headerlink" title="9. 交换数据的位置"></a><font color="red">9. 交换数据的位置</font></h3><p>（1）打标记方法： 这种方式理解起来更轻松, 注意这种方式，如果元数据中包含0或者小于0，但是目标数据中是大于0的([1, size])， 那可以将0，负数转为size+1; 否则如果元数据有0， 目标数据也有0的话，打标记是无法解决的</p><ol><li>缺失的第一个正数 （用负号在原地打标记代替hash方法，或者用置换方法，一定要将负数和&gt;size都转为size+1；同时对于target_index和当前index数据相同时，退出循环）</li><li>丢失的数字</li><li>数组中重复的数据</li></ol><p>将当前的数在对应的下标中打上标记，同时为了找到被覆盖数据的元数据，可以使用+n（这种可以找到重复3次， 4次都可以）,或者变为负数的这种做法<br>但是变负数的这种方式，不能适用于含有0的这种情况，因为-0和0是一样的，无法判断是否出现过这个数字</p><p>找到的条件是 nums[i]&gt;=0 退出</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">firstMissingPositive</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>     <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>&amp; num: nums) &#123;<br>         <span class="hljs-keyword">if</span> (num &lt;= <span class="hljs-number">0</span>) &#123;<br>             num = n + <span class="hljs-number">1</span>;<br>         &#125;<br>     &#125;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>         <span class="hljs-keyword">int</span> num = <span class="hljs-built_in">abs</span>(nums[i]);<br>         <span class="hljs-keyword">if</span> (num &lt;= n) &#123;<br>             nums[num - <span class="hljs-number">1</span>] = -<span class="hljs-built_in">abs</span>(nums[num - <span class="hljs-number">1</span>]);<br>         &#125;<br>     &#125;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>         <span class="hljs-keyword">if</span> (nums[i] &gt; <span class="hljs-number">0</span>) &#123;<br>             <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>         &#125;<br>     &#125;<br>     <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;<br> &#125;<br><br></code></pre></td></tr></table></figure><p>（2）置换方法</p><ol><li>缺失的第一个正数 把数据放在对应的位置</li></ol><p>将当前的数放在当前数据对应的下标中</p><p>找到的条件是 nums[i]！=i+1 退出</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">firstMissingPositive</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">while</span> (nums[i] &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[nums[i] - <span class="hljs-number">1</span>] != nums[i]) &#123;<br>            <span class="hljs-built_in">swap</span>(nums[nums[i] - <span class="hljs-number">1</span>], nums[i]); <span class="hljs-comment">//要和它交换的数不能等于它本身</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] != i + <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p> (3) 二分算法，查找小于mid的数据量，如果是大于mid的话说明重复的数小于等于mid,因此r=mid-1 and ans=mid(或者r=mid), 否则l=mid+1<br> (4) 数组版快慢指针，index-&gt;nums[index] 那么有一个数会被指向两次，那么存在环</p><ul><li>映射找环法， 找冗余的数据，其实就是找环路的起点</li><li><a href="https://segmentfault.com/a/1190000003817671">https://segmentfault.com/a/1190000003817671</a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>   <span class="hljs-keyword">public</span>:<br>       <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findDuplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>           <span class="hljs-keyword">int</span> slow = <span class="hljs-number">0</span>, fast = <span class="hljs-number">0</span>;<br>           <span class="hljs-keyword">do</span> &#123;<br>               slow = nums[slow];<br>               fast = nums[nums[fast]];<br>           &#125; <span class="hljs-keyword">while</span> (slow != fast);<br>           slow = <span class="hljs-number">0</span>;<br>           <span class="hljs-keyword">while</span> (slow != fast) &#123;<br>               slow = nums[slow];<br>               fast = nums[fast];<br>           &#125;<br>           <span class="hljs-keyword">return</span> slow;<br>       &#125;<br>   &#125;;<br></code></pre></td></tr></table></figure></li></ul><h3 id="10-lc-440和lc386-按照字典序排序，和按照字典序排序的第k个数字"><a href="#10-lc-440和lc386-按照字典序排序，和按照字典序排序的第k个数字" class="headerlink" title="10. lc 440和lc386 按照字典序排序，和按照字典序排序的第k个数字"></a><font color="blue">10. lc 440和lc386 按照字典序排序，和按照字典序排序的第k个数字</font></h3><p>我们输入两个值n和k，n表示我们有从1到n个整数，然后将这些整数都字符串化之后按字典排序，找出其中第K大的。例如:n=15,k=5.那么1-15字符串化之后排序如下:1,10,11,12,13,14,15,2,3,4,5,6,7,8,9。其中第5大的就为13。<br>实际上多叉树从到右进行计数</p><p>每次求解二叉树相邻两个节点之间(base 和base+1)包含的数据，如果k&gt;num那么直接更新k 然后当前数+1(base=base+1), 否则递归求里面的数据(base=base*10)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">comp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> _a,  <span class="hljs-keyword">int</span> n)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> b=_a+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a=_a;<br>        <span class="hljs-keyword">while</span>(a&lt;=n)&#123;<br>            res+=(<span class="hljs-keyword">int</span>)<span class="hljs-built_in">min</span>((<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)n+<span class="hljs-number">1</span>, b)-a;<br>            a=a*<span class="hljs-number">10</span>;<br>            b=b*<span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-comment">// cout&lt;&lt;res&lt;&lt;endl;</span><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findKthNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> a=<span class="hljs-number">1</span>, b=a+<span class="hljs-number">1</span>;<br>        k--;<br>        <span class="hljs-keyword">while</span>(k&gt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">int</span> num= <span class="hljs-built_in">comp</span>(a, n);<br>            <span class="hljs-keyword">if</span>(num&lt;=k)&#123;<br>                k-=num;<br>                a=a+<span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                k--;<br>                a=a*<span class="hljs-number">10</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="11-字符串相乘"><a href="#11-字符串相乘" class="headerlink" title="11. 字符串相乘"></a><font color="red">11. 字符串相乘</font></h3><ul><li><p>模板代码：</p>  <figure class="highlight c++"><figcaption><span>关键代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(size1+size2+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-built_in">reverse</span>(num1.<span class="hljs-built_in">begin</span>(), num1.<span class="hljs-built_in">end</span>());<br><span class="hljs-built_in">reverse</span>(num2.<span class="hljs-built_in">begin</span>(), num2.<span class="hljs-built_in">end</span>());<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size1;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;size2;j++)&#123;<br>        res[i+j]=res[i+j]+(num1[i]-<span class="hljs-string">&#x27;0&#x27;</span>)*(num2[j]-<span class="hljs-string">&#x27;0&#x27;</span>);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>知识点：字符ASCII码和数字的相互转换<br>  char a=’0’+81;<br>  char b=a-81;<br>  int c=a-‘0’;<br>  cout&lt;&lt;a&lt;&lt; “ “&lt;&lt;b&lt;&lt;” “&lt;&lt;c&lt;&lt;endl;<br>  注意c最终打印的结果为-175, 而不是81！！！！ 所以在初始化字符串相乘的数组只能用int类型不能用string类型<br>  char m=’A’+1;//打印输出’B’</p></li><li><p>初始化一个m+n的数组（注意一定要为int类型，不能为string类型），然后循环计算每一位应该的值，最后从低位到高位进行进位更新</p></li><li><p>易错点：str1和str2需要翻转，之后的结果需要去前缀零以及翻转回来<br>如果不翻转，那么nums1[i]和nums2[j]对应nums[i+j+1]的数组</p></li></ul><h3 id="12-分数到小数，模拟除法"><a href="#12-分数到小数，模拟除法" class="headerlink" title="12. 分数到小数，模拟除法"></a>12. 分数到小数，模拟除法</h3><p>使用hash记录余数到下标的隐射，如果出现重复余数，说明出现了重复的小数循环体<br>注意易错点：</p><ul><li>1.可能存在负数，但是不能直接对负数取反（因为可能为INT_MIN），需要转为long型<br>  判断结果为负数使用异或<br>  if (numeratorLong &lt; 0 ^ denominatorLong &lt; 0) {//异号为负数<pre><code class="hljs">  sb.append(&#39;-&#39;);</code></pre>  }</li></ul><h3 id="13-lc670-最大交换"><a href="#13-lc670-最大交换" class="headerlink" title="13. lc670. 最大交换"></a>13. lc670. 最大交换</h3><ul><li>一个数字交换一次，如何使得交换后的数最大 输入: 2736 输出: 7236</li><li>先遍历字符串求得每个数最靠后的下标（因为小于当前的数，应该换到越靠后面越好）</li><li>然后从左遍历每个数的时候，遍历 ‘9’到s[i]-‘0’看是否有比当前数大的数，而且在这个数后面，如果有，那么交换，然后退出</li><li>因为第二重循环只是从9到s[i]-‘0’， 因此总的时间复杂度还是O(N)</li></ul><h2 id="并查集专题"><a href="#并查集专题" class="headerlink" title="并查集专题"></a>并查集专题</h2><h3 id="1-除法求值"><a href="#1-除法求值" class="headerlink" title="1.除法求值"></a>1.除法求值</h3><p>并查集的变形，除了要判断各个数字是否连通，还需添加一个数组记录节点之间的权重 weight(当前节点到其父节点的权重); 而且注意如何a/b那么应该是a的父亲节点是b, a指向b的权重为a/b, 反过来的话不对 <strong>一定要注意这个权重的更新，应该为当前的权重 * 他原来父亲的现在的权重</strong></p><p>易错点：</p><ul><li>在进行节点merge的时候一定要注意权重的更新，weight代表的是两个节点之间的权重，而不是一个节点到根节点的权重</li><li>find的时候返回的是father[a]而不是a !!!!!!</li><li>fa!=fb的时候应该是father[fa]=fb, 与两个孩子节点a b无关</li><li>递归寻找father的时候，应该使用father[index]作为函数的参数而不是index(会陷入无限死循环中)</li><li>在并查集的时候，可以直接使用string作为头节点，不一定要转为int类型  unordered_map&lt;string, string&gt; father; unordered_map&lt;string, int&gt;num<br>例题：面试题 17.07. 婴儿名字</li><li>可以使用string的find函数来对字符串进行分割（带括号或者，形式的分割）</li></ul><p>并查集模板：具体可见vscode里面的代码，两个模板 带size和不带size的情况</p><h3 id="例题2：lc947-移除最多的同行或同列石头"><a href="#例题2：lc947-移除最多的同行或同列石头" class="headerlink" title="例题2：lc947. 移除最多的同行或同列石头"></a>例题2：lc947. 移除最多的同行或同列石头</h3><ul><li>这个是二维坐标的，横坐标或者纵坐标相同都在一个并查集，因此需要将横纵坐标放在两个范围中，防止重叠；因为x, y在[0,1000]之间，一次你可以将横坐标放在+10001, 使得x y范围错开</li></ul><h3 id="剑指-Offer-II-111-计算除法"><a href="#剑指-Offer-II-111-计算除法" class="headerlink" title="剑指 Offer II 111. 计算除法"></a>剑指 Offer II 111. 计算除法</h3><ul><li>使用并查集或者BFS/DFS</li><li>并查集注意分母为儿子（大），分子为父亲</li><li>BFS的时候正向，反向都要连接</li></ul><h3 id="lc685-冗余连接-冗余连接II"><a href="#lc685-冗余连接-冗余连接II" class="headerlink" title="lc685. 冗余连接 /冗余连接II"></a>lc685. 冗余连接 /冗余连接II</h3><ul><li>有向图的这种情况，并不是删除环的任意一条边就可以<br>  需要先判断是否有度为2，如果有，然后删除度为2的两条边中的一条，如果没有环，说明就是树。<br>  如果没有度为2，那么就是删除环的最后一条边。（或者说删除环任一一边就行，但是答案要求最后一边）</li><li>如果出现没有环，而且没有度为2，那么一定就是树</li></ul><h2 id="分类讨论题"><a href="#分类讨论题" class="headerlink" title="分类讨论题"></a>分类讨论题</h2><ol><li> K 次串联后最大子数组之和<br>分类分析<br>k=1;<br>k=2;<br>k&gt;2 如果array之和小于0，那么结果就是k=2情况，否则k=2+(k-2)*sum(one array)</li></ol><h2 id="分治算法专题-分而治之"><a href="#分治算法专题-分而治之" class="headerlink" title="分治算法专题(分而治之)"></a>分治算法专题(分而治之)</h2><h3 id="1-IP地址验证合理性"><a href="#1-IP地址验证合理性" class="headerlink" title="1.IP地址验证合理性"></a>1.IP地址验证合理性</h3><ol><li>对于 IPv4 地址，通过界定符 . 将地址分为四块-&gt;a；对于 IPv6 地址，通过界定符 : 将地址分为八块-&gt;b。（count(.)==4/count(:)==6/neither）<br> a. 对于 IPv4 地址的每一块，检查它们是否在 0 - 255 内，且没有前置零。<br> b. 对于 IPv6 地址的每一块，检查其长度是否为 1 - 4 位的十六进制数。</li></ol><h3 id="2-删除注释"><a href="#2-删除注释" class="headerlink" title="2. 删除注释"></a>2. 删除注释</h3><p>分情况判断+用一个状态表明现在是否在注释内，主要是用于/* <em>/情况<br>（1）题目中没有考虑/</em> 不属于注释的这种情况，因此每次遇到/* &amp;&amp;block= False 表示开始块注释，每次遇到*/&amp;&amp;block=True,表示结束块注释<br>（2）遇到//直接结束，因为//后面都是注释，而且不改变状态</p><h3 id="3-超级次方"><a href="#3-超级次方" class="headerlink" title="3. 超级次方"></a>3. 超级次方</h3><p> 也类似观察规律的题目，就是在定义一种新的运算的时候，将它化简为熟知的运算。同时运用规律“对乘法的结果求模，等价于先对每个因子都求模，然后对因子相乘的结果再求模”<br>不能直接使用系统自带的pow,只能自己实现pow因为，在求乘方过程随时会出现溢出，所以要为每一个中间结果取模</p><h3 id="4-第K个语法符号"><a href="#4-第K个语法符号" class="headerlink" title="4. 第K个语法符号"></a>4. 第K个语法符号</h3><p>找第n个的数的第k个字符是什么，转为找第n-1个数的对应f(k)位上面的数据（左半边不取反，右半边取反）<br>易错点在：一个数的时候会add两次如何解决, 那么就在返回的时候，只有一个数的时候，说明出现了[[num, []]]的这种情况，那么直接return result.getInterger, 否则直接返回result</p><h3 id="corner-case的例子"><a href="#corner-case的例子" class="headerlink" title="corner case的例子"></a>corner case的例子</h3><p>lc1363: 形成3的最大倍数<br>思路： 判断sum之和</p><ol><li>%3==0， 那么返回res</li><li>%3==1, 如果数组中有%3==1的数字那么直接删除； 否则删除两个%3==2的数字</li><li>%3==2, 如果数组中有%3==2的数字那么直接删除； 否则删除两个%3==1的数字</li><li>易错点：结果可能包含前缀0，因此需要将前缀0去掉（000001/000000）；结果也可能只是“”， 那么直接返回“”， 而不是0</li></ol><h3 id="lc旋转链表"><a href="#lc旋转链表" class="headerlink" title="lc旋转链表"></a>lc旋转链表</h3><ol><li>求size</li><li>k=k%size; k=k-size,表示第k个节点是现在的头结点（k-1是新链表尾节点）</li><li>将头节点前面一个节点（k-1）的next置为null, 同时将当前链表的最后一个节点next指向头节点（利用在第二步变成环，可以减少找尾结点这一步）<br><font color="red">链表类似题一定要判断head是否为null, size是否为0或者1这种情况 </font><br>快慢指针删除链表的重复元素的时候，一定要记得将慢指针的next设置为null</li></ol><p>lc,加1<br>在vector数组上+1</p><ul><li>一定要注意最后carry不为0的情况，需要在最开头插入一个数 digits.insert(digits.begin(),carry);</li><li>应该使用tmp记录当前位的和。int tmp=digits[i]+carry;</li></ul><h3 id="lc68-文本左右对齐"><a href="#lc68-文本左右对齐" class="headerlink" title="lc68. 文本左右对齐"></a>lc68. 文本左右对齐</h3><p>字符串相关的模拟题，主要是分情况讨论<br>一个单词/最后一行/其他情况（spacecount, extraspace）</p><p>其他corner case: </p><ul><li><ol><li>乘法可能会超出范围，可能需要使用long long型 （数据范围一定要注意是用long long还是int）</li></ol></li><li><ol start="2"><li>在进行寻找mid的时候left+(right-left)/2</li></ol></li><li><ol start="3"><li>一定要注意&lt; &lt;=，以及边界情况的例子，在微软（矩阵旋转）和字节（和滑动窗口的最大值）最开始取[0,k-1]以及压入一个元素 已经跌过两次坑了</li></ol></li><li>lc220. 存在重复元素 III，一定要注意nums[i]-t可能超出整数的范围，因此需要使用long 或者longlong对nums进行强制转换</li></ul><h2 id="模拟类型题"><a href="#模拟类型题" class="headerlink" title="模拟类型题"></a>模拟类型题</h2><h3 id="1-矩阵旋转90"><a href="#1-矩阵旋转90" class="headerlink" title="1. 矩阵旋转90"></a>1. 矩阵旋转90</h3><h3 id="2-螺旋矩阵"><a href="#2-螺旋矩阵" class="headerlink" title="2. 螺旋矩阵"></a>2. 螺旋矩阵</h3><p>使用分成4段（后面两段需要判断 left&lt; right&amp;&amp; upper&lt; down才可以），或者坐标移动+vis数组</p><h3 id="3-倒酒杯"><a href="#3-倒酒杯" class="headerlink" title="3. 倒酒杯"></a>3. 倒酒杯</h3><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>二维差分数组常用在对数组中的某一个块的区域进行操作， 比如这道题的贴邮票， 对整块数组+1; 比如对0-k这段距离的数据都进行翻转</p></li><li><p>一个数比较大，但是它取模之后的结果不一定大,两种解决方案</p><ol><li>保存long long的结果</li><li>sum为定值的时候，一个数越接近sum的一半，乘积之后的结果越大</li></ol> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(cur*<span class="hljs-number">2</span> - sum) &lt; <span class="hljs-built_in">abs</span>(best*<span class="hljs-number">2</span> - sum)) &#123;<br>    best = cur;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>负数和正数的向上向下取整不同<br>Math.floor(2.6);    //2.0   floor地板 水平数轴向右取整<br>Math.floor(-2.6);   //-3.0   floor地板 水平数轴向右取整</p></li><li><p>固定数字price保留2我小数，并以字符串形式返回<br>ostringstream oss;<br>oss &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; price;<br>oss.str();</p></li><li><p>原位标记针对[0~n-1]可以改为 n或者-1，而不是负数来进行标记</p></li><li><p>循环队列或者优先队列相关问题， 如果队列总共能容纳的元素是k,那么需要开k+1大小，初始化front=end=0, 队列满表示 front=(end+1)%size</p></li><li><p> 用char* data 实现string<br><a href="https://www.geeksforgeeks.org/how-to-create-a-custom-string-class-in-c-with-basic-functionalities/">How to create a custom String class in C++ with basic functionalities - GeeksforGeeks</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
            <tag> 数组 </tag>
            
            <tag> 模拟 </tag>
            
            <tag> 分而治之 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双指针</title>
      <link href="/2021/11/13/leetcode/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
      <url>/2021/11/13/leetcode/%E5%8F%8C%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h2 id="双指针-字符串"><a href="#双指针-字符串" class="headerlink" title="双指针+字符串"></a>双指针+字符串</h2><h3 id="1-反转字符串s中左闭又闭的区间-start-end"><a href="#1-反转字符串s中左闭又闭的区间-start-end" class="headerlink" title="1. 反转字符串s中左闭又闭的区间[start, end]"></a>1. 反转字符串s中左闭又闭的区间[start, end]</h3><p>void reverse(string&amp; s, int start, int end) {<br>    for (int i = start, j = end; i &lt; j; i++, j–) {<br>        swap(s[i], s[j]);<br>    }<br>}</p><h3 id="2-替换后的最长重复字符"><a href="#2-替换后的最长重复字符" class="headerlink" title=" 2. 替换后的最长重复字符"></a><font color="red"> 2. 替换后的最长重复字符</font></h3><ul><li>经典滑动窗口题目，但是和其他滑动窗口不一样；主要是由于窗口内最多的字符是未知的，因为窗口即使收缩，长度也不会变小</li><li>如果k=0就是求连续的最长重复字符， 注意使用maxn保存滑动窗口内相同字母出现次数的 历史 最大值(注意不是当前最大值，而是历史最大值)， 所以窗口的长度只会增加或者保持不变不会减少；</li></ul><p>注意不是找当前窗口重复字符的最长，而是历史最长！！！</p><h3 id="3-字符串的排列"><a href="#3-字符串的排列" class="headerlink" title="3. 字符串的排列"></a>3. 字符串的排列</h3><p>滑动窗口和双指针都可以，注意这道题只需要记录needle数组就可以了，不需要记录count<br>因为这道题不是找到包含目标子串的子串，而是一定要包含子串，而且不多出额外字符（目标子串的任意排列）<br>所以这道题也可以用固定长度的窗口</p><p>所以只需要needle, needle小于0，就可以收缩窗口了。但是如果是包含关系，那么needle&lt;0还不能收缩窗口，之后count==0才能收缩（题意应该为：包含目标子串的最短字符串）</p><h2 id="双指针与数组-hash"><a href="#双指针与数组-hash" class="headerlink" title="双指针与数组/hash"></a>双指针与数组/hash</h2><h3 id="1-N数之和"><a href="#1-N数之和" class="headerlink" title="1. N数之和"></a>1. N数之和</h3><p>两数之和<br>三数之和<br>四数之和</p><p>lc16, 最近三数之和，思路和三数之和差不多==target的时候直接返回<br>lc259. 3Sum Smaller 三数之和较小值， 找到nums[i] + nums[j] + nums[k] &lt; target. 数量</p><ul><li>仍然使用三数之和的双指针方法，只是在找到&lt; target的时候 res+=right-left; left++;(因为小于right三数之后都满足条件)；<br>否则right–</li></ul><h3 id="2-有效三角形的个数"><a href="#2-有效三角形的个数" class="headerlink" title="2. 有效三角形的个数"></a>2. 有效三角形的个数</h3><ul><li>排序后使用二分查找</li><li>或者使用双指针， 类似于三数之和，只不过这道题求的是两数之和大于第三数， 而不是两数之和等于第三数，因此也不需要hash</li></ul><h3 id="3-01交换（把1全部换到后面）"><a href="#3-01交换（把1全部换到后面）" class="headerlink" title="3. 01交换（把1全部换到后面）"></a>3. 01交换（把1全部换到后面）</h3><p>我的思路：所有1全部往右移动，1的顺序不变<br>答案：右边第一个0，左边第一个1，如果左边_index&lt;右边_index，那么res+=right-left+1(1的顺序是可以打乱的)</p><h3 id="4-lc80-删除有序数组中的重复项-II"><a href="#4-lc80-删除有序数组中的重复项-II" class="headerlink" title="4. lc80. 删除有序数组中的重复项 II"></a>4. lc80. 删除有序数组中的重复项 II</h3><p>快慢指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">///k次</span><br><span class="hljs-keyword">int</span> u = <span class="hljs-number">0</span>; <br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x : nums) &#123;<br>    <span class="hljs-keyword">if</span> (u &lt; k || nums[u - k] != x) nums[u++] = x; <span class="hljs-comment">//保证每个元素最多重复两次，同理可以类推到k次</span><br>&#125;<br><span class="hljs-keyword">return</span> u;<br><br></code></pre></td></tr></table></figure><h3 id="5-lc202-快乐数"><a href="#5-lc202-快乐数" class="headerlink" title="5. lc202. 快乐数"></a>5. lc202. 快乐数</h3><ul><li>快慢指针不一定用在链表中判断是否有环，还可以用在数组中，以及用在替换hash， 查看这个数是否之前被访问过<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> slow = n, fast = n;<br><span class="hljs-keyword">do</span>&#123;<br>    slow = <span class="hljs-built_in">bitSquareSum</span>(slow);<br>    fast = <span class="hljs-built_in">bitSquareSum</span>(fast);<br>    fast = <span class="hljs-built_in">bitSquareSum</span>(fast);<br>&#125;<span class="hljs-keyword">while</span>(slow != fast);<br></code></pre></td></tr></table></figure></li></ul><h2 id="其他（与栈有关）"><a href="#其他（与栈有关）" class="headerlink" title="其他（与栈有关）"></a>其他（与栈有关）</h2><h3 id="1-盛最多水的容器"><a href="#1-盛最多水的容器" class="headerlink" title="1. 盛最多水的容器"></a><font color="red">1. 盛最多水的容器</font></h3><p>因为水的容量=左右较小值<em>len;那么移动较大值是不会增加容量的大小的<br>双指针的问题，常用于排序数组中找target数，特征就是知道当前的值，能够容易的判断，下一个是移动左边还是右边指针<br>注意这个是容积因此是长</em>宽，<br>区分：对于和大于0的最长这道题，使用先遍历一次降序，然后逆序判断，这种方法是求长度最长，不是容积最大</p><h3 id="2-通过删除字母匹配到字典里最长单词"><a href="#2-通过删除字母匹配到字典里最长单词" class="headerlink" title="2. 通过删除字母匹配到字典里最长单词"></a><font color="blue">2. 通过删除字母匹配到字典里最长单词</font></h3><p>双指针来查找一个字符串是否为另一个字符串的子序列。<br>同时这道题可以使用序列自动机来避免重复的字符查找。dp[i][j]  就是存储 s字符串从大于等于i开始的 第一个等于j的下标，如果s[i]==j那么dp[i][j]=i, 否则，dp[i][j]=dp[i+1][j]， 应该从后向前计算dp数组</p><h2 id="双指针与枚举子集"><a href="#双指针与枚举子集" class="headerlink" title="双指针与枚举子集"></a>双指针与枚举子集</h2><h3 id="1-乘积小于K的数组"><a href="#1-乘积小于K的数组" class="headerlink" title="1. 乘积小于K的数组"></a>1. 乘积小于K的数组</h3><p>找到符合条件的子集的个数<br>模板代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> left=<span class="hljs-number">0</span>, right=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> cur=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span>(k==<span class="hljs-number">0</span>||k==<span class="hljs-number">1</span>)&#123;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-keyword">while</span>(right&lt;size)&#123;<br>    cur=cur*nums[right];<br>    <span class="hljs-keyword">if</span>(cur&lt;k)&#123;<br>        res+=right-left+<span class="hljs-number">1</span>; <span class="hljs-comment">//注意需要+1</span><br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">while</span>(cur&gt;=k)&#123;<br>            cur/=nums[left];<br>            left++;<br>        &#125;<br>        res+=right-left+<span class="hljs-number">1</span>;<br>        <br>    &#125;<br>    right++;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br></code></pre></td></tr></table></figure><p>另外一种求所有子集的方式是使用统计计算，比如有窗口有cnt个数据，那么子集个数为cnt*(cnt+1)/2</p><h3 id="2-lc349-数组的交集（easy）"><a href="#2-lc349-数组的交集（easy）" class="headerlink" title="2.lc349.数组的交集（easy）"></a>2.lc349.数组的交集（easy）</h3><p>排序之后+双指针，相等时候判断加不加这个数</p><h2 id="双指针和链表"><a href="#双指针和链表" class="headerlink" title="双指针和链表"></a>双指针和链表</h2><h3 id="lc86-分隔链表"><a href="#lc86-分隔链表" class="headerlink" title="lc86. 分隔链表"></a>lc86. 分隔链表</h3><ul><li>将小于target放在大于等于target的前面，同时小于和大于target的数相对顺序不能变</li><li>将链表分为smallList 和largeList (一个链表拆分成两个链表)， 同时为了避免空的讨论，使用dummy节点</li><li>易错点， largeList的末尾节点-&gt;next一定要赋值为NULL</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>双指针通常和滑动窗口， dp， hash共同来解决 字符串/数组等问题</p></li><li><p>左右移动的双指针通常满足在移动一边的指针的时候拥有一个递增或者递减的规律</p></li><li><p>两个有序数组中任意选一个数出来，之间的最短距离是多少; 较小的一个向前移动</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">while</span> (i &lt; index1.length &amp;&amp; j &lt; index2.length) &#123;<br>    <span class="hljs-keyword">const</span> idx1 = index1[i], idx2 = index2[j];<br>    <span class="hljs-keyword">if</span> (idx1 &gt; idx2) &#123;<br>      j++;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (idx2 &gt; idx1) &#123;<br>      i++;<br>    &#125;<br>    min = Math.<span class="hljs-built_in">min</span>(min, Math.<span class="hljs-built_in">abs</span>(idx1 - idx2));<br>  &#125;<br></code></pre></td></tr></table></figure></li><li><p>当以字符串作为hash的key时候，可以使用字符数组 string s(26, ‘0’); 也可以对字符串进行排序后作为key</p></li><li><p>翻转交换类型的题目使用双指针，比如交换一个字符串里面全部的元音字母</p></li><li><p>快慢指针不一定用在链表中判断是否有环，还可以用在数组中，以及用在替换hash， 查看这个数是否之前被访问过；还可以用在去除冗余（类似于双指针）（lc442 数组中重复的数据/ 80. 删除有序数组中的重复项 II）<br>但是lc442用原地hash或者置换到应该在的位置更好理解，使用快慢指针不好理解</p></li></ol><p>找到环路起点的标准模板代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> slow = <span class="hljs-number">0</span>, fast = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">do</span> &#123;<br>  slow = nums[slow];<br>  fast = nums[nums[fast]];<br>&#125; <span class="hljs-keyword">while</span> (slow != fast);<br>slow = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (slow != fast) &#123;<br>  slow = nums[slow];<br>  fast = nums[fast];<br>&#125;<br><span class="hljs-keyword">return</span> slow;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="/2021/11/13/leetcode/%E6%8E%92%E5%BA%8F%E9%A2%98/"/>
      <url>/2021/11/13/leetcode/%E6%8E%92%E5%BA%8F%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<img src="/2021/11/13/leetcode/%E6%8E%92%E5%BA%8F%E9%A2%98/image-summary.png" class title="image-20220821153753481"><p>快选希堆 不稳定<br>基插归冒 稳定</p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h3 id="堆排序的基本思路"><a href="#堆排序的基本思路" class="headerlink" title="堆排序的基本思路"></a>堆排序的基本思路</h3><p><font color="red">亚马逊原题，一定要会写代码</font><br>（每个内部节点，和左右节点对比，往上浮；之后根分别与最后，倒数第二个交换往下沉）<br>a.先所有的内部节点的每个，从下到上进行往上浮的操作heap_build<br>b.然后根节点和最后一个节点交换，然后从根节点向下沉（0,n-1），然后根节点和倒数第二个节点交换，然后往下沉(0,n-2)然后重复上述的过程</p><p>也就是先build最大堆，然后逐渐交换，然后重复build</p><p>优先队列默认是从大到小进行排序；multiset 基于红黑树实现，默认是从小到大进行排序<br>priority&lt;int, vector<int>, greater<int> &gt; q;//最小堆<br>multiset&lt;int, greater<int> &gt; //最大堆</int></int></int></p><p>使用归并排序可以求逆序对的数量以及“计算数组的小和”问题:<br>特征，如果一个数组中两个元素，nums[i]&lt;nums[j]或者nums[i]&gt;nums[j]再执行某个操作，而且数组元素之间的连续性等没有其他要求，那么使用归并排序计算</p><p>merge函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= right)<br>    &#123;<br>        res += arr[p1] &lt;= arr[p2] ? arr[p1]*(right-p2+<span class="hljs-number">1</span>) : <span class="hljs-number">0</span>;<br>        help[i++] = arr[p1] &lt;= arr[p2] ? arr[p1++] : arr[p2++];<br>    &#125;<br>    <span class="hljs-keyword">while</span> (p1 &lt;= mid) help[i++] = arr[p1++];<br>    <span class="hljs-keyword">while</span> (p2 &lt;= right) help[i++] = arr[p2++];<br></code></pre></td></tr></table></figure><h3 id="相关例题"><a href="#相关例题" class="headerlink" title="相关例题"></a>相关例题</h3><h3 id="1-打印N个数组的最大TopK-topk类似题使用堆"><a href="#1-打印N个数组的最大TopK-topk类似题使用堆" class="headerlink" title="1.打印N个数组的最大TopK (topk类似题使用堆)"></a>1.打印N个数组的最大TopK (topk类似题使用堆)</h3><p>用N个最后的元素建立一个最大堆，然后移去堆顶元素，然后用移去元素的下一个元素放在堆顶调整堆，重复上面的过程；<br>如果被移去元素数组中没有下一个元素，那么用堆的最后一个元素移到堆顶，让堆的size-1</p><p>注意堆排序都是下沉的过程，但是如果向堆中一个一个插入元素，是插入到最后一个位置，heapsize++, 然后上浮过程<br>同时也可以先全部放入数组中，然后从内部节点倒叙下沉</p><p>*****在进行代码编写的时候，可以不直接实现堆，而是用STL的priority_queue（默认最大堆） ******</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">int</span> row;<br>    <span class="hljs-keyword">int</span> val; <span class="hljs-comment">//因为是pop_back所以不用记录下标</span><br>    <span class="hljs-built_in">node</span>(<span class="hljs-keyword">int</span> _r,<span class="hljs-keyword">int</span> _v)<br>    &#123;<br>        row=_r;<br>        val=_v;<br>    &#125;<br>    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-keyword">const</span> node&amp; b)<span class="hljs-keyword">const</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;val&lt;b.val;<br>    &#125;<br>   <br>&#125;;<br>priority_queue&lt;node,vector&lt;node&gt;&gt; heap；<br><br>因此这道题的解答方案<br><span class="hljs-comment">//首先初始化 n个末尾各自的最大元素入堆</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(arr[i].<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">continue</span>;<br>        heap.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">node</span>(i,arr[i][arr[i].<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>]));<br>        arr[i].<span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">//最后一个元素入堆</span><br>    &#125;<br>    <span class="hljs-comment">//开始从末尾遍历</span><br>   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)  <span class="hljs-comment">//从堆中选举k个最大的元素</span><br>   &#123;<br>       cout&lt;&lt;heap.<span class="hljs-built_in">top</span>().val&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<span class="hljs-comment">//打印出最大的那个元素</span><br>       <span class="hljs-keyword">int</span> row=heap.<span class="hljs-built_in">top</span>().row;<span class="hljs-comment">//那个元素所在行</span><br>       heap.<span class="hljs-built_in">pop</span>();<br>       <span class="hljs-keyword">if</span>(arr[row].<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">0</span>) <span class="hljs-comment">//最大的那个元素弹出后 用所在行的下一个元素顶上（因为第二大元素一定在已有的元素 + 下一个顶上的元素 中产生）</span><br>       &#123;<br>           heap.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">node</span>(row,arr[row][arr[row].<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>]));<span class="hljs-comment">//下一个接替的node</span><br>           arr[row].<span class="hljs-built_in">pop_back</span>();<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p>PS:类似的一个题：两个有序数组的整体中位数（或者第K位数）<br>1.使用归并排序，但是只需要记录一个pre cur O(n/2)<br>2.使用类似二分的删除的方法，先求出中位数的位置k<br>然后比较两个数组nums1[k/2] nums2[k/2]，较小的那个数组，直接跳过k/2个数 index_next=before_index + k/2</p><h3 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h3><p>priority_queue的自定义排序函数：<br><a href="https://www.cnblogs.com/shona/p/12163381.html">C++ | priority_queue的用法（含自定义排序方式） - 山竹小果 - 博客园</a> 记住priority_queue排序大小和排序函数都是和正常反着的<br>建议使用struct cmp方式，重载operator &lt; 会报错，如果是在solution 类中重载的话</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cmp</span>&#123;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">const</span> node &amp;a, <span class="hljs-keyword">const</span> node &amp;b)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> a.val&gt;b.val; <span class="hljs-comment">//从小到大排序</span><br>    &#125;<br>&#125;;<span class="hljs-comment">//一定要注意结构体后面添加;</span><br></code></pre></td></tr></table></figure><h3 id="2-查找和最小的K对数字，使用最大堆，以及每个数组最大循环k次"><a href="#2-查找和最小的K对数字，使用最大堆，以及每个数组最大循环k次" class="headerlink" title="2. 查找和最小的K对数字，使用最大堆，以及每个数组最大循环k次"></a>2. 查找和最小的K对数字，使用最大堆，以及每个数组最大循环k次</h3><h2 id="基数排序和桶排序"><a href="#基数排序和桶排序" class="headerlink" title="基数排序和桶排序"></a>基数排序和桶排序</h2><p>时间复杂度为O(n)的排序算法：基数排序和桶排序<br>例题：最大间距问题<br>桶排序：需要确定桶的数量，然后遍历每一个数，求当前数应该放的桶的位置，有点时候并不一定要明确每个桶里面有哪些数据，只需要知道桶<br>里面是否有数据（bucket[i]），以及每个桶里面的最大最小值(max_bucket[i], min_bucket[i])，那么就不需要用二维数组记录每个桶里面的具体数据（如例题），然后遍历桶里面的元素，用当前桶的最小值，减去上一个有数据的桶的最大值</p><h3 id="基数排序的主要思想："><a href="#基数排序的主要思想：" class="headerlink" title="基数排序的主要思想："></a>基数排序的主要思想：</h3><p>1.每次排序都是从最低位到最高位进行排序，因此求最大数的位数，作为基数排序循环的次数<br>2.在每次循环，求当前基数位的count<br>3.将count进行累加，求在整个count数组中排列的具体位置<br>4.从大到小重复计算count数组的过程，将data数据排好后放入tmp数组 count[k]–<br>5.将tmp数组赋值为data数组 基数*10，重复上面的步骤</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxbit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data[], <span class="hljs-keyword">int</span> n)</span> <span class="hljs-comment">//辅助函数，求数据的最大位数</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> maxData = data[<span class="hljs-number">0</span>];              <span class="hljs-comment">///&lt; 最大数</span><br>    <span class="hljs-comment">/// 先求出最大数，再求其位数，这样有原先依次每个数判断其位数，稍微优化点。</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (maxData &lt; data[i])<br>            maxData = data[i];<br>    &#125;<br>    <span class="hljs-keyword">int</span> d = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> p = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">while</span> (maxData &gt;= p)<br>    &#123;<br>        <span class="hljs-comment">//p *= 10; // Maybe overflow</span><br>        maxData /= <span class="hljs-number">10</span>;<br>        ++d;<br>    &#125;<br>    <span class="hljs-keyword">return</span> d;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">radixsort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data[], <span class="hljs-keyword">int</span> n)</span> <span class="hljs-comment">//基数排序</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> d = <span class="hljs-built_in">maxbit</span>(data, n);<br>    <span class="hljs-keyword">int</span> *tmp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>    <span class="hljs-keyword">int</span> *count = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>]; <span class="hljs-comment">//计数器</span><br>    <span class="hljs-keyword">int</span> i, j, k;<br>    <span class="hljs-keyword">int</span> radix = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i &lt;= d; i++) <span class="hljs-comment">//进行d次排序</span><br>    &#123;<br>        <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++)<br>            count[j] = <span class="hljs-number">0</span>; <span class="hljs-comment">//每次分配前清空计数器</span><br>        <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>        &#123;<br>            k = (data[j] / radix) % <span class="hljs-number">10</span>; <span class="hljs-comment">//统计每个桶中的记录数</span><br>            count[k]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(j = <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">10</span>; j++)<br>            count[j] = count[j - <span class="hljs-number">1</span>] + count[j]; <span class="hljs-comment">//将tmp中的位置依次分配给每个桶</span><br>        <span class="hljs-keyword">for</span>(j = n - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) <span class="hljs-comment">//将所有桶中记录依次收集到tmp中</span><br>        &#123;<br>            k = (data[j] / radix) % <span class="hljs-number">10</span>;<br>            tmp[count[k] - <span class="hljs-number">1</span>] = data[j];<br>            count[k]--;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; n; j++) <span class="hljs-comment">//将临时数组的内容复制到data中</span><br>            data[j] = tmp[j];<br>        radix = radix * <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">delete</span> []tmp;<br>    <span class="hljs-keyword">delete</span> []count;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="乱序数据使用多进程进行排序"><a href="#乱序数据使用多进程进行排序" class="headerlink" title="乱序数据使用多进程进行排序"></a>乱序数据使用多进程进行排序</h3><p>每个进程进行各种的快速排序，然后将所有进程排序好的结果进行两两归并<br>使用pthread_t 和pthread_create</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> <span class="hljs-title">s</span>[10];</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)<br>    &#123;<br>        s[i].id = i;<br>        s[i].l = i*<span class="hljs-number">10</span>;<br>        s[i].r = i*<span class="hljs-number">10</span>+<span class="hljs-number">9</span>;<br>    &#125;<br> <br>    <span class="hljs-keyword">pthread_t</span> t[<span class="hljs-number">10</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)<br>        <span class="hljs-built_in">pthread_create</span>(&amp;t[i],<span class="hljs-literal">NULL</span>,__sort,(<span class="hljs-keyword">void</span> *)&amp;s[i]);<br> <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)<br>        <span class="hljs-built_in">pthread_join</span>(t[i],<span class="hljs-literal">NULL</span>);<br><br>[完整代码参考链接](https:<span class="hljs-comment">//blog.csdn.net/Return_nellen/article/details/79937320)</span><br><br></code></pre></td></tr></table></figure><h3 id="桶排序例题"><a href="#桶排序例题" class="headerlink" title="桶排序例题"></a>桶排序例题</h3><p><font color="red">存在重复元素 III</font><br>使用二分查找（set.lower_bound）和滑动窗口，或者桶排序和滑动窗口，比较经典<br>主要思路：查找当窗口元素中是否存在大于等于nums[i]-t的元素，如果存在，判断这个元素是否是小于等于 nums[i]+t 如果存在返回true;<br>如果是桶排序解决，就设定每个桶的大小为t+1 计算每个nums[i]应该在的桶的编号，判断这个桶是否有数据，如果有数据直接返回true； 如果没有，那么判断左右两边桶的数据之间的abs差是否 &lt;=t，同时在<br>循环向前的时候记得删除范围大于k的桶里面的数据</p><p>感觉使用滑动窗口更好理解，就是查找窗口为k的，是否能够找到当前加入的元素x, [x-t, x+t]范围内的数，而且不是当前的数x,如果能,那么返回true</p><p>易错点：<br>1.滑动窗口记得删除窗口之外的数据<br>2. nums[i]-t可能超出了整数的范围，一定要记得判断范围</p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序一般是求逆序对个数，或者其他规则的逆序对<br>比如例题lc493. 翻转对 求i&lt;j, 且nums[i]&gt;2*nums[j]</p><ul><li><p>易错点: 有负数+是大于，因此在求解的时候/2 向上还是向下取整会不同</p></li><li><p>题解是将求res这个过程单调拎出来计算，之后再进行归并</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"> <span class="hljs-keyword">while</span>(i&lt;=mid)&#123;<br>    <span class="hljs-keyword">while</span>(j&lt;=right&amp;&amp;(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)nums[i]&gt;(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)<span class="hljs-number">2</span>*nums[j]) j++; <span class="hljs-comment">//最好不要转为nums[i]/2&gt; nums[j] 因为负数在取整的时候和正数向上和向下不一样</span><br>    res+=(j-mid<span class="hljs-number">-1</span>);<br>    i++;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>方法二：使用树状数组，但是因为数据的范围太大，因此使用hash对数据进行离散化， 对x 2*x 一些列数据排序后，递增给予他们idx 1….</p></li></ul><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序模板题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp;  nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span></span>&#123;<br>       <span class="hljs-keyword">while</span>(left&gt;=right)&#123;<br>           <span class="hljs-keyword">return</span>;<br>       &#125;<br>       <span class="hljs-keyword">int</span> rand_num= <span class="hljs-built_in">rand</span>()%(right-left+<span class="hljs-number">1</span>)+left;<br>       <span class="hljs-keyword">int</span> pivot=nums[rand_num];<br>       <span class="hljs-built_in">swap</span>(nums[rand_num],nums[left]);<br>       <span class="hljs-keyword">int</span> l=left;<br>       <span class="hljs-keyword">int</span> r=right;<br>       <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>           <span class="hljs-keyword">while</span>(l&lt;r&amp;&amp;nums[r]&gt;=pivot)&#123;<br>               r--;<br>           &#125;<br>           <span class="hljs-keyword">while</span>(l&lt;r&amp;&amp;nums[l]&lt;=pivot)&#123;<br>               l++;<br>           &#125;<br>           <span class="hljs-keyword">if</span>(l&lt;r)&#123;<br>               <span class="hljs-built_in">swap</span>(nums[l], nums[r]);<br>           &#125;<br><br>       &#125;<br>       <span class="hljs-built_in">swap</span>(nums[left], nums[l]);<br>       <span class="hljs-built_in">quickSort</span>(nums, left, l<span class="hljs-number">-1</span>);<br>       <span class="hljs-built_in">quickSort</span>(nums, l+<span class="hljs-number">1</span>, right);<br>   &#125;<br>   <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>       <span class="hljs-keyword">int</span> num_len=nums.<span class="hljs-built_in">size</span>();<br>       <span class="hljs-built_in">quickSort</span>(nums, <span class="hljs-number">0</span>, num_len<span class="hljs-number">-1</span>);<br>       <span class="hljs-keyword">return</span> nums;<br>   &#125;<br></code></pre></td></tr></table></figure><p>快速排序找出第k个数的代码模板，类似于二分</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minMoves2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> mid = nums.length / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">int</span> mid_num = <span class="hljs-built_in">quickSort</span>(nums, mid); <span class="hljs-comment">//这道题中k为mid</span><br>        <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;<br>            ret += Math.<span class="hljs-built_in">abs</span>(mid_num - num);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> h = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt; h) &#123;<br>            <span class="hljs-keyword">int</span> ret = <span class="hljs-built_in">partion</span>(nums, l, h);<br>            <span class="hljs-keyword">if</span> (ret == k) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (ret &lt; k) &#123;<br>                l = ret + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                h = ret - <span class="hljs-number">1</span>; <br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[k];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partion</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> h)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Random</span>().<span class="hljs-built_in">nextInt</span>(h - l + <span class="hljs-number">1</span>) + l; <span class="hljs-comment">//记住pivot是随机产生</span><br>        <span class="hljs-keyword">int</span> temp = nums[p];<br>        nums[p] = nums[l];<br>        nums[l] = temp;<span class="hljs-comment">//交换left和pivot的值</span><br>        <br>        <span class="hljs-comment">//可以如下方式写，也可以，l和r每次交换，最后l和pivot所在的位置交换</span><br>        <span class="hljs-keyword">while</span> (l &lt; h) &#123;<br>            <span class="hljs-keyword">while</span> (l &lt; h &amp;&amp; nums[h] &gt;= temp) &#123; <span class="hljs-comment">//注意等于也要走，因为如果不，就可能导致在中间出现死循环</span><br>                h--;<br>            &#125;<br>            nums[l] = nums[h];<br>            <span class="hljs-keyword">while</span> (l &lt; h &amp;&amp; nums[l] &lt;= temp) &#123;<br>                l++;<br>            &#125;<br>            nums[h] = nums[l];<br>        &#125;<br>        nums[l] = temp;<br>        <span class="hljs-keyword">return</span> l;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用快速排序找到第k个数， 同时考虑结构体(在进行比较的时候使用second, 同时pivot也是second的值)的这种情况， 注意比较value, 但是交换的时候使用index</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">qsort</span><span class="hljs-params">(vector&lt;pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt;&amp; v, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; ret, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> picked = <span class="hljs-built_in">rand</span>() % (end - start + <span class="hljs-number">1</span>) + start;<br>    <span class="hljs-built_in">swap</span>(v[picked], v[start]);<br><br>    <span class="hljs-keyword">int</span> pivot = v[start].second;<br>    <span class="hljs-keyword">int</span> index = start;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start + <span class="hljs-number">1</span>; i &lt;= end; i++) &#123;<br>        <span class="hljs-keyword">if</span> (v[i].second &gt;= pivot) &#123;<br>            <span class="hljs-built_in">swap</span>(v[index + <span class="hljs-number">1</span>], v[i]);<br>            index++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">swap</span>(v[start], v[index]);<br><br>    <span class="hljs-keyword">if</span> (k &lt;= index - start) &#123;<br>        <span class="hljs-built_in">qsort</span>(v, start, index - <span class="hljs-number">1</span>, ret, k);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start; i &lt;= index; i++) &#123;<br>            ret.<span class="hljs-built_in">push_back</span>(v[i].first);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (k &gt; index - start + <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-built_in">qsort</span>(v, index + <span class="hljs-number">1</span>, end, ret, k - (index - start + <span class="hljs-number">1</span>));<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="排序算法总结与例题"><a href="#排序算法总结与例题" class="headerlink" title="排序算法总结与例题"></a>排序算法总结与例题</h2><p><a href="https://www.runoob.com/w3cnote/ten-sorting-algorithm.html">1.0 十大经典排序算法 | 菜鸟教程</a><br>快速排序的额外空间复杂度是O(logn)， 因为每次递归只使用运用了常数时间的额外空间</p><h3 id="1-常见算法的稳定性（要记住）"><a href="#1-常见算法的稳定性（要记住）" class="headerlink" title="1. 常见算法的稳定性（要记住）"></a>1. 常见算法的稳定性（要记住）</h3><p>不稳定排序算法： 堆排序、快速排序、希尔排序、选择排序 （快选西堆）</p><p>稳定排序算法： 基数排序、冒泡排序、插入排序、归并排序 （极差归帽（0））</p><p>计数排序的时间复杂度是O(n+k), 空间复杂度为O(k)<br>桶排序 O(n+k) 先分桶再快排 O(n+k)//count+tmp数组<br>基数排序  O(nxk) O(n+k)</p><h3 id="2-比较各种数据结构"><a href="#2-比较各种数据结构" class="headerlink" title="2. 比较各种数据结构"></a>2. 比较各种数据结构</h3><p>数组 插入慢，删除慢，查找慢（通过下标获取快）， 空间连续且固定<br>链表 插入快，删除快， 查找慢， 物理空间不连续，同时方便扩容<br>二叉树： 查找、插入、删除都快（如果树保持平衡）。缺点是删除算法复杂。<br>堆： 堆是一种特殊的完全二叉树<br>栈：后进先出，存取和查找其他项非常缓慢<br>队列： 先进先出，存取和查找其他项非常缓慢<br>散列表（hash）： 则存取极快，插入快。缺点是删除慢，对存储空间使用不充分, 需要解决可能产生的hash冲突。<br>图：邻接矩阵或者邻接链表，复杂，不同的存储方式导致查找比较缓慢</p><h3 id="3-外部排序方法"><a href="#3-外部排序方法" class="headerlink" title="3. 外部排序方法"></a>3. 外部排序方法</h3><p>外排序的一个例子是外归并排序（External merge sort），它读入一些能放在内存内的数据量，在内存中排序后输出为一个顺串（即是内部数据有序的临时文件），处理完所有的数据后再进行归并。[1][2]比如，要对900 MB的数据进行排序，但机器上只有100 MB的可用内存时，外归并排序按如下方法操作：</p><pre><code class="hljs">1. 读入100 MB的数据至内存中，用某种常规方式（如快速排序、堆排序、归并排序等方法）在内存中完成排序。2. 将排序完成的数据写入磁盘。3. 读入每个临时文件（顺串）的前10 MB（ = 100 MB / (9块 + 1)）的数据放入内存中的输入缓冲区，最后的10 MB作为输出缓冲区。（实践中，将输入缓冲适当调小，而适当增大输出缓冲区能获得更好的效果。）4. 执行九路归并算法，将结果输出到输出缓冲区。一旦输出缓冲区满，将缓冲区中的数据写出至目标文件，清空缓冲区。一旦9个输入缓冲区中的一个变空，就从这个缓冲区关联的文件，读入下一个10M数据，除非这个文件已读完。这是“外归并排序”能在主存外完成排序的关键步骤 -- 因为“归并算法”(merge algorithm)对每一个大块只是顺序地做一轮访问(进行归并)，每个大块不用完全载入主存。</code></pre><p>为了增加每一个有序的临时文件的长度，可以采用置换选择排序（Replacement selection sorting）。它可以产生大于内存大小的顺串。具体方法是在内存中使用一个最小堆进行排序，设该最小堆的大小为{\displaystyle M}M。算法描述如下：</p><pre><code class="hljs">1. 初始时将输入文件读入内存，建立最小堆。2. 将堆顶元素输出至输出缓冲区。然后读入下一个记录：    a. 若该元素的关键码值不小于刚输出的关键码值，将其作为堆顶元素并调整堆，使之满足堆的性质；    b. 否则将新元素放入堆底位置，将堆的大小减1。3. 重复第2步，直至堆大小变为0。此时一个顺串已经产生。将堆中的所有元素建堆，开始生成下一个顺串。[3]此方法能生成平均长度为&#123;\displaystyle 2M&#125;2M的顺串，可以进一步减少访问外部存储器的次数，节约时间，提高算法效率。</code></pre><p>总结：顺串产生可以用1）小顶堆或者2）划分为多个小文件+各自快速排序产生</p><h3 id="4-向数组中追加-K-个整数（lc6017）"><a href="#4-向数组中追加-K-个整数（lc6017）" class="headerlink" title="4. 向数组中追加 K 个整数（lc6017）"></a>4. 向数组中追加 K 个整数（lc6017）</h3><p>题意，向数组中插入k个数组都没出现过的正整数，如果是插入的和最小<br>解决方案：排序数组，然后填充数组的空隙， 使用高斯求和公式得到结果会更快<br>易错点：注意的是需要在数组前面和后面加两个哨兵</p><h3 id="5-lc1539-第-k-个缺失的正整数-easy"><a href="#5-lc1539-第-k-个缺失的正整数-easy" class="headerlink" title="5.lc1539. 第 k 个缺失的正整数 (easy)"></a>5.lc1539. 第 k 个缺失的正整数 (easy)</h3><ul><li>一个排序正整数数组，找到缺失的第k个正整数</li><li>算法1：为了减少分类讨论，直接在数组前面+一个哨兵节点0， 然后k依次减去相邻两个数中间包含数的个数</li><li>算法2：缺失的正整数一定 &gt;= k；数组中每出现一个 &lt;= k 的数字, 意味着少了一个缺失的数字, 此时k+1<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">size</span>(); i++) &#123;<br>    <span class="hljs-keyword">if</span> (arr[i] &lt;= k) &#123;<br>        k++;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">return</span> k;<br></code></pre></td></tr></table></figure></li></ul><h3 id="6-lc414-第三大的数（easy）"><a href="#6-lc414-第三大的数（easy）" class="headerlink" title="6. lc414. 第三大的数（easy）"></a>6. lc414. 第三大的数（easy）</h3><ul><li>题意：返回第k大的数，相同的数同一level, 如果每个第k大的数，返回第一大</li><li>注意数据中可能包含INT_MIN</li><li>思路：可以使用排序，可以O(n)， 用三个数a, b, c, 初始化为long INT_MIN</li><li>定要注意等于的情况是不更新的，比如等于b, 不会更新c的！！！！</li></ul><h3 id="7-lc870-优势洗牌"><a href="#7-lc870-优势洗牌" class="headerlink" title="7. lc870. 优势洗牌"></a>7. lc870. 优势洗牌</h3><ul><li>题意：将nums1和nums2如何进行配对，使得在i, nums1[i]&gt;nums2[i]的对数最大</li><li>田忌赛马的思想</li><li>使用优先队列，将每个nums2的下标和数据入队</li><li>每次弹出nums2的最大的一个，如果当前nums1的最大不能打败当前的数，那么就将nums1的最小和nums2的最大匹配（nums1 index left++）, 否则right– （更易理解）</li><li>或者每次弹出nums2的最小的一个，如果当前nums1的最小不能打败当前的数，那么就将nums1的最小和nums2的最大匹配(此时用优先队列好像不行，可以直接对结构体nums2进行排序), 否则right–</li><li>“滑动窗口的最大值”，也是使用了优先队列</li></ul><h3 id="8-奇偶稳定排序"><a href="#8-奇偶稳定排序" class="headerlink" title="8. 奇偶稳定排序"></a>8. 奇偶稳定排序</h3><ul><li>将数组的奇数全部排在偶数前面，同时不交换奇数和偶数原本的相对顺序</li><li>用一个k来记录前面以及排好序的奇数的个数， 然后每遇到一个奇数，就使用冒泡排序的方法，一个一个的交换到前面去<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reOrderArray</span>(<span class="hljs-params">arr</span>):</span><br>    m = <span class="hljs-built_in">len</span>(arr)<br>    k = <span class="hljs-number">0</span> <span class="hljs-comment"># 记录当前已经排序好的奇数个数</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>        <span class="hljs-keyword">if</span> arr[i] % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>:<br>            j = i<br>            <span class="hljs-keyword">while</span> j &gt; k:  <span class="hljs-comment"># 将奇数移到最前面</span><br>                temp = arr[j]<br>                arr[j] = arr[j-<span class="hljs-number">1</span>]<br>                arr[j-<span class="hljs-number">1</span>] = temp<br>                j -= <span class="hljs-number">1</span><br>            k += <span class="hljs-number">1</span> <br>    <span class="hljs-built_in">print</span>(arr)<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">12</span>]<br>    reOrderArray(arr)<br></code></pre></td></tr></table></figure></li></ul><h3 id="9-lc703-数据流中的第-K-大元素"><a href="#9-lc703-数据流中的第-K-大元素" class="headerlink" title="9. lc703. 数据流中的第 K 大元素"></a>9. lc703. 数据流中的第 K 大元素</h3><p>标准优先队列的题目</p><ul><li>注意k大和k小的含义区别</li><li>易错点，最开始的nums为空；因此需要判断优先队列里面元素&gt;k的时候才弹出，否则可能会出现空队列弹出，或者push 空的错误</li></ul><h3 id="10-6155-找出数组的第-K-大和"><a href="#10-6155-找出数组的第-K-大和" class="headerlink" title="10. 6155. 找出数组的第 K 大和"></a>10. 6155. 找出数组的第 K 大和</h3><p><font color="red">不重不漏的生成一个全正数序列的所有子序列和的方法</font></p><ol><li>使用小根堆维护(sum, i)</li><li>选择将a_{i+1} 元素添加到弹出的头元素(sum+a_{i+1}， i+1) </li><li>选择将a_{i+1} 元素添加到弹出的头元素同时删除第i个元素(sum+a_{i+1}-a_{i}， i+1) </li></ol><ul><li>变形1：求第 k个最大的子序列和，与求第 k的最小的子序列和是一样的。我们求出 k小子序列后取反, 也就是所有元素之和减去 k 小 子序列和，就能得到 k大子序列和。</li><li>变形2，序列中有负数。将所有负数转为正数后求k大子序列，然后减去<strong>所有的</strong>负数元素</li><li>变形2的第二种解法是，先所有的正数相加一定是最大的数，然后从小到大的减去sum需要减去的子序列，知道第k次，就是第k大的和</li></ul><h3 id="11-寻找两个正序数组的中位数-寻找两个正序数组的第k个数"><a href="#11-寻找两个正序数组的中位数-寻找两个正序数组的第k个数" class="headerlink" title="11. 寻找两个正序数组的中位数 (寻找两个正序数组的第k个数)"></a>11. 寻找两个正序数组的中位数 (寻找两个正序数组的第k个数)</h3><p>注意k表示的第k个数，而不是下标为k<br>同时注意算法是一边在进行移动，而不是两边都移动</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//时间复杂度log(m+n) 空间复杂度O(1)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">getKthElement</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums2, <span class="hljs-keyword">int</span> k)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> size1 = nums1.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">int</span> size2 = nums2.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">int</span> index1 = <span class="hljs-number">0</span>, index2 = <span class="hljs-number">0</span>; <br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(index1==size1)&#123;<br>                <span class="hljs-keyword">return</span> nums2[index2 + k - <span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-keyword">if</span>(index2==size2)&#123;<br>                <span class="hljs-keyword">return</span> nums1[index1 + k - <span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-keyword">if</span>(k==<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(nums1[index1], nums2[index2]);<br>            &#125;<br>            <span class="hljs-keyword">int</span> newIndex1 = <span class="hljs-built_in">min</span>(index1 + k / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>, size1 - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">int</span> newIndex2 = <span class="hljs-built_in">min</span>(index2 + k / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>, size2 - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">int</span> pivot1 = nums1[newIndex1];<br>            <span class="hljs-keyword">int</span> pivot2 = nums2[newIndex2];<br>            <br>            <span class="hljs-keyword">if</span>(pivot1&lt;=pivot2)&#123;<br>                <br>                k = k - (newIndex1 - index1 + <span class="hljs-number">1</span>);<br>                index1 = newIndex1 + <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <br>                k = k - (newIndex2 - index2 + <span class="hljs-number">1</span>);<br>                index2 = newIndex2 + <span class="hljs-number">1</span>;<br>            &#125;<br>            cout&lt;&lt;pivot1&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;pivot2&lt;&lt;endl;<br>            <br>        &#125;<br>        <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> size1 = nums1.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">int</span> size2 = nums2.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">int</span> sum = size1 + size2;<br>        <span class="hljs-keyword">if</span>(sum%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> (<span class="hljs-built_in">getKthElement</span>(nums1, nums2, sum / <span class="hljs-number">2</span>) + <span class="hljs-built_in">getKthElement</span>(nums1, nums2, sum / <span class="hljs-number">2</span> +<span class="hljs-number">1</span>)) / <span class="hljs-number">2</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            cout&lt;&lt;sum/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>&lt;&lt;endl;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">getKthElement</span>(nums1, nums2, sum / <span class="hljs-number">2</span>+<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h3 id="12-排序和优先队列结合！！"><a href="#12-排序和优先队列结合！！" class="headerlink" title="12. 排序和优先队列结合！！"></a>12. 排序和优先队列结合！！</h3><p>两个最好的不重叠活动<br>步骤：</p><ul><li>先将活动按起始时间从小到大进行排序</li><li>维护一个最小堆，堆内元素代表活动的结束时间和对应价值(结束时间越早的越先弹出)</li><li>遍历所有活动，如果堆内的活动结束时间小于当前活动的起始时间，又因为活动时间是从小到大进行排序的，所以当前堆内的活动是可以与后面任意活动一起参与的，因此我们可以维护maxVal记录下当前活动开始前，我们可以选择的最大价值</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>主要是针对大文件或者多线程情况的下排序，或者数据结构本身的考察</p><p>priority_queue和set multiset都是有序的集合，但是priority_queue不支持从里面删除一个元素，set和multiset支持<br>s.erase(s.find(val)), 如果一定要用priority_queue，可以考虑使用延迟删除，就是先判断元素的有效性，再返回结果</p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>滑动窗口</title>
      <link href="/2021/11/13/leetcode/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
      <url>/2021/11/13/leetcode/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="1-最小覆盖子串（两个字符串）"><a href="#1-最小覆盖子串（两个字符串）" class="headerlink" title="1. 最小覆盖子串（两个字符串）"></a>1. 最小覆盖子串（两个字符串）</h3><h3 id="2-不同字符的最小子序列（一个字符串）"><a href="#2-不同字符的最小子序列（一个字符串）" class="headerlink" title="2. 不同字符的最小子序列（一个字符串）"></a>2. 不同字符的最小子序列（一个字符串）</h3><p>  需要有一个hash来记录一个字符的剩余出现次数<br>  如果栈中没找到，从栈中弹出剩余出现次数大于0，而且大于当前字符的字符，然后压入当前字符<br>  否则直接将num[当前字符]–</p><h3 id="3-窗口内的最大值，使用的是单调栈"><a href="#3-窗口内的最大值，使用的是单调栈" class="headerlink" title="3. 窗口内的最大值，使用的是单调栈"></a>3. 窗口内的最大值，使用的是单调栈</h3><h3 id="4-未排序数组中，累加和为给定值的最长子数组"><a href="#4-未排序数组中，累加和为给定值的最长子数组" class="headerlink" title="4. 未排序数组中，累加和为给定值的最长子数组"></a>4. 未排序数组中，累加和为给定值的最长子数组</h3><ul><li><p>方法一： 滑动窗口 （使用了条件，数据全部为正数，如果没有这个条件就不能使用滑动窗口）</p></li><li><p>方法二： 使用hash记录一个sum出现的最早index,同时要记得压入hash[0]=-1<br>(PS: 累加和为给定值的子数组个数-&gt;hash)</p></li><li><p>补充问题1，正数和负数个数相等的最长子数组<br>  将正数转为1，负数转为0，求累加和为0最长子数组</p></li><li><p>补充问题2： 元素只有0和1的情况下，求0 和 1个数相等的最长子数组<br>  将0转为-1，1不变，求累加和为0的最长子数组</p></li></ul><h3 id="5-未排序数组中，累加和小于等于给定值的最长子数组"><a href="#5-未排序数组中，累加和小于等于给定值的最长子数组" class="headerlink" title="5. 未排序数组中，累加和小于等于给定值的最长子数组"></a>5. 未排序数组中，累加和小于等于给定值的最长子数组</h3><h3 id="6-和小于等于K的最长子数组-以及-和不小于k的最短子数组leetcode-862"><a href="#6-和小于等于K的最长子数组-以及-和不小于k的最短子数组leetcode-862" class="headerlink" title="6. 和小于等于K的最长子数组  以及 和不小于k的最短子数组leetcode 862"></a>6. 和小于等于K的最长子数组  以及 和不小于k的最短子数组leetcode 862</h3><p><font color="red">862. 和至少为 K 的最短子数组(hard)</font><br>因为带有负数，所以收缩窗口不一定sum变小，和还有可能变大,所以滑动窗口不行<br>解决方案：使用前缀和+双端队列</p><ul><li>先把当前遍历的index i当做起始点，再把i当做末尾点</li><li>题目说明K一定是大于0的数</li><li>如果当前的值比队尾小，那么循环弹出队尾部的值；</li><li>如果队尾的值减去队首前缀和大于等于target，那么循环弹出首部的值（下标）,同时更新minlen (先pop前面再pop后面，或者先pop后面再pop前面都是可以的)</li><li>易错点：一定要注意先push_back(0), 因为要处理只有一个元素的情况  [1] k=1</li></ul><p><font color="blue"> 这道题可以和连续和大于0的最长序列（lc-1124:表现良好的最长时间段）一起看：</font></p><ul><li>求最长大于 or 小于 k使用前缀和+单调栈，求最短大于等于k使用前缀和+双端队列； </li><li>如果是求最长小于k（和小于k的最长序列），那么使用先遍历一次前缀和数组（小压栈，否则continue），得到底部到顶单增的栈，然后逆序遍历，求小于k的最长序列</li><li>如果是求最长大于k（和大于0的最长序列），那么使用先遍历一次前缀和数组（小压栈，否则continue），得到底部到顶单减的栈，然后逆序遍历，求大于k的最长序列</li><li>如果是求最短小于k（一般无这种问法）</li></ul><h3 id="7-至少有-K-个重复字符的最长子串"><a href="#7-至少有-K-个重复字符的最长子串" class="headerlink" title="7. 至少有 K 个重复字符的最长子串"></a><font color="red">7. 至少有 K 个重复字符的最长子串</font></h3><p>题意：子串中每个字符都需要重复k次<br>解决方案： </p><ul><li><p>滑动窗口，枚举窗口内包含的字符的总数，如果字符总数大于（1-26个字符26种情况下，每个字符至少k个）的最大长度，当当前窗口包含的字符数大于遍历的这种情况的话，收缩窗口， 末尾如果typecnt=k_num那么就更新答案</p></li><li><p>分治算法，先统计当前字符串，每个字符的频率，然后以小于k 的字符的任意一个作为划分点（感觉也可以放在一个集合，判断字符是否在集合内），将当前字符分为多个段，然后递归求解</p></li></ul><h3 id="8-等差数列的划分"><a href="#8-等差数列的划分" class="headerlink" title="8. 等差数列的划分"></a>8. 等差数列的划分</h3><p>求个数问题 每个窗口包含的等差数列的个数=左右指针差-1（滑动窗口内包含子数组的个数计算）</p><h3 id="9-找到字符串的所有异位词，注意这个是两个指针之间只能包含这个词"><a href="#9-找到字符串的所有异位词，注意这个是两个指针之间只能包含这个词" class="headerlink" title="9. 找到字符串的所有异位词，注意这个是两个指针之间只能包含这个词"></a>9. 找到字符串的所有异位词，注意这个是两个指针之间只能包含这个词</h3><ul><li>解法1：类似于needle数组，只有count==0判断right-left+1是否等于p.size() 然后收缩窗口，每次收缩的时候都需要重新判断 len是否相等</li><li>解法2：维护一个和p 一样长度的窗口，如果当前字符频率数组==p的字符频率数组（vec1==vecb），那么说明找到一个异位词</li><li>解法3：也可以使用一个count vector，表示两个字符串各个字符的差值，和一个diff变量，如果diff变量==0说明两个字符串相等。减左边1之后，如果count[i]==0，那么diff–,如果count[i]==-1, diff++；同理加右边1之后</li></ul><p>PS:类似的题 最小覆盖子串（可以包含其他字符）， 至少有k个无重复字符的最长子串, lc 面试题 17.18. 最短超串(big字符串里面包含small字符串里面每个字符的最短串)</p><ul><li><font color="red">易错点：注意一定是needle[big[left]]++/–不是needle[left] or needle[right]</font></li></ul><p>模板 needle+count来判断</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++">总结：count == <span class="hljs-number">0</span>的时候，先收缩不必要的字符再进行判断！！！！<br><span class="hljs-keyword">int</span> left=<span class="hljs-number">0</span>, right=<span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//right最好是包含这个字符</span><br><span class="hljs-keyword">while</span>(right&lt;len1)&#123;<br><br>    <span class="hljs-keyword">if</span>(needle[s[right]]&gt;<span class="hljs-number">0</span>)&#123;<br>        count--; <br>    &#125;<br>    needle[s[right]]--; <span class="hljs-comment">//先减再判断</span><br>    <span class="hljs-keyword">if</span>(count==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">//收缩字符</span><br>        <span class="hljs-keyword">while</span>(needle[s[left]]&lt;<span class="hljs-number">0</span>)&#123;<br>            needle[s[left]]++;<br>            left++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(right-left+<span class="hljs-number">1</span>&lt;min_len)&#123;<br>            min_len = right - left+<span class="hljs-number">1</span>;<br>            start = left;<br>        &#125;<br>            needle[s[left]]++;<br>            count++;<br>            left++;<br>        &#125;<br>        <br>        right++;<br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="10-最少交换次数来组合所有的-1-II"><a href="#10-最少交换次数来组合所有的-1-II" class="headerlink" title="10. 最少交换次数来组合所有的 1 II"></a><font color="red">10. 最少交换次数来组合所有的 1 II</font></h3><p>  先计算出有多少个1，假设为k个<br>  然后用一个固定大小为k的窗口，遍历数组，记录窗口内0的最小个数即为答案<br>  II和I的区别在于II是环形数组，因此需要遍历每一个start(包括==size, 此时end通过求余得到),但是I只需要遍历end&lt;size</p><h3 id="11-水果成篮"><a href="#11-水果成篮" class="headerlink" title="11. 水果成篮"></a>11. 水果成篮</h3><p>题意是包含两种数据类型的最长子数组;使用typecnt， hash_cnt 和left right指针；当typecnt&lt;=2对窗口进行扩， 否则进行收缩<br>用滑动窗口<br>注意是hash[fruit[left]]++/–不是hash[left]++/–</p><h3 id="12-最大连续1的个数III"><a href="#12-最大连续1的个数III" class="headerlink" title="12. 最大连续1的个数III"></a>12. 最大连续1的个数III</h3><p>滑动窗口，当当前的0的个数比k大，就收缩窗口，否则扩展窗口</p><h3 id="13-爱生气的书店老板"><a href="#13-爱生气的书店老板" class="headerlink" title="13. 爱生气的书店老板"></a>13. 爱生气的书店老板</h3><p>先将满意时的数据加起来，然后这些位置的值置为0，剩下的就是求滑动窗口的最大值</p><h3 id="14-尽可能使字符串相等"><a href="#14-尽可能使字符串相等" class="headerlink" title="14. 尽可能使字符串相等"></a>14. 尽可能使字符串相等</h3><p>这道题转化的题意是，使得子数组（连续的数,开销都为正数）的和小于maxCost的最长子数组的长度<br>使用滑动窗口</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">while</span>(right&lt;size)&#123;<br>     sum+=dist[right];<br>     <span class="hljs-keyword">while</span>(sum&gt;maxCost&amp;&amp;left&lt;=right)&#123;<br>         sum-=dist[left];<br>         left++;<br>     &#125;<br>     res=<span class="hljs-built_in">max</span>(res, right-left+<span class="hljs-number">1</span>);<br>     right++;<br> &#125;<br></code></pre></td></tr></table></figure><p>另外一种方法是前缀和+二分，对于每个index, 二分找到前缀和大于等于presum[index]-maxCost的最小下标（lower_bound）</p><h3 id="15-可获得的最大点数"><a href="#15-可获得的最大点数" class="headerlink" title="15. 可获得的最大点数"></a>15. 可获得的最大点数</h3><p>题意：只能从两端取数据，取得k个数据的最大值<br>solution: 滑动窗口size-k内元素之和的最小值, 其实也可以用区间dp解决，但是因为为造成三维dp[left][right][k]，因此会超出内存</p><h3 id="16-最高频元素的频数"><a href="#16-最高频元素的频数" class="headerlink" title="16. 最高频元素的频数"></a><font color="red">16. 最高频元素的频数</font></h3><ul><li>将整个数组进行排序，使用滑动窗口，枚举将窗口内所有的数转为右边界这个数的最长长度， l只会递增不会减少， r就是当前遍历的下标，因为之前的元素都已经转为num[r-1]，因此还需要消耗的数据只有(nums[r]-nums[r-1])*(r-l), 如果比给定的k大，那么收缩窗口</li><li>具有滑动窗口单增特性，r向右滑动，需要的数越来越大，l向右滑动需要的越来越小</li></ul><h3 id="17-查找给定哈希值的子串"><a href="#17-查找给定哈希值的子串" class="headerlink" title="17. 查找给定哈希值的子串"></a>17. 查找给定哈希值的子串</h3><p>这个就是 字符串hash的一个例子，但是和常规的字符串hash不一样的是，字符串hash计算方式为<br>hash(s, p, m) = (val(s[0]) * p0 + val(s[1]) * p1 + … + val(s[k-1]) * pk-1) mod m.</p><p>但是因为除法不满足取余的恒等性质，如果正序的话就会导致需要减去第一个数然后/power+最后一个数的值，会发生错误<br>因此需要倒序，减去当前的值，乘以power再加上新元素的值。（乘法满足取余恒等）<br>solution: 从右到左，滑动窗口计算k字符串里面的hashvalue （求后缀和，中间的那段的hash/滑动窗口从右到左，和从左到右的计算方式不同</p><p>另一种解法，适用于任何长度的字符串，仍然需要反向计算<br>与标准的不同之处：sum[i] 从sum[i-1]变为从sum[i+1], 计算hash由hash[right]-hash[left]变为hash[left]-hash[right]<br><a href="https://leetcode-cn.com/problems/find-substring-with-given-hash-value/solution/zi-fu-chuan-ha-xi-zi-fu-chuan-chu-li-cha-v809/">力扣（LeetCode）官网 - 全球极客挚爱的技术成长平台</a></p><p>PS:取模和乘法同一优先级：乘法都要在后面加一个%运算符， 减了一个元素，需要在取模前加上这个modulo；这道题也不能直接套用以前封装的的字符串哈希类，因为POWER 与 MOD 要互质(存在逆元) 才能调RK算法</p><h3 id="18-lc713-乘积小于K的子数组"><a href="#18-lc713-乘积小于K的子数组" class="headerlink" title="18. lc713. 乘积小于K的子数组"></a>18. lc713. 乘积小于K的子数组</h3><ul><li>求乘积小于K的连续子数组的个数</li><li>滑动窗口：具有增大窗口，值递增，减少窗口值减少，求所有满足条件子集的个数；如果增大窗口，值并不出现单调趋势，就不能使用滑窗</li></ul><h3 id="19-lc632-最小区间"><a href="#19-lc632-最小区间" class="headerlink" title="19. lc632. 最小区间"></a>19. lc632. 最小区间</h3><ul><li>每个区间的数至少包含一个，其实就是1 3 2都要包含的最短区间问题，使用滑动窗口</li><li>使用最小覆盖子串解决</li></ul><h3 id="20-lc295-数据流的中位数"><a href="#20-lc295-数据流的中位数" class="headerlink" title="20. lc295. 数据流的中位数"></a>20. lc295. 数据流的中位数</h3><ul><li>使用两个优先队列/multiset来维护一个大顶堆和小顶堆</li><li>为了保证大顶堆和小顶堆数据量的平衡，可以使用偶数插入大顶堆， 并移除最大元素到小顶堆， 以及奇数插入小顶堆， 并移除最大元素到大顶堆的方法<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">set1.<span class="hljs-built_in">insert</span>(num);<br><span class="hljs-keyword">int</span> tmp=*set1.<span class="hljs-built_in">begin</span>();<br>set1.<span class="hljs-built_in">erase</span>(set1.<span class="hljs-built_in">begin</span>());<br>set2.<span class="hljs-built_in">insert</span>(tmp);<br></code></pre></td></tr></table></figure></li></ul><h3 id="21-lc480-滑动窗口中位数"><a href="#21-lc480-滑动窗口中位数" class="headerlink" title="21. lc480. 滑动窗口中位数"></a>21. lc480. 滑动窗口中位数</h3><ul><li>方法一：需要使用一个map来记录需要删除的数，进行延迟删除 mp[l]++; 这种方法，为了保证左右两边数据的平衡，可以用一个变量balance来记录，（small加一个数，balance++， 减一个数balance–） 使得balance维持0就行了</li><li>方法二：可以使用multiset来删除特定的数</li><li>因为large（小顶堆）应该始终比 small(大顶堆)的size 大于等于1, 因此可以通过这个来判断之后的数应该是插入大顶堆还是小顶堆</li></ul><h3 id="22-lc424-替换后的最长重复字符"><a href="#22-lc424-替换后的最长重复字符" class="headerlink" title="22.  lc424: 替换后的最长重复字符"></a>22.  lc424: 替换后的最长重复字符</h3><p>这道题和和其他滑动窗口都不一样；主要是由于窗口内最多的字符是未知的，因为窗口即使收缩，长度也不会变小，不能以右边指针的字符代表整个窗口最后选定的字符！！！！！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">while</span>(right&lt;size)&#123;<br>     nums[s[right]-<span class="hljs-string">&#x27;A&#x27;</span>]++;<br>     maxn=<span class="hljs-built_in">max</span>(maxn, nums[s[right]-<span class="hljs-string">&#x27;A&#x27;</span>]);<span class="hljs-comment">//这个可以求到曾经滑动窗口中出现最多的字符数目，但是具体是哪个字符不知道</span><br>     <span class="hljs-keyword">if</span>(right-left+<span class="hljs-number">1</span>&gt;maxn+k)&#123;<br>         nums[s[left]-<span class="hljs-string">&#x27;A&#x27;</span>]--;<br>         left++;<br>     &#125;<br>     right++;<br> &#125;<br> <span class="hljs-keyword">return</span> right-left;<br></code></pre></td></tr></table></figure><h3 id="23-lc1438-绝对差不超过限制的最长连续子数组"><a href="#23-lc1438-绝对差不超过限制的最长连续子数组" class="headerlink" title="23. lc1438. 绝对差不超过限制的最长连续子数组"></a>23. lc1438. 绝对差不超过限制的最长连续子数组</h3><ul><li>如何维护滑动窗口的最大值和最小值？</li><li>方法1：使用multiset的方法，使用*s.rbegin()- *s.begin()来找到最小和最大的差值，使用s.erase(s.find(nums[left]))来删除最左边的元素</li><li>方法2: 使用两个双端队列，分别维护滑动窗口的最大值和最小值，其中最大值q，存储元素类似一个单调递减的栈（当一个更大的值出现后，前面更小的元素都不可能成为窗口的最大值了，因此弹出，成为单调减队列；最前面最大值弹出后，后面下的一个数可能为窗口最大值）; 最小值q,存储元素的时候类似一个单调递增的栈；然后判断两个队列的差值是否在limit之内，如果不在就判断q_min和q_max的front是否是当前的nums[left], 如果是就弹出，否则就说明有可能之前就已经被弹出了。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>涉及连续子数组的两种方法：<br>a.滑动窗口<br>b.前缀和+hash+二分</p><ul><li>如果是小于等于K的最长，那么使用二分查找，查找大于等于sums[i]-target的第一个下标index（向前查找）i-index+1  lower_bound 最后返回时候判断一下是否&gt;=target</li><li>如果是大于等于K的最短，那么使用二分查找，查找大于等于sums[i]+target的第一个下标index（向后查找）index-i+1<br>(hash适用于==target, 滑动窗口适用于至多至少target，最长连续，最短连续这种情况)  </li></ul></li><li><p>滑动串口count==0 先收缩再判断</p></li><li><p>求子数组的个数，以及最长子数组， 可能使用滑动窗口(右边固定，左边每个都可以，子数组的所有个数)，可能使用hash+前缀和（和为k， 右边固定，左边部分可，部分不行），也可能两种都可以，注意区别。<br>如果固定了left到right之间的间距，一般用滑动窗口<br>而且区分子序列（不连续）， 子数组（连续）</p></li><li><p>滑动窗口适合字符串/数组是连续场景，滑动窗口里面的字符是可能都需要，也能只需要子序列满足条件就可以</p></li><li><p>如果字符串连续+长度固定，使用滑动窗口 （lc1423. 可获得的最大点数, 拿的点数是固定的，所以没必要使用动态规划， 使用动态规划三维数组，反而会导致错误）</p></li><li><p>求滑动窗口的适合没有负数的场景，对于负数这种情况，不满足扩充窗口和变大，减小窗口和变小的规律（不满足单调性质），因此不使用于滑动窗口这种场景<br>对于包含负数的这种情况：求最短大于使用前缀和+双端队列，求最长大于或者小于k使用前缀和+单调栈，见例题6详细说明</p></li><li><p>滑动窗口使用与某一段连续只包含k中字符，只允许翻转k个数类似的题目， 同时也可以转为前缀和+二分来进行查找</p></li><li><p>两端k个元素和最大的问题可以转为中间size-k个元素和最小的问题</p></li><li><p>一种是right每次往右走，只要不满足条件，left就一直收敛。 另一种是，right每次往右走，如果不满足条件，left最多收敛一次（进阶）lc424:替换后的最长重复字符</p></li></ol><p>10.如果遇到环形数组，那么将数组拉直解决，就是并列两个相同的数组aa</p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>二分算法</title>
      <link href="/2021/11/13/leetcode/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/"/>
      <url>/2021/11/13/leetcode/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="二分查找模板"><a href="#二分查找模板" class="headerlink" title="二分查找模板"></a>二分查找模板</h2><blockquote><p>参考链接：[二分查找专题]（<a href="https://blog.csdn.net/qq_41221520/article/details/108277801">[C/C++]二分查找专题/最后一个小于等于目标值target的数/第一个大于等于目标值target的数_c++二分查找最后一个小于等于x的数-CSDN博客</a>）</p></blockquote><p><font color="red">提型： 第一个大于，第一个大于等于， 等于的左右边界</font><br>（1）某一个数<br>（2）最后一个小于目标值target的数<br>（3）最后一个小于等于目标值target的数<br>（3）第一个大于目标值target的数<br>（5）第一个大于等于目标值target的数</p><ol><li>如果找左右边界2 4 4 4 4 5（第一个等于，最后一个等于），那么使用left&lt;right以及找左右边界，控制右边；找右边界，控制左边的口诀；</li><li>如果找第一个大于target,第一个大于等于target；小于target, 最后一个小于等于target<br>那么使用常规二分算法，left&lt;=right 以及题目中有等号，等式中无，以及大于对应left=mid+1在前，小于对应right=mid-1在前的口诀</li></ol><p><font color="red">统一：<br>第一个大于等于target，转为左边界；<br>最后一个小于等于target，转换为右边界.<br>其余等于，大于，或者小于都转为标准二分<br>注意标准二分记得返回的时候判断l， r是否在范围内（-1 size，判断）； 左右边界不用判断是否在返回内<br>记住大于目标值的第一个数，并不一定是等于target的右边界+1对应的下标</font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//找到第一个大于target的数</span><br><span class="hljs-keyword">int</span> l=<span class="hljs-number">0</span>, r=arr.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">while</span>(l&lt;=r)&#123; <br>    <span class="hljs-keyword">int</span> mid=l+(r-l)/<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(arr[mid]&gt;x)&#123;<br>        r=mid<span class="hljs-number">-1</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">//等于情况应该为mid+1</span><br>        l=mid+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">if</span>(l&gt;=size)&#123;<br>    <span class="hljs-keyword">return</span> error<br>&#125;<br><span class="hljs-keyword">return</span> l;<br></code></pre></td></tr></table></figure><p>第一个大于不能转为左边界：<br>[0] 当size=1的时候不行，会直接退出循环，然后返回0， 实际上应该返回1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++">左右边界<br><span class="hljs-comment">//左边界</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">left_bound</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> arr, <span class="hljs-keyword">int</span> target)</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>        <span class="hljs-keyword">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(arr[mid]&lt;target)&#123;<br>            left=mid+<span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            right=mid;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr[left];<br>&#125;<br><br><span class="hljs-comment">//右边界</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">right_bound</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> arr, <span class="hljs-keyword">int</span> target)</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>        <span class="hljs-keyword">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(arr[mid]&lt;=target)&#123;<br>            left=mid;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            right=mid<span class="hljs-number">-1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr[right];<br>&#125;<br><br><br>标准：<br><span class="hljs-keyword">while</span>(left&lt;=right)&#123;<br>    <span class="hljs-keyword">int</span> mid=(left+right)/<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(arr[mid]&lt;target)&#123;<br>        left=mid+<span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr[mid]&gt;target)&#123;<br>        right=mid<span class="hljs-number">-1</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> mid;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="1-lc34-在排序数组中查找元素的第一个和最后一个位置"><a href="#1-lc34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="1. lc34. 在排序数组中查找元素的第一个和最后一个位置"></a><font color="red">1. lc34. 在排序数组中查找元素的第一个和最后一个位置</font></h3><p>这道题元素可能存在可能不存在，使用左右边界的方法，同时需要判断最后结果是否是target</p><h3 id="2-在数组中找到一个局部最小值"><a href="#2-在数组中找到一个局部最小值" class="headerlink" title="2. 在数组中找到一个局部最小值"></a>2. 在数组中找到一个局部最小值</h3><p>一定要在排序数组中使用二分算法，只要能确定二分两侧的某一侧肯定存在你要找的内容，就可以使用二分查找。</p><h3 id="3-寻找旋转排序数组中的最小值（一个是可能包含重复数据，一个是不包含重复数据）"><a href="#3-寻找旋转排序数组中的最小值（一个是可能包含重复数据，一个是不包含重复数据）" class="headerlink" title="3. 寻找旋转排序数组中的最小值（一个是可能包含重复数据，一个是不包含重复数据）"></a><font color="red">3. 寻找旋转排序数组中的最小值（一个是可能包含重复数据，一个是不包含重复数据）</font></h3><p>两个都是arr可能经过一次旋转处理，可能没有<br>(1)不包含重复，那么比较中间的值和右边的值，如果小于则说明右边顺序没变，right=mid,否则，left=mid+1<br>(2)可能包含重复数据就是在不包含重复数据基础上 添加一个如果nums[r]==nums[mid]，那么r–,一直到右边不等于mid</p><p><strong>注意</strong>: 一定是右边的数和中间的数进行比较，因为要考虑没有旋转的这种情况</p><h3 id="4-有序旋转数组中找到一个数-target"><a href="#4-有序旋转数组中找到一个数-target" class="headerlink" title="4. 有序旋转数组中找到一个数 target"></a>4. 有序旋转数组中找到一个数 target</h3><p>Solution:为了方便记忆，仍然使用右边的数和中间的数进行对比</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">while</span>(left&lt;=right)&#123;<br>    <span class="hljs-keyword">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(arr[mid]==target)&#123;<br>        <span class="hljs-keyword">return</span> arr[mid];<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">if</span>(arr[mid]==arr[right])&#123;<br>            right--;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr[mid]&lt;arr[right])&#123;<br>            <span class="hljs-keyword">if</span>(target&gt;arr[mid]&amp;&amp;target&lt;=arr[right])&#123;<br>                left=mid+<span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                right=mid<span class="hljs-number">-1</span>;<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(target&gt;=arr[left]&amp;&amp;target&lt;arr[mid])&#123;<br>                right=mid<span class="hljs-number">-1</span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                left=mid+<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br></code></pre></td></tr></table></figure><h3 id="5-H指数-计数排序"><a href="#5-H指数-计数排序" class="headerlink" title="5. H指数 计数排序"></a>5. H指数 计数排序</h3><p>复杂度为O(n)（计数的数组应该为size+1, 每个index的数量，如果&gt;=n全部计算为count[n]）或者二分查找(O(logn))<br>H指数II多了一个已经拍好序，以及O(logn)因此不能遍历求citation的范围；所以只能二分查找数组，不能二分查找h_指数，同时返回的应该是个数，而不是引用量<br>根据分割点右边论文的个数与分割点 citations[x] 的大小关系进行二分 。</p><h3 id="6-寻找排序矩阵中的第k个数"><a href="#6-寻找排序矩阵中的第k个数" class="headerlink" title=" 6. 寻找排序矩阵中的第k个数"></a><font color="red"> 6. 寻找排序矩阵中的第k个数</font></h3><p>二分查找算法，假设第k个数的值，然后判断小于他的数据是不是k<br> 计算mid值，查找，大于等于这个数的数量，然后right=mid  如果数量小于这个数量， left=mid+1<br>注意抓住矩阵横向和纵向都是有序的特点<br>同时在计算小于k的数量的时候，是每列每列的计算（从左下角）,因为是mid对矩阵进行划分</p><h3 id="7-蜡烛之间的盘子-可以直接使用vector自带的函数进行二分查找"><a href="#7-蜡烛之间的盘子-可以直接使用vector自带的函数进行二分查找" class="headerlink" title=" 7. 蜡烛之间的盘子,可以直接使用vector自带的函数进行二分查找"></a><font color="blue"> 7. 蜡烛之间的盘子,可以直接使用vector自带的函数进行二分查找</font></h3><p>lower_bound(vec.begin(), vec.end(), target)-vec.begin()<br>==只有两种数据， 比如0，1 找最近：使用下标的二分查找，而不是循环往前遍历==</p><h3 id="8-寻找右区间，-二分查找-hash"><a href="#8-寻找右区间，-二分查找-hash" class="headerlink" title="8. 寻找右区间， 二分查找+hash"></a>8. 寻找右区间， 二分查找+hash</h3><ul><li>按照左边排序+遍历每个区间右边，在区间二分查找，找到最近那个</li><li>因为是interval (vector<int>), 因此自己实现二分，而不是使用标准库函数里面的方法</int></li></ul><h3 id="9-我的日程安排表I"><a href="#9-我的日程安排表I" class="headerlink" title=" 9. 我的日程安排表I "></a><font color="red"> 9. 我的日程安排表I </font></h3><p>题意，就是判断是否能向当前的区间继续插入，插入之前如何高效判断，以及以如何形式表示已经插入了该区间，提示，不使用vector<interval>结构表示插入<br>    方法一：暴力算法<br>    方法二：使用map对key进行排序，之后使用二分查找，查找当前区间应该插入的位置<br>    两个考点：<br>    1.map的lower_bound and upper_bound<br>    2. 插入的时候使用mp[end]=start<br>    查找的时候查找start所在end后面的位置，这样的话就不用和左右两边进行对比，只需要对比一边就好了<br>    插入end查找start; 插入start, 查找end, 这样判断只需要判断一边<br>    方法三：使用二叉搜索树, 每个数节点，包含left,right指针，以及start,和end两个val</interval></p><p>PS 我的日程安排II III都是使用边界计数来实现，就是mp[start]++ mp[end]–</p><p><strong>总结：</strong>二分算法解决区间题目， 这三道题都比较简单，前两道是判断是否有三重或者多重预定，最后一个是判断有几重预定。但是微软有一个题目是删除最少的区间，使得预定数重叠不超过2（可以等于2）：<br>微软这道题：</p><ul><li>按照左边边排序，同时用一个优先队列记录现在ok的序列，同时优先队列按照右边排序（我们贪心地删除右边能扩展到最远的那个）</li><li>依次遍历排好序的区间，如果当前区间和优先队列中的前两个区间都有交集，那么将当区间压入优先队列中，并弹出一个区间；否则直接压入，不弹出</li></ul><p>这个其实也是上下车题目的模板代码，思想就是差分数组，只需要在两端进行标记</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxConcurrent</span> <span class="hljs-params">(vecotr&lt;vecotr&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; time)</span></span>&#123;<br>    map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; record;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; t : time)&#123;<br>        record[t[<span class="hljs-number">0</span>]] += <span class="hljs-number">1</span>;<br>        record[t[<span class="hljs-number">1</span>]] -= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>, concurrent = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; p : record)&#123;<br>        concurrent += p.second;<br>        ans = <span class="hljs-built_in">max</span>(ans, concurrent);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="10-在-D-天内送达包裹的能力"><a href="#10-在-D-天内送达包裹的能力" class="headerlink" title="10. 在 D 天内送达包裹的能力"></a>10. 在 D 天内送达包裹的能力</h3><p>使用二分搜索，查找船最低的容量，使得能在days内完成传输<br>易错点：一定要记得left 应该为里面最大的val，而不是0</p><h3 id="11-制作-m-束花所需的最少天数"><a href="#11-制作-m-束花所需的最少天数" class="headerlink" title="11. 制作 m 束花所需的最少天数"></a>11. 制作 m 束花所需的最少天数</h3><p>二分查找天数的下限，使得至少能够制作要求的花束<br>PS: 一定要注意没有找到的情况下，应该返回-1</p><h3 id="12-同时运行-N-台电脑的最长时间-hard"><a href="#12-同时运行-N-台电脑的最长时间-hard" class="headerlink" title="12. 同时运行 N 台电脑的最长时间(hard)"></a>12. 同时运行 N 台电脑的最长时间(hard)</h3><p>S=min(barries[i], mid)  Sum/mid&gt;=n<br>left=1, right=sum(barries)/n<br>也就是如果当前假设的值大于电池容量，电池就会被榨干，否则电池会被用掉mid (因此电池不会同时被多台电脑用，因此最多用掉假设t这么多的电量)</p><h3 id="13-转变数组后最接近目标值的数组和"><a href="#13-转变数组后最接近目标值的数组和" class="headerlink" title="  13.  转变数组后最接近目标值的数组和 "></a><font color="blue">  13.  转变数组后最接近目标值的数组和 </font></h3><p>二分，但是因为是绝对值，所以需要比较mid计算值比target小还是大，决定搜索那边<br>第一种思路： 这道题使用二分，但是因为是找target更近的点，因此mid的和是大于target或者小于target都有可能，虽然整体上left和right应该向target靠拢，但是最终的结果应该有另外的变量记录。==/&lt;/&gt; target的时候都不是找到了最终结果，而是候选结果。</p><p>也就是结果和left/right的变化是两个逻辑，不在一条线上</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(sum-target)&lt;dist)&#123;<br>    res=mid;<br>    dist=<span class="hljs-built_in">abs</span>(sum-target);<br>&#125;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(sum-target)==dist)&#123;<br>    <span class="hljs-keyword">if</span>(res&gt;mid)&#123;<br>        res=mid;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">if</span>(sum&gt;=target)&#123;<br>    maxvalue=mid<span class="hljs-number">-1</span>; <span class="hljs-comment">//right</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    minvalue=mid+<span class="hljs-number">1</span>; <span class="hljs-comment">//left</span><br>&#125;<br></code></pre></td></tr></table></figure><p>第二种思路: 要想确定差的绝对值最小，可以先求出比target大的最小值，结果必出在最小值和最小值-1，二选一，比较下即可</p><h3 id="14-搜索旋转排序数组-（寻找里面的某个元素target-或者里面的最小值）"><a href="#14-搜索旋转排序数组-（寻找里面的某个元素target-或者里面的最小值）" class="headerlink" title="14. 搜索旋转排序数组 （寻找里面的某个元素target/或者里面的最小值）"></a><font color="red">14. 搜索旋转排序数组 （寻找里面的某个元素target/或者里面的最小值）</font></h3><p>1） 无重复数据，直接返回下标，那么使用标准二分查找<br>2） 有重复数据，返回true或者false<br>3)  有重复数据，同时返回==target的最小的下标 (<font color="red">面试题 10.03. 搜索旋转数组</font>)<br>    a. 需要对比mid的左边的元素，因为是找到最小index b. 需要加一些条件判断，方便直接退出<br>    if(nums[left]==target) 直接返回left; if(nums[mid]==target) right=mid<br>    b. 因为需要最小的下标，所以只看中和左，不看右边<br>    c. 对左边和中间相等的端点进行单独处理， 只有确定target&gt;mid的时候，才left=mid+1; target==mid的时候不能left=mid+1；需要加一些预处理的命令<br>4） 寻找旋转排序数组的最小值-无重复元素<br>5)  寻找旋转排序数组的最小值-有重复元素<br>6） 旋转数组， 让数组向右移动k个位置，<br>    reverse(0,n-1)<br>    reverse(0,k-1)<br>    reverse(k,n-1)</p><p>总结：前三个为标准的二分查找 4，5个 为边界类型的二分查找（right=mid）；找最小值的时候比较mid和right的值，找target的最小下标使用left, mid进行比较，其余情况两种都可以</p><h3 id="15-面试题-10-10-数字流的秩"><a href="#15-面试题-10-10-数字流的秩" class="headerlink" title="15. 面试题 10.10. 数字流的秩"></a>15. 面试题 10.10. 数字流的秩</h3><ul><li>先随机插入一些数，如何找到小于等于x的数据个数</li><li>方法1：插入的时候顺序插入，在查找的时候，使用二分查找</li><li>方法2：使用树状数组</li></ul><h3 id="16-lc363-矩形区域不超过-K-的最大数值和-二维前缀和问题"><a href="#16-lc363-矩形区域不超过-K-的最大数值和-二维前缀和问题" class="headerlink" title="16. lc363. 矩形区域不超过 K 的最大数值和(二维前缀和问题)"></a>16. lc363. 矩形区域不超过 K 的最大数值和(二维前缀和问题)</h3><ul><li>求一个矩阵内部一个矩阵和小于k的最大数值和</li><li>枚举上下两边，然后求和时累加前面（减少空间复杂度），查找的时候使用二分查找（nlogn），大于sum[i]-k的最小值(lower_bound因为是大于等于)</li></ul><h3 id="17-lc373-查找和最小的-K-对数字"><a href="#17-lc373-查找和最小的-K-对数字" class="headerlink" title="17. lc373. 查找和最小的 K 对数字"></a>17. lc373. 查找和最小的 K 对数字</h3><p>优先队列+使用多路归并：<br>nums1[0]: nums2[0]-nums2[9]<br>nums1[1]: nums2[0]-nums2[9]<br>…<br>nums1[9]: nums2[0]-nums2[9]<br>多条路，每条路都是压入第一个元素<br>从优先队列中弹出一个元素（压入），看他在哪条路中，然后压入这条路的后一个元素</p><h3 id="18-lc1235-规划兼职工作"><a href="#18-lc1235-规划兼职工作" class="headerlink" title="18. lc1235. 规划兼职工作"></a>18. lc1235. 规划兼职工作</h3><ul><li>题意：找到不重叠而且profit最大的区间段</li><li>解决方法：使用dp+二分算法， 首先将区间按照endTime进行排序，然后定义dp为 0-i之间的最大的利益，然后使用二分找到0到i-1之间endTime&lt; i start_time的最后的区间，然后进行状态转移<br>f[i]=f[i-1]<br>f[i] = max(f[i], f[r] + q[i][2]); </li><li>为了减少区间0的判断，区间的编号可以直接从1开始向后</li><li>易错点：最主要在进行动态规划的时候dp[i]不能定义为以i结尾的最大profit，只能定义为前i个最大的profit, 因为在进行二分的时候，可能有多个endTime相同，因此选择哪个i是未知的，如果dp定义为区间段，那么就知道选择的是最右边的i</li></ul><h3 id="19-求x的平方根"><a href="#19-求x的平方根" class="headerlink" title="19. 求x的平方根"></a>19. 求x的平方根</h3><ul><li>方法1：牛顿法<br>将x看成常量C, 即使你将第一个数选择C，但是推公式的时候一定要注意x0和C不能写成一样</li><li>y=x^2-C 求y=0的解。 y-(x0^2-C)=2<em>x0(x-x0)<br>然后y=0 求得x也就是x1=-(x0^2-C)/2</em>x0+x0</li><li>方法2：使用二分算法</li></ul><h3 id="20-lc786-第-K-个最小的素数分数"><a href="#20-lc786-第-K-个最小的素数分数" class="headerlink" title="20. lc786. 第 K 个最小的素数分数"></a><font color="blue">20. lc786. 第 K 个最小的素数分数</font></h3><ul><li>每行是有序的，找到第k个数</li><li>使用二分搜索或者多路归并</li><li>二分搜索就是先猜测一个数，然后计算小于它的count和小于它的数中最大的数，如果count==k那么说明找到答案，否则change right or left重复这样的过程</li><li>多路归并，就是先将多路的头节点都压入一个优先队列，然后将最小的弹出来，压入弹出来的后面的一个数（需要检查这个数后面是有数的），然后重复这样的过程，直到弹出了k个数</li><li>扩展：一个矩阵横着递增，竖着递增（有序矩阵中第K小的元素）<br>不同：这道题是横着递增，竖着递减；所以应该i++, j++; 扩展题应该x++, y–</li></ul><h3 id="21-数据流相关问题"><a href="#21-数据流相关问题" class="headerlink" title=" 21. 数据流相关问题 "></a><font color="red"> 21. 数据流相关问题 </font></h3><p>problem1: lc295数据流的中位数<br>使用一个最小堆， 最大堆（优先队列) 奇数的时候插入最大，然后移除一个元素到最小，偶数的时候反过来<br>problem2: 在一个数据流中找一个元素的左右边界<br>别人思路：我觉得如果不能得到数组的长度，可以用2的n次方的形式从左往右遍历数组，找到一个合适的右边界。比如说依次访问数组下标为1，2，4，8，16，32，64的值，如果这个位置的值大于给定的数字就把这个数设置成右边界，然后同样二分去找，但会有越界问题，需要处理这种error，时间复杂度是O(logN)</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>结果是整数, 数组排好序，或者数值选择有规律</li><li>时间复杂度要求O(nlogn)</li><li>类似于一种缩小范围的随机查找, 有方向的猜测</li><li>寻找类型题，可以考虑二分，如果是最大最小题，可以试试动态规划或者二分算法<br>找第k个数，不一定需要排序，可以直接二分猜测+计数验证</li><li>区间问题，感觉总是出错，一般用二分或者贪心算法</li><li>二分算法也可能用于多路归并（优先队列）的题型</li></ol>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划</title>
      <link href="/2021/11/13/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%A2%98%E5%9E%8B/"/>
      <url>/2021/11/13/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%A2%98%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="求总数问题"><a href="#求总数问题" class="headerlink" title="求总数问题"></a>求总数问题</h2><h3 id="1-回文字符串的个数"><a href="#1-回文字符串的个数" class="headerlink" title="1. 回文字符串的个数"></a>1. 回文字符串的个数</h3><h3 id="2-表达式为期望结果的总数"><a href="#2-表达式为期望结果的总数" class="headerlink" title="2. 表达式为期望结果的总数"></a>2. 表达式为期望结果的总数</h3><ul><li>也是区间dp, dp[i][j][0]或者dp[i][j][1])</li><li>因为不是表达式的个数，而是达到期望值的个数，因此要记录一个表达式的值，用三维数组</li></ul><h3 id="3-能够组成的二叉树的个数"><a href="#3-能够组成的二叉树的个数" class="headerlink" title="3. 能够组成的二叉树的个数"></a>3. 能够组成的二叉树的个数</h3><h3 id="4-打气球的最大分数-区间dp"><a href="#4-打气球的最大分数-区间dp" class="headerlink" title="4. 打气球的最大分数(区间dp)"></a>4. 打气球的最大分数(区间dp)</h3><ul><li>虽然不是求个数，而是求最大，但是也是与当前状态的左右边界有关。因为最终结果和左右两边有关，因此都是枚举的长度+右边界，计算左边界，进行动态规划<br>转移方程：考虑这个区间上最后一个气球的打破方式，即最后一个气球的打破位置。在左边右边和中间<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">f[i][j] = <span class="hljs-built_in">max</span>( f[i][j], f[i][k - <span class="hljs-number">1</span>] + f[k + <span class="hljs-number">1</span>][j] + a[k] * a[i - <span class="hljs-number">1</span>] * a[j + <span class="hljs-number">1</span>]); <span class="hljs-comment">//闭区间的更新方式</span><br></code></pre></td></tr></table></figure></li></ul><p>在leetcode上面的一道原题，只是描述改变了<br>lc312. 戳气球</p><ul><li>这道题如果将dp[i][j]定义为开区间或得的最大值就更容易理解<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">状态转移： dp[i][j]=<span class="hljs-built_in">max</span>(dp[i][j], dp[i][k]+dp[k][j]+val[i]*val[k]*val[j]);<span class="hljs-comment">//开区间的更新方式</span><br></code></pre></td></tr></table></figure></li><li>注意为了减少情况的分类讨论，需要在左右两边都加上1，这样的话枚举一个区间留下的最后一个数，也是可以求得值的</li></ul><h3 id="5-旋变字符串问题-区间dp-lc87-扰乱字符串"><a href="#5-旋变字符串问题-区间dp-lc87-扰乱字符串" class="headerlink" title="5. 旋变字符串问题 (区间dp) lc87. 扰乱字符串"></a>5. 旋变字符串问题 (区间dp) lc87. 扰乱字符串</h3><ul><li>四重循环，三维dp（两个字符串两个端点+一个长度）</li><li>这道题不是求个数，而是求是否，但是仍然是需要枚举长度的问题，因为是两个字符串，所以应该有4个边，但是运用长度相等的信息，将思维坐标转为左边坐标+size, 成为三维问题<br>dp[start1][start2][len] 而且这道题有两个长度：一个是总字符串长度，一个是总字符串化为为两个旋变字符串的长度  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> size = <span class="hljs-number">2</span>; size &lt;= n; size++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> l1 = <span class="hljs-number">0</span>; l1 &lt;= n - size; l1++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> l2 = <span class="hljs-number">0</span>; l2 &lt;= n - size; l2++)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> leftPart = <span class="hljs-number">1</span>; leftPart &lt; size; leftPart++)&#123;<br>                    <span class="hljs-keyword">if</span>((dp[l1][l2][leftPart] &amp;&amp; dp[l1 + leftPart][l2 + leftPart][size - leftPart]) || <br>                        (dp[l1][l2 + size - leftPart][leftPart] &amp;&amp; dp[l1 + leftPart][l2][size - leftPart]))&#123;<br>                        dp[l1][l2][size] = <span class="hljs-literal">true</span>;      <span class="hljs-comment">// 只要有一个leftPart满足旋变串条件就可以break出去</span><br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="6-数字字符串转为字母组合的总数"><a href="#6-数字字符串转为字母组合的总数" class="headerlink" title="6. 数字字符串转为字母组合的总数"></a>6. 数字字符串转为字母组合的总数</h3><ul><li>因为只是与之前的结果或者后面的结果有关，因此只需要从左到右枚举下标就可以了<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++">递推式<br><span class="hljs-comment">// 第 i 个字符只能单独转换为一个 字母</span><br><span class="hljs-comment">// dp[i-1] ：第 i 个字符单独转换的方案数</span><br>dp[i]=dp[i<span class="hljs-number">-1</span>];<br><span class="hljs-comment">// 第 i 个字符 可以和 第 i-1 个字符 共同转换为一个 字母</span><br><span class="hljs-comment">// dp[i-1] ：第 i 个字符单独转换的方案数</span><br><span class="hljs-comment">// dp[i-2] ：第 i 个字符，结合第 i-1 个字符组合转换为一个字母的方案数</span><br>dp[i]=dp[i<span class="hljs-number">-1</span>]+dp[i<span class="hljs-number">-2</span>];<br><span class="hljs-comment">//如果第i个字符不能单独存在那么</span><br>dp[i]=<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="7-组合总数IV"><a href="#7-组合总数IV" class="headerlink" title="7. 组合总数IV"></a>7. 组合总数IV</h3><ul><li>可以用作骰子问题的解决方案， 600个点数扔出400点总共有多少种方案</li><li>总结：如果排序不同算不同的排列组合的话那么 target循环在外侧， nums总数循环在内侧  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=target;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;size;j++)&#123; <span class="hljs-comment">//最后这个数1-size都可以选择</span><br>            <span class="hljs-keyword">if</span>(i&gt;=nums[j]&amp;&amp;dp[i - nums[j]] &lt; INT_MAX - dp[i])&#123;<br>                dp[i]+=dp[i-nums[j]]; <span class="hljs-comment">//只需要一维就好</span><br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></li><li>如果排序不同算相同的排列祝贺的话那么， target循环在内侧，nums总数循环在外侧, 完全背包问题  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=size;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=target;j++)&#123;<br>        dp[i][j]+=dp[i<span class="hljs-number">-1</span>][j];<br>        <span class="hljs-keyword">if</span>(j&gt;=nums[i<span class="hljs-number">-1</span>])&#123;<br>            dp[i][j]+=dp[i][j-nums[i<span class="hljs-number">-1</span>]]; <span class="hljs-comment">//完全背包</span><br>        &#125;<br>    &#125;<br>&#125;<br>- 如果是&#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>&#125;可以重复选择每个数组成target的话，使用完全背包<br>dp[i][j]=dp[i][j-nums[i]]+dp[i<span class="hljs-number">-1</span>][j]<br></code></pre></td></tr></table></figure></li></ul><h3 id="8-删除回文子数组"><a href="#8-删除回文子数组" class="headerlink" title="8. 删除回文子数组"></a>8. 删除回文子数组</h3><ul><li>区间dp/枚举长度的dp</li><li>数组，每次可以删除一个数字，或者删除掉一个回文串，求删除需要的最少次数<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">dp<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-attr">[j]</span>=min(dp<span class="hljs-selector-attr">[i+1]</span><span class="hljs-selector-attr">[j-1]</span>, dp<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-attr">[j]</span>) <span class="hljs-keyword">if</span> <span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[i]</span>==<span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[j]</span><br>dp<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-attr">[j]</span>=min(dp<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-attr">[k]</span>+dp<span class="hljs-selector-attr">[k+1]</span><span class="hljs-selector-attr">[j]</span>, dp<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-attr">[j]</span>)<br>dp长度从<span class="hljs-number">3</span>开始，dp长度为<span class="hljs-number">1</span>， <span class="hljs-number">2</span>的时候使用初始化<br></code></pre></td></tr></table></figure></li><li>答案见：<a href="https://cloud.tencent.com/developer/article/1659691">LeetCode 1246. 删除回文子数组（区间DP）-腾讯云开发者社区-腾讯云</a> 可以作为区间dp模板，但是枚举长度和转移方程那里可以修改一下</li></ul><h3 id="9-lc115-不同的子序列-具体分析见字符串匹配问题"><a href="#9-lc115-不同的子序列-具体分析见字符串匹配问题" class="headerlink" title="9. lc115. 不同的子序列 (具体分析见字符串匹配问题)"></a>9. lc115. 不同的子序列 (具体分析见字符串匹配问题)</h3><h3 id="10-lc446-等差数列划分-II-子序列（hard）"><a href="#10-lc446-等差数列划分-II-子序列（hard）" class="headerlink" title="10. lc446. 等差数列划分 II - 子序列（hard）"></a>10. lc446. 等差数列划分 II - 子序列（hard）</h3><ul><li>题意：等差子序列个数，可不连续，每个序列至少包含3个数</li><li>我的困难地方在于，这个序列长度要等于3，那么将序列==2的如何处理，如果出现重复如何处理 比如2  1 2 3</li><li>官方解题方案是，计算弱等差子序列的个数（序列==2），然后再计算结果的时候遍历三个数，同时因为差为负数，所以使用hash_map数组vector&lt;unordered_map&lt;long long, int&gt;&gt; d(size)</li><li>将记录以某一下标结尾的序列中包含的数个数，转为差为d的对数（个数-&gt;对数）</li></ul><h3 id="11-lc1000-合并石头的最低成本-hard"><a href="#11-lc1000-合并石头的最低成本-hard" class="headerlink" title="11. lc1000. 合并石头的最低成本(hard)"></a>11. lc1000. 合并石头的最低成本(hard)</h3><ul><li>区间dp的经典题目，四重区间dp</li><li>将i，j之间的num堆转为 区间划分前面1堆后面num-1堆，然后因为连续k堆可以转为一堆，所以单独对于dp[i][j][k]单独进行转换为dp[i][j][1]<br>dp[i][j][num]=min(dp[i][j][num], dp[i][q][1]+dp[q+1][j][num-1]); //num表示num堆， 注意没有必要枚举dp[i][q][2]+dp[q+1][j][num-2]//这种情况，因为下标划分已经达到枚举的作用</li></ul><h3 id="12-lc1130-叶值的最小代价生成树"><a href="#12-lc1130-叶值的最小代价生成树" class="headerlink" title="12. lc1130. 叶值的最小代价生成树"></a>12. lc1130. 叶值的最小代价生成树</h3><ul><li><p>注意题意：中序遍历要对应！！！（相邻顺序不变的题，一般使用区间dp）</p></li><li><p>解决方法：区间dp或者贪心算法<br>状态转移方程<br>f[i][j]=min(f[i][j],f[i][k]+f[k+1][j]+g[i][k]∗g[k+1][j]</p></li><li><p><a href="https://leetcode.cn/problems/minimum-cost-tree-from-leaf-values/solution/qu-jian-dp-dong-tai-gui-hua-die-dai-xie-g4jac/">参考链接</a></p></li></ul><h3 id="13-lc1039-多边形三角剖分的最低得分"><a href="#13-lc1039-多边形三角剖分的最低得分" class="headerlink" title="13. lc1039. 多边形三角剖分的最低得分"></a>13. lc1039. 多边形三角剖分的最低得分</h3><ul><li>区间dp问题</li><li>主要找到中间那个三角形+左右两边子问题， 直接划分为两个子问题做不出来</li><li>不要想象为环形</li></ul><h3 id="14-和为偶数的子数组的个数，-子序列的个数"><a href="#14-和为偶数的子数组的个数，-子序列的个数" class="headerlink" title="14. 和为偶数的子数组的个数， 子序列的个数"></a>14. 和为偶数的子数组的个数， 子序列的个数</h3><p>扩展：长度为n， 使用二维状态转移方程<br>思路：转为0 1， 然后和为奇数和偶数分开计算</p><ul><li><p>子数组的个数：（连续）</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus">当前值为<span class="hljs-number">0</span>：<br>even<span class="hljs-selector-attr">[i]</span>=even<span class="hljs-selector-attr">[i-1]</span>+<span class="hljs-number">1</span><span class="hljs-comment">//以i结尾的偶数子数组的个数</span><br>odd<span class="hljs-selector-attr">[i]</span>=odd<span class="hljs-selector-attr">[i-1]</span> <span class="hljs-comment">// 以i结尾的奇数子数组的个数</span><br>当前值为<span class="hljs-number">1</span>: <br>odd<span class="hljs-selector-attr">[i]</span>=even<span class="hljs-selector-attr">[i-1]</span>+<span class="hljs-number">1</span><span class="hljs-comment">//以i结尾的偶数子数组的个数</span><br>even<span class="hljs-selector-attr">[i]</span>=odd<span class="hljs-selector-attr">[i-1]</span> <span class="hljs-comment">// 以i结尾的偶数子数组的个数</span><br>最后结果是even<span class="hljs-selector-attr">[0~n-1]</span><br></code></pre></td></tr></table></figure></li><li><p>子序列的个数：（连续）</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus">当前值为<span class="hljs-number">0</span>：<br>even<span class="hljs-selector-attr">[i]</span>=<span class="hljs-number">2</span>*even<span class="hljs-selector-attr">[i-1]</span>+<span class="hljs-number">1</span><span class="hljs-comment">//以i结尾的偶数子数组的个数</span><br>odd<span class="hljs-selector-attr">[i]</span>=<span class="hljs-number">2</span>*odd<span class="hljs-selector-attr">[i-1]</span> <span class="hljs-comment">// 以i结尾的奇数子数组的个数</span><br>当前值为<span class="hljs-number">1</span>: <br>even<span class="hljs-selector-attr">[i]</span>=even<span class="hljs-selector-attr">[i-1]</span>+odd<span class="hljs-selector-attr">[i-1]</span><span class="hljs-comment">//以i结尾的偶数子数组的个数</span><br>odd<span class="hljs-selector-attr">[i]</span>=odd<span class="hljs-selector-attr">[i-1]</span>+even<span class="hljs-selector-attr">[i-1]</span>+<span class="hljs-number">1</span> <span class="hljs-comment">// 以i结尾的偶数子数组的个数</span><br>最后返回even<span class="hljs-selector-attr">[size-1]</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="求最大最小问题"><a href="#求最大最小问题" class="headerlink" title="求最大最小问题"></a>求最大最小问题</h2><p>PS: 子串都是要求连续的，而子序列是不要求连续的</p><h3 id="1-扔鸡蛋-lc887"><a href="#1-扔鸡蛋-lc887" class="headerlink" title="1. 扔鸡蛋 lc887"></a>1. 扔鸡蛋 lc887</h3><p><a href="https://zhuanlan.zhihu.com/p/92288604">https://zhuanlan.zhihu.com/p/92288604</a></p><ul><li>两种状态转移：<br>  a. dp[k][n], k个鸡蛋n层楼， 需要最少扔多少次  <figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">dp<span class="hljs-comment">[1]</span><span class="hljs-comment">[N]</span> = N<br>dp<span class="hljs-comment">[..]</span><span class="hljs-comment">[0]</span> = 0<br>for i=1到n:<br>    dp<span class="hljs-comment">[k]</span><span class="hljs-comment">[n]</span>=min(dp<span class="hljs-comment">[k]</span><span class="hljs-comment">[n]</span>, max(dp<span class="hljs-comment">[k]</span><span class="hljs-comment">[i-1]</span>+dp<span class="hljs-comment">[k-1]</span><span class="hljs-comment">[n-i]</span>)+1);//不需要在第i层再扔，因此删除i<br></code></pre></td></tr></table></figure>  b. dp[k][m], k个鸡蛋扔m次，可以验证的最大楼层数  <figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs inform7">dp<span class="hljs-comment">[0]</span><span class="hljs-comment">[..]</span> = 0<br>dp<span class="hljs-comment">[..]</span><span class="hljs-comment">[0]</span> = 0<br>whle(dp<span class="hljs-comment">[K]</span><span class="hljs-comment">[m]</span>&lt;N)&#123;<br>    m++;<br>    for (int k = 1; k &lt;= K; k++)&#123;<br>        dp<span class="hljs-comment">[k]</span><span class="hljs-comment">[m]</span> = dp<span class="hljs-comment">[k]</span><span class="hljs-comment">[m - 1]</span> + dp<span class="hljs-comment">[k - 1]</span><span class="hljs-comment">[m - 1]</span> + 1;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>整体解法<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> ans=<span class="hljs-number">-1</span>;<br>vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n+<span class="hljs-number">1</span>,vector&lt;<span class="hljs-keyword">int</span>&gt;(k+<span class="hljs-number">1</span>));<br><span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>&amp;k&gt;=<span class="hljs-number">1</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++)&#123;<br>    dp[i][<span class="hljs-number">1</span>]=i; <span class="hljs-comment">//一个鸡蛋</span><br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=k;j++)&#123;<br>    dp[<span class="hljs-number">1</span>][j]=<span class="hljs-number">1</span>; <span class="hljs-comment">//一次操作</span><br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123; <span class="hljs-comment">//n次操作</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=k;j++)&#123; <span class="hljs-comment">//k个鸡蛋</span><br>        dp[i][j]=dp[i<span class="hljs-number">-1</span>][j]+dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(dp[i][k]&gt;=n)&#123;<br>            ans=i;<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-最长递增子串"><a href="#2-最长递增子串" class="headerlink" title="2. 最长递增子串"></a>2. 最长递增子串</h3><h3 id="3-最长递增子序列"><a href="#3-最长递增子序列" class="headerlink" title="3. 最长递增子序列"></a>3. 最长递增子序列</h3><p>两种方法：</p><ul><li>两重循环</li><li>单调栈+二分查找<br>扩展 最长递增子序列的个数，时间复杂度仍然是O(n^2)，只是多了一个cnt, 每次出现最大就更新，否则进行cnt的累加</li></ul><p>另外类似的题目: 1027. 最长等差数列<br>dp[i][j]表示以i结尾而且差为j的最长数列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;i;j++)&#123;<br>        <span class="hljs-keyword">int</span> tmp=nums[i]-nums[j];<span class="hljs-comment">//因为差可能是负数</span><br>        dp[i][tmp+<span class="hljs-number">1000</span>]=dp[j][tmp+<span class="hljs-number">1000</span>]+<span class="hljs-number">1</span>;<br>        res=<span class="hljs-built_in">max</span>(res, dp[i][tmp+<span class="hljs-number">1000</span>]);   <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>lc1218. 最长定差子序列： 这道题diff是定了，因此只需要一维hash就可以了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>    hash[arr[i]]=<span class="hljs-built_in">max</span>(hash[arr[i]-difference]+<span class="hljs-number">1</span>, hash[arr[i]]);<br>    res=<span class="hljs-built_in">max</span>(res, hash[arr[i]]);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-最长公共子串（要求连续）"><a href="#4-最长公共子串（要求连续）" class="headerlink" title="4. 最长公共子串（要求连续）"></a>4. 最长公共子串（要求连续）</h3><pre><code class="hljs">- 注意和子序列的区别：动态规划转移方程是 dp[i][j]=dp[i-1][j-1]+1 or dp[i][j]=0表示以i或者j结尾的子串， 最后遍历二维数组求最大值</code></pre><p>求具体的最长公共子串，只需要动态规划的时候，记录最长的公共子串的下标，然后<code>s.substr(start_pos = index-maxlen+1, len = maxlen)</code>就可以了</p><h3 id="5-最长公共子序列-（最长长度-最长具体序列-最短包含序列）"><a href="#5-最长公共子序列-（最长长度-最长具体序列-最短包含序列）" class="headerlink" title="5. 最长公共子序列 （最长长度/最长具体序列/最短包含序列）"></a>5. 最长公共子序列 （最长长度/最长具体序列/最短包含序列）</h3><ul><li>题意改变，但是代码不变的题目–不相交的线</li><li>相似的题目：</li></ul><ol><li>编辑距离</li><li>两个字符串的删除操作， 可以直接动态规划求最少的删除字符数量，也可以用最长公共子序列，然后用m+n-2*lcs</li></ol><ul><li>如果要求具体删除的是哪些字符串，两种方法应该都是可以的</li><li>动态规划转移方程是 <figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>=dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>+1 or dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>=max(dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j-1]</span>, dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[j]</span>)<br></code></pre></td></tr></table></figure>dp[i-1][j] 表示以i或者j结尾的子串中包括的最长公共子序列（不一定是以i j结尾）， 所以最后只用直接返回dp[m][n]</li><li>在求最长的公共子序列的时候，需要使用dp转换等式 i–,j– 或者j–, 或者i–来进行查找最长的公共子序列， 同时也可以求最短的删除的字符具体是哪些<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> i = m<span class="hljs-number">-1</span>, j = n<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">if</span>(s1.<span class="hljs-built_in">charAt</span>(i) == s2.<span class="hljs-built_in">charAt</span>(j))&#123;<br>        res.<span class="hljs-built_in">append</span>(s1.<span class="hljs-built_in">charAt</span>(i));<br>        i--;<br>        j--;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span> &amp;&amp; j&gt;<span class="hljs-number">0</span> &amp;&amp; s1.<span class="hljs-built_in">charAt</span>(i) != s2.<span class="hljs-built_in">charAt</span>(j))&#123;<br>        <span class="hljs-keyword">if</span>(dp[i<span class="hljs-number">-1</span>][j] &gt; dp[i][j<span class="hljs-number">-1</span>])<br>            i--;<br>        <span class="hljs-keyword">else</span><br>            j--;<br>        <span class="hljs-comment">//dp[i-1][j] &lt; dp[i][j-1]时,j--;</span><br>        <span class="hljs-comment">//dp[i-1][j] = dp[i][j-1]时,i--或j--,这里统一为j--;</span><br>    &#125;<br>    <br>    <span class="hljs-comment">//行或列到达边界</span><br>    <span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>)j--;<br>    <span class="hljs-keyword">if</span>(j==<span class="hljs-number">0</span>)i--;<br>&#125;<br></code></pre></td></tr></table></figure>PS: lc1092. 最短公共超序列</li><li>求包含两个字符的最短序列， 其实就是m+n-k(k为公共序列的长度)<br>相比于公共序列， 会在i–, j– 都push_back字符; 求具体的公共序列的时候，只有相等的时候才push相等的字符<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> i=size1<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">int</span> j=size2<span class="hljs-number">-1</span>;<br>string res;<br><span class="hljs-keyword">while</span>(i&gt;<span class="hljs-number">0</span>&amp;&amp;j&gt;<span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">if</span>(str1[i]==str2[j])&#123;<br>        res.<span class="hljs-built_in">push_back</span>(str1[i]);<br>        i--;j--;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">if</span>(dp[i<span class="hljs-number">-1</span>][j]&gt;dp[i][j<span class="hljs-number">-1</span>])&#123;<br>            res.<span class="hljs-built_in">push_back</span>(str1[i]);<br>            i--;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            res.<span class="hljs-built_in">push_back</span>(str2[j]);<br>            j--;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">while</span>(i&gt;<span class="hljs-number">0</span>)&#123;<br>    res.<span class="hljs-built_in">push_back</span>(str1[i--]);<br>&#125;<br>    <span class="hljs-keyword">while</span>(j&gt;<span class="hljs-number">0</span>)&#123;<br>    res.<span class="hljs-built_in">push_back</span>(str2[j--]);<br>&#125;<br><span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>());<br></code></pre></td></tr></table></figure></li></ul><h3 id="6-最长回文子序列"><a href="#6-最长回文子序列" class="headerlink" title="6. 最长回文子序列"></a>6. 最长回文子序列</h3><ul><li>不要求连续，枚举长度</li><li>初始化长度为1和2的情况，然后<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> len=<span class="hljs-number">3</span>;len&lt;=s_len;len++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> left=<span class="hljs-number">0</span>;left&lt;s_len;left++)&#123;<br>        <span class="hljs-keyword">int</span> right=left+len<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">if</span>(right&lt;s_len)&#123;<br>            dp[left][right]=<span class="hljs-built_in">max</span>(dp[left+<span class="hljs-number">1</span>][right], dp[left][right<span class="hljs-number">-1</span>]);<br>            <span class="hljs-keyword">if</span>(s[left]==s[right])&#123;<br>                dp[left][right]=<span class="hljs-built_in">max</span>(dp[left][right],dp[left+<span class="hljs-number">1</span>][right<span class="hljs-number">-1</span>]+<span class="hljs-number">2</span>);<br>            &#125; <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="7-最长回文子串的问题-（判断true-false的dp系列）"><a href="#7-最长回文子串的问题-（判断true-false的dp系列）" class="headerlink" title="7. 最长回文子串的问题 （判断true/false的dp系列）"></a>7. 最长回文子串的问题 （判断true/false的dp系列）</h3><ul><li>可以用动态规划也可以用从中间向两边扩展的方法<br>动态规划dp[left][right]不是表示长度，而是表示是否为回文子串，在求长度使用一个公共变量max_len,每求出dp 如果dp为1那么更新max_len</li></ul><h3 id="8-最长有效括号子串"><a href="#8-最长有效括号子串" class="headerlink" title="8. 最长有效括号子串"></a>8. 最长有效括号子串</h3><ul><li>方法一：动态规划</li><li>转移方程 dp[i]:以i结尾的最长有效括号子串 转移方程如下<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;s_len;i++)&#123;<br>    <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;)&#x27;</span>)&#123;<br>        <span class="hljs-keyword">int</span> j=i-dp[i<span class="hljs-number">-1</span>]<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">if</span>(j&gt;=<span class="hljs-number">0</span>&amp;&amp;s[j]==<span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>            dp[i]=dp[i<span class="hljs-number">-1</span>]+<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(j<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>)&#123;<br>                dp[i]+=dp[j<span class="hljs-number">-1</span>];<br>            &#125;<br>        &#125;<br>        result=<span class="hljs-built_in">max</span>(result, dp[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>方法二：下标栈，栈低维护的是最后一个没有被匹配的右括号下标，如果<code>s[i]==&#39;(&#39;</code>入栈下标; 如果<code>s[i]==&#39;)&#39;</code>, 栈中弹出一个元素，如果栈为空，直接<code>push(i) continue</code>，否则更新<code>ans=max(ans, i-s.peek())</code></li></ul><h3 id="9-分割回文串系列题目"><a href="#9-分割回文串系列题目" class="headerlink" title="9. 分割回文串系列题目"></a>9. 分割回文串系列题目</h3><ol><li>分割回文串1</li></ol><ul><li>动态规划+回溯dfs，求所有i， j之间的子字符串p[i][j]是否是回文（类似最长回文子串的题目）</li></ul><ol start="2"><li>分割回文串2</li></ol><ul><li>求最少分割次数<ul><li>这道题不能使用枚举长度和左边界+枚举分割点的方式，时间复杂度太高（O(N^3)）</li><li>正确的解决方案是，求dp[i] 从0到i需要分割的最少次数，同时事先需要使用动态规划求出任意i j之间是否是回文串；如果0-i是回文串，直接结果为0，否则依次遍历i之后的字符串，找到回文串j+1-i，同时更新dp[i]=min(dp[i], dp[j]+1)</li><li>这道题可以和“子数组异或值为0的最多划分”进行类比（动态规划+map映射上一个位置）；不同之处这道题通过回文串映射到上一个位置，异或和是通过异或值为和当前值相同隐射到上一个位置<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;s_len;i++)&#123;<br>    dp[i]=INT_MAX;<br>&#125;<br>dp[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;s_len;i++)&#123;<br>    <span class="hljs-keyword">if</span>(p[<span class="hljs-number">0</span>][i])&#123;<br>        dp[i]=<span class="hljs-number">0</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;i;j++)&#123; <span class="hljs-comment">//类似最长递增序列 需要预处理，i, j之间是否为回文， 预处理代码i为逆序，j为顺序</span><br>            <span class="hljs-keyword">if</span>(p[j+<span class="hljs-number">1</span>][i])&#123;<br>                dp[i]=<span class="hljs-built_in">min</span>(dp[i], dp[j]+<span class="hljs-number">1</span>);<span class="hljs-comment">//每一个被分割的子字符串都必须要为回文</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>&#125;<br><span class="hljs-keyword">return</span> dp[s_len<span class="hljs-number">-1</span>];<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="10-背包问题"><a href="#10-背包问题" class="headerlink" title="10. 背包问题"></a>10. 背包问题</h3><ul><li><p>比较难的例题：货物转移（lintcode-困难） 反向dp（求背包数最少）+滚动数组+额外条件</p><ul><li>相当于转为两个题：</li></ul><ol><li>从n个背包里面选择最少的背包使得背包容量大于等于sum（与选最大价值使得，重量小于sum相反）</li><li>假设1求出来的结果为m, 从n个背包里面选择m个背包使得转移最少–&gt;选出的n个背包里面包含货物最多（weight最大）<br>相当于在状态转移方程再加上了一个weight数组的更新，具体代码如下：<br>dp[i]表示使得容量达到i（大于等于i），选择的最少的背包；<br>weight[i]表示使得背包容量达到i（大于等于i），在选择的背包最少的前提下，背包里原本包含的货物最多。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=sum;j&gt;=<span class="hljs-number">1</span>;j--)&#123; <span class="hljs-comment">//0-1背包问题</span><br>            <span class="hljs-keyword">int</span> tmp=<span class="hljs-built_in">max</span>(j-b[i], <span class="hljs-number">0</span>);<br>            <span class="hljs-comment">// dp[j]=min(dp[tmp]+1, dp[j]); 实际上的状态转移</span><br>            <span class="hljs-keyword">if</span>(dp[j]&lt;dp[tmp]+<span class="hljs-number">1</span>)&#123;  <span class="hljs-comment">//拆分后的状态转移</span><br>                <span class="hljs-comment">// weight[j]=weight[tmp];</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dp[j]==dp[tmp]+<span class="hljs-number">1</span>)&#123;<br>                weight[j]=<span class="hljs-built_in">max</span>(weight[j], weight[tmp]+a[i]); <span class="hljs-comment">//背包数量一样，选择权重加起来更大的背包</span><br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dp[j]&gt;dp[tmp]+<span class="hljs-number">1</span>)&#123;<br>                dp[j]=dp[tmp]+<span class="hljs-number">1</span>;<br>                weight[j]=weight[tmp]+a[i];<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></li></ol></li><li><p>扩展的有关于 分组背包的问题（），每个组k的数量还不一样<br>分组背包：每组物品有若干个，同一组内的物品最多只能选一个。（每组中物品不同，个数和体积都可能不一样）<br>多重背包: 有N种物品和一个容量为V 的背包。第i种物品最多有Mi件可用，每件耗费的空间是Ci ，价值是Wi (每组物品相同，且个数相等)</p><figure class="highlight c++"><figcaption><span>分组背包伪代码 和多重背包有点类似也是三重循环</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//注意这里是三层循环</span><br>    <span class="hljs-keyword">for</span> 所有的组k<br>        <span class="hljs-keyword">for</span> v=V to <span class="hljs-number">0</span><br>            <span class="hljs-keyword">for</span> 所有属于组k的i <br>            f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;<br>            end<br>        end<br>    end<br></code></pre></td></tr></table></figure><p>例题：lc2218. 从栈中取出 K 个硬币的最大面值和（hard）</p></li><li><p>使用前缀和+动态规划</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123; <span class="hljs-comment">//注意1-n, 之后piles在进行下标访问的时候需要i-1</span><br>    <span class="hljs-keyword">int</span> size=piles[i<span class="hljs-number">-1</span>].<span class="hljs-built_in">size</span>();<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">presum</span><span class="hljs-params">(piles[i<span class="hljs-number">-1</span>].size(), <span class="hljs-number">0</span>)</span></span>;<br>    presum[<span class="hljs-number">0</span>]=piles[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>];<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">1</span>;k&lt;size;k++)&#123;<br>        presum[k]=presum[k<span class="hljs-number">-1</span>]+piles[i<span class="hljs-number">-1</span>][k]; <span class="hljs-comment">//用前缀和表示选择前面z个</span><br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=k;j++)&#123;<br>        dp[i][j]=dp[i<span class="hljs-number">-1</span>][j];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> z=<span class="hljs-number">1</span>;z&lt;=size;z++)&#123; <span class="hljs-comment">//每组的size可能都不相同</span><br>            <span class="hljs-keyword">if</span>(j&gt;=z)&#123;<br>                dp[i][j]=<span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][j-z]+presum[z<span class="hljs-number">-1</span>], dp[i][j]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">return</span> dp[n][k];<br></code></pre></td></tr></table></figure></li><li><p>背包问题求具体的转移方案：我们可以用g_{i,v}表示第 i件物品占用空间为 v的时候是否选择了此物品。</p><figure class="highlight c++"><figcaption><span>(感觉应该是0-1背包的)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> v = V;  <span class="hljs-comment">// 记录当前的存储空间</span><br><span class="hljs-comment">// 因为最后一件物品存储的是最终状态，所以从最后一件物品进行循环</span><br><span class="hljs-keyword">for</span> (从最后一件循环至第一件) &#123;<br><span class="hljs-keyword">if</span> (g[i][v]) &#123;<br>    选了第 i 项物品;<br>    v -= 第 i 项物品的价值;<br>&#125; <span class="hljs-keyword">else</span><br>    未选第 i 项物品;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="11-换钱问题"><a href="#11-换钱问题" class="headerlink" title="11. 换钱问题"></a>11. 换钱问题</h3><p>零钱兑换II：一定要注意虽然每个硬币都有无数个，但是不能出现重复，也就是 121  112这种情况，所以硬币的循环一定要放在最外层</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;coins.<span class="hljs-built_in">size</span>();i++)&#123;<span class="hljs-comment">//硬币放在最内层会发生错误</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;=amount;j++)&#123;<br>        <span class="hljs-keyword">if</span>(j&gt;=coins[i])&#123;<br>                dp[j]=dp[j]+dp[j-coins[i]];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="12-通配符匹配问题（hard）-类似最短单词距离的动态转移"><a href="#12-通配符匹配问题（hard）-类似最短单词距离的动态转移" class="headerlink" title="12. 通配符匹配问题（hard） 类似最短单词距离的动态转移"></a>12. 通配符匹配问题（hard） 类似最短单词距离的动态转移</h3><ul><li>一定要注意动态规划的状态转移方程式是i j 从 i-k j-k转移过来，不能出现i+k j+k(如果出现，一定是枚举的长度，例如回文串和打气球问题)</li><li>易错点：<br>字符串的匹配问题，通常会在字符前面加上” “ dp[0][0]=1<br>同时如果i j从1开始取的话，需要初始化赋值dp[0][i] 和dp[i][0]</li></ul><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">corner case:<br>    <span class="hljs-attr">s</span> = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-attr">p</span> = <span class="hljs-string">&quot;******&quot;</span> <br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++">dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span><br><span class="hljs-comment">//下面这个循环是非常重要的</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;p_len;i++)&#123;<br>    <span class="hljs-keyword">if</span>(p[i]==<span class="hljs-string">&#x27;*&#x27;</span>)&#123;<br>        dp[<span class="hljs-number">0</span>][i]=dp[<span class="hljs-number">0</span>][i<span class="hljs-number">-1</span>]; <span class="hljs-comment">// or dp[0][i]=dp[0][i-1];</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;s_len;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;p_len;j++)&#123;<br>        <span class="hljs-keyword">if</span>(p[j]==<span class="hljs-string">&#x27;*&#x27;</span>)&#123;<br>            dp[i][j]=dp[i<span class="hljs-number">-1</span>][j]||dp[i][j<span class="hljs-number">-1</span>];<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(s[i]==p[j]||p[j]==<span class="hljs-string">&#x27;?&#x27;</span>)&#123;<br>                dp[i][j]=dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]; <br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                dp[i][j]=<span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>如果不好赋值dp[i][0] or dp[0][i] 可以让i j 从0开始取，但是在状态转移的时候注意进行j 或者i的判断 if j&gt;=1  dp[j-1]<ol><li>问题1：*可以匹配任意字符 </li><li>问题2：*只能匹配前面字符的0个1个或多个(正则表达式匹配) 需要判断s[i] p[j-1]是否相等</li></ol></li></ul><h3 id="13-打家劫舍"><a href="#13-打家劫舍" class="headerlink" title="13. 打家劫舍"></a>13. 打家劫舍</h3><ul><li>求能够得到金额的最大值。</li><li>环形可以转为dp[0][size-2]和dp[1][size-1]两者之中求最大值</li><li>类似的一道题：删除并获得点数（题意：选了nums[i]， 就不能选择nums[i-1] 和nums[i+1]， 打家劫舍这里的i, i+1是下标的， 这道题是实际数字上的。两个问题都是使用dp </li></ul><h3 id="14-整数拆分"><a href="#14-整数拆分" class="headerlink" title="14. 整数拆分"></a>14. 整数拆分</h3><ul><li>可以使用动态规划 二层循环 dp[i]= max(j*(i-j), j* dp[i-j])， 因为存在i-j &gt; dp[i-j]的情况</li><li>或者使用数据规划，将余数为2（2<em>） 1（4</em>） 0(3*)情况区别对待</li></ul><h3 id="15-最大整除子集"><a href="#15-最大整除子集" class="headerlink" title="15. 最大整除子集"></a>15. 最大整除子集</h3><ul><li>和最长递增序列有相似之处）</li><li>注意：在进行倒推序列的时候，需要记录当前的maxval 以及target_dpval, 这两者都需要在压入每个元素的时候更新</li><li>相邻两个数的商不一定相等</li></ul><h3 id="16-摆动序列-（序列最长问题）"><a href="#16-摆动序列-（序列最长问题）" class="headerlink" title="16.  摆动序列 （序列最长问题）"></a>16.  摆动序列 （序列最长问题）</h3><h3 id="17-无重叠区间"><a href="#17-无重叠区间" class="headerlink" title="17. 无重叠区间"></a>17. 无重叠区间</h3><ul><li>可以使用动态规划，找到以每个区间结尾的最长子序列（O(N^2)） 或者贪心，对区间右边进行排序然后选择 O(nlogn)</li></ul><h3 id="18-最后一块石头的重量-II"><a href="#18-最后一块石头的重量-II" class="headerlink" title="18. 最后一块石头的重量 II"></a>18. 最后一块石头的重量 II</h3><ul><li><p>需要理解题意之后转为背包问题，也就是最大最小问题</p></li><li><p>求两个子集相差的最小值 -&gt; 转为背包问题，背包容量是sum/2，求能够放入背包的最大数</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>=max(dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[j]</span>, dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[j-stone<span class="hljs-comment">[i]</span>]</span>+stone<span class="hljs-comment">[i]</span>)<br></code></pre></td></tr></table></figure></li><li><p>0-1的最大背包问题，逆向枚举</p></li><li><p>多重背包问题也是，只能逆向枚举</p></li><li><p>完全背包（无限个）才是正向枚举！！！</p></li></ul><h3 id="19-乘积为正数的最长子数组长度-最长子数组系列题目"><a href="#19-乘积为正数的最长子数组长度-最长子数组系列题目" class="headerlink" title="19. 乘积为正数的最长子数组长度 (最长子数组系列题目)"></a>19. 乘积为正数的最长子数组长度 (最长子数组系列题目)</h3><ul><li>注意这道题是求最长的长度，不是最大的乘积，但是这两个问题都可以使用动态规划完成</li></ul><ol><li>最长的长度，positive[i]表示以i结尾的为正数的子数组，negtive[i] i结尾的为负数的子数组，<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span> (nums[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">0</span>) &#123;<br>    positive[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[<span class="hljs-number">0</span>] &lt; <span class="hljs-number">0</span>) &#123;<br>    negative[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">int</span> maxLength = positive[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; length; i++) &#123;<br>    <span class="hljs-keyword">if</span> (nums[i] &gt; <span class="hljs-number">0</span>) &#123;<br>        positive[i] = positive[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>        negative[i] = negative[i - <span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span> ? negative[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span> : <span class="hljs-number">0</span>; <span class="hljs-comment">//注意一定要和0判断</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] &lt; <span class="hljs-number">0</span>) &#123;<br>        positive[i] = negative[i - <span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span> ? negative[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        negative[i] = positive[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        positive[i] = <span class="hljs-number">0</span>;<br>        negative[i] = <span class="hljs-number">0</span>;<br>    &#125;<br>    maxLength = Math.<span class="hljs-built_in">max</span>(maxLength, positive[i]);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><ul><li>我的思路：转为前缀和+hash<br>  题意转为：负数为1，正数为0， 0单独处理，相加和为偶数的最长子数组<br>  如果&lt;0, 那么sum+=1；<br>  如果&gt;0, 那么sum不变；<br>  如果=0, 那么sum=0，  hash.clear(), hash[0]=i；<br>  如果sum为偶数：<br>  res=max(res, i-hash[0])<br>  如果sum为奇数：<br>  如果hash[1]存在<br>  res=max(res, i-hash[1])<br>  否则hash[1]=i;</li></ul><ol start="2"><li>最大乘积（可能为负数），dp1[i]表示以i结尾乘积最大子数组，dp2[i]的乘积最小(注意不一定为负数)的子数组<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=size;i++)&#123;<br>    <span class="hljs-keyword">if</span>(nums[i<span class="hljs-number">-1</span>]&gt;<span class="hljs-number">0</span>)&#123;<br>        dp1[i]=<span class="hljs-built_in">max</span>(dp1[i<span class="hljs-number">-1</span>]*nums[i<span class="hljs-number">-1</span>], nums[i<span class="hljs-number">-1</span>]);<br>        dp2[i]=<span class="hljs-built_in">min</span>(dp2[i<span class="hljs-number">-1</span>]*nums[i<span class="hljs-number">-1</span>], nums[i<span class="hljs-number">-1</span>]);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[i<span class="hljs-number">-1</span>]&lt;<span class="hljs-number">0</span>)&#123;<br>        dp1[i]=<span class="hljs-built_in">max</span>(dp2[i<span class="hljs-number">-1</span>]*nums[i<span class="hljs-number">-1</span>], nums[i<span class="hljs-number">-1</span>]);<br>        dp2[i]=<span class="hljs-built_in">min</span>(dp1[i<span class="hljs-number">-1</span>]*nums[i<span class="hljs-number">-1</span>], nums[i<span class="hljs-number">-1</span>]);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        dp1[i]=<span class="hljs-number">0</span>;<br>        dp2[i]=<span class="hljs-number">0</span>;<br>    &#125;<br>    res=<span class="hljs-built_in">max</span>(res, dp1[i]);<br></code></pre></td></tr></table></figure></li></ol><h3 id="20-最低票价"><a href="#20-最低票价" class="headerlink" title="20. 最低票价"></a>20. 最低票价</h3><ul><li><p>找到能够让days天都观光的最低票价，类似完全背包问题， 最少兑换钞票</p></li><li><p>dp[i]定义为至少让index==i天观光所需要的最低票价， 分别遍历决策1，决策2， 决策3需要的最低票价</p></li><li><p>solution 1：每天进行dp + 从后往前</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> len = days.length, maxDay = days[len - <span class="hljs-number">1</span>], minDay = days[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[maxDay + <span class="hljs-number">31</span>]; <span class="hljs-comment">// 多扩几天，省得判断 365 的限制</span><br><span class="hljs-comment">// 只需看 maxDay -&gt; minDay，此区间外都不需要出门，不会增加费用</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> d = maxDay, i = len - <span class="hljs-number">1</span>; d &gt;= minDay; d--) &#123;<br>    <span class="hljs-comment">// i 表示 days 的索引</span><br>    <span class="hljs-comment">// 也可提前将所有 days 放入 Set，再通过 set.contains() 判断</span><br>    <span class="hljs-keyword">if</span> (d == days[i]) &#123;<br>        dp[d] = Math.<span class="hljs-built_in">min</span>(dp[d + <span class="hljs-number">1</span>] + costs[<span class="hljs-number">0</span>], dp[d + <span class="hljs-number">7</span>] + costs[<span class="hljs-number">1</span>]); <span class="hljs-comment">//三种情况</span><br>        dp[d] = Math.<span class="hljs-built_in">min</span>(dp[d], dp[d + <span class="hljs-number">30</span>] + costs[<span class="hljs-number">2</span>]);<br>        i--; <span class="hljs-comment">// 别忘了递减一天</span><br>    &#125; <span class="hljs-keyword">else</span> dp[d] = dp[d + <span class="hljs-number">1</span>]; <span class="hljs-comment">// 不需要出门</span><br>&#125;<br><span class="hljs-keyword">return</span> dp[minDay]; <span class="hljs-comment">// 从后向前遍历，返回最前的 minDay</span><br></code></pre></td></tr></table></figure></li><li><p>solution 2：只从days包含的天数进行dp + 从前往后</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> valid[<span class="hljs-number">3</span>]=&#123;<span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">30</span>&#125;;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>    dp[i]=INT_MAX;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>        <span class="hljs-keyword">if</span>(days[i]-valid[j]&lt;days[<span class="hljs-number">0</span>])&#123;<br>            dp[i]=<span class="hljs-built_in">min</span>(dp[i], costs[j]); <br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">int</span> index=<span class="hljs-built_in">upper_bound</span>(days.<span class="hljs-built_in">begin</span>(), days.<span class="hljs-built_in">end</span>(), days[i]-valid[j])-days.<span class="hljs-built_in">begin</span>();<br>            <span class="hljs-comment">//找到对应的前面天数对应的下标</span><br>            <span class="hljs-comment">// cout&lt;&lt;index&lt;&lt;endl;</span><br>            dp[i]=<span class="hljs-built_in">min</span>(dp[index<span class="hljs-number">-1</span>]+costs[j], dp[i]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="21-lc1186-删除一次得到子数组最大和"><a href="#21-lc1186-删除一次得到子数组最大和" class="headerlink" title="21. lc1186. 删除一次得到子数组最大和"></a>21. lc1186. 删除一次得到子数组最大和</h3><ul><li>最大连续和的变形题目：得到最大的连续和之后，可以选择删除序列的一个数，或者选择不删除</li><li>使用动态规划：记录到index i的两种状态：1. 执行了删除操作的最大值 2. 没有执行删除操作的最大值<br>所以得到的状态转移方程就是:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> a=arr[<span class="hljs-number">0</span>]; <span class="hljs-comment">//未执行删除得到的最大值</span><br><span class="hljs-keyword">int</span> b=<span class="hljs-number">0</span>;<span class="hljs-comment">//已经执行删除得到的最大值</span><br><span class="hljs-keyword">int</span> res=arr[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span> 到 size<br>b=<span class="hljs-built_in">max</span>(b+arr[i], a);<br>a=<span class="hljs-built_in">max</span>(a+arr[i], arr[i]);<br>res=<span class="hljs-built_in">max</span>(res, a);<br>res=<span class="hljs-built_in">max</span>(res, b);<br></code></pre></td></tr></table></figure></li></ul><h2 id="数学相关问题（找规律）"><a href="#数学相关问题（找规律）" class="headerlink" title="数学相关问题（找规律）"></a>数学相关问题（找规律）</h2><h3 id="1-计算各个位数不同的数字个数"><a href="#1-计算各个位数不同的数字个数" class="headerlink" title="1. 计算各个位数不同的数字个数"></a>1. 计算各个位数不同的数字个数</h3><ul><li>其实就是9* 9 * 8* 7这种情况）但是要注意是n位数以内的n位数都需要计算，开始各位数有10种情况，后面在当前数插入数据的时候，最开头有9种情况，后面数据有（10-1）种情况，因为后面的数据是可以为0的（固定前面，枚举后面）</li></ul><h3 id="2-消除游戏-和约瑟夫环问题"><a href="#2-消除游戏-和约瑟夫环问题" class="headerlink" title="2. 消除游戏 和约瑟夫环问题"></a>2. 消除游戏 和约瑟夫环问题</h3><ul><li><p>解决方案一：使用之后的下标和之前下标的映射 来解决（删除后，末尾从1开始编号）<br>2 ~ 2k映射为k ~ 1那么还原的规律f(2k)=2*(k+1-f(k))</p></li><li><p>解决方案二：每次记录剩下链表的头结点，如果当前剩下的个数==1那么直接返回这个数</p></li><li><p>约瑟夫环递推问题的公式</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">𝑓(𝑛)=(𝑓(𝑛−<span class="hljs-number">1</span>)+𝑚)%𝑛  （一共n个人，数到m的人被杀）<br>def last<span class="hljs-constructor">Remaining(<span class="hljs-params">n</span>, <span class="hljs-params">m</span>)</span>:<br>    <span class="hljs-keyword">if</span> n<span class="hljs-operator"> == </span><span class="hljs-number">1</span>: return <span class="hljs-number">0</span><br>    return (last<span class="hljs-constructor">Remaining(<span class="hljs-params">n</span>-1, <span class="hljs-params">m</span>)</span> + m) % n<br></code></pre></td></tr></table></figure></li></ul><h3 id="3-第-N-位数字（一位）"><a href="#3-第-N-位数字（一位）" class="headerlink" title="3. 第 N 位数字（一位）"></a>3. 第 N 位数字（一位）</h3><ul><li><p>题意： 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,顺序排列后的第n位数字</p></li><li><p>找到不同位数包含的数字number= base*10-base,如果n&gt;这个数那么更新n-=number * weishu,否则就在这个位数里面查找</p></li><li><p>如果当前的数%位数==0，那么当前的数字是cur_num=base+n/weishu-1, 否则当前的数字为cur_num=base+n/weishu，然后计算在当前数字里面对应具体哪个数字， 为(cur_num/pow(10, weishu-n%weishu))%10</p></li><li><p>扩展：还有一个排序后的数 （一个数）二叉树，求两个节点直接夹的数组，类似于上面这道题base* 10的操作，如果小于，那么就往二叉树的下一层节点走（a=a<em>10, b=b</em>10, 知道a大于n, 退出向下搜索的循环）</p></li></ul><h3 id="4-灯泡开关-灯泡开关II"><a href="#4-灯泡开关-灯泡开关II" class="headerlink" title="4. 灯泡开关/灯泡开关II"></a>4. 灯泡开关/灯泡开关II</h3><ul><li>主要是找到规律前6个灯泡可以推导出其他灯泡的状态，更进一步是，前三个灯可以推导后面所有的状态，因此有状态16种</li><li>只需要枚举每个灯泡的每种状态(为0或者为1)就可以了因此是16种情况，用4位表示； 1的数量num num&lt; m， 而且num%2 == m%2</li><li>同时要注意可能灯泡小于6， 因此需要shift=max(6-n, 0)</li><li>然后再将每个状态异或起来就可以了<br>（找规律，但不是动态规划问题）</li></ul><h3 id="5-到达终点数字"><a href="#5-到达终点数字" class="headerlink" title="5. 到达终点数字"></a>5. 到达终点数字</h3><ul><li>左右走，步数为1， 2， 3，…。也是属于找规律，但是不是动态规划的问题 </li><li>找到连加中大于target的最小sum(cur=k),然后求delta=sum-target,如果为奇数那么k++, 直到为delta偶数 (那么就可以减去delta/2)，然后返回当前k值</li></ul><h3 id="6-子矩阵问题-lintcode"><a href="#6-子矩阵问题-lintcode" class="headerlink" title="6. 子矩阵问题(lintcode)"></a>6. 子矩阵问题(lintcode)</h3><ol><li><p>第一种题型，要求矩阵内部的元素全部为1，那么以i， j为右下角的最长矩阵边长为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span>(matrix[i][j]==<span class="hljs-number">1</span>)&#123;<br>    dp[i][j]=<span class="hljs-built_in">min</span>(dp[i][j<span class="hljs-number">-1</span>], dp[i<span class="hljs-number">-1</span>][j], dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>])+<span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure><p>那么以 i， j为右下角的子矩阵的个数为dp[i][j]个</p></li><li><p>要求矩形框最长, 那么每个点需要为何它上面最长 up，和左边最长 left， 两个数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> tmp = <span class="hljs-built_in">min</span>(left[i][j<span class="hljs-number">-1</span>], up[i<span class="hljs-number">-1</span>][j])+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> len=tmp<span class="hljs-number">-1</span>;len&gt;=<span class="hljs-number">1</span>;len--)&#123; <span class="hljs-comment">//枚举长度，使得4个边长都是在len之内，说明能围成一个框</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">min</span>(up[i][j-len], left[i-len][j])&gt;=len)&#123;<br>        <span class="hljs-keyword">return</span> len+<span class="hljs-number">1</span>;<span class="hljs-comment">//返回枚举得到的最长边框</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="7-捡苹果-lintcode"><a href="#7-捡苹果-lintcode" class="headerlink" title="7. 捡苹果(lintcode) "></a><font color="red">7. 捡苹果(lintcode) </font></h3><ul><li>前后缀问题(找两个区间，一个区间连续k个数，一个区间连续l个数，两个区间不相交且和最大)</li><li>solution: 枚举中间的划分点i,使得<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">res=<span class="hljs-built_in">max</span>(res, presumK[i]+postsumL[i+<span class="hljs-number">1</span>])<br>res=<span class="hljs-built_in">max</span>(res, presumL[i]+postsumK[i+<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure></li><li>思路没问题：主要是没有找打0<del>i之前连续窗口最大值与i</del>len-1 连续窗口的最大值怎么求</li><li>计算前缀和后缀数组，注意如果index转为1~size，那么后缀数组需要开size+2 !!!!<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=K;i&lt;=size;i++)&#123;<br>    presumK[i]=<span class="hljs-built_in">max</span>(presum[i]-presum[i-K], presumK[i<span class="hljs-number">-1</span>]);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=L;i&lt;=size;i++)&#123;<br>    presumL[i]=<span class="hljs-built_in">max</span>(presum[i]-presum[i-L], presumL[i<span class="hljs-number">-1</span>]);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=size-K+<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">1</span>;i--)&#123;<br>    postsumK[i]=<span class="hljs-built_in">max</span>(presum[i+K<span class="hljs-number">-1</span>]-presum[i<span class="hljs-number">-1</span>], postsumK[i+<span class="hljs-number">1</span>]);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=size-L+<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">1</span>;i--)&#123;<br>    postsumL[i]=<span class="hljs-built_in">max</span>(presum[i+L<span class="hljs-number">-1</span>]-presum[i<span class="hljs-number">-1</span>], postsumL[i+<span class="hljs-number">1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="8-钢笔和"><a href="#8-钢笔和" class="headerlink" title="8. 钢笔和"></a>8. 钢笔和</h3><ul><li>题意：找到两个不相交的区间，每个区间和都为target, 使得这两个区间len之和最小，其实也可以向上一题一样，分为pre post,然后枚举划分点，使用分治算法进行计算</li></ul><h3 id="9-可被三整除的最大和-这道题和lc1363-形成3的最大倍数是一样的思路"><a href="#9-可被三整除的最大和-这道题和lc1363-形成3的最大倍数是一样的思路" class="headerlink" title="9. 可被三整除的最大和 这道题和lc1363 形成3的最大倍数是一样的思路"></a>9. 可被三整除的最大和 这道题和lc1363 形成3的最大倍数是一样的思路</h3><ul><li><p>不要求是连续</p></li><li><p>使用余数的递归公式 dp[i][j]表示以i结尾的余数为j的最大和</p></li><li><p>那么就要根据nums[i]%3的余数分类别更新dp[i][0], dp[i][1], dp[i][2]</p></li><li><p>一个更简单的方法是 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++">a=remainder[<span class="hljs-number">0</span>]+nums[i]; <br>b=remainder[<span class="hljs-number">1</span>]+nums[i];<br>c=remainder[<span class="hljs-number">2</span>]+nums[i];<span class="hljs-comment">//因为可以不连续</span><br>remainder[a%<span class="hljs-number">3</span>]=<span class="hljs-built_in">max</span>(remainder[a%<span class="hljs-number">3</span>], a);<span class="hljs-comment">//a对余数就是a%3,所以分在一组</span><br>remainder[b%<span class="hljs-number">3</span>]=<span class="hljs-built_in">max</span>(remainder[b%<span class="hljs-number">3</span>], b);<br>remainder[c%<span class="hljs-number">3</span>]=<span class="hljs-built_in">max</span>(remainder[c%<span class="hljs-number">3</span>], c);<br></code></pre></td></tr></table></figure></li><li><p>PS: 类似的一个题：将字符串翻转到单调递增<br>dp[i][0]表示前i个数以0结尾，dp[i][0]表示前i个数以1结尾<br>易错点：dp[i][1]=min(dp[i-1][0], dp[i-1][1]) //以1结尾的时候，前面以0结尾是不需要+1的</p></li></ul><h3 id="10-lc1594-矩阵的最大非负积"><a href="#10-lc1594-矩阵的最大非负积" class="headerlink" title="10. lc1594. 矩阵的最大非负积"></a>10. lc1594. 矩阵的最大非负积</h3><ul><li>有负数的最后最大题型+结果需要取余</li><li>因为有负数，所以需要记录每个位置的最大和最小值，而不只是最大值</li><li>负数取余会变正，所以一定要注意 在最后取余，同时为了防止中间数溢出，需要使用long long类型的数据</li></ul><h3 id="11-lc1621-大小为-K-的不重叠线段的数目"><a href="#11-lc1621-大小为-K-的不重叠线段的数目" class="headerlink" title="11. lc1621. 大小为 K 的不重叠线段的数目"></a>11. lc1621. 大小为 K 的不重叠线段的数目</h3><ul><li> 通过状态转移方程多加入一维，就可以减少三重循环为两重循环的例子</li><li>dp[i][j][0] 表示第 j 条线段的右端点不是 i，也就是说我们没有办法继续延长第 j 条线段；<br>  dp[i][j][1] 表示第 j条线段的右端点就是 i，也就是说我们可以选择是否继续延长第 j条线段。<br>  dp[i][j][1]= dp[i-1][j][1] 就表示当前线和之前线连在一起，</li></ul><p>也就是延长之前的线，那么就不用第三重训练来遍历起点</p><h2 id="博弈论相关问题"><a href="#博弈论相关问题" class="headerlink" title="博弈论相关问题"></a>博弈论相关问题</h2><h3 id="1-石子问题"><a href="#1-石子问题" class="headerlink" title="1. 石子问题"></a>1. 石子问题</h3><h3 id="2-预测家"><a href="#2-预测家" class="headerlink" title="2. 预测家"></a>2. 预测家</h3><ul><li>当前只能从石子序列的头或者尾部进行取，那么使用枚举长度的动态规划+前缀和 （区dp） 注意这道题和lc1423. 可获得的最大点数 不一样因为这个是一定要拿完，而且有两个人拿，而lc1423是一个人拿，所以使用滑动窗口解决 n-k的窗口内数据最小就行</li></ul><h3 id="3-能赢吗"><a href="#3-能赢吗" class="headerlink" title="3. 能赢吗"></a>3. 能赢吗</h3><ul><li>因为是从1-n中随机取，而且取了之后就不能取了，所以使用带记忆的dfs, 使用位图来记录当前状态是否遍历过 dp[state]</li></ul><h2 id="字符串与动态规划"><a href="#字符串与动态规划" class="headerlink" title="字符串与动态规划"></a>字符串与动态规划</h2><p>也可以划分到Trie树问题:一般是对单词建立Trie树</p><h3 id="1-单词拆分问题"><a href="#1-单词拆分问题" class="headerlink" title="1. 单词拆分问题"></a>1. 单词拆分问题</h3><ul><li>dp代表的是True or False</li><li>dp+第二层循环枚举字典里面的每一个单词，看是否恰好是当前遍历序列0~i的最后几个字符<br>为了进一步减少时间，内层训练从i枚举到0，同时为true的时候直接退出<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;size;i++)&#123; <span class="hljs-comment">//遍历字符串的每一个字符</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i;j&gt;=<span class="hljs-number">0</span>;j--)&#123;<br>        string tmp=s.<span class="hljs-built_in">substr</span>(j, i-j+<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span>(wordSet.<span class="hljs-built_in">find</span>(tmp)!=wordSet.<span class="hljs-built_in">end</span>())&#123;<br>            dp[i]=dp[i]|dp[j<span class="hljs-number">-1</span>];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(dp[i])&#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br>方法二：<br>以当前判断后面的字符串<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=s.<span class="hljs-built_in">size</span>();i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;wordDict.<span class="hljs-built_in">size</span>();j++)&#123;<br>        <span class="hljs-keyword">if</span>(!dp[i])&#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        string tmp=s.<span class="hljs-built_in">substr</span>(i,wordDict[j].<span class="hljs-built_in">size</span>());<br>        <span class="hljs-keyword">if</span>(tmp==wordDict[j])&#123;<br>            dp[i+wordDict[j].<span class="hljs-built_in">size</span>()]=<span class="hljs-literal">true</span>;<br>        <br>            path[i].<span class="hljs-built_in">push_back</span>(i+wordDict[j].<span class="hljs-built_in">size</span>());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><font color="red">单词拆分II需要求出所有可行的解</font><br>为了避免重复的计算和对比，字符串的前缀是否包含单词表里面的单词，需要使用单词拆分1的方法将i后面对应的true的下标放在hash&lt;int, vector&gt;里面记录起来，这样之后再进行遍历的时候就不需要重复判断；<br>另外一个去处回溯的重复方案是， 将一个下标后面的字符串对应的可以拆分方案提前记录起来（hash&lt;int, vector&lt;vector<int>&gt;），这样的话，就不用对同一下标进行多次重复求值（类似于二叉树的组成类似的）</int></li></ul><h3 id="2-恢复空格问题-代表的无效字符的个数-使用Trie树的经典案例"><a href="#2-恢复空格问题-代表的无效字符的个数-使用Trie树的经典案例" class="headerlink" title="2. 恢复空格问题(代表的无效字符的个数)- 使用Trie树的经典案例 "></a><font color="red">2. 恢复空格问题(代表的无效字符的个数)- 使用Trie树的经典案例 </font></h3><ul><li>都可以转为Trie树+dp类型的题目 </li><li>这个不能暴力erase,因为可能出现一个单词是另外一个单词的前缀，可能导致erase顺序不同，结果不同；这个只能使用字典序；</li><li>另外一个减少暴力深搜索带来的超时问题，可以使用第二层循环每次枚举dict的每个元素，看是否与当前遍历序列的最后几个字符相同，而不是每个不同长度的单词一个一个的进行比较。</li><li>多次搜索：使用暴力的string find或者使用将small单词列表建立Trie树，然后big以每个字符为开头，查找字符串是否出现在Trie树中，在查找的路径中如果遇到isend=True说明找到了一个字符<br>然后继续找下去</li></ul><h3 id="3-环绕字符串中唯一的子字符串"><a href="#3-环绕字符串中唯一的子字符串" class="headerlink" title="3. 环绕字符串中唯一的子字符串"></a>3. 环绕字符串中唯一的子字符串</h3><ul><li>题意为：找到子串字符必须是连续的，这样的子串的个数，但是这样可以会出现重复比如abcbc，所以要使用dp (其实就是hash，记录以某个字符结尾的最长的子串)</li><li>计算出26个英文字母中每一个英文字母的结尾的最长的连续的环绕字符串，然后求和</li><li>PS：注意字符串去重，如果不考虑去重的话，可以直接使用滑动窗口记录子串个数；因为这个滑动窗口是直接出现不连续，窗口长度直接退化为1，所以可以只记录窗口长度，不记录窗口左右两端</li></ul><h3 id="4-lc97-交错字符串"><a href="#4-lc97-交错字符串" class="headerlink" title="4. lc97. 交错字符串"></a>4. lc97. 交错字符串</h3><ul><li>求第三个字符串是否能由第一个和第二个字符串组合得到，是否问题</li><li>易错点：不能使用双指针，因为针对一个两个字符串相同的情况可能造成错误</li><li>使用动态规划，dp[i][j]表示字符串1的前i个字符和字符串1的前j个字符能否组成第三个字符串的i+j个字符</li></ul><h3 id="5-最长公共前缀（lcp）"><a href="#5-最长公共前缀（lcp）" class="headerlink" title="5. 最长公共前缀（lcp）"></a>5. 最长公共前缀（lcp）</h3><p><code>dp[i][j]</code>表示从下标 i开始的子字符串 <code>s[i:]</code>和以下标 j 开始的子字符串 <code>s[j] </code>的最长公共前缀的长度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=n<span class="hljs-number">-1</span>;j&gt;=<span class="hljs-number">0</span>;j++)&#123;<br>        <span class="hljs-keyword">if</span>(s[i]==s[j])&#123;<br>            dp[i][j]=dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            dp[i][j]=<span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="状态压缩"><a href="#状态压缩" class="headerlink" title="状态压缩"></a>状态压缩</h2><h3 id="1-划分为k个相同子集，也可以看做dfs-回溯-贪心"><a href="#1-划分为k个相同子集，也可以看做dfs-回溯-贪心" class="headerlink" title="1. 划分为k个相同子集，也可以看做dfs+回溯+贪心"></a>1. 划分为k个相同子集，也可以看做dfs+回溯+贪心</h3><ul><li>状态压缩的话就是dp[i]中i的每一个数由二进制位的状态组成，然后遍历二进制的每一个状态，当前的状态可以由当前状态中任意取消一个1的状态转移过来，或者用当前的状态更新下一个状态（将状态中为0的转为1），只有只有dp[i]=true, 而且当前状态的和%target+nums[i]&lt;=target下一个状态才为true,否则为false<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">canPartitionKSubsets</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> size=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">int</span> total_sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>            total_sum+=nums[i];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(total_sum%k!=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> target=total_sum/k;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">int</span> total_state=<span class="hljs-number">1</span>&lt;&lt;size;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(total_state, <span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sum</span><span class="hljs-params">(total_state, <span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>]=<span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;total_state;i++)&#123;<br>            <span class="hljs-keyword">if</span>(!dp[i])&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">// cout&lt;&lt;i&lt;&lt;endl;</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;size;j++)&#123;<br>                <span class="hljs-comment">// cout&lt;&lt;j&lt;&lt;endl;</span><br>                <span class="hljs-keyword">if</span>((i&amp;(<span class="hljs-number">1</span>&lt;&lt;j))==<span class="hljs-number">0</span>)&#123;   <span class="hljs-comment">//注意：位运算一定要记得打上括号之后再判断是否相等，否则会出错！！！！！</span><br>                    <span class="hljs-keyword">int</span> next=i|(<span class="hljs-number">1</span>&lt;&lt;j);<br>                    <span class="hljs-comment">// cout&lt;&lt;next&lt;&lt;endl;</span><br>                    <span class="hljs-keyword">if</span>(sum[i]%target+nums[j]&lt;=target)&#123;<br>                        sum[next]=sum[i]+nums[j];<br>                        dp[next]=<span class="hljs-literal">true</span>;<br>                        cout&lt;&lt;next&lt;&lt;endl;<br>                    &#125;<span class="hljs-keyword">else</span>&#123;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[total_state<span class="hljs-number">-1</span>];<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-优美的排列"><a href="#2-优美的排列" class="headerlink" title="2. 优美的排列"></a>2. 优美的排列</h3><ul><li>也是状态压缩 或者回溯，相比第2题需要枚举当前位置放的数是哪个，所以多一层循环。上面那道题因为数的位置是固定的，所以只需要判断这个数放没放。</li><li>其实还是顺序放，当前放了m个，那么下一个要放的数就是m+1， 所以也可以不同像下面的题解一样多一层循环（3月8日修改）<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-class"><span class="hljs-title">public</span>:</span><br>    <span class="hljs-built_in">int</span> count(<span class="hljs-built_in">int</span> number)&#123;<br>        <span class="hljs-built_in">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(number!=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>(number&amp;<span class="hljs-number">1</span>)&#123;<br>                res++;<br>            &#125;<br>            number=number&gt;&gt;<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-built_in">int</span> countArrangement(<span class="hljs-built_in">int</span> n) &#123;<br>        <span class="hljs-built_in">int</span> state=<span class="hljs-number">1</span>&lt;&lt;n;<br>        <br>        vector&lt;<span class="hljs-built_in">int</span>&gt; dp(state, <span class="hljs-number">0</span>);<br>        dp[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> num=<span class="hljs-number">1</span>;num&lt;=n;num++)&#123; //类似背包的，当前放第num数， 标准答案是将状态放在外层， 然后通过<span class="hljs-number">1</span>个个数判断当前的num<br>            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;state;i++)&#123;<br>                // <span class="hljs-keyword">if</span>(!dp[i])&#123;<br>                //     <span class="hljs-keyword">continue</span>;<br>                // &#125;<br>                <span class="hljs-keyword">if</span>(count(i)!=num-<span class="hljs-number">1</span>)&#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>                    <span class="hljs-keyword">if</span>((i&amp;(<span class="hljs-number">1</span>&lt;&lt;j))==<span class="hljs-number">0</span>)&#123;<br>                        <span class="hljs-keyword">if</span>(num%(j+<span class="hljs-number">1</span>)==<span class="hljs-number">0</span>||(j+<span class="hljs-number">1</span>)%num==<span class="hljs-number">0</span>)&#123;<br>                            <span class="hljs-built_in">int</span> <span class="hljs-built_in">next</span>=i^(<span class="hljs-number">1</span>&lt;&lt;j);<br>                            dp[<span class="hljs-built_in">next</span>]+=dp[i];<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[state-<span class="hljs-number">1</span>];<br>        <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><h3 id="3-华为的一个机试题目"><a href="#3-华为的一个机试题目" class="headerlink" title="3. 华为的一个机试题目"></a>3. 华为的一个机试题目</h3><ul><li><p>需要在规定燃油内（规定长度内）得到的资源最大化（有点像0-1背包问题）， 但是这个不同之处在于：从不同点到相同的i，消耗的燃油是不一样的， 而且这个最后还需要回到原点，所以dist需要走过的位置mask 以及最后的位置i</p></li><li><p>其实就是先求每个mask的最小dist, 得到d[mask][i]:也就是以i结尾的最小燃油，然后遍历这个数组，如果d[mask][i]+fuel[i][0]&lt;=maxdist 那么更新ans<br>ans=max(ans, g[mask])</p></li><li><p>为什么不直接求d[fuel][i]的最大化，这样也会重复vis统一节点<br><a href="https://leetcode-cn.com/circle/discuss/a4pRYY/">https://leetcode-cn.com/circle/discuss/a4pRYY/</a></p></li></ul><h3 id="4-访问所有节点的最短路径-hard"><a href="#4-访问所有节点的最短路径-hard" class="headerlink" title="4. 访问所有节点的最短路径(hard)"></a>4. 访问所有节点的最短路径(hard)</h3><ul><li>题意：一笔走完所有的节点，注意可能重复访问同一个节点</li><li>主要思路：<br>先求出任意两个节点间的距离，使用floyd，同时记得出事dist[i][i]=0<br>然后使用d[mask][i]:表示最后状态为mask,并且以i结尾的最短路径<br>最后遍历d[mask][i] 求最小值</li><li>易错点，mask的循环一定要在节点i的循环的外面， 否则就会出错<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> mask=<span class="hljs-number">1</span>;mask&lt;(<span class="hljs-number">1</span>&lt;&lt;n);mask++)&#123;<br>          <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>              <span class="hljs-keyword">if</span> (mask &amp; (<span class="hljs-number">1</span> &lt;&lt; i)) &#123; <span class="hljs-comment">//如果i这个点已经被选过</span><br>                  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;n;k++)&#123;<br>                      <span class="hljs-keyword">if</span>((mask&amp;(<span class="hljs-number">1</span>&lt;&lt;k))==<span class="hljs-number">0</span>)&#123;<br>                          d[mask|(<span class="hljs-number">1</span>&lt;&lt;k)][k]=<span class="hljs-built_in">min</span>(d[mask|(<span class="hljs-number">1</span>&lt;&lt;k)][k],d[mask][i]+dist[i][k]); <span class="hljs-comment">//需要先使用floy求出任意两点之间的最短距离</span><br>                      &#125;<br>                  &#125;<br>              &#125;<br>          &#125;<br>      &#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="5-基于陈述统计最多好人数"><a href="#5-基于陈述统计最多好人数" class="headerlink" title="5. 基于陈述统计最多好人数"></a>5. 基于陈述统计最多好人数</h3><ul><li>这个是枚举状态（二进制），与dp无关，但是和状态压缩dp有点类似</li></ul><h3 id="6-两个数组最小的异或值之和-lc2172：-数组的最大与和"><a href="#6-两个数组最小的异或值之和-lc2172：-数组的最大与和" class="headerlink" title="6. 两个数组最小的异或值之和  / lc2172： 数组的最大与和 "></a>6. 两个数组最小的异或值之和  / <font color="red">lc2172： 数组的最大与和 </font></h3><ul><li>这两道题都是位运算相关的状态压缩<br>第一题枚举nums2每个数应该放的位置<br>第二题需要先装为状态压缩的样子，因为每个index有两个slot,所以需要先转为2*n个slot，那么slot和index对应关系为j/2+1<br>然后枚举每个数应该放在哪个slot,同时注意这道题不是每个状态都有值，对于one_num of state i&gt;=num数量, 直接continue</li><li>一个位可以放两个数的情况，需要展开分别讨论<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-number">1</span> &lt;&lt; (numSlots * <span class="hljs-number">2</span>))</span></span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; f.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>    <span class="hljs-keyword">int</span> c = __builtin_popcount(i); <span class="hljs-comment">//当前已经放了几个数，下一个放的数就是nums[c]</span><br>    <span class="hljs-keyword">if</span> (c &gt;= nums.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">//直接跳过</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; numSlots * <span class="hljs-number">2</span>; ++j) &#123;<br>        <span class="hljs-keyword">if</span> ((i &amp; (<span class="hljs-number">1</span> &lt;&lt; j)) == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 枚举空篮子 j</span><br>            <span class="hljs-keyword">int</span> s = i | (<span class="hljs-number">1</span> &lt;&lt; j);<br>            f[s] = <span class="hljs-built_in">max</span>(f[s], f[i] + ((j / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>) &amp; nums[c]));<br>            ans = <span class="hljs-built_in">max</span>(ans, f[s]); <span class="hljs-comment">//有效的状态求结果</span><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br></code></pre></td></tr></table></figure></li></ul><h3 id="7-状态压缩的二分查找方法"><a href="#7-状态压缩的二分查找方法" class="headerlink" title="7. 状态压缩的二分查找方法"></a>7. 状态压缩的二分查找方法</h3><p>lc805. 数组的均值分割</p><ul><li>30个元素进行状态压缩枚举可能会超时,因为转为两个集合，分别状态压缩，然后进行排序后，使用双指针查找和为0的组合是否存在<ol><li>通过公式推导可以得到需要找到k个元素，他们的平均值是整个数组的平均值，将每个元素-avg,那就是找k个数加起来和为0</li><li>本来是暴力枚举，但是因为30个元素可能超时间，所以使用二分枚举</li><li>二分枚举先各自判断是否有和为0的情况（一定要记得删除不包含任何元素的状态压缩这种情况），再删除掉一个元素不包括和包括所有元素的情况</li><li>最后使用双指针查找和为0的组合</li></ol></li></ul><h2 id="动态规划-拓扑排序"><a href="#动态规划-拓扑排序" class="headerlink" title="动态规划 + 拓扑排序"></a>动态规划 + 拓扑排序</h2><h3 id="1-并行课程III"><a href="#1-并行课程III" class="headerlink" title="1. 并行课程III"></a>1. 并行课程III</h3><p>题意：可能具有拓扑结构+每节课程都有上课时间， 任意两节不依赖课程可以同时上，求最短上完所有课程的时间<br>转化：拓扑排序的最长路径<br>两种解决方案：</p><ul><li>转为dfs，建立依赖关系的时候反向建立，然后将度为0的点放入队列之中（root）,dfs求深度，然后多棵树取最长深度</li><li>使用拓扑排序，将度为0的点放入队列，同时每次在取出队列中的点的时候，用当前点的结果f[v]更新v后面所有后修课程的结果<br>f[w]=max(f[w], f[v]+time[v])</li></ul><h2 id="反向dp"><a href="#反向dp" class="headerlink" title="反向dp"></a>反向dp</h2><h3 id="1-lc174-地下城游戏"><a href="#1-lc174-地下城游戏" class="headerlink" title="1. lc174. 地下城游戏"></a>1. <font color="red">lc174. 地下城游戏</font></h3><ul><li>正序的含义为“从起点出发，到达位置（i，j）所需要的最少血量”；正向dp有两个因素影响，可能每条路各有一个因素好，因此不知道选择哪条；（当前需要的血量，和整条路径中至少需要的血量）</li><li>倒序的含义是“从（i，j）出发，到达终点需要最少的血量”。初始血量本来就是要求的，所以只能倒序dp</li><li>转移方程：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span>(i==m<span class="hljs-number">-1</span>&amp;&amp;j==n<span class="hljs-number">-1</span>)&#123;<br>    dp[i][j]=<span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>-dungeon[i][j], <span class="hljs-number">1</span>);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i==m<span class="hljs-number">-1</span>)&#123;<br>    dp[i][j]=<span class="hljs-built_in">max</span>(dp[i][j+<span class="hljs-number">1</span>]-dungeon[i][j], <span class="hljs-number">1</span>); <span class="hljs-comment">//每个点的初始健康点都必须为正整数</span><br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j==n<span class="hljs-number">-1</span>)&#123;<br>        dp[i][j]=<span class="hljs-built_in">max</span>(dp[i+<span class="hljs-number">1</span>][j]-dungeon[i][j], <span class="hljs-number">1</span>);                <br>&#125;<span class="hljs-keyword">else</span>&#123;<br>        dp[i][j]=<span class="hljs-built_in">max</span>(<span class="hljs-built_in">min</span>(dp[i+<span class="hljs-number">1</span>][j], dp[i][j+<span class="hljs-number">1</span>])-dungeon[i][j], <span class="hljs-number">1</span>); <br>&#125;   <br></code></pre></td></tr></table></figure></li></ul><h2 id="数位dp"><a href="#数位dp" class="headerlink" title="数位dp"></a>数位dp</h2><p><a href="https://leetcode.cn/problems/count-special-integers/solution/shu-wei-dp-mo-ban-by-endlesscheng-xtgx/">力扣（LeetCode）官网 - 全球极客挚爱的技术成长平台</a><br>主要是抓住现在的index, mask(前面i位选择的数组)， isLimit（前面是否选的最大）， isNum 前面是否填了数字（非0）<br>注意最开始的时候isLimit=True, isNum=false<br>同时记忆化搜索主要用于出现重复计算的情况，因此可以从4维降低到2维 dp[index][mask]<br>一些类似的题目：<a href="https://leetcode.cn/problems/numbers-with-repeated-digits/">https://leetcode.cn/problems/numbers-with-repeated-digits/</a></p><p><a href="https://zerotrac.github.io/leetcode_problem_rating/#/">灵神网页</a></p><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><h3 id="1-每个物品选择或者不选择，使得总体的方案是n-同时花费最少类似题"><a href="#1-每个物品选择或者不选择，使得总体的方案是n-同时花费最少类似题" class="headerlink" title="1. 每个物品选择或者不选择，使得总体的方案是n, 同时花费最少类似题"></a>1. 每个物品选择或者不选择，使得总体的方案是n, 同时花费最少类似题</h3><p>例题1: lc1029. 两地调度</p><ul><li>第一想法是使用二进制的暴力枚举</li><li>因为整体的方案一定要是n, 所以一定要初始化dp[0][j] (j&gt;=2为一个比较大的值)； 同时dp[i][0] 为dp[i-1][0]+cost[i][1]<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++">    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=costs[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=costs[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">2</span>;j&lt;=n/<span class="hljs-number">2</span>;j++)&#123;<br>        dp[<span class="hljs-number">0</span>][j]=<span class="hljs-number">1000000</span>; <span class="hljs-comment">//注意这个是非常重要的！！！！</span><br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>        dp[i][<span class="hljs-number">0</span>]=dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]+costs[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n/<span class="hljs-number">2</span>;j++)&#123; <span class="hljs-comment">//j代表剩余的0类的数量</span><br>            dp[i][j]=<span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j]+costs[i][<span class="hljs-number">1</span>], dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+costs[i][<span class="hljs-number">0</span>]);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></li><li>第二种方法是贪心：<br>a[i] - b[i]代表将i员工派往a地比派往b地的费钱程度，数值越高表示派往a地越不划算；<br>  将所有花费按a[i] - b[i]从小到大排序，则前n个为派往a地更划算的员工，后n个为派往b地更划算的员工。</li></ul><p>例题2: lc474. 一和零 （类似于0-1背包问题）</p><ul><li>选不选择每个字符串，满足0， 1不超过m, n同时使得最后的字符串个数最多; 或者选了这个不能选择左右两边， 类似问题都使用dp</li><li>这种第一种想到的思路是回溯，更进一步的方法是动态规划</li><li>回溯思路如果不求具体序列，只求总数的话，可以考虑动态规划解决<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span>(j&gt;=zero_num&amp;&amp;k&gt;=one_num)&#123;<br>    dp[i][j][k]=<span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][j-zero_num][k-one_num]+<span class="hljs-number">1</span>, dp[i<span class="hljs-number">-1</span>][j][k]);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    dp[i][j][k]=dp[i<span class="hljs-number">-1</span>][j][k]; <span class="hljs-comment">//一定注意else别忘了</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="1-斐波拉切数列问题"><a href="#1-斐波拉切数列问题" class="headerlink" title="1. 斐波拉切数列问题"></a>1. 斐波拉切数列问题</h3><p><font color="red"> 扩展题：lc873. 最长的斐波那契子序列的长度</font></p><ul><li>使用动态规划的话，不能只数列的最后一个数，而要考虑数列的最后两个数 dp[i][j]=max(dp[i][j], d[k][i]+1);<br>因为有三个变量，为了减少三重循环为二重，使用hash_map 找到k的index为 hash[arr[j]-arr[i]]</li><li>使用二重循环暴力寻找，为了减少寻找的时间，使用hash_map（因为数据各不相同）</li></ul><h3 id="2-成熟的牛不断生小牛的问题"><a href="#2-成熟的牛不断生小牛的问题" class="headerlink" title="2. 成熟的牛不断生小牛的问题"></a>2. 成熟的牛不断生小牛的问题</h3><h3 id="3-汉罗塔问题"><a href="#3-汉罗塔问题" class="headerlink" title="3. 汉罗塔问题"></a>3. 汉罗塔问题</h3><h3 id="4-走地图问题（最短-最长价值-龙与地下城游戏）"><a href="#4-走地图问题（最短-最长价值-龙与地下城游戏）" class="headerlink" title="4. 走地图问题（最短/最长价值/龙与地下城游戏）"></a>4. 走地图问题（最短/最长价值/龙与地下城游戏）</h3><h3 id="5-扔鸡蛋问题"><a href="#5-扔鸡蛋问题" class="headerlink" title="5. 扔鸡蛋问题"></a>5. 扔鸡蛋问题</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">dp[i][j]=<span class="hljs-number">1</span>+dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+dp[i<span class="hljs-number">-1</span>][j] <span class="hljs-comment">//dp[i][j]表示用i次操作j个鸡蛋能够验证的最高高度</span><br></code></pre></td></tr></table></figure><h3 id="6-画匠问题"><a href="#6-画匠问题" class="headerlink" title="6. 画匠问题"></a>6. 画匠问题</h3><ul><li><p>动态规划或者二分算法</p></li><li><p>动态规划：类似于鸡蛋问题，可以使用滑动数组，将二维转为一维，但是在转的时候注意i j的顺序 dp[i-1][0<del>j]可以转 dp[0</del>i][j]不太好转</p></li><li><p>二分解法如下<br>二分法，限制所有画作完成的时长，然后检查在这个时长限制下画家的数量够不够。够的话说明时间还可以压缩，不够的话就要放宽时长限制，多给一些时间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span> limit)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> tmpsum=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;arr.<span class="hljs-built_in">size</span>();i++)&#123;<br>        tmpsum+=arr[i];<br>        <span class="hljs-keyword">if</span>(tmpsum&gt;limit)&#123;<br>            cnt++;<br>            tmpsum=arr[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt+<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">int</span> left=INT_MIN, right=<span class="hljs-number">0</span>; <span class="hljs-comment">//表示一个画家画的时长</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;arr.<span class="hljs-built_in">size</span>();i++)&#123;<br>    left=<span class="hljs-built_in">max</span>(arr[i], left);<br>    right+=arr[i];<br>&#125;<br><br><span class="hljs-keyword">if</span>(K&gt;=arr.<span class="hljs-built_in">size</span>())&#123;<span class="hljs-comment">//如果画家数量比画多</span><br>    <span class="hljs-keyword">return</span> left;<span class="hljs-comment">//返回时长最大的画</span><br>&#125;<br><br><span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>    <span class="hljs-keyword">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">int</span> tmp=<span class="hljs-built_in">getNumber</span>(mid);<br>    <span class="hljs-keyword">if</span>(tmp==K)&#123;<br>        right=mid;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tmp&lt;K)&#123;<br>        right=mid<span class="hljs-number">-1</span>;<span class="hljs-comment">//应该也可以和tmp==K合并为right=mid</span><br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        left=mid+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> right;<span class="hljs-comment">//最小的时长</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="7-邮局选址的问题"><a href="#7-邮局选址的问题" class="headerlink" title="7. 邮局选址的问题"></a><font color="red">7. 邮局选址的问题</font></h3><ul><li>转移状态的枚举类似于画匠问题</li><li>因为两个邮局的情况，不清楚那个邮局负责哪些居民区，那么就枚举，然后求最小。</li><li>这道题前提是要知道：建立一个邮局的时候，建在中间是最优的情况！<ol><li>提前求i ~ j这段距离建立一个邮局的最小距离</li><li>dp[i][j]表示0 ~ i这段居民区，有j+1个邮局的最小距离   也可以改成j对应j个邮局，这样初始化dp[i][1],循环j从 2 ~ num</li><li>初始化边界dp[i][0]=w[0][i];</li><li>建立转移方程： dp[i][j]=min(dp[k][j-1]+w[k+1][i], dp[i][j]) k从0到i，（官方题解：两端值都取!!!!!），表示建邮局的位置<br>注意j&lt;=i，当j&gt;i dp=0; 每次进入k循环的时候，在初始化dp[i][j]=INT_MAX</li><li>返回结果 dp[n-1][K-1];<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> w[size+<span class="hljs-number">1</span>][size+<span class="hljs-number">1</span>];<br><span class="hljs-comment">//求任意两个居民点之间建立一个邮局的最短距离</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i+<span class="hljs-number">1</span>;j&lt;size;j++)&#123;<br>        w[i][j]=w[i][j<span class="hljs-number">-1</span>]+a[j]-a[(i+j)/<span class="hljs-number">2</span>];<br>    &#125;<br>&#125;<br>dp[i][<span class="hljs-number">0</span>]=w[<span class="hljs-number">0</span>][i];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=size<span class="hljs-number">-1</span>;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=num<span class="hljs-number">-1</span>;j++)&#123;  <br>        <span class="hljs-keyword">if</span>(j&gt;=i)&#123;<span class="hljs-comment">//邮局数量&gt;=居民区数量  如果不进行判断就需要 k&lt;=i，否则就会因为进不去 k 的循环，导致dp[i][j]=INT_MAX</span><br>            dp[i][j]=<span class="hljs-number">0</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            dp[i][j]=INT_MAX;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;i;k++)&#123;<br>                dp[i][j]=<span class="hljs-built_in">min</span>(dp[k][j<span class="hljs-number">-1</span>]+ w[k+<span class="hljs-number">1</span>][i], dp[i][j]); <span class="hljs-comment">//注意k+1可能==size，因此需要w需要size+1空间</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>总结，从左到右开始建立，而不是使用二进制记录状态，随机建立<br>状态转移类似最长递增子序列的思路， 需要提前计算i， j之间建立一个邮局的最短距离</li></ol></li></ul><h3 id="8-数组的最大价值-区间dp"><a href="#8-数组的最大价值-区间dp" class="headerlink" title="8. 数组的最大价值 (区间dp)"></a><font color="red">8. 数组的最大价值 (区间dp)</font></h3><ul><li>题意，就是找任意不相交区间且每个区间首位值相等，使得这些区间加起来价值最大</li><li>转移方程：<br><code>  dp[i]=max(dp[i-1], dp[j-1]+presum[i]-presum[j-1]); （a[i]==a[j]）</code><br>因为需要<code>a[j]==a[i]</code>，如果使用二重循环会超时<br>解决方案：<br>（1）使用hash存储不同a[i]对应的下标<br>（2）记录另外一个hash 使得<code>hash[a[i]]=max(hash[a[i]], dp[i-1]-presum[i-1]) </code></li><li>之后再进行更新就不用循环找与i相同的下标j,可以直接更新<code>dp[i]=max(dp[i-1], presum[i]+hash[a[i]]); </code><br>（注意要对<code>hash[a[i]]</code>是否存在进行分类讨论）</li></ul><h3 id="9-盒子放置（谷歌）-现在无权限查看"><a href="#9-盒子放置（谷歌）-现在无权限查看" class="headerlink" title="9. 盒子放置（谷歌）/现在无权限查看"></a><font color="red">9. 盒子放置（谷歌）/现在无权限查看</font></h3><ul><li>使用动态规划的思想；</li><li>dp[i][j] 表示当前第i个box，第j个position能放置的最多的box数量。<br>如果 box[i - 1] &lt;= position[j - 1]，则dp[i][j] = dp[i - 1][ j - 1] + 1 贪心，放在最后一个位置最好<br>反之，dp[i][j] = max(dp[i-1][j], dp[i][j - 1]) 其中di[i-1][j]表示不放第i个box, dp[i][j - 1] 第i个box不放在j个位置</li></ul><p><strong>重要！！！！！</strong></p><ul><li>注意下标i从0 ~ n-1，但是这个因为有w，所以最好和w对应，不转为1 ~ n。<br>从i从0开始取的话，每次k循环，划分两个部分相加， 后半部分都不会包含第一个数，因此j要从2开始取，否则就会造成dp[0][0]//第一个0代表有地址，第二个0代表无邮局，就会返回INT_MAX,造成结果错误<br>背包问题，i下标是1~n 因为i可能从i-1推导，需要i&gt;=1</li></ul><h3 id="8-“马”在棋盘上的概率"><a href="#8-“马”在棋盘上的概率" class="headerlink" title="8. “马”在棋盘上的概率"></a>8. “马”在棋盘上的概率</h3><ul><li>类似的==地图问题==，虽然当前位置可以由它四面八方的位置推出来，但是因为步数，所以对应的三维数组还是由之前的状态推导出来，因此仍然可以使用动态规划<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> K=<span class="hljs-number">1</span>;K&lt;=k;K++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> q=<span class="hljs-number">0</span>;q&lt;<span class="hljs-number">8</span>;q++)&#123;<br>                <span class="hljs-keyword">int</span> nextx=i+dx[q];<br>                <span class="hljs-keyword">int</span> nexty=j+dy[q];<br>                <span class="hljs-keyword">if</span>(nextx&gt;=<span class="hljs-number">0</span>&amp;&amp;nextx&lt;n&amp;&amp;nexty&gt;=<span class="hljs-number">0</span>&amp;&amp;nexty&lt;n)&#123;<br>                    dp[i][j][K]+=dp[nextx][nexty][K<span class="hljs-number">-1</span>]/<span class="hljs-number">8.0</span>; <span class="hljs-comment">//下一个和当前反过来感觉也行</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">double</span> sum=<span class="hljs-number">0.0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>        sum+=dp[i][j][k]; <span class="hljs-comment">//k步走到每个棋盘的概率加起来</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>图与动态规划，一定要注意vis的问题，bellman-ford以及floyd算法都是图的动态规划的例子<br>但是注意因为bellman-ford是求距离最小，所以不会出现重复vis同一个节点的情况<br>但是如果求max的情况，使用动态规划+图就可能造成一个节点vis多次，因此最好考虑记忆化dfs或者状态压缩</p></li><li><p>状态压缩问题，将状态放在外层比较保险；如果是list数组，那么可以将num放在外面，如果是图，那么只能将状态放在外面。 通常状态压缩使用的题目是将数据放在哪个位置，得到最大/最小、/满足什么样的条件的XXX类似题型<br><font color="red">图类型的状态压缩：求遍历这个图中所有节点的最小代价（代价指的是走过路径长度的总和， 应该是顺序走完）。状态压缩dp，注意不要理解成最小生成树</font></p></li></ol><ol start="3"><li><p>动态规划的关键是处理 i 取值范围 j取值范围，转移方程以及边界情况求动态规划<br>也就是找到dp[i]-&gt; dp[j] (j&lt; i) 的递推公式,这个递推可能由i，j之间回文，括号，或者异或和组成；特别的，如果是回文可以提前得到任何i，j之间是否为回文字符串，模板代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=s_len<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>     <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i+<span class="hljs-number">1</span>;j&lt;s_len;j++)&#123;<br>         p[i][j]=(s[i]==s[j]&amp;&amp;p[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>]);<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure></li><li><p>区间dp问题，外围长度的字符状态，可以由内围的长度的字符推导出来 <code>dp[i][size]</code><br> 数组中左右相邻顺序不变的题，一般使用区间dp （lc1130. 叶值的最小代价生成树）<br> 这种问题有两种思路：<br> a. 直接当前问题划分为左右两个子问题<br> b. 将当前问题划分为左右两个子问题+当前的问题</p></li><li><p>如果进行了状态压缩：<br>0-1的最大背包问题，逆向枚举<br>多重背包问题也是，只能逆向枚举<br>完全背包（无限个）才是正向枚举！！！</p></li><li><p>有的时候动态规划不好解决，考虑使用带记忆的dfs，（比如要求所有的路径，或者所有路径中花费最小等等） 而且dp 的index可以为一个vector（类似与状态压缩）</p></li><li><p>最短时间类似题，除了考虑动态规划，也可以向二分算法中思考，比如画匠问题</p></li><li><p>动态规划可以解决true/false（是否能化为k个相同区间，单词拆分问题）, 最小最大最长问题，总数问题</p></li><li><p>当动态规划的状态比较多的情况下<br>注意 res+=dp[i][m]%MOD(wrong answer)<br>res=(res+dp[m][i])%MOD(right answer);</p></li><li><p>划分性dp有两种情况：以i为结尾，和0-i之间，区分这两种情况就是判断在进行dp递推的时候，如果dp[i] 依赖于多个之前的dp[j]那么应该使用以i为结尾，如果dp[i]只依赖之前的一个dp[j]那么使用0-i之内的元素<br>（最长子序列和最长子串问题）</p></li><li><p>使用状态枚举（状态压缩）的方法，要求k&lt;32 !!!!如果n&lt;100那么就不能这么枚举</p></li><li><p>背包问题可能也会加一个额外的条件，类似于最短路径问题（Dijstra/bellman-ford/floyd）中再加一个额外条件,具体例题见“货物转移”(lintcode)模板： dp数量最小+weight最大类似题目</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span>(d[j]+<span class="hljs-number">1</span>&lt;d[i])&#123; <span class="hljs-comment">//找到更优解</span><br>    d[i]=d[j]+<span class="hljs-number">1</span>;<br>    weight[i]=weight[j]; <span class="hljs-comment">// update weight and d</span><br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(d[i]==d[j]+<span class="hljs-number">1</span>)&#123;<br>    weight[i]=max/<span class="hljs-built_in">min</span>(weight[j], weight[i]); <span class="hljs-comment">//only update weight</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-keyword">continue</span>; <span class="hljs-comment">//do not update anything</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>动态规划一定要注意状态的初始化，在i 和 j都从1开始取的时候，一定要记得赋值dp[0][1到n] 以及dp[1到n][0]</p></li><li><p>如果出现反复将一个字符串的子串和字典中的每个字符比对的题目，可以使用Trie树，或者使用动态规划（True/False类型），提前判断某一个子字符串是否在字典中</p></li><li><p>刷一刷leetcode以面试题开始的题目</p></li></ol><ol start="16"><li><p>非常重要的资源：<a href="https://oi-wiki.org/dp/knapsack/">背包 DP - OI Wiki</a><br>OI-wiki  《背包九讲》</p></li><li><p>连续数组进行划分，使得划分个数满足条件，使用动态规划或者二分查找<br>例题：lc410. 分割数组的最大值(hard), 画匠问题</p></li><li><p>一定要注意数组越界可能不会报错，比如403. 青蛙过河，申请dp[size][size] size=18， 但是访问dp[18][29]范围为true<br>所以这道题关键在于一定要加上判断if(k&lt;=j+1) 才能进行dp的更新，否则就会发生访问到越界的数据</p></li></ol><ol start="19"><li> 注意异或，因为值不一定为前面的值，所以dp[i][j]的i不能够减少，这种情况为了减少内存空间占用，使用dp[2][j]<br>转移方程为：<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs prolog">dp[i&amp;<span class="hljs-number">1</span>][j]= (dp[(i<span class="hljs-number">-1</span>)&amp;<span class="hljs-number">1</span>][j]+dp[(i<span class="hljs-number">-1</span>)&amp;<span class="hljs-number">1</span>][j^(arr[i<span class="hljs-number">-1</span>])])<span class="hljs-comment">%MOD;</span><br></code></pre></td></tr></table></figure>返回结果为<code>dp[size&amp;1][max_j]</code></li></ol><ol start="20"><li>动态规划主要在于定义状态有几种（删除/不删除元素  买股票/卖股票 等），以及定义状态间的递推-转移关系(当前状态可以由之前的状态决定)</li></ol><ol start="21"><li><a href="https://leetcode.cn/problems/number-of-dice-rolls-with-target-sum/solution/dong-tai-gui-hua-bei-bao-wen-ti-yun-yong-axtf/">背包问题详解</a></li></ol><ol start="22"><li>子数组是连续的；子序列是不连续的。数组题一定要先确定，选择的数是连续还是不连续，是可以打乱顺序还是不能打乱顺序<br>(lc1524. 和为奇数的子数组数目)</li></ol>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单调栈</title>
      <link href="/2021/11/13/leetcode/%E5%8D%95%E8%B0%83%E6%A0%88%E7%9B%B8%E5%85%B3/"/>
      <url>/2021/11/13/leetcode/%E5%8D%95%E8%B0%83%E6%A0%88%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><h3 id="1-去除重复字母"><a href="#1-去除重复字母" class="headerlink" title="1. 去除重复字母"></a>1. 去除重复字母</h3><ul><li>使得去除重复字母之后，字符串的字典序最小</li><li>值栈<br>记录剩下字符串中是否包含这个字符，如果包含，那么就可以弹出（如果当前字符比这个字符小，就弹出）</li></ul><h3 id="2-接雨水"><a href="#2-接雨水" class="headerlink" title="2. 接雨水"></a>2. 接雨水</h3><p>接雨水I:</p><ul><li>方法一：每个地方能接的雨水是当前下标左右两边最大值（LeftMax and RightMax）的较小一个 –&gt;值栈</li><li>方法二：使用单调递减栈，维护top and left（单调栈的top下面的值） –&gt;下标栈</li></ul><p>接雨水II:</p><ul><li>二维接雨水</li><li>上下左右四个方向分别取最大值再求短板这种想法在二维接雨水中，是不能获得正确结果的。</li><li>正确的解法是，先将矩阵的外围放入优先队列中，然后取出最端的一个点，更新它四周的（需要使用vis数组，有的更新过就不能更新了），<br>如果没有被vis而且当前点比他高，那么res+=h-matrix[i][j], 然后将改点压入栈中（高度为max(h, matrix[i][j])）；否则直接压入栈中</li></ul><h3 id="3-直方图最大矩阵面积"><a href="#3-直方图最大矩阵面积" class="headerlink" title="3. 直方图最大矩阵面积"></a>3. 直方图最大矩阵面积</h3><ul><li>求离当前直方图左右两边第一个小于该直方图的下标，使用左边单调递增+右边单调递增</li><li>注意边缘的节点，因此需要提前向栈push -1或者size， 作为哨兵节点</li><li>下标栈</li></ul><h3 id="4-围成矩形的最大面积"><a href="#4-围成矩形的最大面积" class="headerlink" title="4. 围成矩形的最大面积"></a>4. 围成矩形的最大面积</h3><ul><li>转为每行的直方图的最大面积 O(mn)，转为单调栈求左右第一个比当前数小的下标</li><li>（下标栈）<br>扩展： 最大正方形：使用dp  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>        <span class="hljs-keyword">if</span>(matrix[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]==<span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>            dp[i][j]=<span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>],<span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j],dp[i][j<span class="hljs-number">-1</span>]))+<span class="hljs-number">1</span>;<br>            result=<span class="hljs-built_in">max</span>(dp[i][j],result);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>  最大正方形框：尾货left和up的最长，然后分别走到另外框边缘两个点进行判断是否符合，不符合的话使用循环，减小当前判断的值</li></ul><h3 id="5-公式字符串求值"><a href="#5-公式字符串求值" class="headerlink" title="5. 公式字符串求值"></a>5. 公式字符串求值</h3><ul><li>可以遇到（）后进入递归，或者压入op栈中.注意（-15）这种要特别判断，if(s[i]==’-‘) &amp;&amp; if(i==0||s[i-1]==’(‘) 那么就循环获得一个负数（括号可以进入op栈中，也可以直接跳过）</li><li>在计算优先级的时候：可以不用传入两个判断，可以给每一个运算符一个分数  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">int grade( char op ) &#123;<br><span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;(&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;+&#x27;</span> || op == <span class="hljs-string">&#x27;-&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;*&#x27;</span> || op == <span class="hljs-string">&#x27;/&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="6-逆波兰表达式"><a href="#6-逆波兰表达式" class="headerlink" title="6. 逆波兰表达式"></a>6. 逆波兰表达式</h3><h3 id="7-滑动窗口的最大值"><a href="#7-滑动窗口的最大值" class="headerlink" title="7. 滑动窗口的最大值"></a>7. 滑动窗口的最大值</h3><ul><li>可以使用优先队列， 单调递减的双向队列</li><li>一定要注意最开始压入0~k-1个字符的时候，就要压入一个结果，而不是下一个压入前面一个字符的结果，因为这样可能导致压入少一个字符</li><li>前pop deque中后面小于当前元素的值，再pop deque前面超过len的值</li><li>因为滑动窗口可以看成一个队列，所以这个题也可以实现找队列中最大值，而且队列没有滑动窗口一样有size的限制</li></ul><h3 id="8-频率最高的k个字符"><a href="#8-频率最高的k个字符" class="headerlink" title="8. 频率最高的k个字符"></a>8. 频率最高的k个字符</h3><ul><li>使用大小为k的最小堆，其实也是使用优先队列实现的堆，需要自定义排序方式<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 小顶堆</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">mycomparison</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">const</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&amp; lhs, <span class="hljs-keyword">const</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&amp; rhs)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> lhs.second &gt; rhs.second;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><h3 id="9-有的模拟题也是用栈的，"><a href="#9-有的模拟题也是用栈的，" class="headerlink" title="9. 有的模拟题也是用栈的，"></a>9. 有的模拟题也是用栈的，</h3><ul><li>比如文件的最长路径，栈中维护递增level的长度，如果当前的level&lt;栈顶的level那么弹栈；如果遇到当前是文件，那么统计栈中元素加起来的值和result比较取最大</li><li>这种题一般需要对token先进行划分，然后进行统计</li></ul><h3 id="10-移掉-K-位数字"><a href="#10-移掉-K-位数字" class="headerlink" title="10. 移掉 K 位数字"></a>10. 移掉 K 位数字</h3><ul><li>使用单调栈，如果当前的字符小于栈顶的元素，那么循环弹出。易错点：剩下的字符包含头部0元素，以及最后如何结果为空字符串的话，应该返回“0”而不是“”</li></ul><h3 id="11-下一个更大元素II"><a href="#11-下一个更大元素II" class="headerlink" title="11. 下一个更大元素II"></a>11. 下一个更大元素II</h3><ul><li>题意：找到每个元素后面，第一个大于当前元素的数</li><li>我的解法：从后往前，前面在进行判断的时候使用后面的<code>nextid</code>,可以跳过一些数，<code>next[i]==-1</code>表示没有比当前数更大的，<code>next[i]==-2</code>表示当前数还没有计算 nextid有值那么直接进行跳转<code>nextid=next[nextid]</code></li><li>官方题解：单调栈，但是因为是训练列表，所以需要遍历n+n-1个数据</li></ul><h3 id="12-子数组的最小值之和"><a href="#12-子数组的最小值之和" class="headerlink" title="12. 子数组的最小值之和"></a>12. 子数组的最小值之和</h3><ul><li>题意：这道题求每个数左边比他小的第一个数的下标，和右边第一个比他小于或等于的数的下标</li><li>解决：使用单调递减栈； 结果就是：arr[i]*(i-left[i]) * (right[i]-i)<br>注意为了处理两个数相同的情况，使用左边小于，右边小于等于！！！ </li><li>比如：1 2 4 8 1</li></ul><h3 id="13-最小栈"><a href="#13-最小栈" class="headerlink" title="13. 最小栈"></a>13. 最小栈</h3><ul><li>题目：如何用时间O(1)和空间O(1)的复杂度得到栈中的最小值</li><li>解决：原始的数据栈用来记录数据与min的差值 （value-min），同时用一个min变量记录当前栈的最小值;注意如果数值没有限制的话，差值的计算可能会溢出。<ul><li>getmin()：始终返回min变量的值</li><li>void pop(): 如果栈顶元素小于0，那么说明当前栈顶元素就是min(如果需要返回栈顶元素只，那么返回min),同时更新min为min-stack.top();否则不更新min</li><li>void push(value): 当栈为空，直接压入value, 令min=value, push(0); 如果不为空，计算 value-min，并压入栈中; 如果小于0, 那么修改min为value, 否则min不变。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> 设计一个有<span class="hljs-title">gitMin</span>的栈 &#123;</span><br><br>    <span class="hljs-keyword">private</span> Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> min;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (stack.<span class="hljs-built_in">isEmpty</span>()) &#123;<br>            min = x;<br>            stack.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 计算差值</span><br>            <span class="hljs-keyword">int</span> compare = x - min;<br>            stack.<span class="hljs-built_in">push</span>(compare);<br>            <span class="hljs-comment">// 如果差值小于0，显然 x 成为最小值，否则最小值不变</span><br>            min = compare &lt; <span class="hljs-number">0</span> ? x : min;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> top = stack.<span class="hljs-built_in">peek</span>();<br>        <span class="hljs-comment">// 如果top小于0，显然最小值也一并会被删除，此时更新最小值</span><br>        min = top &lt; <span class="hljs-number">0</span> ? (min - top) : min;<br>        stack.<span class="hljs-built_in">pop</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> min;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="括号相关的题目专题"><a href="#括号相关的题目专题" class="headerlink" title="括号相关的题目专题"></a>括号相关的题目专题</h2><p><strong>总结:</strong> 一般来说括号相关的题使用栈解决，但是有的题目也使用动态规划解决。同时栈的方式也可以演变为更加简单的整数加减问题，不需要额外的空间。左括号出现那么+1， 右括号出现那么如果有左括号，那么左括号-1否则右括号+1</p><h3 id="1-有效的括号字符串"><a href="#1-有效的括号字符串" class="headerlink" title="1. 有效的括号字符串"></a>1. 有效的括号字符串</h3><ul><li>因为*既可以当左括号，又可以当右括号，又可以当空白字符</li><li>因此需要两个栈，当左括号栈为空的时候，从星号栈弹，否则从左括号栈弹、如果最后左括号不为空，那么比较信号栈顶和左括号栈顶下标，如果星号栈顶下标大，那么同时弹出，重复上述过程</li><li>如果是动态规划的话； 就是判断dp[i][j]是否为true, 判断标准是 如果i==’(‘或者’<em>‘ 且j==’)’或者 ‘ <em>‘那么dp[i][j]=dp[i+1][j-1] 同时遍历i 到j之间的每一个元素，dp[i][j] |=dp[i][k]&amp;&amp;dp[k][j] (发现为true就break)<br>类似长度的动态规划（最长回文子串）<br>len==1 s[i]==’</em>‘ dp[i][i]=true<br>len==2 (s[i]==’(‘||s[i]==’</em>‘ ) &amp;&amp; (s[j]==’)’||s[j]==’*’)</li></ul><h3 id="2-括号的生成"><a href="#2-括号的生成" class="headerlink" title="2. 括号的生成"></a>2. 括号的生成</h3><ul><li>使用dfs， 左括号的数量应该时刻保持&gt;=右括号的数量， 因此可以使用每使用一个左括号，可使用的右括号数量+1， 左括号：n-&gt;0, 右括号：0-&gt;n</li></ul><h3 id="3-最长有效括号（动态规划中也有总结）"><a href="#3-最长有效括号（动态规划中也有总结）" class="headerlink" title="3. 最长有效括号（动态规划中也有总结）"></a>3. 最长有效括号（动态规划中也有总结）</h3><pre><code class="hljs"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestValidParentheses</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> maxans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[s.<span class="hljs-built_in">length</span>()];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; s.<span class="hljs-built_in">length</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">charAt</span>(i) == <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>                <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">charAt</span>(i - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                    dp[i] = (i &gt;= <span class="hljs-number">2</span> ? dp[i - <span class="hljs-number">2</span>] : <span class="hljs-number">0</span>) + <span class="hljs-number">2</span>;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i - dp[i - <span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span> &amp;&amp; s.<span class="hljs-built_in">charAt</span>(i - dp[i - <span class="hljs-number">1</span>] - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                    dp[i] = dp[i - <span class="hljs-number">1</span>] + ((i - dp[i - <span class="hljs-number">1</span>]) &gt;= <span class="hljs-number">2</span> ? dp[i - dp[i - <span class="hljs-number">1</span>] - <span class="hljs-number">2</span>] : <span class="hljs-number">0</span>) + <span class="hljs-number">2</span>;<br>                &#125;<br>                maxans = Math.<span class="hljs-built_in">max</span>(maxans, dp[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxans;<br>    &#125;<br></code></pre></td></tr></table></figure></code></pre><p>另外的解决方案：使用栈，栈底需要提前push一个-1<br>不需要额外的空间：需要两次遍历</p><ul><li>从左向右：如果left==right 更新答案，如果right&gt;left 重新设置left=right=0;</li><li>从右向左：如果left==right 更新答案，如果left&gt;right 重新设置left=right=0;<h3 id="4-删除无效的括号"><a href="#4-删除无效的括号" class="headerlink" title=" 4. 删除无效的括号 "></a><font color="red"> 4. 删除无效的括号 </font></h3></li><li>因为是需要知道删除后所有有效的情况，所以应该dfs，同时难点在于去重</li><li>solution: 先计算得到要删除的左右括号的数量，然后再dfs求所有合格的情况</li><li>和其他dfs不一样在于，dfs遍历的是删除的括号，而不是留下的括号</li><li>使用dfs的两种剪枝技巧：<ol><li>不重复遍历相同的 if i!=cur &amp;&amp; char[i]==char[i-1] continue</li><li>记录当前左括号和右括号的数量，只有左括号的数量大于等于右括号，再遍历需要这个右括号的这种情况，否则就不遍历这种情况（这道题没用）</li></ol></li><li>注意这道题在进行递归的时候，不是一个字符一个字符的判断到底加不加当前的字符，而是使用一个循环，从当前字符遍历到最后一个字符，然后将当前字符前面和后面的字符串进行拼接， 然后仍然从当前遍历的下标，进入下一个循环。通过这种方式可以跳过一些重复的循环， 比如（（（）， 这种方式只需要移除一个（ ， 没必要每个进行判断</li></ul><p>回溯+剪枝+去冗余（set/循环去）+括号匹配check, 这道题是遍历删除的字符，而不是留下的字符，因此需要用到path.substr，来进行删除后字符串的重新组合</p><ul><li>这道题可以扩展出另外一个题：如何判断一个字符串应该删除多少左括号，多少右括号使得剩下括号有效<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++">left=<span class="hljs-number">0</span>, right=<span class="hljs-number">0</span>; <span class="hljs-comment">//需要删除的左右括号数量</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>    <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>        left++;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">if</span>(left&gt;<span class="hljs-number">0</span>)&#123;<br>            left--;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            right++;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="5-最多能完成排序的块-I-II"><a href="#5-最多能完成排序的块-I-II" class="headerlink" title="5. 最多能完成排序的块 I/II"></a><font color="blue">5. 最多能完成排序的块 I/II</font></h3><ul><li><p>总结：==最大的元素标记了一个段==</p></li><li><p>题解</p><ol><li>无重复的元素：可以直接i==maxnum的时候res++</li><li>有重复的元素<br> 使用单调栈<br> 1.如果大于等于栈顶，直接入栈， 也就是重复元素是可以单独成块的<br> 2.如果小于，那么将栈顶下面小于当前值的元素pop掉，然后压入原来的栈顶</li></ol></li></ul><h3 id="6-基本计算器-基本计算器-基本计算器-（表达式中可能有空格）"><a href="#6-基本计算器-基本计算器-基本计算器-（表达式中可能有空格）" class="headerlink" title="6. 基本计算器/基本计算器||/基本计算器||| （表达式中可能有空格）"></a><font color="red">6. 基本计算器/基本计算器||/基本计算器||| （表达式中可能有空格）</font></h3><ul><li>第一个是只有正负符号和括号，（直接将括号展开）因此不需要转化逆波兰，只需要一个递归符号的栈+一个当前数的前面的符号就可以了；res+=s.top()* sign *num   易错点：注意在（ 要手动赋值当前的sign=1</li><li>第二个是有+-*/ ，但是全是正整数，因此只需要逆波兰，一个数字栈一个符号栈，在压栈的同时，根据优先级计算结果，同时在最后判断符号栈是否为空，如果不为空的话，需要将符号栈里面的元素逐个弹出</li><li>第三个是有+-*/ 和括号，如题2，在（压入栈中，在）依次弹出符号栈中的符号</li><li>第四个，自己的扩展，在第三个上面加上数据可以为正负； 难点在于判断-是负号还是减号<br>  1）将所有空格去掉 ，题目必须保证两个运算符号不会同时出现<br>  2）在num里面压入0，因为可能出现-(2+6)这种情况<br>  3）在（-变为（0-；将（+ 变为（0+<br>  4）题解如第三题</li></ul><h3 id="7-lc362-design-hit-counter"><a href="#7-lc362-design-hit-counter" class="headerlink" title="7.  lc362. design-hit-counter"></a>7.  lc362. design-hit-counter</h3><p>这道题和单调没有什么关系，主要是队列</p><ul><li>这道题让我们设计一个点击计数器（设计数据结构），能够返回五分钟内的点击数，提示了有可能同一时间内有多次点击。</li><li>由于操作都是按时间顺序的，下一次的时间戳都会大于等于本次的时间戳，那么最直接的方法就是用一个队列queue，每次点击时都将当前时间戳加入queue中，然后在需要获取点击数时，我们从队列开头开始看，如果开头的时间戳在5分钟以外了，就删掉，直到开头的时间戳在5分钟以内停止，然后返回queue的元素个数即为所求的点击数，</li><li>follow up： 比较重要，因为在每个时间戳可能有多个数，所以可以用两个300大小数组，记录时间戳和点击数，节省时间和空间，每个时间戳应该放在timestamp%300的位置，因为多个timestamp映射同一个位置，所以需要先判断当前位置是不是放的当前这个数；然后read的时候，遍历300次，如果满足在5分钟内的条件，就res+=times[i]</li><li>解题链接：<a href="https://www.cnblogs.com/grandyang/p/5605552.html">[LeetCode] 362. Design Hit Counter 设计点击计数器 - Grandyang - 博客园</a></li></ul><h3 id="8-lc456-132-Pattern"><a href="#8-lc456-132-Pattern" class="headerlink" title="8. lc456. 132 Pattern"></a><font color="red">8. lc456. 132 Pattern</font></h3><ul><li><p>找到是否存在132这样的数对</p></li><li><p>枚举3， 然后维护遍历到3左边的最小值，那么就找到了1， 问题的关键在于如何找到2， 就是找到3右边最大小于3的数</p></li><li><p>方法1： 使用单调栈（找到每个数右边，第一个小于这个数的最大数，注意不是第一个小于他的数，而是小于他的最大数）进行预处理，并将结果存在一个vector中，时间复杂度为O(nlogn)<br>第一个小于他的数： 左到右， 单增<br>第一个小于这个数的最大数：二分查找（multiset） 转为找到第一个大于leftmin的数</p></li><li><p>方法二：使用栈记录3（左到右，递增，3越来越大）， 变量记录2，使得3 2都尽可能大; 然后枚举1，如果1小于当前变量记录值two，那么return true;<br>在这个过程中，two会逐渐变高，不会出现two下降的情况</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> two = INT_MIN;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = size - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>&#123;<br>    <span class="hljs-keyword">if</span>(nums[i]&lt;two)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>()&amp;&amp;nums[i]&gt;s.<span class="hljs-built_in">top</span>())&#123; <span class="hljs-comment">//找到小于他的最大值, 逐渐增大two</span><br>        two = s.<span class="hljs-built_in">top</span>();<br>        s.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    s.<span class="hljs-built_in">push</span>(nums[i]);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>类似的一个题: lc334. 递增的三元子序列 （类似模式123）</p><ul><li>找到i, j, k使得nums[i]&lt; nums[j] &lt; nums[k]</li><li>使用一个单调递增栈，同时不断减少当前数字在栈中位置的那个数， 比如1 5，7 后来访问到 3改为 1， 3， 7（一定注意使用lower_bound） 类似最长递增子序列长度大于3</li><li>方法二：两次遍历，求每个数的leftMin 和rightMax, 看是否有一个数在两者之间</li></ul><h3 id="9-lc895-最大频率栈"><a href="#9-lc895-最大频率栈" class="headerlink" title="9. lc895. 最大频率栈"></a>9. lc895. 最大频率栈</h3><ul><li>这个和LFU有点相像，但是实际上是不同的， LFU是删除最低频率的元素，但是这个是删除最高频率的栈中元素</li><li>因此不需要每次改变频率的时候都从原来的频率栈中弹出，同理，每次减低频率的时候，也不用弹出+加入新的频率</li><li>实际的解决方法用两个hash, 一个存储&lt;k, freq&gt; 一个存储&lt;freq, vector<k>&gt;/&lt;freq, stack<k>&gt;</k></k></li><li>一定要注意这两个hash一定要同时修改，不能只修改一个，频率包含的元素在变，元素当前的频率在变</li><li>LFU是使用unordered_map&lt;int, NodeList*&gt; 存储频率到一个双向链表； 以及一个unordered_map&lt;int, Node*&gt; 存储key到节点的位置</li></ul><h3 id="10-lc6080-使数组按非递减顺序排列-mid实际上有hard难度"><a href="#10-lc6080-使数组按非递减顺序排列-mid实际上有hard难度" class="headerlink" title="10. lc6080. 使数组按非递减顺序排列(mid实际上有hard难度)"></a><font color="red">10. lc6080. 使数组按非递减顺序排列(mid实际上有hard难度)</font></h3><ul><li>找到每个数左边第一个比该数大的数的距离的变形题目</li><li>题意：每轮删除相邻的 nums[i - 1] &gt; nums[i] 的 nums[i]， 问删除多少轮，使得数组变为 非递减 数组</li><li>解决方案：<ul><li>使用单调栈找到每个数左边第一个比他大的数，那么就是最大的跨度</li><li>易错点：<font color="red"> 因为中间的数是可以合并的 </font>，所以不能用每个数的最大跨度的最大值作为最后的结果，而只能用找到左边第一个比较大的数过程中 弹出的每个数的 合并间隔 的最大结果+1 作为当前数的合并最大间隔。</li><li>比如：[14,13,2,6,13]最大间隔是4， 结果是3， 因为13， 2在第一轮删除， 6在第二轮删除， 13在第三轮删除</li><li>思路类似的别人解法：<a href="https://leetcode.cn/problems/steps-to-make-array-non-decreasing/solution/dan-diao-zhan-by-haodong-du-p5hc/">力扣（LeetCode）官网 - 全球极客挚爱的技术成长平台</a></li></ul></li></ul><h3 id="11-lc1438-绝对差不超过限制的最长连续子数组"><a href="#11-lc1438-绝对差不超过限制的最长连续子数组" class="headerlink" title="11. lc1438. 绝对差不超过限制的最长连续子数组"></a>11. lc1438. 绝对差不超过限制的最长连续子数组</h3><ul><li>两个双端队列可以用来记录一个滑动窗口的最大最小值</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>一定要清楚是单调递增栈还是单调递减栈；判断是单减栈还是单增栈的关键：是弹出的元素对后面的结果不会有影响。同时要注意push的是下标还是值</p></li><li><p>栈适合题目：括号相关，左右的第一个最大最小，表达式求值，模拟文件层数，树结构题目，数字数组（也可能用二分）操作。</p></li><li><p>括号是否匹配也可以转为整数加减问题</p></li><li><p>表达式求值可以直接将表达式转为逆波兰，在对逆波兰求值；或者直接用一个栈求值<br>第一种方法：使用一个结果栈（vector<char>），一个符号栈；如果遇到数字，直接压栈；如果遇到（，压栈；反括号，弹出符号栈中所有符号到结果栈，直到遇到（，并弹出（；运算符，如果符号栈顶符号优先级高于当前栈，那么弹出并压入结果栈，否则直接压入符号栈；最后如何符号栈有值，那么弹出所有符号到结果栈；注意是否有正负， 字母这些边界情况的处理</char></p></li><li><p>求每个数右边第一个比当前数大的数，使用单调递增栈（栈顶到栈底），弹出的时候进行判断<br>//正序遍历求右边，用单调递增栈（栈顶到栈底），弹出的时候判断；逆序遍历，单调递增栈<br>注意：单增还是单减，看从栈顶到栈顶，不是栈低到栈顶<br>（底部）1，2，3，4，5（头部）   是单调递减</p></li><li><p>口诀：左右两边第一个比他大的数，用单调递增栈；比他小的数，用单调递减栈<br> 找较大，那么应该越远越大；找较小，应该越远越小</p></li><li><p>滑动窗口可以看成队列，FIFO</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈, 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode/单调栈相关</title>
      <link href="/2021/11/13/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/leetcode-%E5%8D%95%E8%B0%83%E6%A0%88%E7%9B%B8%E5%85%B3/"/>
      <url>/2021/11/13/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/leetcode-%E5%8D%95%E8%B0%83%E6%A0%88%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>scheduler_ralated</title>
      <link href="/2021/11/12/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/scheduler-ralated/"/>
      <url>/2021/11/12/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/scheduler-ralated/</url>
      
        <content type="html"><![CDATA[<h2 id="任务介绍"><a href="#任务介绍" class="headerlink" title="任务介绍"></a>任务介绍</h2><p>调度需要关注的问题/或者目标：提高资源利用率，负载均衡，用户的优先级和公平性<br>可能是针对深度学习场景的调度，也可能是平常的请求任务</p><h2 id="阿里项目"><a href="#阿里项目" class="headerlink" title="阿里项目"></a>阿里项目</h2><p>资源池化的理解：<br>CPU、内存、磁盘、I/O等硬件变成可以动态管理的“资源池”，从而提高资源的利用率，简化系统管理，实现服务器整合。核心思想：能够通过区分资源优先次序并随时随地能够将服务器资源分配给最需要它们的工作负载来简化管理和提高效率，从而减少为单个工作负载峰值而存储的资源。</p><blockquote><p>池化简单来讲就是使用远程访问的形式使用GPU资源，任务使用本机的CPU和另一台机器的GPU，两者通过网络进行通信。</p></blockquote><p>参考文献:<a href="https://bbs.cvmart.net/articles/3696">极市开发者平台-计算机视觉算法开发落地平台-极市科技</a></p><p>深度学习场景下异构池化资源管理和任务调度研究</p><p>池化和异构集群下的资源调度有什么区别？</p><p>相关研究工作：</p><p>Demand Based Hierarchical QoS Using Storage Resource Pools</p><p>化零为整:将多台服务器上的GPU集合起来提供给一个容器或者一个虚拟机使用<br>隔空取物：将虚拟机或者容器运行在一台没有物理 GPU 的服务器上，通过计算机网络，透明地使用另一台服务器上的 GPU 资源。<br>小模型场景的典型应用：从算力和显存两个角度，对GPU资源进行切分</p><p>问题：<br>这个池化是GPU还是包括CPU， 存储所有资源的池化<br>这个GPU的池化和云服务器有什么区别<br>GPU池化之后，拉远，数据传输的开销如何弥补<br>如果做到多个应用之间互不影响的，因为虽然充分应用了GPU的显存和算力资源，但是数据传输的带宽，不会因为任务量多，而相互竞争，从而影响效率吗</p><p>通过算力和显存从切分， 不在一个GPU上算力和显存如何协作起来，完成一件事情<br>与k8S的区别在哪里</p><p>为什么需要劫持调用才能实现资源的隔离</p><p>这里的调度是分配好了，就固定直到任务结束，还是像gandivia一样需要动态调整<br>主要是针对deep learning 的训练 推理还是普遍多任务背景下的任务调度，与资源池化</p><h2 id="相关论文总结："><a href="#相关论文总结：" class="headerlink" title="相关论文总结："></a>相关论文总结：</h2><h2 id="1-Multi-Job："><a href="#1-Multi-Job：" class="headerlink" title="1. Multi-Job："></a>1. Multi-Job：</h2><p>Gandiva: 主要是针对multi-job 超参数搜索的场景下的可预测性，在训练过程中，自适应的调整job, 最大化GPU资源的利用率</p><h2 id="2-训练推理混合调度："><a href="#2-训练推理混合调度：" class="headerlink" title="2. 训练推理混合调度："></a>2. 训练推理混合调度：</h2><p>AntMan : Dynamic Scaling on GPU Clusters for Deep Learning<br>PipeSwitch: Fast Pipelined Context Switching for Deep Learning Applications</p><p>将推理任务插入训练的时间片中，充分利用GPU的资源</p><h2 id="3-池化相关"><a href="#3-池化相关" class="headerlink" title="3. 池化相关"></a>3. 池化相关</h2><p>LegoOS: A Disseminated, Distributed OS for Hardware Resource Disaggregation<br>推翻常规的整体server模式，使process memory和storage通过网络来进行通讯，而不是总线，使用一个全局manager进行粗粒度的分配，然后使用一个local manager进行细粒度资源管理</p><p>rCUDA remote CUDA<br>rCUDA: Going Further in Remote GPU Virtualization<br>VMware-vSphere-Bitfusion<br>驱动科技的GPU拉远策略</p><h2 id="4-异构-集群资源调度"><a href="#4-异构-集群资源调度" class="headerlink" title="4. 异构/集群资源调度"></a>4. 异构/集群资源调度</h2><p>Scaling Large Production Clusters with Partitioned Synchronization<br>主要是多个调度器对集群支援进行调度，同时为了保证调度维持较好的实时性，减低可能发生的资源竞争，使用时间片轮训的方式，让一个调度器对多个机器组成的组进行调度</p><p>HiveD : Sharing a GPU Cluster for Deep Learning with Guarantees<br>Heterogeneity-Aware Cluster Scheduling Policies for Deep Learning Workloads<br>Topology-aware GPU scheduling for learning workloads in cloud environments<br>Tiresias: A GPU cluster manager for distributed deep learning<br>Gandiva: Introspective cluster scheduling for deep learning</p><h2 id="5-针对深度学习的GPU共享survey"><a href="#5-针对深度学习的GPU共享survey" class="headerlink" title="5. 针对深度学习的GPU共享survey"></a>5. 针对深度学习的GPU共享survey</h2><p><a href="https://bbs.cvmart.net/articles/3696">极市开发者平台-计算机视觉算法开发落地平台-极市科技</a></p><p><a href="https://cloud.tencent.com/developer/article/1766184">Improving GPU Utilization in Kubernetes-腾讯云开发者社区-腾讯云</a>   Improving GPU Utilization in Kubernetes</p><h2 id="6-其他"><a href="#6-其他" class="headerlink" title="6. 其他"></a>6. 其他</h2><p>ParSync:调度器需要进行及时的同步，如果不及时进行同步那么就可能造成大量冲突；但是在同步的时候，如果一个调度器固定同步固定几个机器的话。就无法充分利用机器空闲资源；<br>所以这篇论文提出利用分片同步的策略，就是一个调度器通过轮训的方式，分时段和多个机器进行同步；同时给最后同步的机器更高的优先级，因为它的状态最新，最可信，因此发生冲突的可能性会更小</p><p>Gavel: 针对深度学习的异构感知的集群调度策略； 将调度转为一个优化问题</p><h2 id="k8s学习资源"><a href="#k8s学习资源" class="headerlink" title="k8s学习资源"></a>k8s学习资源</h2><p><a href="https://github.com/0voice/k8s_awesome_document">GitHub - 0voice/k8s_awesome_document: 【2021年新鲜出炉】K8s（Kubernetes）的工程师资料合辑，书籍推荐，面试题，精选文章，开源项目，PPT，视频，大厂资料</a><br>minikube和microk8s</p><h2 id="k8s调度器修改"><a href="#k8s调度器修改" class="headerlink" title="k8s调度器修改"></a>k8s调度器修改</h2><p>自定义k8s调度器<br>调度器其实也是运行在node上面的一个pod<br>调度框架现在更加适用</p><p>感觉扩展程序和调度框架的区别在于：扩展程序修改的extend字段，而框架修改的是plugin字段</p><ul><li>扩展程序：主要实现/filter 和 /prioritize 两个端点的处理程序</li><li>调度框架：实现自己的插件，必须向调度框架注册插件并完成配置，另外还必须实现扩展点接口，对应的扩展点接口我们可以在源码 pkg/scheduler/framework/v1alpha1/interface.go 文件中找到；<br>在最新的 Kubernetes v1.17 版本中，Scheduler Framework 内置的预选和优选函数已经全部插件化，所以要扩展调度器我们应该掌握并理解调度框架这种方式。</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>如何构建自己的k8s Framework插件</p><ul><li><p><a href="https://kubernetes.io/zh/docs/reference/scheduling/config/#multiple-profiles">https://kubernetes.io/zh/docs/reference/scheduling/config/#multiple-profiles</a> 官网上的配置</p></li><li><p>Kubernetes 负责 Kube-scheduler 的小组 sig-scheduling 为了更好的管理调度相关的 Plugin，新建了项目<br>scheduler-plugins 来方便用户管理不同的插件，用户可以直接基于这个项目来定义自己的插件。<br><a href="https://github.com/kubernetes-sigs/scheduler-plugins">GitHub - kubernetes-sigs/scheduler-plugins: Repository for out-of-tree scheduler plugins based on scheduler framework.</a></p></li><li><p>进击的 Kubernetes 调度系统系列文章<br>(一) Scheduling Framework<br><a href="https://www.infoq.cn/article/lYUw79lJH9bZv7HrgGH5">进击的Kubernetes调度系统（一）：Scheduling Framework_服务革新_王庆璨_InfoQ精选文章</a><br>(二) 支持批任务的 Coscheduling/Gang scheduling<br><a href="https://www.infoq.cn/article/Q1l845yOl2GAF8WIVtCW">进击的Kubernetes调度系统（二）：支持批任务的Coscheduling/Gang scheduling_服务革新_王庆璨_InfoQ精选文章</a></p></li><li><p><a href="https://www.cncf.io/wp-content/uploads/2020/08/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%A6%82%E4%BD%95%E6%89%A9%E5%B1%95Kubernetes-%E8%B0%83%E5%BA%A6%E5%99%A8%E6%94%AF%E6%8C%81-AI-%E5%92%8C%E5%A4%A7%E6%95%B0%E6%8D%AE%E4%BD%9C%E4%B8%9A%EF%BC%9F1-xi-jiang.pdf">阿里巴巴如何扩展Kubernetes-调度器支持-AI-和大数据作业</a></p></li></ul><p><a href="https://www.servicemesher.com/blog/202003-k8s-scheduling-framework/">202003-k8s-scheduling-framework</a> 插件里面每个需要实现的函数包括哪些，主要还是go语言实现</p><h2 id="microk8s安装问题及解决"><a href="#microk8s安装问题及解决" class="headerlink" title="microk8s安装问题及解决"></a>microk8s安装问题及解决</h2><h2 id="1-enable网络连不上"><a href="#1-enable网络连不上" class="headerlink" title="1. enable网络连不上"></a>1. enable网络连不上</h2><p><a href="https://blog.51cto.com/u_10272167/2711146">Microk8s 安装helm3_51CTO博客_microk8s 安装到centos</a><br>将脚本拷贝出来，然后修改为国内网站，然后再下载</p><h2 id="2-helm-command-not-found"><a href="#2-helm-command-not-found" class="headerlink" title="2.helm command not found"></a>2.helm command not found</h2><p>sudo snap install helm –classic</p><h2 id="3-adaptive-dl下载的时候可能会出现问题"><a href="#3-adaptive-dl下载的时候可能会出现问题" class="headerlink" title="3. adaptive dl下载的时候可能会出现问题"></a>3. adaptive dl下载的时候可能会出现问题</h2><p>重试一次就好了<br><a href="https://githublab.com/repository/issues/petuum/adaptdl/106">Adaptive DL问题解决</a></p><h2 id="4-docker连接的时候出现permission-denied"><a href="#4-docker连接的时候出现permission-denied" class="headerlink" title="4. docker连接的时候出现permission denied"></a>4. docker连接的时候出现permission denied</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo groupadd docker<br>sudo gpasswd -a <span class="hljs-variable">$USER</span> docker <span class="hljs-regexp">//</span>添加当前用户到docker组中<br>sudo gpasswd -a <span class="hljs-variable">$shu</span> <span class="hljs-regexp">//</span>查看是否添加成功<br>newgrp docker<br></code></pre></td></tr></table></figure><p>方法二：<br>sudo groupadd docker<br>sudo usermod -aG docker $USER<br>newgrp docker</p><p>方法三：<br>sudo chmod 666 /var/run/docker.sock （ok）</p><h2 id="5-Dockerfile运行的时候-pip-install-非常缓慢"><a href="#5-Dockerfile运行的时候-pip-install-非常缓慢" class="headerlink" title="5. Dockerfile运行的时候 pip install 非常缓慢"></a>5. Dockerfile运行的时候 pip install 非常缓慢</h2><p>加上国内源： <code>-i https://pypi.tuna.tsinghua.edu.cn/simple</code></p><h2 id="6-建立用户组并修改权限"><a href="#6-建立用户组并修改权限" class="headerlink" title="6. 建立用户组并修改权限"></a>6. 建立用户组并修改权限</h2><p>sudo usermod -aG microk8s $USER 创建microk8s用户组<br>sudo groupadd microk8s<br>sudo gpasswd -a $USER microk8s<br>newgrp microk8s</p><h2 id="7-k8s镜像创建方法"><a href="#7-k8s镜像创建方法" class="headerlink" title="7. k8s镜像创建方法"></a>7. k8s镜像创建方法</h2><h3 id="k8s私有镜像创建方法"><a href="#k8s私有镜像创建方法" class="headerlink" title="k8s私有镜像创建方法"></a>k8s私有镜像创建方法</h3><p>私有registry的创建：理解为让自己的服务器作为k8s docker镜像的仓库</p><p>需要先创建一个docker 私有仓库，然后使用insecure-registries:<br><a href="https://yeasy.gitbook.io/docker_practice/repository/registry">私有仓库 - Docker — 从入门到实践</a> (私有创建方法)<br>然后修改</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus">sudo vim /etc/docker/daemon<span class="hljs-selector-class">.json</span><br>&#123; <br> <br><span class="hljs-string">&quot;registry-mirrors&quot;</span>: <span class="hljs-selector-attr">[<span class="hljs-string">&quot;https://registry.docker-cn.com&quot;</span>]</span>, <br> <br><span class="hljs-string">&quot;insecure-registries&quot;</span>:<span class="hljs-selector-attr">[<span class="hljs-string">&quot;127.0.0.1:5000&quot;</span>]</span> <br> <br>&#125; <br></code></pre></td></tr></table></figure><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># 重载修改过的配置文件 </span><br>sudo systemctl daemon-reload <br><span class="hljs-meta"># 重启docker service </span><br>sudo systemctl restart docker.service <br><span class="hljs-meta"># 查看docker service 状态 </span><br>systemctl status docker.service<br></code></pre></td></tr></table></figure><h3 id="共有registry的创建方法"><a href="#共有registry的创建方法" class="headerlink" title="共有registry的创建方法"></a>共有registry的创建方法</h3><p>共有registry的创建：理解为让dockerhub作为k8s docker镜像的仓库<br><a href="https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/#create-a-secret-by-providing-credentials-on-the-command-line">Pull an Image from a Private Registry | Kubernetes</a></p><h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><p>上传不成功，需要修改为 用户名/镜像名 的样子<br>export ADAPTDL_SUBMIT_REPO=index.docker.io/cindybrain/adaptdl-submit<br>export ADAPTDL_SUBMIT_REPO_CREDS=regcred</p><p>运行adaptdl hello world例子<br>sudo microk8s.kubectl version 测试是否有权限<br>sudo microk8s.kubectl create –dry-run=client -f hello_world/adaptdljob.yaml -o json<br>提交语句<br> adaptdl submit hello_world</p><p>目前遇到的问题：</p><blockquote><p>Failure (InternalError): Internal error occurred: failed calling webhook “adaptdl-validator.adaptdl.svc.cluster.local”: Post <a href="https://adaptdl-validator.adaptdl.svc/validate?timeout=10s">https://adaptdl-validator.adaptdl.svc:443/validate?timeout=10s</a>: dial tcp 10.152.183.186:443: connect: connection refused</p></blockquote><p><a href="https://www.qikqiak.com/post/k8s-admission-webhook/">深入理解 Kubernetes Admission Webhook-阳明的博客|Kubernetes|Istio|Prometheus|Python|Golang|云原生</a></p><h2 id="现有的调度算法总结"><a href="#现有的调度算法总结" class="headerlink" title="现有的调度算法总结"></a>现有的调度算法总结</h2><ol><li>使用类似gpu-share的方法，将任务按照memory-request进行gpu-memory的分配，使用最少适配方法</li><li>建立规则进行调度。将workload特征 进行感知分类后进行资源的调度，比如延迟敏感性感知（决定任务优先级）、CPU敏感性感知（CPU处理更多还是GPU处理更多）、拓扑逻辑敏感性感知</li><li>建立模型自动进行资源调度。</li></ol><h2 id="github资源汇总"><a href="#github资源汇总" class="headerlink" title="github资源汇总"></a>github资源汇总</h2><p>目标找到：主要针对推理任务+ 提高 GPU资源利用率（最好是使用GPU资源共享的）相关的论文<br>问题: 池化和GPU共享(使用GPU共享的调度 gpushare)最主要的区别在哪？在于能够将一个任务分配到不同GPU上么</p><ol><li>gpushare-scheduler-extender<br><a href="https://github.com/AliyunContainerService/gpushare-scheduler-extender">code</a><br>基于的假设:cuda核的数量和GPU内存是成正比的，因此在进行调度的时候查看一个任务需要的GPU内存需求，使用最佳适配原则（选择大于任务需求内存中同时最小的一个设备）来进行任务的调度。主要针对推理场景，而且不会保证任务共享资源的隔离</li></ol><ol start="2"><li> 针对资源的负载均衡的调度算法<br><a href="https://github.com/adolphlwq/liang">code</a><br>提出两种算法：针对NetWork资源均衡 （BN算法）+ CPU, Memory, disk IO and network IO均衡的（CMDN算法），使用k8s extender实现代码<br><a href="https://developpaper.com/how-to-customize-kubernetes-scheduling-algorithm/">论文解析博客</a>（可能是毕设论文或者个人实现项目，因为没有相关文献找到）</li></ol><ol start="3"><li> 微软的针对深度学习的调度器<br><a href="https://anonymity1.github.io/2021/04/06/osdi2020-HiveD/">论文解析博客</a><br><a href="https://github.com/microsoft/hivedscheduler">code</a><br><a href="https://www.usenix.org/conference/osdi20/presentation/zhao-hanyu">论文</a><br><a href="https://cs.fudan.edu.cn/1b/d5/c24259a269269/page.htm">论文作者概述</a><br>主要是针对深度学习训练场景 对 1. 拓扑逻辑感知的资源保障 和 2. gang-scheduling 3. 任务的优先级 三方面 进行了优化，<br>idea 1. 将资源进行分层，实现细粒度资源调度：5GPU（最小cell是一个GPU，第一层） -&gt; PCIe switch -&gt; CPU socket -&gt; node -&gt; Rack（第5层）<br>使用伙伴算法，如果没有找到第k层可用资源，就将第k+1层拆分为第k层。尽可能保持粗粒度的资源没有被占用。<br>idea 2. 使用低优先级任务充分利用GPU资源，如果高优先级任务未找到可用资源的时候，可以抢占低优先级任务的资源</li></ol><p>异同：<br>这篇论文拆分最小粒度还是1GPU，并没有考虑到拆分GPU情况（GPU-share），虽然减少了资源碎片问题，但是单个GPU的碎片并没有解决<br>池化场景应该GPU粒度可以更细的拆分，同时还要考虑到异构，以及提高单个GPU资源利用率（GPU-share场景）,以及可能存在的隔离问题</p><p>现在推理的时候会考虑分布式吗？还是主要关注资源的共享和隔离 方面的调度<br>总结一下算法！！！！</p><ol start="4"><li><p>Firmament Fast, centralized cluster scheduling at scale<br>OSDI16 - 在k8s上进行修改的调度器， 使用图的最小流算法来确定调度的方案（Min-cost flow scheduler / min-cost max-flow (MCMF) optimization.）主要解决的是 高质量的放置策略通常会带来较高的放置延迟 问题<br>背景是一个任务被调度到不同的机器，会导致不同的cost（调度时延等）, 如何求一个最好的调度方案能够使得最后的cost最小<br><a href="https://github.com/coreos/ksched">code</a><br>没有非常仔细的看</p></li><li><p> 一个根据GPU指标来进行调度的调度器<br><a href="https://github.com/Mr-Linus/Yoda-Scheduler">code</a><br>就是找到GPU mem/clock/数量 符合条件的设备（过滤）， 然后根据每个设备的带宽，时钟，核， 空闲的内存，总内存等值来求三个分数（打分）<br>CalculateBasicScore(data.Value, s, pod) + CalculateAllocateScore(info, s) + CalculateActualScore(s) 最后得到candidate 设备的总分数，为什么这么计算，没有说</p></li><li><p>现有的k8s 框架提供的一系列有关调度规则的插件<br><a href="https://github.com/kubernetes-sigs/scheduler-plugins">code</a></p></li></ol><ul><li>Capacity scheduling： 弹性的资源分配策略。定义每个任务的时候定义min, max资源，max该任务可以利用的最大资源 min表示为了保证整个任务运行的最少资源，在分配的时候只需要保证每个任务的min 加起来不超过节点GPU要求，<br>但是在实际运行的时候，每个任务可以暂时借用其他任务没用的资源，错时能够达到任务的最大资源，相比最开始就分配给每个任务最大资源提高了资源的利用率</li><li>Coscheduling：多个任务要么同时启动要么都不启动的这种情况，现有的k8s可能会导致部分这样任务得到调度，部分没有，从而得到调度的任务一直等待状态，造成资源的浪费。这个插件就能通过将这些任务定义为同一个PodGroup使这样的任务具有相同优先级，在队列中排在一起，同时使用延迟绑定的方法，如果再出现上述情况，此时与Default Scheduler不同的是，并不是直接将3个Pod调度并创建。而是通过Framework的Permit机制进行等待。</li><li>NodeResourcesLeastAllocatable： 就是在调度的时候选择满足要求，剩余资源最少/最接近的资源进行调度，这样更多的资源就被保留给需求更大的任务调度<br>（NodeResourcesLeastAllocated：选择满足要求，已分配资源最少的节点）</li><li>Topology Aware Scheduling：在进行资源选择的时候会将NUMA拓扑逻辑结构作为输入信息考虑</li><li>Preemption Toleration: 通过定义PriorityClass使得任务之间可以实现抢占，相比于默认的k8s提供的抢占功能，多了条件抢占/low-non-preempted priority class等功能</li><li>Trimaran: Load-aware scheduling plugins： 设定资源利用率为x%,那么在进行选择的时候就选择调度方案使得集群每个节点利用率都接近x%。<br>包括下面两个插件<pre><code class="hljs">- TargetLoadPacking 插件：它是 bin pack 算法的最佳变体，它根据节点的实际资源利用率对节点进行评分，所有使用的节点都有大约 x% 的利用率。一旦所有节点达到 x% 利用率，它就会移动到最不适合的变体。- LoadVariationRiskBalancing Plugin：它是一个节点排序插件，根据节点资源利用率的均值和标准差对节点进行排序。它的目的不仅在于平衡平均负载，还在于平衡负载变化引起的风险。</code></pre></li></ul><ol start="7"><li><p>现在k8s拥有的高级调度策略<br>针对不同QoS的任务，执行不同的调度策略。在进行share的时候，尽可能选择best-effort的任务进行抢占和共享， 针对Garantee任务，尽可能分配空闲的机器，而不是共享的机器<br><a href="https://www.alibabacloud.com/blog/getting-started-with-kubernetes-%7C-scheduling-and-resource-management_596298">链接</a> （没看完，继续看）<br>针对单个用户/命名空间 分配的资源量不能超过一个阈值<br>the total submission amount of a business or a user must be limited so that all the resources of the entire cluster cannot be occupied by one business or user.<br>现有share的是 不同QoS任务 时间片的共享，我们是否可以利用这个规则+CPU敏感/GPU敏感任务/共享敏感  指定GPU内存共享的规则 （任务分类处理思想好像比较老）</p></li><li><p>一个batch的同步变为了众多小数据（minibatch）上的异步，计算完一个minibatch就立刻反向，一个minibatch的反向结束之后就更新对应worker的梯度<br>没有代码，但是是建立了一个模型来进行GPU利用率的预测</p></li><li><p>也是有关于GPU共享的-应该是腾讯的vCuda项目<br><a href="https://github.com/tkestack/gpu-admission">调度器code</a><br><a href="https://github.com/tkestack/gpu-manager">manager_code</a><br>（also supports the payload with fraction resource of GPU device such as 0.1 card or 100MiB gpu device memory.）<br><a href="https://ieeexplore.ieee.org/abstract/document/8672318">相关论文</a><br><a href="https://blog.csdn.net/o0haidee0o/article/details/119407372">部署/使用文档</a> </p></li></ol><p>调度器实现的两个目标:<br>provides quota limitation according to GPU device type<br>avoids fragment allocation of node by working with gpu-manager<br>(感觉类似gpu-share找到满足条件且提供最小资源的node， 同时gpu-manager能够实现将多个任务放在一个节点上，感觉是从算力角度<br>对GPU资源进行划分，因为可以将GPU分成几分之几的GPU)</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用微软（训练） gpu-share gpu-admission antman(无代码) 进行对比</p><p><a href="https://github.com/HuaizhengZhang/Awesome-System-for-Machine-Learning/blob/master/training.md">论文及代码仓库汇总</a></p><p><a href="https://www.alibabacloud.com/blog/getting-started-with-kubernetes-%7C-scheduling-and-resource-management_596298">阿里云针对k8s现有算法的介绍</a></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>CPU资源是和GPU资源绑定分配还是一起分配<br>池化和GPU共享(使用GPU共享的调度 gpushare)最主要的区别在哪？在于能够将一个任务分配到不同GPU上么</p><p>论文的话一般是从策略角度，如果要具体算法的话，可能需要看repo 源码，但是现有的开源论文并不多</p>]]></content>
      
      
      
        <tags>
            
            <tag> scheduler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python相关</title>
      <link href="/2021/11/11/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/python%E7%9B%B8%E5%85%B3/"/>
      <url>/2021/11/11/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/python%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="Python语言部分"><a href="#Python语言部分" class="headerlink" title="Python语言部分"></a>Python语言部分</h2><ol><li>python 开启debug模式，使用logger.setLevel 以及在logger的时候设置不同的logger.info  logger.error  logger.warning等</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> logging<br><span class="hljs-keyword">import</span> requests<br>logging.basicConfig(level=logging.DEBUG,<br>                    <span class="hljs-built_in">format</span>=<span class="hljs-string">&#x27;%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s&#x27;</span>,<br>                    datefmt=<span class="hljs-string">&#x27;%a, %d %b %Y %H:%M:%S&#x27;</span>,<br>                    filename=<span class="hljs-string">&#x27;myapp.log&#x27;</span>,<br>                    filemode=<span class="hljs-string">&#x27;w&#x27;</span>)<br> <br>logging.debug(session.get(<span class="hljs-string">&#x27;http://www.qq.com&#x27;</span>))<br>logging.debug(session.get(<span class="hljs-string">&#x27;http://www.qq.com&#x27;</span>))<br><br></code></pre></td></tr></table></figure><p>tuple和list的区别</p><p>tuple和list都可以通过下标访问元素，但是list是可以修改列表中的元素， 但是tuple一旦初始化就不能修改，不能append和insert</p><h2 id="PyTorch-部分"><a href="#PyTorch-部分" class="headerlink" title="PyTorch 部分"></a>PyTorch 部分</h2><h3 id="1-模型使用dataparallel进行并行训练与加载"><a href="#1-模型使用dataparallel进行并行训练与加载" class="headerlink" title="1. 模型使用dataparallel进行并行训练与加载"></a>1. 模型使用dataparallel进行并行训练与加载</h3><p>在如果在模型训练的时候，一部分卷积使用的是dataparallel一部分使用的是直接cuda (比如alexnet) 这种情况在模型参数的加载的时候，需要修改keys中包含 module.的部分（dataparallel 部分）</p><p>方法一:<br>修改保存或者加载时的字典</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs haxe">from collections <span class="hljs-keyword">import</span> OrderedDict<br><span class="hljs-keyword">new</span><span class="hljs-type">_state_dict</span> = OrderedDict()<br><span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> state_dict.items():<span class="hljs-type"></span><br>    namekey = k[<span class="hljs-number">7</span>:<span class="hljs-type"></span>] <span class="hljs-keyword">if</span> k.startswith(<span class="hljs-string">&#x27;module.&#x27;</span>) <span class="hljs-keyword">else</span> k<br>    <span class="hljs-keyword">new</span><span class="hljs-type">_state_dict</span>[namekey] = v<br></code></pre></td></tr></table></figure><p>方法二：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">uni_model.load_state_dict(&#123;k.replace(<span class="hljs-string">&#x27;module.&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>) :v <span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> model_queue.<span class="hljs-builtin-name">get</span>(<span class="hljs-attribute">block</span>=<span class="hljs-literal">False</span>).items() &#125;)<br></code></pre></td></tr></table></figure><h3 id="2-DatasetFolder类的解读"><a href="#2-DatasetFolder类的解读" class="headerlink" title="2. DatasetFolder类的解读"></a>2. DatasetFolder类的解读</h3><p>数据类别，是通过遍历目标文件夹，得到每个文件夹的名字，以及名字对应的下标<br>make_data返回的是 数据的路径+类别下标 序列元组 List of (sample path, class_index) tuples 得到self.samples<br>然后再在get_item函数中使用path = self.samples[index] self.loader(path) 获得图片实例</p><p>那么我自定义的缓存，既可以在MyDataSet里面的DataSet_ImageNet里面修改，判断是应该从缓存中取还是从文件系统；<br>也可以修改ImageFolder, 里面加一个缓存， 在self.loader那里加上if-else判断语句</p><p>但是多进程会初始化多个dataset, 这样每个进程都会有一个cache， 我的目的应该是只有一个cache, 然后多进程从里面都可以从这个cache中取数据；而且多进程如果每一轮的dataset的实例被销毁的话会导致<br>cache也会被销毁</p><h3 id="3-DatasetLoader类的解读"><a href="#3-DatasetLoader类的解读" class="headerlink" title="3. DatasetLoader类的解读"></a>3. DatasetLoader类的解读</h3><p>问题：<br>worker_init_fn， prefetch_factor 和persistent_workers（保持被实例化的Dataset在下一轮仍然保持alive） 的作用是什么<br>warning中表示如果spwarn start method被使用， 那么worker_init_fn 不能是一个unpicklable object</p><p>_MultiProcessingDataLoaderIter 可以学习一下多进程的退出<br>使用了三个队列 index_queue worker_result_queue data_queue</p><p>workers_done_event 检测一个迭代器是否shut down, 如果一个迭代器进行shutdown，那么那个进程的input_queue里面的数据只需要为None就好了， 就不用一直等待那个queue里面的数据</p><p>为什么要使用 cancel_join_thread()  index_queue.cancel_join_thread()</p><p>记录：<br>多进程每个进程都可以创建多个dataset实例(这个好像是错的), 是否在主函数中初始化一个cacheout类，然后作为dataset的参数传过去，这样多进程也是使用的一个cache<br>主要的逻辑</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self._num_workers):<br>            <span class="hljs-comment"># No certainty which module multiprocessing_context is</span><br>            index_queue = multiprocessing_context.Queue()  <span class="hljs-comment"># type: ignore</span><br>            <span class="hljs-comment"># Need to `cancel_join_thread` here!</span><br>            <span class="hljs-comment"># See sections (2) and (3b) above.</span><br>            index_queue.cancel_join_thread()<br>            w = multiprocessing_context.Process(<br>                target=_utils.worker._worker_loop,<br>                args=(self._dataset_kind, self._dataset, index_queue,<br>                      self._worker_result_queue, self._workers_done_event,<br>                      self._auto_collation, self._collate_fn, self._drop_last,<br>                      self._base_seed + i, self._worker_init_fn, i, self._num_workers,<br>                      self._persistent_workers))<br></code></pre></td></tr></table></figure><p>只有一个worker_result_queue, 以及多个result_queue; 如果pin_memory=True, 那么会将worker_result_queue里面的数据，全部放在另外一个_data_queue中</p><h3 id="4-pyTorch取数据过程详解（面试版本）"><a href="#4-pyTorch取数据过程详解（面试版本）" class="headerlink" title="4. pyTorch取数据过程详解（面试版本）"></a>4. pyTorch取数据过程详解（面试版本）</h3><ol><li>初始化的时候，每个进程都会拥有自己的index_queue,里面最多存储两个batch 的index</li><li>每个worker会不断判断自己的index_queue里面有没有数据，如果有，那么就取读一个batch, 读取的时候调用collate_fn函数，读取之后放入多进程共享的data_queue / worker_result_queue 里面</li><li>data_queue里面的数据会先放入reorder字典中进行重新排序，如果需要的下一个batch在reorder_dict里面，那么就从reorder_dict中弹出这个数据，否则就等待</li><li>某个worker读取的数据被消耗之后，dataloader就会将新的index放到对应worker的index_queue里面，这个worker就继续从queue里面读下标和取数据<br>参考：<br><a href="https://www.dazhuanlan.com/yiliabi/topics/1111356">https://www.dazhuanlan.com/yiliabi/topics/1111356</a></li></ol><h3 id="5-代码常见标记"><a href="#5-代码常见标记" class="headerlink" title="5. 代码常见标记"></a>5. 代码常见标记</h3><p>TODO：英语翻译为待办事项，备忘录。如果代码中有该标识，说明在标识处有功能代码待编写，待实现的功能在说明中会简略说明。</p><p>FIXME：可以拆成短语，fix me ，意为修理我。如果代码中有该标识，说明标识处代码需要修正，甚至代码是错误的，不能工作，需要修复，如何修正会在说明中简略说明。</p><p>XXX：如果代码中有该标识，说明标识处代码虽然实现了功能，但是实现的方法有待商榷，希望将来能改进，要改进的地方会在说明中简略说明。</p><p>HACK：英语翻译为砍。如果代码中有该标识，说明标识处代码我们需要根据自己的需求去调整程序代码。</p><h3 id="6-pytorch安装各种版本链接："><a href="#6-pytorch安装各种版本链接：" class="headerlink" title="6. pytorch安装各种版本链接："></a>6. pytorch安装各种版本链接：</h3><p><a href="https://pytorch.org/get-started/previous-versions/">Previous PyTorch Versions | PyTorch</a></p><h3 id="7-pytorch-多进程数据加载流程"><a href="#7-pytorch-多进程数据加载流程" class="headerlink" title="7. pytorch 多进程数据加载流程"></a>7. pytorch 多进程数据加载流程</h3><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">TODO:</span> 具体看源代码，单进程和多进程区别<br></code></pre></td></tr></table></figure><h3 id="8-iterator和next函数的关系"><a href="#8-iterator和next函数的关系" class="headerlink" title="8. iterator和next函数的关系"></a>8. iterator和next函数的关系</h3><p>生成器都是iterator对象<br>可以被next函数调用的都是一个iterator对象，Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。直到没有数据时抛出StopIteration错误。<br>list/dict/str这些是iterable但是不是iterator</p><p>Python的for循环本质上就是通过不断调用next()函数实现的，首先需要将list作为参数，传入iter函数中，获得一个iterator对象，然后才能调用next函数</p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见问题及解决方案</title>
      <link href="/2021/11/11/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2021/11/11/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h3 id="1-vscode调试的时候找不到路径"><a href="#1-vscode调试的时候找不到路径" class="headerlink" title="1. vscode调试的时候找不到路径"></a>1. vscode调试的时候找不到路径</h3><ul><li>解决方案:在运行的python文件中添加sys.path，同时注意vscode调试的环境可以通过vscode界面最下面一栏进行替换<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">import</span> sys<br><span class="hljs-title">sys</span>.path.append(<span class="hljs-string">&quot;/root/hushuang/IS-code&quot;</span>)<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-程序运行的时候报错-no-module-named-XXX"><a href="#2-程序运行的时候报错-no-module-named-XXX" class="headerlink" title="2. 程序运行的时候报错 no module named XXX"></a>2. 程序运行的时候报错 no module named XXX</h3><ul><li>如果是引入了与当前包并行的其他包里面的python文件，需要对文件使用setup tools进行打包，才能看到其他module里面的python文件<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs clean">setup.py<br>    <span class="hljs-keyword">from</span> setuptools <span class="hljs-keyword">import</span> setup, find_packages<br><br>    setup(<br>        name=<span class="hljs-string">&#x27;IO-aware Importance Sampling&#x27;</span>,               # 应用名<br>        version=<span class="hljs-string">&#x27;1.0&#x27;</span>,              # 版本号<br>        packages=find_packages(),   # 包括在安装包内的Python包<br>        include_package_data=<span class="hljs-literal">True</span>,   # 启用清单文件MANIFEST.<span class="hljs-keyword">in</span><br>        # exclude_package_date=&#123;<span class="hljs-string">&#x27;&#x27;</span>:[<span class="hljs-string">&#x27;.gitignore&#x27;</span>]&#125;,<br>        # install_requires=[          # 依赖列表<br>        #     <span class="hljs-string">&#x27;Flask&gt;=0.10&#x27;</span>,<br>        #     <span class="hljs-string">&#x27;Flask-SQLAlchemy&gt;=1.5,&lt;=2.1&#x27;</span><br>        # ]<br>    )<br><br>install.sh<br>    python setup.py <br><span class="hljs-comment">//生成的XXX.egg.info文件是和install.sh一个目录内， build文件夹 是和setup.py同一个目录内</span><br></code></pre></td></tr></table></figure></li><li>在import的时候不能导入整个包名 比如IOAS/A/a.py 想要访问IOAS/B/b.py的函数时候，不能在a.py函数里面写 from IOAS.B.b import func_XXX; 正确应该是 from B.b import func_XXX; </li></ul><h3 id="3-vscode无法连接远程服务器，但是能够ssh"><a href="#3-vscode无法连接远程服务器，但是能够ssh" class="headerlink" title="3. vscode无法连接远程服务器，但是能够ssh"></a>3. vscode无法连接远程服务器，但是能够ssh</h3><p>解决方案：服务器/home目录满，清理之后就可以了<br>方法二：将~/.vscode-server 删除就可以了</p><h3 id="4-python-出现no-module-find-XX"><a href="#4-python-出现no-module-find-XX" class="headerlink" title="4. python 出现no module find XX"></a>4. python 出现no module find XX</h3><p>一般是一个python文件引用了同一个文件夹里面另外一个python文件，解决方案就是添加一个setup文件，同时一定要注意install文件和setup文件要放在整个目录的最外层 IOAS里面包含的第一层</p><p>如果出现函数参数和报错信息不一致的话，可能是因为setup安装了两个同名的文件，导致出错，使用pip unistall 自己的项目文件名称就可以了</p><h3 id="5-在使用RPC的时候发现如下问题"><a href="#5-在使用RPC的时候发现如下问题" class="headerlink" title="5. 在使用RPC的时候发现如下问题"></a>5. 在使用RPC的时候发现如下问题</h3><blockquote><p> uni_score_rref = rpc.rpc_async(“worker”, get_uni_sample_score_rref, args=(rank, uni_list_rref, model_param_rref, args, ))<br>  File “/nfs/home/shu/.local/lib/python3.6/site-packages/torch/distributed/rpc/api.py”, line 77, in wrapper<br>    return func(*args, **kwargs)<br>  File “/nfs/home/shu/.local/lib/python3.6/site-packages/torch/distributed/rpc/api.py”, line 635, in rpc_async<br>    return _invoke_rpc(to, func, RPCExecMode.ASYNC, args, kwargs)<br>  File “/nfs/home/shu/.local/lib/python3.6/site-packages/torch/distributed/rpc/api.py”, line 481, in _invoke_rpc<br>    PythonUDF(func, args, kwargs)<br>  File “/nfs/home/shu/.local/lib/python3.6/site-packages/torch/distributed/rpc/internal.py”, line 86, in serialize<br>    p.dump(obj)<br>TypeError: can’t pickle _thread.RLock objects</p></blockquote><p>解决：去掉调用rpc函数里面的args参数，因为args参数里面有一个logger 会导致报错</p><h3 id="6-The-results-is-different-when-placing-rpc-aync-at-a-different-py-file"><a href="#6-The-results-is-different-when-placing-rpc-aync-at-a-different-py-file" class="headerlink" title="6. The results is different when placing rpc_aync at a different .py file"></a>6. The results is different when placing rpc_aync at a different .py file</h3><p>I want to execute a function at the worker side and return the results to the master. However, I find that the results is different when placing rpc_async at a different .py file</p><h4 id="Method-1"><a href="#Method-1" class="headerlink" title="Method 1"></a>Method 1</h4><p>master.py:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.distributed.rpc <span class="hljs-keyword">as</span> rpc<br><span class="hljs-keyword">from</span> torch.distributed.rpc <span class="hljs-keyword">import</span> RRef<br><span class="hljs-keyword">from</span> test <span class="hljs-keyword">import</span> sub_fun<br><br>os.environ[<span class="hljs-string">&#x27;MASTER_ADDR&#x27;</span>] = <span class="hljs-string">&#x27;10.5.26.19&#x27;</span><br>os.environ[<span class="hljs-string">&#x27;MASTER_PORT&#x27;</span>] = <span class="hljs-string">&#x27;5677&#x27;</span><br><br>rpc.init_rpc(<span class="hljs-string">&quot;master&quot;</span>, rank=<span class="hljs-number">0</span>, world_size=<span class="hljs-number">2</span>)<br>rref = torch.Tensor([<span class="hljs-number">0</span>])<br>sub_fun(rref)<br>rpc.shutdown()<br></code></pre></td></tr></table></figure><p>test.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>(<span class="hljs-params">rref</span>):</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;function is executed on master&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sub_fun</span>(<span class="hljs-params">rref</span>):</span><br>x = rpc.rpc_async(<span class="hljs-string">&quot;worker&quot;</span>, f, args=(rref,))<br></code></pre></td></tr></table></figure><p>worker.py:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.distributed.rpc <span class="hljs-keyword">as</span> rpc<br><span class="hljs-keyword">from</span> torch.distributed.rpc <span class="hljs-keyword">import</span> RRef<br><br>os.environ[<span class="hljs-string">&#x27;MASTER_ADDR&#x27;</span>] = <span class="hljs-string">&#x27;10.5.26.19&#x27;</span><br>os.environ[<span class="hljs-string">&#x27;MASTER_PORT&#x27;</span>] = <span class="hljs-string">&#x27;5677&#x27;</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>(<span class="hljs-params">rref</span>):</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;function is executed on worker&quot;</span>)<br>rpc.init_rpc(<span class="hljs-string">&quot;worker&quot;</span>, rank=<span class="hljs-number">1</span>, world_size=<span class="hljs-number">2</span>)<br>rpc.shutdown()<br></code></pre></td></tr></table></figure><p>I found that the output is “function is executed on master” at the worker side.</p><h4 id="Method-2"><a href="#Method-2" class="headerlink" title="Method 2"></a>Method 2</h4><p>when I put the two functions: sub_fun and f in the master.py rather than the test.py, the result is “function is executed on worker”.</p><p>Why the two ways output the different results. and how can I get the result 2 with the method 1.</p><h3 id="7-args-删除里面的某个参数"><a href="#7-args-删除里面的某个参数" class="headerlink" title="7. args 删除里面的某个参数"></a>7. args 删除里面的某个参数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">logger_arg = args.logger<br><span class="hljs-keyword">del</span> <span class="hljs-built_in">vars</span>(args)[<span class="hljs-string">&#x27;logger&#x27;</span>]<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;--------args----------&#x27;</span>)<br><span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">list</span>(<span class="hljs-built_in">vars</span>(args).keys()):<br>    <span class="hljs-built_in">print</span>(k)<br>    <span class="hljs-comment"># print(&#x27;%s: %s&#x27; % (k, vars(args)[k]))</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;--------args----------\n&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="8-torch-distributed-rpc-rpc-aync"><a href="#8-torch-distributed-rpc-rpc-aync" class="headerlink" title="8. torch.distributed.rpc.rpc_aync"></a>8. torch.distributed.rpc.rpc_aync</h3><p>rref相关文档 <a href="https://m.w3cschool.cn/pytorch/pytorch-cdva3buf.html">PyTorch 远程参考协议-PyTorch 中文教程-w3cschool</a></p><p><a href="https://github.com/pytorch/pytorch/issues/26759">[RFC] RRef Protocol · Issue #26759 · pytorch/pytorch · GitHub</a></p><h3 id="9-修改账户sudo权限"><a href="#9-修改账户sudo权限" class="headerlink" title="9. 修改账户sudo权限"></a>9. 修改账户sudo权限</h3><p>在有sudo权限的账户下执行 sudo visudo<br>并在下面添加以下权限<br><code>zhinengjisuan ALL=(ALL)     ALL</code></p><h3 id="10-how-to-share-a-cache-among-multiple-subprocesses-when-using-PyTorch-DDP-training"><a href="#10-how-to-share-a-cache-among-multiple-subprocesses-when-using-PyTorch-DDP-training" class="headerlink" title="10. how to share a cache among multiple subprocesses when using PyTorch DDP training."></a>10. how to share a cache among multiple subprocesses when using PyTorch DDP training.</h3><p>I want to share a cache among multiple processes when using ddp training.<br>I found a potential solution is to use shared memory with torch.multiprocessing.<br>However, it is not convinient if I want to training on multiple nodes, thus I choose the method <code>torch.distributed.launch</code> rather than <code>mp.spwarn</code> to init DDP training.<br>The question is how can I share a cache among multiple subprocesses in the same node,  when using the method <code>torch.distributed.init_process_group</code>.<br>Supposed that there are N nodes, we should create N caches, and these subprocesses in the same node share one of the caches.</p><p>Has someone encounter the same problem before?</p><p>已解决:<br>mp.set_start_method(‘spawn’)</p><h3 id="11-nfs-home-shu-local-lib-python3-6-site-packages-PIL-TiffImagePlugin-py-788-UserWarning-Corrupt-EXIF-data-Expecting-to-read-4-bytes-but-only-got-0"><a href="#11-nfs-home-shu-local-lib-python3-6-site-packages-PIL-TiffImagePlugin-py-788-UserWarning-Corrupt-EXIF-data-Expecting-to-read-4-bytes-but-only-got-0" class="headerlink" title="11. /nfs/home/shu/.local/lib/python3.6/site-packages/PIL/TiffImagePlugin.py:788: UserWarning: Corrupt EXIF data.  Expecting to read 4 bytes but only got 0."></a>11. /nfs/home/shu/.local/lib/python3.6/site-packages/PIL/TiffImagePlugin.py:788: UserWarning: Corrupt EXIF data.  Expecting to read 4 bytes but only got 0.</h3><p>  warnings.warn(str(msg))</p><p>solution 1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br><br>imageFolder = /Path/To/Image/Folder<br>listImages = os.listdir(imageFolder)<br><br><span class="hljs-keyword">for</span> img <span class="hljs-keyword">in</span> listImages:<br>    imgPath = os.path.join(imageFolder,img)<br>            <br>    <span class="hljs-keyword">try</span>:<br>        img = Image.<span class="hljs-built_in">open</span>(imgPath)<br>        exif_data = img._getexif()<br>    <span class="hljs-keyword">except</span> ValueError <span class="hljs-keyword">as</span> err:<br>        <span class="hljs-built_in">print</span>(err)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Error on image: &quot;</span>, img)<br></code></pre></td></tr></table></figure><h3 id="12-8a100连接hec报错"><a href="#12-8a100连接hec报错" class="headerlink" title="12. 8a100连接hec报错"></a>12. 8a100连接hec报错</h3><blockquote><p>Torch RPC Connection closed by peer<br>[W tensorpipe_agent.cpp:942] RPC agent for worker encountered error when sending outgoing request #0 to master: ECONNREFUSED: connection refused<br>[W tensorpipe_agent.cpp:942] RPC agent for worker encountered error when sending outgoing request #1 to master: ECONNREFUSED: connection refused</p></blockquote><p>真正的解决方案：<code>backend=rpc.BackendType.PROCESS_GROUP</code>，<br>不需要加其他的 <code>os.environ[&#39;TF_SOCKET_IFNAME&#39;] = &#39;ens3&#39;</code> 或者<code>os.environ[&#39;GLOO_SOCKET_IFNAME&#39;] = &#39;ens3&#39;</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> vscode python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令</title>
      <link href="/2021/11/11/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/Linux%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/11/11/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/Linux%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h3 id="1-rename"><a href="#1-rename" class="headerlink" title="1. rename"></a>1. rename</h3><p>批量修改后缀名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>rename s/\后缀1/\后缀/<span class="hljs-string">&#x27; *</span><br><span class="hljs-string"></span><br><span class="hljs-string">rename s/\后缀1/\后缀/&#x27;</span> ** //递归所有的子目录<br><br>example: rename <span class="hljs-string">&#x27;s/\.tar.gz.1/\.tar.gz/&#x27;</span> *<br></code></pre></td></tr></table></figure><h3 id="2-手动清理缓存"><a href="#2-手动清理缓存" class="headerlink" title="2. 手动清理缓存"></a>2. 手动清理缓存</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">释放缓存区内存的方法<br>1）清理pagecache（页面缓存）<br>[root@backup ~]<span class="hljs-comment"># echo 1 &gt; /proc/sys/vm/drop_caches     或者 # sysctl -w vm.drop_caches=1</span><br> <br>2）清理dentries（目录缓存）和inodes<br>[root@backup ~]<span class="hljs-comment"># echo 2 &gt; /proc/sys/vm/drop_caches     或者 # sysctl -w vm.drop_caches=2</span><br> <br>3）清理pagecache、dentries和inodes<br>[root@backup ~]<span class="hljs-comment"># echo 3 &gt; /proc/sys/vm/drop_caches     或者 # sysctl -w vm.drop_caches=3</span><br>　<br>上面三种方式都是临时释放缓存的方法，要想永久释放缓存，需要在/etc/sysctl.conf文件中配置：vm.drop_caches=1/2/3，然后sysctl -p生效即可！<br> <br>另外，可以使用sync命令来清理文件系统缓存，还会清理僵尸(zombie)对象和它们占用的内存<br>[root@backup ~]<span class="hljs-comment"># sync</span><br></code></pre></td></tr></table></figure><h3 id="3-服务器之间使用scp进行文件传输和同步"><a href="#3-服务器之间使用scp进行文件传输和同步" class="headerlink" title="3. 服务器之间使用scp进行文件传输和同步"></a>3. 服务器之间使用scp进行文件传输和同步</h3><p><code>rsync -r -P --rsh=ssh source_dir dest_dir(shu@10.5.26.19:/nfs/home/shu/hushuang-8a100)</code></p><p>Linux服务器上修改gcc版本<br><a href="https://blog.csdn.net/qq_31175231/article/details/77774971">更改gcc默认版本(gcc版本降级/升级)_修改gcc版本-CSDN博客</a></p><h3 id="4-linux如果安装一半-ctrl-C中止了，锁住如何解决"><a href="#4-linux如果安装一半-ctrl-C中止了，锁住如何解决" class="headerlink" title="4. linux如果安装一半 ctrl+C中止了，锁住如何解决"></a>4. linux如果安装一半 ctrl+C中止了，锁住如何解决</h3><p><code>sudo rm /var/lib/dpkg/lock-frontend</code></p><h3 id="5-mac终端配置代理的方式"><a href="#5-mac终端配置代理的方式" class="headerlink" title="5. mac终端配置代理的方式"></a>5. mac终端配置代理的方式</h3><p><a href="https://github.com/Eathoublu/Content404/blob/master/Use%20Proxy%20on%20mac:linux/mac%E3%80%81linux%E7%BB%88%E7%AB%AF%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86.md">github参考文献</a></p><h3 id="6-在ubuntu服务器上实现科学上网（翻墙）"><a href="#6-在ubuntu服务器上实现科学上网（翻墙）" class="headerlink" title="6. 在ubuntu服务器上实现科学上网（翻墙）"></a>6. 在ubuntu服务器上实现科学上网（翻墙）</h3><p>安装好后，使用ss-local命令，即可运行</p><h3 id="7-挂载nfs-hec节点"><a href="#7-挂载nfs-hec节点" class="headerlink" title="7. 挂载nfs hec节点"></a>7. 挂载nfs hec节点</h3><pre><code class="sudo">mount -t nfs4 ws-nas.zhejianglab.com:/NAS/CAPFS/data/xxznjsxt   /nfs```</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>secrete</title>
      <link href="/2021/11/10/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/secrete/"/>
      <url>/2021/11/10/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/secrete/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="42bdb50f24ef810bd1fe9c3a68189192ac22e3a686b9d240c1c7f8ebad6aba86">792393e20cb95a16d338204aed962f21dfc09fc732608dcc9224b9c53e390244da9a389fb5651bdcf8a6634c53e59a5aa6711d5b381e161d71676c092e311df3</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> private </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rclone</title>
      <link href="/2021/11/08/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/rclone/"/>
      <url>/2021/11/08/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/rclone/</url>
      
        <content type="html"><![CDATA[<h2 id="从google-drive中下载文件的两种方法"><a href="#从google-drive中下载文件的两种方法" class="headerlink" title="从google drive中下载文件的两种方法"></a>从google drive中下载文件的两种方法</h2><h3 id="1-让远程服务器使用rclone挂载google-drive-谷歌云端硬盘"><a href="#1-让远程服务器使用rclone挂载google-drive-谷歌云端硬盘" class="headerlink" title="1.让远程服务器使用rclone挂载google drive (谷歌云端硬盘)"></a>1.让远程服务器使用rclone挂载google drive (谷歌云端硬盘)</h3><p>简易步骤：</p><ol><li><p>下载rclone:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://www.moerats.com/usr/shell/rclone_debian.sh &amp;&amp; bash rclone_debian.sh<br></code></pre></td></tr></table></figure></li><li><p>rclone的配置</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rclone config<br></code></pre></td></tr></table></figure><ol start="3"><li>使用rclone进行google drive的挂载</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#新建本地文件夹，路径自己定，即下面的LocalFolder</span><br>mkdir /root/GoogleDrive<br><span class="hljs-comment">#挂载为磁盘，下面的DriveName、Folder、LocalFolder参数根据说明自行替换</span><br>rclone mount DriveName:Folder LocalFolder --copy-links --no-gzip-encoding --no-check-certificate --allow-other --allow-non-empty --<span class="hljs-built_in">umask</span> 000<br><br><span class="hljs-comment">#eg. DriveName:Folader ==&gt; GoogleDrive:/   LoacalFolder ==&gt; /data1/shu </span><br><br><span class="hljs-comment">#rclone取消挂载</span><br>fusermount -qzu &lt;本地路径&gt;<br></code></pre></td></tr></table></figure><p>参考链接： <a href="https://www.moerats.com/archives/481/">在Debian/Ubuntu上使用rclone挂载Google Drive网盘 - Rat’s Blog</a></p><h3 id="2-从google-drive中使用wget下载单个文件"><a href="#2-从google-drive中使用wget下载单个文件" class="headerlink" title="2. 从google drive中使用wget下载单个文件"></a>2. 从google drive中使用wget下载单个文件</h3><p>1.下载小文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget --no-check-certificate <span class="hljs-string">&#x27;https://docs.google.com/uc?export=download&amp;id=FILEID&#x27;</span> -O FILENAME<br><br><span class="hljs-comment">#有的评论说针对rar文件需要加上-r</span><br>wget --no-check-certificate -r <span class="hljs-string">&#x27;https://docs.google.com/uc?export=download&amp;id=FILEID&#x27;</span> -O FILENAME<br></code></pre></td></tr></table></figure><p>2.下载大文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget --load-cookies /tmp/cookies.txt <span class="hljs-string">&quot;https://docs.google.com/uc?export=download&amp;confirm=<span class="hljs-subst">$(wget --quiet --save-cookies /tmp/cookies.txt --keep-session-cookies --no-check-certificate &#x27;https://docs.google.com/uc?export=download&amp;id=FILEID&#x27; -O- | sed -rn &#x27;s/.*confirm=([0-9A-Za-z_]+)</span>.*/\1\n/p&#x27;)&amp;id=FILEID&quot;</span> -O FILENAME &amp;&amp; rm -rf /tmp/cookies.txt<br><br></code></pre></td></tr></table></figure><p>PS:注意都是下载的文件，不是文件夹; folder目前找到的解决方案是使用循环</p><p>参考链接： <a href="https://gist.github.com/iamtekeste/3cdfd0366ebfd2c0d805">Download Google Drive files with WGET · GitHub</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rclone </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>command-related</title>
      <link href="/2021/11/08/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/command-related/"/>
      <url>/2021/11/08/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/command-related/</url>
      
        <content type="html"><![CDATA[<h3 id="1-让远程服务器节点使用本地节点的vpn进行翻墙，-适用于远程节点"><a href="#1-让远程服务器节点使用本地节点的vpn进行翻墙，-适用于远程节点" class="headerlink" title="1.让远程服务器节点使用本地节点的vpn进行翻墙， 适用于远程节点"></a>1.让远程服务器节点使用本地节点的vpn进行翻墙， 适用于远程节点</h3><p>方法一：<br>假设，服务器上你选择使用端口18860，先在你的mac上运行命令：ssh -C  -N -g -R 18860:127.0.0.1:7890 服务器用户名@服务器ip  然后在服务器运行：export https_proxy=<a href="http://127.0.0.1:18860/">http://127.0.0.1:18860</a> 那么当服务器使用Https去下载东西的时候，就会通过端口18860把下载请求转发到你mac的7890端口，然后你的Mac作为一个代理进行下载，服务器就能获取目的网址的内容了。当你下载完的时候，记得unset https_proxy</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh -C  -N -g -R 18861:127.0.0.1:7890 zhinengjisuan@10.5.30.42 -o ProxyCommand=<span class="hljs-string">&quot;ssh shu@10.5.26.19 -W %h:%p&quot;</span><br>shu@10.5.26.19<span class="hljs-string">&#x27;s password: </span><br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">curl https:<span class="hljs-regexp">//</span>www.baidu.com 反应数据说明连接正确<br></code></pre></td></tr></table></figure><p>方法二: 使用terminus节点，建立一个新的连接，配置如下</p><img src="/2021/11/08/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/command-related/image-20211207175530810.png" class title="image-20211207175530810"><p>这个节点相当于加了方法一的命令 <code>ssh -C  -N -g -R 18860:127.0.0.1:7890 服务器用户名@服务器ip</code></p><p>然后运行一下proxy脚本,相当于方法一的第二条命令，具体的脚本内容如下:意思是bash一停（exit）, 这两条命令的效用就停止了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-built_in">export</span> http_proxy=http://127.0.0.1:18880<br><span class="hljs-built_in">export</span> https_proxy=https://127.0.0.1:18880<br>bash<br></code></pre></td></tr></table></figure><p>PS: 18860是随机选的端口， 7890的clashx的代理端口<br>只能使用curl, 不能使用ping 因为ping是在TCP协议之上的，但是curl是http协议（具体见操作系统）</p><h3 id="2-查看端口号被哪个进程占用"><a href="#2-查看端口号被哪个进程占用" class="headerlink" title="2. 查看端口号被哪个进程占用"></a>2. 查看端口号被哪个进程占用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo lsof -i :7891<br></code></pre></td></tr></table></figure><p>查看某个进程， 例子为dlv</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ps -ef | grep dlv<br></code></pre></td></tr></table></figure><h3 id="3-conda安装torch-1-8-0版本"><a href="#3-conda安装torch-1-8-0版本" class="headerlink" title="3. conda安装torch 1.8.0版本"></a>3. conda安装torch 1.8.0版本</h3><p><code>conda install pytorch==1.8.0 torchvision==0.9.0 torchaudio==0.8.0 cudatoolkit=10.2 -c pytorch</code></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">pip</span> install torch==<span class="hljs-number">1</span>.<span class="hljs-number">8</span>.<span class="hljs-number">0</span>+cu<span class="hljs-number">101</span> torchvision==<span class="hljs-number">0</span>.<span class="hljs-number">9</span>.<span class="hljs-number">0</span>+cu<span class="hljs-number">101</span> torchaudio==<span class="hljs-number">0</span>.<span class="hljs-number">8</span>.<span class="hljs-number">0</span> -f https://download.pytorch.org/whl/torch_stable.html<br></code></pre></td></tr></table></figure><p>//1.8.0 如果运行起来还是非常慢的话，修改为1.7 因为1.8.1稳定版本需要gpu驱动大于hec01 440.33</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">pip</span> install torch==<span class="hljs-number">1</span>.<span class="hljs-number">7</span>.<span class="hljs-number">1</span>+cu<span class="hljs-number">101</span> torchvision==<span class="hljs-number">0</span>.<span class="hljs-number">8</span>.<span class="hljs-number">2</span>+cu<span class="hljs-number">101</span> torchaudio==<span class="hljs-number">0</span>.<span class="hljs-number">7</span>.<span class="hljs-number">2</span> -f https://download.pytorch.org/whl/torch_stable.html -i https://pypi.douban.com/simple some-package<br></code></pre></td></tr></table></figure><h3 id="4-查看并杀死vscode-进程-macos"><a href="#4-查看并杀死vscode-进程-macos" class="headerlink" title="4. 查看并杀死vscode 进程 macos"></a>4. 查看并杀死vscode 进程 macos</h3><p><code>pgrep -f &quot;vscode&quot; | xargs kill</code> 或者 <code>pgrep -f &quot;vscode&quot;</code> 查看进程号之后使用 <code>kill -9 pid</code></p><h3 id="5-本地通过浏览器-跳板机访问远程服务器上的应用-grafana"><a href="#5-本地通过浏览器-跳板机访问远程服务器上的应用-grafana" class="headerlink" title="5.本地通过浏览器+跳板机访问远程服务器上的应用  grafana/"></a>5.本地通过浏览器+跳板机访问远程服务器上的应用  grafana/</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">ssh -L <span class="hljs-number">30091</span>:<span class="hljs-number">127.0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">30090</span> shu@10.<span class="hljs-number">5.26</span>.<span class="hljs-number">66</span> -o ProxyCommand=<span class="hljs-string">&quot;ssh shu@10.5.26.19 -W %h:%p&quot;</span><br></code></pre></td></tr></table></figure><p>将远程服务器的30090端口映射到本地的30091端口，然后可以在本地浏览器中输入<br><code>http://localhost:30090/graph</code>访问远程服务器的登录界面</p><h3 id="6-使用跳板机在服务器间传输文件scp"><a href="#6-使用跳板机在服务器间传输文件scp" class="headerlink" title="6.使用跳板机在服务器间传输文件scp:"></a>6.使用跳板机在服务器间传输文件scp:</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">scp -o <span class="hljs-string">&#x27;ProxyJump shu@10.5.26.19&#x27;</span>  -r /Users/hushuang/Desktop/Graduate_Thesis wanghongsheng<span class="hljs-variable">@10</span>.<span class="hljs-number">5.30</span>.<span class="hljs-number">43</span><span class="hljs-symbol">:/home/wanghongsheng/shu</span><br></code></pre></td></tr></table></figure><h3 id="7-linux-mv命令-将当前文件夹除了xx的文件夹move到另外一个文件夹"><a href="#7-linux-mv命令-将当前文件夹除了xx的文件夹move到另外一个文件夹" class="headerlink" title="7.linux mv命令 将当前文件夹除了xx的文件夹move到另外一个文件夹"></a>7.linux mv命令 将当前文件夹除了xx的文件夹move到另外一个文件夹</h3><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">mv !(github.com|<span class="hljs-type">gopkg</span>.<span class="hljs-built_in">in</span>|<span class="hljs-type">golang</span>.org|<span class="hljs-type">k8s</span>.io) github.com/<br></code></pre></td></tr></table></figure><p>注意：<br><code>mv /!(github.com|gopkg.in|golang.org|k8s.io) github.com/</code> 是错误的！！！！！</p><p>如果出现<code>bash: !: event not found</code>，那么运行下面命令解决<br><code>shopt -s extglob</code></p><h3 id="8-latex中插入代码"><a href="#8-latex中插入代码" class="headerlink" title="8.latex中插入代码"></a>8.latex中插入代码</h3><p><a href="https://blog.csdn.net/u012675539/article/details/49131567">latex 插入代码、代码框、代码配色-CSDN博客</a></p><h3 id="9-Linux查看和删除某一后缀文件命令"><a href="#9-Linux查看和删除某一后缀文件命令" class="headerlink" title="9.Linux查看和删除某一后缀文件命令"></a>9.Linux查看和删除某一后缀文件命令</h3><p>我们可以用以下命令找出当前目录, 包括所有子目录, 中的所有具有后缀.tex的文件并将它们一一删除:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">find . -<span class="hljs-type">name</span> &quot;*.tex&quot; -<span class="hljs-keyword">type</span> f -<span class="hljs-keyword">delete</span><br></code></pre></td></tr></table></figure><p>为保险起见, 我们可以用以下命令先找出当前目录及其子目录中所有具有后缀.tex的文件:</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-built_in">find</span> . -<span class="hljs-built_in">name</span> <span class="hljs-string">&quot;*.tex&quot;</span> -<span class="hljs-built_in">type</span> f<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>about</title>
      <link href="/2021/11/08/summer_intern_company/about/index/"/>
      <url>/2021/11/08/summer_intern_company/about/index/</url>
      
        <content type="html"><![CDATA[<p>Hello, my name is Shuang Hu. I have graduated from Zhejiang University as a postgraduate in March, 2023. Now, I am working at my hometown Chongqing.</p><p>I have two-year research experience in the fields of Deep Learning and Software Development. I have worked on several projects in these areas (details in CV), and have gained valuable skills and knowledge along the way.</p><p>I am a passionate learner and always eager to expand my knowledge and skills. Besides, I also love to take on new challenges. I believe that every challenge presents an opportunity for growth and development, and I am always ready to step up and take on new tasks and responsibilities.</p><p>Finally, I take pride in my work and am fully responsible for every task that I undertake. I expect to have a chance to work with you!</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 相关笔记</title>
      <link href="/2021/11/08/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/hexo-notes/"/>
      <url>/2021/11/08/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/hexo-notes/</url>
      
        <content type="html"><![CDATA[<h3 id="hexo功能"><a href="#hexo功能" class="headerlink" title="hexo功能"></a>hexo功能</h3><h4 id="hexo-主题切换"><a href="#hexo-主题切换" class="headerlink" title="hexo 主题切换"></a>hexo 主题切换</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs php">git <span class="hljs-keyword">clone</span> xxx.git themes/black-blue <span class="hljs-comment">//注意在blog路径里面</span><br><br>vim _config.yml <span class="hljs-comment">//修改theme为black-blue</span><br><br>npm install --save hexo-renderer-jade hexo-<span class="hljs-built_in">generator</span>-feed hexo-<span class="hljs-built_in">generator</span>-sitemap hexo-browsersync hexo-<span class="hljs-built_in">generator</span>-archive<br><br>hexo clean<br><br>hexo g<br><br>hexo s<br><br></code></pre></td></tr></table></figure><h4 id="Hexo-常见命令"><a href="#Hexo-常见命令" class="headerlink" title="Hexo 常见命令"></a>Hexo 常见命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">1.hexo建立某一个目录下的blog<br>hexo new blog -p leetcode/new_name.md<br><br>2.上传到github仓库 (一定注意在mac电脑上使用sudo)<br>sudo hexo d <br><br>3. 生成静态页面<br>hexo generate<br><br>4.查看网页<br>hexo server<br><br>5.本地查看<br>hexo clean &amp;&amp; hexo g &amp;&amp; hexo s<br></code></pre></td></tr></table></figure><p>上传git上面的一系列命令<br>hexo clean &amp;&amp; hexo g &amp;&amp; sudo hexo d</p><h4 id="hexo-source文件上传，-source-分支和master分支"><a href="#hexo-source文件上传，-source-分支和master分支" class="headerlink" title="hexo source文件上传， source 分支和master分支"></a>hexo source文件上传， source 分支和master分支</h4><p><a href="https://blog.csdn.net/itnerd/article/details/114274304">https://blog.csdn.net/itnerd/article/details/114274304</a> </p><h4 id="hexo-github私有仓库"><a href="#hexo-github私有仓库" class="headerlink" title="hexo+github私有仓库"></a>hexo+github私有仓库</h4><p>(参考链接)[<a href="https://hexo.io/zh-cn/docs/github-pages.html#%E7%A7%81%E6%9C%89-Repository]">https://hexo.io/zh-cn/docs/github-pages.html#%E7%A7%81%E6%9C%89-Repository]</a></p><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://juejin.cn/post/6978377036645531662">Mac OS上搭建Hexo博客流程</a><br><a href="https://hexo.fluid-dev.com/docs/guide/#%E6%96%87%E7%AB%A0%E5%9C%A8%E9%A6%96%E9%A1%B5%E7%9A%84%E5%B0%81%E9%9D%A2%E5%9B%BE">配置指南</a></p><h4 id="hexo文章加密或隐藏"><a href="#hexo文章加密或隐藏" class="headerlink" title="hexo文章加密或隐藏"></a>hexo文章加密或隐藏</h4><ul><li><p>设置某一个目录的文章加密<br>在_config.yml文件中设置目录名字和密码 - {name: tagName, password: 密码B}<br>在对应文章中设置tags 为 tagName （默认为private）即可完成文章的加密</p></li><li><p>设置某一文章为hidden<br>如果设置文章 hidden:true则网页上无法搜索到文章，上述方法可以在网页上看文章，但是需要密码<br>查看标签为hidden的文章 <a href="https://github.com/prinsss/hexo-hide-posts">github repo</a><br><code>hexo hidden:list</code> </p></li><li><p>使用草稿箱隐藏<br><a href="https://blog.holic-x.com/wv-blog/post/6aa34fdd.html#hexo-butterfly-%E6%96%87%E7%AB%A0%E9%9A%90%E8%97%8F">使用方法参考链接</a></p></li></ul><h4 id="创建中英文博客"><a href="#创建中英文博客" class="headerlink" title="创建中英文博客"></a>创建中英文博客</h4><ul><li>两个仓库 两个域名 推送/部署两次[参考链接]（<a href="https://youngforest.github.io/2021/09/07/Setup-English-blog/%EF%BC%89">https://youngforest.github.io/2021/09/07/Setup-English-blog/）</a></li><li>一个仓库 一个域名 推送/部署一次<a href="https://www.brando.dev/zh-hans/2021/01/03/%E8%AE%B0%E4%B8%80%E6%AC%A1-Hexo-%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E4%B8%8E%E5%A4%9A%E8%AF%AD%E8%A8%80%E7%AB%99%E7%82%B9%E6%94%B9%E9%80%A0/">参考链接1</a><br><a href="https://zhuanlan.zhihu.com/p/358599353">参考链接2</a></li><li>使用hexo具有中英文切换的主题 minos <a href="https://medium.com/learn-or-die/%E5%88%A9%E7%94%A8-hexo-%E4%BE%86%E5%BB%BA%E7%AB%8B%E4%B8%80%E5%80%8B-%E5%A4%9A%E8%AA%9E%E7%B3%BB-%E9%83%A8%E8%90%BD%E6%A0%BC-4545cc6cdb6">参考链接</a><br>icarus: 中英文文章会同时出现<a href="https://github.com/ppoffice/hexo-theme-icarus/discussions/1046">github repo</a></li><li><a href="https://medium.com/learn-or-die/%E5%88%A9%E7%94%A8-hexo-%E4%BE%86%E5%BB%BA%E7%AB%8B%E4%B8%80%E5%80%8B-%E5%A4%9A%E8%AA%9E%E7%B3%BB-%E9%83%A8%E8%90%BD%E6%A0%BC-4545cc6cdb6">搭建好的博客例子</a></li></ul><h4 id="hexo代码块设置Mac-Panel风格-以及-使用highlightjs设置代码高亮风格"><a href="#hexo代码块设置Mac-Panel风格-以及-使用highlightjs设置代码高亮风格" class="headerlink" title="hexo代码块设置Mac Panel风格 以及 使用highlightjs设置代码高亮风格"></a>hexo代码块设置Mac Panel风格 以及 使用highlightjs设置代码高亮风格</h4><p><a href="https://hwcoder.top/Hexo-Configuration#%E6%B7%BB%E5%8A%A0%E7%99%BE%E5%BA%A6%E8%B0%B7%E6%AD%8C%E6%94%B6%E5%BD%95">hexo代码块设置Mac Panel风格</a><br><a href="https://juejin.cn/s/hexo%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE%E6%9B%B4%E6%94%B9%E4%B8%BB%E9%A2%98">highlightjs设置代码高亮风格</a><br>注意：</p><ul><li>直接将highlightjs 中css文件下载下来放在css/ 或者 /themes/fluid/source/css路径下不起作用</li><li>en/目录下需要再次下载插件</li></ul><h3 id="常见问题及解决方案"><a href="#常见问题及解决方案" class="headerlink" title="常见问题及解决方案"></a>常见问题及解决方案</h3><h4 id="1-文章中插入图片无法显示"><a href="#1-文章中插入图片无法显示" class="headerlink" title="1. 文章中插入图片无法显示"></a>1. 文章中插入图片无法显示</h4><p>解决方法：</p><ul><li>注意将图片放在<code>/source/img</code> 而不是<code>/img</code>路径，即使是首页图像也是如此</li><li>本地图片正常显示，远程部署后无法显示： 安装hexo-asset-image，并修改里面<code>index.js</code>的内容<br><a href="https://cloud.tencent.com/developer/article/2171899">解决方法</a></li></ul><h4 id="2-远程github仓库build-and-deployment的时候失败，出现themes-fluid主题没有找到"><a href="#2-远程github仓库build-and-deployment的时候失败，出现themes-fluid主题没有找到" class="headerlink" title="2. 远程github仓库build and deployment的时候失败，出现themes/fluid主题没有找到"></a>2. 远程github仓库build and deployment的时候失败，出现themes/fluid主题没有找到</h4><p>解决方法：本地仓库执行<code>npm install hexo-cli -g</code> 不要使用-d参数,否则远程运行不通过</p><h4 id="3-本地仓库只能使用https的方式部署，使用ssh-key方式部署出现无法验证身份的问题"><a href="#3-本地仓库只能使用https的方式部署，使用ssh-key方式部署出现无法验证身份的问题" class="headerlink" title="3. 本地仓库只能使用https的方式部署，使用ssh key方式部署出现无法验证身份的问题"></a>3. 本地仓库只能使用https的方式部署，使用ssh key方式部署出现无法验证身份的问题</h4><p>解决方法：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs erlang">给整个blog目录重新赋值权限<br>chmod -X .<br>将sudo hexo d 改为 hexo d<br></code></pre></td></tr></table></figure><p><a href="https://yaune.site/2019/11/20/%E5%B0%86hexo%E9%83%A8%E7%BD%B2%E5%88%B0github%E4%B8%8A%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/">参考链接</a></p><h4 id="个人网页分析"><a href="#个人网页分析" class="headerlink" title="个人网页分析"></a>个人网页分析</h4><ul><li>方法一：<br><a href="https://www.zywvvd.com/notes/tools/umami/umami/">使用unimai和个人服务器搭建网站分析页面</a></li><li>方法二：<br><a href="https://zhuanlan.zhihu.com/p/338903685">使用Google Analytics进行网站页面分析</a><br>注意：按照上述链接操作的时候，不需要重新建立web数据流，直接使用页面新建账户建立的All数据流即可</li></ul><div class="note note-info">            <p><a href="https://analytics.google.com/analytics/web/provision/#/p418110856/reports/reportinghub?params=_u..nav%3Dmaui">已搭建好的Google Analytics分析页面</a><br><a href="https://analytics.google.com/analytics/web/provision/#/report-home/a294899992w418110855p297980297">页面2</a></p>          </div><h3 id="未来优化的方向"><a href="#未来优化的方向" class="headerlink" title="未来优化的方向"></a>未来优化的方向</h3><ol><li><p>随机图片同一个时刻返回相同，导致主页index_img都相同</p></li><li><p>添加谷歌百度收录，mac风格代码块<a href="https://hwcoder.top/Hexo-Configuration#%E6%B7%BB%E5%8A%A0%E7%99%BE%E5%BA%A6%E8%B0%B7%E6%AD%8C%E6%94%B6%E5%BD%95">参考文献</a></p></li><li><p>[待解决的问题]</p><blockquote><p>WARN  Looks like you use a deprecated property “template” to set up template, consider to use “theme”? See <a href="https://github.com/D0n9X1n/hexo-blog-encrypt#encrypt-theme">https://github.com/D0n9X1n/hexo-blog-encrypt#encrypt-theme</a></p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具相关 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
