<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>多线程</title>
    <link href="/2022/01/26/leetcode/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"/>
    <url>/2022/01/26/leetcode/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="semaphore-信号量"><a href="#semaphore-信号量" class="headerlink" title="semaphore 信号量"></a>semaphore 信号量</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">#<span class="hljs-keyword">include</span> &lt;semaphore.h&gt;<br>sem_t sem1;<span class="hljs-comment">//进行变量申明</span><br><br>sem<span class="hljs-constructor">_init(&amp;<span class="hljs-params">sem1</span>, 1, 0)</span>; <br>第一个参数：指向的信号对象<br>第二个参数：控制信号量的类型，如果其值为<span class="hljs-number">0</span>，就表示信号量是当前进程的局部信号量，否则信号量就可以在多个进程间共享<br>第三个参数：信号量sem的初始值<br><br>sem<span class="hljs-constructor">_post(&amp;<span class="hljs-params">sem1</span>)</span> 信号量值加<span class="hljs-number">1</span><br><br>sem<span class="hljs-constructor">_wait(&amp;<span class="hljs-params">sem1</span>)</span> 信号量值减<span class="hljs-number">1</span><br><br>sem<span class="hljs-constructor">_destroy(&amp;<span class="hljs-params">sem1</span>)</span> 信号量销毁<br></code></pre></td></tr></table></figure><h3 id="互斥锁和条件变量（可以实现一个进程打印5次，另外一个进程打印1次的场景）"><a href="#互斥锁和条件变量（可以实现一个进程打印5次，另外一个进程打印1次的场景）" class="headerlink" title="互斥锁和条件变量（可以实现一个进程打印5次，另外一个进程打印1次的场景）"></a>互斥锁和条件变量（可以实现一个进程打印5次，另外一个进程打印1次的场景）</h3><p>C++： condition_variable C: pthread_cond_t<br>条件变量的一个例子，讲得很详细：<a href="https://blog.csdn.net/jinking01/article/details/110362483">https://blog.csdn.net/jinking01/article/details/110362483</a></p><p>讲述conditon_variable的一个例子：<a href="https://segmentfault.com/a/1190000006679917">https://segmentfault.com/a/1190000006679917</a> </p><p>1.<br>引入条件变量一个就是为了避免为了查看条件是否成立而不断轮询的情况<br>总结：互斥锁实现的是线程之间的互斥，条件变量实现的是线程之间的同步。<br>初始化条件变量<br>pthread_cond_t cond = PTHREAD_COND_INITIALIZER;</p><p>该函数用来在一个ConditionVariable上阻塞等待，做以下三步操作：①释放Mutex；②阻塞等待；③当被唤醒时，重新获得Mutex并返回。<br>int pthread_cond_wait(pthread_cond_t &amp;cond_name, pthread_mutex_t &amp;mutex_name);</p><p>唤醒等待线程<br>pthread_cond_signal()：用于唤醒在该条件变量下等待的一个线程，至于哪个被唤醒，取决于线程的优先级和调度策略。<br>pthread_cond_broadcast()：用于唤醒在某个ConditionVariable 上等待的所有线程。使用这种方法时，瞬间唤醒的线程数过多，资源请求过大，容易导致系统不稳定。<br>int pthread_cond_signal(pthread_cond_t &amp;cond_name);<br>int pthread_cond_broadcast(pthread_cond_t &amp;cond_name);</p><ol start="2"><li>和信号量的区别：<br>条件变量的提出是为了解决互斥锁中的循环等待问题，其希望引入一种挂起、唤醒的机制来实现cpu的高效利用<br>（1）使用条件变量可以一次唤醒所有等待者，而这个信号量没有的功能，感觉是最大区别。<br>（2）信号量是有一个值（状态的），而条件变量是没有的，没有地方记录唤醒（发送信号）过多少次，也没有地方记录唤醒线程（wait返回）过多少次。</li></ol><ol start="3"><li>注意！！！！<br>条件变量被通知后，挂起的线程就被唤醒，但是唤醒也有可能是假唤醒，或者是因为超时等异常情况，所以被唤醒的线程仍要检查条件是否满足，所以 wait 是放在条件循环里面。cv.wait(lock, [] { return ready; }); 相当于：while (!ready) { cv.wait(lock); }。</li></ol><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>为了实现两个函数的交替打印，可以使用信号量，也可以使用交替锁<br>1115. 交替打印 FooBar</p><p>solution 1:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++">func1:<br><span class="hljs-built_in">sem_wait</span>(&amp;sem_foo);<br><span class="hljs-built_in">printFoo</span>();<br><span class="hljs-built_in">sem_post</span>(&amp;sem_bar);<br><br><span class="hljs-function">func2</span><br><span class="hljs-function"><span class="hljs-title">sem_wait</span><span class="hljs-params">(&amp;sem_bar)</span></span>;<br><span class="hljs-built_in">printBar</span>();<br><span class="hljs-built_in">sem_post</span>(&amp;sem_foo);<br></code></pre></td></tr></table></figure><p>solution 2 互斥锁（不建议用这种解法，在不同线程加锁解锁确实会出问题）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++">func1:<br>mutex lock1, lock2; <span class="hljs-comment">//这里锁类似条件变量</span><br><br>lock1.<span class="hljs-built_in">lock</span>();<br><span class="hljs-built_in">printFoo</span>();<br>lock2.<span class="hljs-built_in">unlock</span>();<br><br>func2<br>lock2.<span class="hljs-built_in">lock</span>();<br><span class="hljs-built_in">printBar</span>();<br>lock1.<span class="hljs-built_in">unlock</span>();<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>多线程并发， 信号量， 互斥锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式训练</title>
    <link href="/2022/01/26/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%AD%E7%BB%83/"/>
    <url>/2022/01/26/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%AD%E7%BB%83/</url>
    
    <content type="html"><![CDATA[<h3 id="资料："><a href="#资料：" class="headerlink" title="资料："></a>资料：</h3><p>一个pytorch 分布式 单机多卡/多机多卡的例子<br><a href="https://github.com/lesliejackson/PyTorch-Distributed-Training">https://github.com/lesliejackson/PyTorch-Distributed-Training</a></p><p>常见分布式训练讲解，但是主要命令是启动单机多卡，而不是多机多卡 包括slum, apex, horovod<br><a href="https://github.com/tczhangzhi/pytorch-distributed">https://github.com/tczhangzhi/pytorch-distributed</a> </p><p>pytorch DDP介绍<br><a href="https://zhuanlan.zhihu.com/p/76638962">https://zhuanlan.zhihu.com/p/76638962</a></p><p><a href="https://github.com/richardkxu/distributed-pytorch">https://github.com/richardkxu/distributed-pytorch</a> （也有多机多卡的命令）</p><p>可能会用到：<br>两个机器之间相互免密登录：<a href="https://blog.csdn.net/u010391029/article/details/51126210">https://blog.csdn.net/u010391029/article/details/51126210</a></p><p>DDP time breakdown<br><a href="https://discuss.pytorch.org/t/how-to-measure-ddp-time-breakdown/78925">https://discuss.pytorch.org/t/how-to-measure-ddp-time-breakdown/78925</a><br><a href="https://discuss.pytorch.org/t/how-to-measure-ddp-time-breakdown/78925">https://discuss.pytorch.org/t/how-to-measure-ddp-time-breakdown/78925</a><br><a href="https://discuss.pytorch.org/t/calculating-flops-of-a-given-pytorch-model/3711/4">https://discuss.pytorch.org/t/calculating-flops-of-a-given-pytorch-model/3711/4</a> FLOPS计算</p><p>多进程logging和mkdir设置，分布式inferenc/ 分布式训练的一些小技巧</p><p><a href="https://zhuanlan.zhihu.com/p/250471767">https://zhuanlan.zhihu.com/p/250471767</a> </p><blockquote><p>包括的内容1. 在DDP中引入SyncBN<br>2. DDP下的Gradient Accumulation的进一步加速<br>3. 多机多卡环境下的inference加速<br>4. 保证DDP性能：确保数据的一致性<br>5. 和DDP有关的小技巧<br>6. 1. 控制不同进程的执行顺序<br>   2. 避免DDP带来的冗余输出</p></blockquote><p>Ray分布式执行框架  PyTorch + Ray Tune 调参<br><a href="https://blog.csdn.net/tszupup/article/details/112059788">https://blog.csdn.net/tszupup/article/details/112059788</a></p><p>分布式相关论文源码<br><a href="https://github.com/msr-fiddle/pipedream">https://github.com/msr-fiddle/pipedream</a>  pipedream源码 mini-bath parallism<br><a href="https://github.com/kakaobrain/torchgpipe">https://github.com/kakaobrain/torchgpipe</a></p><p>pytorch分布式训练的时候保存一定要用model.module<br><a href="https://blog.csdn.net/comway_Li/article/details/107531165">https://blog.csdn.net/comway_Li/article/details/107531165</a> 一些需要注意的地方</p><p>horovod多机多卡<br><a href="http://chaopeng.name/2020/01/03/horovod%E5%A4%9A%E6%9C%BA%E5%A4%9A%E5%8D%A1%E5%90%AF%E5%8A%A8%E6%8C%87%E5%8D%97/">http://chaopeng.name/2020/01/03/horovod%E5%A4%9A%E6%9C%BA%E5%A4%9A%E5%8D%A1%E5%90%AF%E5%8A%A8%E6%8C%87%E5%8D%97/</a></p><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ol><li>DP和DDP区别<br>DP是单进程多线程数据并行，将模型copy到每个设备，scatter数据到每个设备进行计算后，将多个GPU输出传到master device(一般为设备0)进行损失计算，（可以优化一下：将loss作为forward 一部分，这样的话每个GPU上自行计算loss，而不用进行模型输出的传输）将损失结果（分发的是各个GPU分别对应的loss）传给每个设备进行反向传播，每个设备将反向传播后的梯度到主设备进行汇聚求平均，然后replicate一份模型的参数到每个设备中，重复上诉的训练过程。</li></ol><ol start="2"><li><p>DDP中all reduce与PS<br> DDP （all reduce）同步的是梯度，不是参数<br> PS，传给master的是梯度，返回的是参数</p><p> 思考：对不重要的梯度进行累积后同步/直接不同步（会不会造成模型的不一致）</p></li><li><p>同步代码<br>分布式训练源代码解读：<a href="https://zhuanlan.zhihu.com/p/343951042">https://zhuanlan.zhihu.com/p/343951042</a></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">手动同步梯度<br><span class="hljs-keyword">for</span> param <span class="hljs-keyword">in</span> ddp_model.parameters<span class="hljs-literal">()</span>: <br>dist.all<span class="hljs-constructor">_reduce(<span class="hljs-params">param</span>.<span class="hljs-params">grad</span>.<span class="hljs-params">data</span>, <span class="hljs-params">op</span>=<span class="hljs-params">dist</span>.<span class="hljs-params">reduce_op</span>.SUM)</span><br>    param.grad.data /= world_size <br><br>手动同步参数：<br>在不重要的样本反向传播后但是不同步参数后，同步梯度<br><span class="hljs-keyword">for</span> param <span class="hljs-keyword">in</span> ddp_model.parameters<span class="hljs-literal">()</span>: <br>dist.all<span class="hljs-constructor">_reduce(<span class="hljs-params">param</span>.<span class="hljs-params">data</span>, <span class="hljs-params">op</span>=<span class="hljs-params">dist</span>.<span class="hljs-params">reduce_op</span>.SUM)</span><br>    param.data /= world_size <br></code></pre></td></tr></table></figure></li></ol><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><h4 id="solution-1-atom版本"><a href="#solution-1-atom版本" class="headerlink" title="solution 1 - atom版本"></a>solution 1 - atom版本</h4><p>裸机 多节点 atom平台</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /workspace/mnt/storage/anchao/ac_file/traffic_iteration/SupreVision &amp;&amp; \<br>./install.sh &amp;&amp; \<br>python -m torch.distributed.launch \<br>        --nnode=4 \<br>        --node_rank=0 \<br>        --nproc_per_node=8 \<br>        --master_addr=<span class="hljs-string">&quot;10.244.55.30&quot;</span> \<br>        --master_port=23467 \<br>        tools/train.py \<br>        --config_file configs/YOLOv3/opencv_pelee_reorg.yml \<br>        SOLVER.IMS_PER_BATCH <span class="hljs-string">&quot;16&quot;</span> \<br>        MODEL.DEVICE_ID <span class="hljs-string">&quot;(&#x27;0,1,2,3,4,5,6,7&#x27;)&quot;</span> \<br>        &gt; detection0.log 2&gt;&amp;1<br></code></pre></td></tr></table></figure><p>单机多卡</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /workspace/mnt/storage/anchao/ac_file/traffic_iteration/SupreVision &amp;&amp; \<br>./install.sh &amp;&amp; \<br>CUDA_VISIBLE_DEVICES=3,4,5,6 python -m torch.distributed.launch \<br>                --nproc_per_node=2 \<br>                --master_port=$((RANDOM + <span class="hljs-number">20000</span>)) \<br>                ./imagenet_final_train_master.py \<br>                --config_file configs/YOLOv3/opencv_pelee_reorg.yml \<br>                &gt; detection0.log 2&gt;&amp;1<br></code></pre></td></tr></table></figure><h4 id="solution-2-简洁版"><a href="#solution-2-简洁版" class="headerlink" title="solution 2 - 简洁版"></a>solution 2 - 简洁版</h4><p>多机多卡<br>suppose we have two machines and one machine have 4 gpus<br>In multi machine multi gpu situation, you have to choose a machine to be master node.<br>we named the machines A and B, and set A to be master node</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">script run at A<br><br>python -m torch.distributed.launch --nproc_per_node=4 --nnode=2 --node_rank=0 --master_addr=A_ip_address master_port=29500 main.py ... <br><br>script run at B<br><br>python -m torch.distributed.launch --nproc_per_node=4 --nnode=2 --node_rank=1 --master_addr=A_ip_address master_port=29500 main.py ... <br></code></pre></td></tr></table></figure><p>单机多卡</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python -m torch.distributed.launch --nproc_per_node=ngpus --master_port=29500 main.py ... <br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>md语法相关</title>
    <link href="/2022/01/20/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/md%E8%AF%AD%E6%B3%95%E7%9B%B8%E5%85%B3/"/>
    <url>/2022/01/20/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/md%E8%AF%AD%E6%B3%95%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<p>对代码块进行折叠</p><details>  <summary>点击时的区域标题</summary><pre><p>内容</p></code></details>]]></content>
    
    
    
    <tags>
      
      <tag>typora, md</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>系统设计相关题目</title>
    <link href="/2022/01/19/leetcode/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    <url>/2022/01/19/leetcode/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h4 id="题型"><a href="#题型" class="headerlink" title="题型"></a>题型</h4><h5 id="1-标准布隆过滤器hash函数的设置"><a href="#1-标准布隆过滤器hash函数的设置" class="headerlink" title="1.标准布隆过滤器hash函数的设置"></a>1.标准布隆过滤器hash函数的设置</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashFunction</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> cap, seed;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">HashFunction</span>(<span class="hljs-keyword">int</span> cap, <span class="hljs-keyword">int</span> seed) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;cap = cap;<br>        <span class="hljs-keyword">this</span>-&gt;seed = seed;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(string&amp; value)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> n = value.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            ret += seed * ret + value[i];<br>            ret %= cap;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StandardBloomFilter</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> k;<br>    vector&lt;HashFunction*&gt; hashFunc;<br>    bitset&lt;200000&gt; bits;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">StandardBloomFilter</span>(<span class="hljs-keyword">int</span> k) &#123;<br>        <span class="hljs-comment">// initialize your data structure here</span><br>        <span class="hljs-keyword">this</span>-&gt;k = k;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i)<br>            hashFunc.<span class="hljs-built_in">push_back</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">HashFunction</span>(<span class="hljs-number">100000</span> + i, <span class="hljs-number">2</span> * i + <span class="hljs-number">3</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>每个字符串通过这个hash函数可以得到一个值（position），然后将bit[200000]中该位置为1，多个函数，那么就会有多个位置为1;判断某一个字符串是否存在，就是判断多个函数计算出来值是否都在bit中位1，如果有一个不为1，说明该字符串不在</p><h5 id="2-序列化Trie树-Lintcode"><a href="#2-序列化Trie树-Lintcode" class="headerlink" title="2. 序列化Trie树(Lintcode)"></a>2. 序列化Trie树(Lintcode)</h5><p>注意这道题</p><ul><li>在进行序列化：使用dfs, 在遍历完所有的chidren后，加上‘/‘表示退出当前循环</li><li>在进行反序列化时： 使用全局index, index在进入下一层循环和退出循环(注意这里和二叉树不同，有两处)之前都需要+1， 其余情况index保持不变</li><li>注意:<br>(1)在退出训练时候不是返回null, 而是返回一个Trie对象的指针！！！<br>(2)因为一个节点有多个节点，而不是只有二叉树的left和right节点，因此需要使用while判断，如果data[index]==’/‘的时候退出while循环<br>(3)<figure class="highlight c++"><figcaption><span>right</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">TrieNode* tmp=<span class="hljs-keyword">new</span> <span class="hljs-built_in">TrieNode</span>(); <span class="hljs-comment">//注意区分类和结构体</span><br>map&lt;<span class="hljs-keyword">char</span>, TrieNode*&gt; &amp;childs=tmp-&gt;children;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><figcaption><span>wrong</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">TrieNode* tmp; <span class="hljs-comment">//注意区分类和类指针，这里直接申明一个空指针是不对的, 即使是结构体也应该是student s;</span><br>map&lt;<span class="hljs-keyword">char</span>, TrieNode*&gt; childs;<br>tmp-&gt;children=childs;<br></code></pre></td></tr></table></figure></li></ul><p>官方题解使用的<data> 进行序列化+栈的方式进行反序列化：&lt;将当前current入栈 &gt;将栈顶出栈 其余：新建一个Trie对象(current)，将当前data[index]指向这个对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition of TrieNode:</span><br><span class="hljs-comment"> * class TrieNode &#123;</span><br><span class="hljs-comment"> * public:</span><br><span class="hljs-comment"> *     TrieNode() &#123;&#125;</span><br><span class="hljs-comment"> *     map&lt;char, TrieNode*&gt; children;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * This method will be invoked first, you should design your own algorithm </span><br><span class="hljs-comment">     * to serialize a trie which denote by a root node to a string which</span><br><span class="hljs-comment">     * can be easily deserialized by your own &quot;deserialize&quot; method later.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">string <span class="hljs-title">serialize</span><span class="hljs-params">(TrieNode* root)</span> </span>&#123;<br>        <span class="hljs-comment">// Write your code here</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        string data;<br>        <span class="hljs-keyword">for</span> (map&lt;<span class="hljs-keyword">char</span>, TrieNode*&gt;::iterator it = root-&gt;children.<span class="hljs-built_in">begin</span>();<br>             it != root-&gt;children.<span class="hljs-built_in">end</span>(); ++it) &#123;<br>            data += it-&gt;first;<br>            data += <span class="hljs-built_in">serialize</span>(it-&gt;second);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;&quot;</span> + data + <span class="hljs-string">&quot;&gt;&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * This method will be invoked second, the argument data is what exactly</span><br><span class="hljs-comment">     * you serialized at method &quot;serialize&quot;, that means the data is not given by</span><br><span class="hljs-comment">     * system, it&#x27;s given by your own serialize method. So the format of data is</span><br><span class="hljs-comment">     * designed by yourself, and deserialize it here as you serialize it in </span><br><span class="hljs-comment">     * &quot;serialize&quot; method.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">TrieNode* <span class="hljs-title">deserialize</span><span class="hljs-params">(string data)</span> </span>&#123;<br>        <span class="hljs-comment">// Write your code here</span><br>        <span class="hljs-keyword">if</span> (data.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>        TrieNode* head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TrieNode</span>();<br>        TrieNode* current = head;<br>        stack&lt;TrieNode*&gt; path;<br>        <span class="hljs-keyword">int</span> len = data.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;<br>            <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (data[i]) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>:<br>                    path.<span class="hljs-built_in">push</span>(current);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>:<br>                    path.<span class="hljs-built_in">pop</span>();<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">default</span>:<br>                    current = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TrieNode</span>();<br>                    path.<span class="hljs-built_in">top</span>()-&gt;children[data[i]] = current;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>一般是有关于系统， 多个函数的整体设计题目<br>比如：GeoHash, GFS, 布隆过滤器， 心跳设计， 缓存系统， LRU cache设计，二叉树的序列化和反序列化等<br>还有新定义一种数据结构，嵌套返回list leetcode-扁平化嵌套列表迭代器 使用递归方式分解</p><p>为了在vector里面删除元素更快，可以再配合使用一个dict (map)映射特定值对应的index;注意在进行删除元素的时候，除了交换vector中最后一个元素和当前元素，还需要修改hash最后一个元素映射的下标为当前index+从hash中删除key</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Zplot画图相关知识点</title>
    <link href="/2022/01/04/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/zplot/"/>
    <url>/2022/01/04/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/zplot/</url>
    
    <content type="html"><![CDATA[<p>Zplot-folder<br>|–breakdown<br>    |–Makefile<br>    |–breakdown1.py<br>    |–breakdown1.data<br>    |–breakdown2.py<br>    |–breakdown2.data<br>|–eval_lineplot<br>    |–Makefile<br>|–…<br>|–makefig.sh</p><ol><li>每次运行的时候只需要运行makefig文件就可以了，如果要修改所有生成的pdf在的目录，直接修改makefig.sh</li></ol><p>2。 Makefile里面的文件主要是运行当前py文件生成eps文件，然后使用ps2pdf转为pdf并使用pdf2crop对生成的pdf文件进行裁剪<br>PS：一定要注意python文件的名字一定要和data文件名字相同，否则会报错</p><p>prequisuite</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install zplot <br><span class="hljs-comment">#注意可能会出现list错误，可能是由于python2 和python3的不兼容原因，只需要将zplot.py里面的ListType改为list就可以了</span><br><br>sudo apt-get install texlive-extra-utils  <br></code></pre></td></tr></table></figure><p>Makefile文件分析</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash">PY=python<br>EPS2PDF=ps2pdf<br>CROP=pdfcrop<br><br>SRC := $(wildcard *.py) <span class="hljs-comment">#列出所有文件对应的py文件</span><br>SRC := $(filter-out zplot.py, $(SRC))<br>EPS = $(patsubst %.py,%.eps,$(SRC))<br>PDF = $(patsubst %.py,%.pdf,$(SRC)) <span class="hljs-comment">#列出所有文件对应的eps和pdf文件</span><br><br>all: $(EPS) $(PDF)<br><br>%.eps: %.py  <span class="hljs-comment"># 目标文件： 源文件</span><br>$(PY) $&lt; eps  <span class="hljs-comment">#$&lt; 表示源文件  $@表示目标文件//官方解释： $&lt; 表示第一个依赖文件， $@ 表示目标集</span><br><br>%.pdf: %.eps<br>$(EPS2PDF) $&lt;<br>$(CROP) <span class="hljs-variable">$@</span> <span class="hljs-variable">$@</span><br>rm -rf $&lt;<br><br>fig:<br><span class="hljs-comment"># mv -f *.pdf ../../../fig/ #将所有的文件都转移到zplot对应的root目录下面</span><br>mv -f *.pdf ../../<br>rm -rf *.eps *.pdf<br></code></pre></td></tr></table></figure><p>makefile语法的参考链接： <a href="https://seisman.github.io/how-to-write-makefile/rules.html">https://seisman.github.io/how-to-write-makefile/rules.html</a> </p><p>makefig.sh文件分析</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>rm -rf *.pdf <span class="hljs-comment">#这是我自己家的，在执行生成之前，现将之前生成的pdf文件删除，应该是也不用</span><br><br><span class="hljs-keyword">for</span>  dir  <span class="hljs-keyword">in</span>  `find .  -name Makefile`  <span class="hljs-comment">#找到包含Makefile文件的dir</span><br><span class="hljs-keyword">do</span><br>path=`dirname <span class="hljs-variable">$dir</span>` <span class="hljs-comment">#找到dir对应的路径path</span><br>    <span class="hljs-comment"># echo $path</span><br>    <span class="hljs-comment"># echo $dir</span><br><span class="hljs-keyword">if</span>  [ <span class="hljs-variable">$path</span>  !=  . ]<br><span class="hljs-keyword">then</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$path</span> <span class="hljs-comment">#打印出path的路径</span><br><span class="hljs-built_in">cd</span> <span class="hljs-variable">$path</span>  <br>make    <span class="hljs-comment">#执行make和makefig命令</span><br>make fig<br><span class="hljs-built_in">cd</span>  -<br><span class="hljs-keyword">fi</span><br><span class="hljs-keyword">done</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>zplot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Anaconda环境搭建</title>
    <link href="/2021/12/15/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/anaconda%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%BB%8E%E9%9B%B6%E5%88%B0%E4%B8%80/"/>
    <url>/2021/12/15/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/anaconda%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%BB%8E%E9%9B%B6%E5%88%B0%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>一个服务器上已经搭建好的环境，但是需要换另一台机器，或者另外的用户需要访问这个环境， 如果另一台服务器上没有anaconda环境就需要从0开始进行搭建，然后再进行环境的迁移</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol><li>安装anaconda3<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">wget</span> https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda<span class="hljs-number">3</span>-<span class="hljs-number">5</span>.<span class="hljs-number">3</span>.<span class="hljs-number">1</span>-Linux-x<span class="hljs-number">86</span>_<span class="hljs-number">64</span>.sh<br><span class="hljs-attribute">bash</span> Anaconda<span class="hljs-number">3</span>-<span class="hljs-number">5</span>.<span class="hljs-number">3</span>.<span class="hljs-number">1</span>-Linux-x<span class="hljs-number">86</span>_<span class="hljs-number">64</span>.sh<br></code></pre></td></tr></table></figure></li></ol><p>一般情况下安装是默认设置，在安装vscode的时候可以根据需要选择no或者yes<br>注意在安装installer的时候需要选择yes, 如果选择了no<br>那么可以自行添加环境:<br><a href="https://zhuanlan.zhihu.com/p/64930395%EF%BC%88%E4%B9%9F%E5%B0%B1%E6%98%AF%E6%BF%80%E6%B4%BB%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%89">https://zhuanlan.zhihu.com/p/64930395（也就是激活环境中的方法二）</a></p><ol start="2"><li>激活环境<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 方法一失效</span><br>输入命令打开配置文件：vim ~/.bashrc<br>在最后添加语句：export PATH=<span class="hljs-regexp">/root/</span>xxx<span class="hljs-regexp">/anaconda3/</span>bin:<span class="hljs-variable">$PATH</span> （<span class="hljs-regexp">/root/</span>xxx 为安装路径）<br>最后输入如下命令，更新配置文件即可：source ~/.bashrc<br><br><span class="hljs-comment">#方法二有效：</span><br>如果conda的初始化时选择了no，则需要自行配置环境变量。<br><br>打开profile文件：<br><br>vi <span class="hljs-regexp">/etc/</span>profile<br>在文件最后加入如下语句（路径需要根据自己的安装位置更改）：<br><br>PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-regexp">/opt/</span>anaconda3/bin<br>export PATH<br>保存文件并退出。最后使用如下命令刷新环境变量即可：<br><br>source <span class="hljs-regexp">/etc/</span>profile<br>echo <span class="hljs-variable">$PATH</span><br></code></pre></td></tr></table></figure></li></ol><p>PS: 如果conda名称弹出问题，使用<code>sudo vi ~/.bashrc</code>查看conda路径是否正确</p><ol start="3"><li>conda相关命令<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs applescript">conda <span class="hljs-built_in">list</span> 查看安装包<br>conda info <span class="hljs-comment">--envs 查看环境</span><br>conda <span class="hljs-built_in">activate</span> XXX 激活环境 （XXX 为环境名称）<br>python -V 检查Python版本<br><br>如果需要卸载anaconda的话，只需要删除anaconda目录即可:<br>rm -rf /root/xxx/anaconda3<br></code></pre></td></tr></table></figure></li><li>使用conda-pack迁移环境</li></ol><p>在源机器：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">conda pack -n env-<span class="hljs-built_in">name</span> <span class="hljs-comment">--ignore-editable-packages（如果没有后面这个会报错）</span><br>得到一个env_name.tar.gz压缩文件<br></code></pre></td></tr></table></figure><p>在目标机器：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">cd ~<span class="hljs-regexp">/anaconda3/</span>envs;<br>mkdir env_name<br>tar -xzvf env_name.tar.gz -C <span class="hljs-regexp">/home/</span>root_name<span class="hljs-regexp">/anaconda3/</span>envs/env_name<br></code></pre></td></tr></table></figure><ol start="5"><li>使用环境<br><code>source activate attnGAN</code></li></ol><p>注意使用conda activate会报错<br>目前找到一个解决方案：<br><a href="https://blog.csdn.net/qq_43828332/article/details/114235922">https://blog.csdn.net/qq_43828332/article/details/114235922</a></p><p>总共耗时 1个半小时左右~</p><h4 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h4><ol><li><a href="https://blog.csdn.net/lwgkzl/article/details/89329383">https://blog.csdn.net/lwgkzl/article/details/89329383</a></li><li><a href="https://www.jianshu.com/p/1fddd11bcd25">https://www.jianshu.com/p/1fddd11bcd25</a></li><li><a href="https://blog.csdn.net/ds1302__/article/details/120027173">https://blog.csdn.net/ds1302__/article/details/120027173</a></li></ol><p>注意之江实验室hec anaconda3的安装路径是：/nfs/home </p><h4 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h4><p>在终端输入conda info –envs检验anaconda是否安装成功，发现报错：conda: command not found</p><p>原因是因为~/.bashrc文件没有配置好</p><p>解决方案：<br>sudo vim ~/.bashrc<br>在最后一行加上<br>export PATH=$PATH:/home/vincent/anaconda3/bin</p>]]></content>
    
    
    
    <tags>
      
      <tag>conda environment</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RPC related</title>
    <link href="/2021/12/03/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/rpc/"/>
    <url>/2021/12/03/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/rpc/</url>
    
    <content type="html"><![CDATA[<p>gRPC 可以保证不同语言之间的通讯<br>编写.proto文件，生成指定语言源代码。<br>编写服务端代码<br>编写客户端代码<br><a href="https://www.liwenzhou.com/posts/Go/gRPC/">https://www.liwenzhou.com/posts/Go/gRPC/</a>  一个python客户端和go服务端的例子</p><p>pytorch的官网框架<br>rpc常见方法<br>rpc_sync同步远程调用、rpc_async异步远程调用、remote异步远程调用。</p><p>rpc.init_rpc 初始化rpc，需要在master和worker都进行初始化，方便之后的通讯<br>rpc.rpc_sync  worker端调用在master上进行执行的方法<br>rpc.rpc_async<br>rpc.remote</p><p>dist_autograd.get_gradient(cid) 目前猜测在rpc场景进行前向传播，的梯度反向传播需要使用dist_grad</p><p>TrainNet是worker调用的假的网络，实际的网络是在Net里面调用，每次worker里面数据的前向传播，实际上都是在master里面的调用net进行前向传播</p><h3 id="分析rpc-parameter-server代码"><a href="#分析rpc-parameter-server代码" class="headerlink" title="分析rpc_parameter_server代码"></a>分析rpc_parameter_server代码</h3><p>master和worker都需要init_rpc</p><p>worker里面主要执行TrainNet：初始化的时候得到远程parameterServer的引用，然后包含二个函数 get_global_param_rref 以及forward函数(均要调用remote_method)<br>master里面执行parameterServer类，：初始的时候，得到真实训练的model, 同时实现三个函数, 对模型参数加上的引用rpc.RRef，使用dist_autograd得到模型参数，以及对输入数据进行前向传播</p><p>在master中加上</p><p>uni_sample_score_rref</p><h3 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h3><p>route_guide_client文件主要是通过stub 和传入的参数调用server的函数</p><p>route_guide_server里面主要是编写得到输入服务器处理函数逻辑</p><p>route_guide_pb2_grpc，类似于头文件，定义Stub类和Servicer类，每个类只是定义函数，但不进行具体的实现； 以及一个add_RouteGuideServicer_to_server的函数</p><h4 id="使用go语言"><a href="#使用go语言" class="headerlink" title="使用go语言"></a>使用go语言</h4><ul><li>前置安装要求<br>安装go，和protocol buffer编译器<br><a href="https://grpc.io/docs/languages/go/quickstart/#prerequisites">https://grpc.io/docs/languages/go/quickstart/#prerequisites</a></li></ul><p>go command not found<br>使用export， 重启一个控制台窗口就找不到这个命令了<br>需要使用vim <del>/.bashrc写入文件 将这个命令写进去，然后使用source ~/.bashrc<br>(</del>/.bashrc:是用户相关的终端（shell）的环境设置，通常打开一个新终端时，默认会load里面的设置，在这里的设置不影响其它人。<br>/etc/profile会影响所有的用户)</p><p>go download超时解决：<br>export GOPROXY=<a href="https://goproxy.cn/">https://goproxy.cn</a></p><h4 id="使用python"><a href="#使用python" class="headerlink" title="使用python"></a>使用python</h4><p>一个python小例子：<a href="https://grpc.io/docs/languages/python/quickstart/">https://grpc.io/docs/languages/python/quickstart/</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>orangefs</title>
    <link href="/2021/12/01/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/orangefs/"/>
    <url>/2021/12/01/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/orangefs/</url>
    
    <content type="html"><![CDATA[<h3 id="orangefs"><a href="#orangefs" class="headerlink" title="orangefs"></a>orangefs</h3><ol><li><p>genconfig是一个go语言文件，它有一个可选参数oranges-server.conf</p></li><li><p>init_start_all.sh相比start_all.sh 多了一个/local500G/orange_store/ 以及多了一条有-f命令的语句 应该是在服务器节点启动pvfs-server<br>orangefs默认的服务器的文件系统挂载的目录是在oranges-server.conf里面进行配置（/nfs/home/yfwang/orangefs/install/etc/oranges-server.conf）</p></li></ol><p>加上f的原因： 第一次启动PVFS2服务要首先分配空间，添加参数-f：<br>root@ubuntu:~# pvfs2-server /etc/pvfs2-fs.conf -f<br>其后启动服务则不需加参数，或使用-d使得服务运行于前台（占用当前终端窗口，终端窗口关闭后服务终止）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> host <span class="hljs-keyword">in</span> `cat /nfs/home/yfwang/orangefs/install/nodelist`<br><span class="hljs-keyword">do</span><br><span class="hljs-comment">#       ssh -t -t -o StrictHostKeyChecking=no -o PasswordAuthentication=no $USER@$host sudo rm -rf /local500G/orange_store/*</span><br>        ssh -t -t -o StrictHostKeyChecking=no -o PasswordAuthentication=no <span class="hljs-variable">$USER</span>@<span class="hljs-variable">$host</span> sudo /nfs/home/yfwang/orangefs/install/sbin/pvfs2-server -f /nfs/home/yfwang/orangefs/install/etc/oranges-server.conf<br>        ssh -t -t -o StrictHostKeyChecking=no -o PasswordAuthentication=no <span class="hljs-variable">$USER</span>@<span class="hljs-variable">$host</span> sudo /nfs/home/yfwang/orangefs/install/sbin/pvfs2-server /nfs/home/yfwang/orangefs/install/etc/oranges-server.conf<br><span class="hljs-keyword">done</span> <br></code></pre></td></tr></table></figure><ol start="4"><li><p>stop_all.sh 停止所有的pvfs-server</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> host <span class="hljs-keyword">in</span> `cat /nfs/home/yfwang/orangefs/install/nodelist`<br><span class="hljs-keyword">do</span><br>        ssh -t -t -o StrictHostKeyChecking=no -o PasswordAuthentication=no <span class="hljs-variable">$USER</span>@<span class="hljs-variable">$host</span> sudo killall pvfs2-server<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure></li><li><p>start_client.sh 启动客户端orangefs-client， 同时将服务器任意一个节点的位置暴露为客户端，例子是hec09</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo /nfs/home/yfwang/orangefs/install/sbin/pvfs2-client -f -p /nfs/home/yfwang/orangefs/install/sbin/pvfs2-client-core<br>sudo mount -t pvfs2 tcp://hec09:3334/orangefs /mnt/orangefs<br></code></pre></td></tr></table></figure><p>nodelist<br>里面直接写hec10 hec11</p><p><a href="https://github.com/waltligon/orangefs/wiki/Distributions-and-Layouts">https://github.com/waltligon/orangefs/wiki/Distributions-and-Layouts</a> 设置数据不同的放置策略,一个文件放在一个节点使用basic方式 distribution</p><p><a href="https://github.com/waltligon/orangefs/wiki/Programming-Guide">https://github.com/waltligon/orangefs/wiki/Programming-Guide</a></p><p>setfattr -n “user.pvfs2.dist_name” -v “basic_dist” /mnt/pvfs2/directory<br>./bin/pvfs2-xattr -s -k “user.pvfs2.dist_name” -v “basic-dist” /mnt/shu-orangefs/dataset</p><p>orangefs里面有一个PINT_dist函数<br><a href="https://www.mcs.anl.gov/~robl/pvfs2/pvfs2-dox/html/pint-distribution_8c.html#a2">https://www.mcs.anl.gov/~robl/pvfs2/pvfs2-dox/html/pint-distribution_8c.html#a2</a></p><h5 id="现在找到将文件保存在一个服务器的方案："><a href="#现在找到将文件保存在一个服务器的方案：" class="headerlink" title="现在找到将文件保存在一个服务器的方案："></a>现在找到将文件保存在一个服务器的方案：</h5><p><a href="https://stackoverflow.com/questions/64923445/how-to-configure-orangefs-save-the-file-into-the-same-server-not-split-it">https://stackoverflow.com/questions/64923445/how-to-configure-orangefs-save-the-file-into-the-same-server-not-split-it</a><br>使用命令：setfattr -n “user.pvfs2.num_dfiles” -v “1” /mnt/orangefs<br>如果按照这种方式设置会报错：setfattr -n “user.pvfs2.dist_name” -v “basic_dist” /mnt/pvfs2/directory 传输数据会报错</p><h3 id="配置教程"><a href="#配置教程" class="headerlink" title="配置教程"></a>配置教程</h3><p>安装server<br>拷贝已经编译好的程序<br>cp -r /nfs/home/yfwang/orangefs/install /nfs/home/weijian/orangefs_install/<br>配置server<br>./bin/pvfs2-genconfig /nfs/home/weijian/orangefs_install/install/orangefs-server.conf<br>具体的配置项，自己可以先记录下来<br>tcp<br>3336<br>/local500G/wj-fast/storage/data<br>/local500G/wj-fast/storage/meta<br>/var/log/orangefs-server.log<br>hec08,hec09<br>配置完成时可以cat /nfs/home/weijian/orangefs_install/install/orangefs-server.conf查看配置项是否符合需求<br>到各个server上，各自初始化存储目录<br>sudo ./sbin/pvfs2-server -f orangefs-server.conf -a <server alias><br>到各个server上，启动服务<br>sudo ./sbin/pvfs2-server  orangefs-server.conf</p><p>安装client<br>拷贝已经编译好的程序（如果已经可以访问就不需要拷贝了）<br>scp -r weijian@hec08:/nfs/home/yfwang/orangefs/install/ /nfs/home/weijian/orangefs_install/<br>向内核加载orangefs模块<br>sudo modprobe orangefs<br>创建挂载点<br>sudo mkdir /mnt/wj-fast-orangefs<br>写配置文件<br>sudo sh -c “echo ‘tcp://hec08:3336/orangefs /mnt/wj-fast-orangefs pvfs2’ &gt;&gt; /etc/pvfs2tab”<br>测试与server是否连通<br>./bin/pvfs2-ping -m /mnt/wj-fast-orangefs<br>启动client客户端<br>sudo ./sbin/pvfs2-client -p ./sbin/pvfs2-client-core<br>挂载<br>sudo mount -t pvfs2 tcp://hec08:3336/orangefs /mnt/wj-fast-orangefs</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>System Design</title>
    <link href="/2021/11/24/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/system%20design/"/>
    <url>/2021/11/24/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/system%20design/</url>
    
    <content type="html"><![CDATA[<p>lintcode</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>二叉树</title>
    <link href="/2021/11/23/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2021/11/23/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<ol><li><p>二叉树的前序序列化<br> 观察规律题或者建树题<br> 我的思路是直接建立一颗二叉树，但是建立树代码可以不写；<br> 官方题解是：通过槽位计数，如果遍历到最后槽位为0说明正确，如果中间槽位为0，说明出错<br> 注意这道题的易错点是: 字符串中包含’,’而且可能数字包含两个字符 98,7,#</p></li><li><p>二叉树的宽度： 宽度应该包含一层的节点之间夹杂的空字符，所以为了得到一层的宽度，应该在栈中压入每个节点的下标(左边：2 * pos, 右边：2 * pos+1)，而不是具体的二叉树ListNode</p></li><li><p>两个子节点的最近公共父节点</p></li></ol><p>如果一个节点为target_one或者target_two那么直接返回当前节点，否则进行dfs, dfs返回的左右节点都是非NULL那么就返回当前节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">ListNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(ListNode* root, ListNode* node1, ListNode* node2)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>||root==p||root==q) <span class="hljs-keyword">return</span> root;<br>    <span class="hljs-keyword">if</span>(root==node1||root==node2)&#123;<br>        <span class="hljs-keyword">return</span> cur;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        ListNode *left=<span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left, node1, node2);<br>        ListNode *right=<span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right, node1, node2);<br>        <span class="hljs-keyword">if</span>(left&amp;&amp;right)&#123;<br>            <span class="hljs-keyword">return</span> cur;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left)&#123;<br>            <span class="hljs-keyword">return</span> left;<br>        &#125;<br>        <span class="hljs-keyword">return</span> right;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><ol start="4"><li>从二叉树一个节点到另一个节点每一步的方向</li></ol><p>方法，通过dfs找到到达startValue和dstValue的具体路径，然后删除路径前面相同的部分，然后到达startValue剩余的size都加上U， 到达dstValue剩余的都加上dst剩余的路径</p><ol start="5"><li>寻找重复的树，<br>注意这道题需要记录空节点，同时，只能使用前序或者后序遍历 唯一判定两棵子树是否相同，而不能使用中序遍历。而且数据与数据应该用，隔开，因为222可以理解为2+2+2也可以理解为2+22 </li></ol><p>==加上#的这种情况，只有后序遍历和前序遍历能够唯一确定一课子树。中序遍历不行==</p><p>同样这道题使用二叉树的序列化和反序列化, 因为前序和后序都可以知道根节点，但是中序不行</p><ol start="6"><li><p>最长同值路径<br>为了区分left+right+1 left+1 right+1三种情况，可以使用一个left_mark 如果左边和root相等那么==left_val+1否则为0。那么最后的结果都是left_mark+right_mark+1， 解决了三种情况 返回max(left_mark, right_mark)+1</p></li><li><p>二叉树中所有距离为 K 的结点<br>先通过dfs找到每个节点的父节点，然后再对target节点进行dfs 左右和父节点 (或者bfs+vis)</p></li><li><p>二叉树寻路，使用数学方法<br> 1.先求每个数正常的父亲，然后再对不同的层进行修改<br> 2.在进行修改的时候抓住对称的点的和是相同的<br> 3.如果层数是偶数，那么只需要修改奇数层的值；如果层数是奇数，那么需要修改奇数层的数据</p></li><li><p>二叉树中两个节点间的距离<br>先求两个节点的最近公共祖先，然后从最近公共祖先出发，求祖先节点分别到两个节点的距离(使用dfs两次，target==p||q)，距离之和就是两个节点的最短路径<br>代码：<a href="https://www.jianshu.com/p/cec33f514f69">https://www.jianshu.com/p/cec33f514f69</a></p></li></ol><ol start="10"><li>树的直径问题<br>任意选择一个节点为根，然后找到离他最远的节点a，然后找到离a最远的节点b，那么a-&gt;b就是最远的路径（数的直径）<br>如果是二叉树有指针的情况可以使用递归<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> result=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxDistance</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> leftLength=<span class="hljs-built_in">maxDistance</span>(root-&gt;left);<br>    <span class="hljs-keyword">int</span> rightLenght=<span class="hljs-built_in">maxDistance</span>(root-&gt;right);<br>    result=<span class="hljs-built_in">max</span>(leftLength+rightLenght+<span class="hljs-number">1</span>, result);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(leftLength, rightLenght)+<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">diameterOfBinaryTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-built_in">maxDistance</span>(root);<br>    <span class="hljs-keyword">return</span> result<span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>如果是无向图：<br>算法思想<br>①从任意一点P出发，通过DFS寻找离它最远的点Q。<br>②再次从点Q出发，通过DFS寻找离它最远的W。<br>③直径即为WQ。<br>证明：<a href="https://zhuanlan.zhihu.com/p/115966044">https://zhuanlan.zhihu.com/p/115966044</a></li></ol><p>两次dfs</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> st)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;edge[st].<span class="hljs-built_in">size</span>();i++)<br>    &#123;<br>        <span class="hljs-keyword">int</span> to=edge[st][i];<br>        <span class="hljs-keyword">if</span>(!vis[to])<br>        &#123;<br>            vis[to]=<span class="hljs-number">1</span>;<br>            dis[to]=dis[st]+<span class="hljs-number">1</span>;<span class="hljs-comment">//注意，本代码计算的是无权树的直径，所以边权为1</span><br>            <span class="hljs-comment">//如果是有权树，则这里的1要改为边权</span><br>            <span class="hljs-built_in">dfs</span>(to);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>求最长就是求最大的dis，两次dfs中间需要重新初始化dis=0</p><ol start="11"><li>具有所有最深节点的最小子树</li></ol><p>在深度优先搜索的时候同时返回结果和计算深度，返回的是一个结构体 node{root, dist}.<br>1)获取当前节点的左右子树的最大深度<br>2)如果两边最大深度相同，则这个节点就是结果<br>3)不相等，那返回深度大的子树的root信息</p><ol start="12"><li><ol start="205"><li>同构字符串/890. 查找和替换模式<br>查找和对应模式一致的字符串，abb模式。<br>使用双hash,也就是两边都没有映射，才建立映射，或者两边都有映射且未对方，那么continue,否则说明出处<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span>(s2t.<span class="hljs-built_in">find</span>(s[i])==s2t.<span class="hljs-built_in">end</span>()&amp;&amp;t2s.<span class="hljs-built_in">find</span>(t[i])==t2s.<span class="hljs-built_in">end</span>())&#123;<br>    s2t[s[i]]=t[i];<br>    t2s[t[i]]=s[i];<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s2t[s[i]]=t[i]&amp;&amp;t2s[t[i]]==s[i])&#123;<br>    <span class="hljs-keyword">continue</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>链表</title>
    <link href="/2021/11/16/leetcode/%E9%93%BE%E8%A1%A8/"/>
    <url>/2021/11/16/leetcode/%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p>有序链表的合并，一定要注意判断两个链表是否相交，或者链表是否有环的情况，如果遇到这两种情况要特殊处理</p><h5 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h5><ol><li>扁平化多级双向链表</li></ol><h5 id="易错点"><a href="#易错点" class="headerlink" title="易错点"></a>易错点</h5><ol><li>判断head是否为null</li><li>在使用tmp-&gt;next 或者tmp-&gt;prev 一定要注意判断当前节点不能为null<br>也就是if(tmp){</li></ol><p>}</p><p>3.双向链表在进行删除某个节点的时候，先固定前面和后面的关系都可以；但是在插入一个节点的时候一定要先固定后面的</p><p>4.LRU cache易错点：再删除需要指针+hash都需要消除，cache.erase(lastNode-&gt;key); delete lastNode;<br>可以用hash.size()定位cache元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"> LRU cache（一个双向链表，一个hash）<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LinkNode</span>&#123;</span><br>    <span class="hljs-keyword">int</span> key,val;<br>    LinkNode* next;<br>    LinkNode* pre;<br>    <span class="hljs-built_in">LinkNode</span>()&#123;<br>        next=<span class="hljs-literal">nullptr</span>;<br>        pre=<span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>资源汇总</title>
    <link href="/2021/11/16/%E5%85%B6%E4%BB%96/%E5%90%84%E7%B1%BB%E8%B5%84%E6%BA%90/"/>
    <url>/2021/11/16/%E5%85%B6%E4%BB%96/%E5%90%84%E7%B1%BB%E8%B5%84%E6%BA%90/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.payititi.com/">人工智能相关各种任务数据集下载网站</a></p><p>阿里巴巴各部门:<a href="https://blog.csdn.net/alitech2017/article/details/105096822">https://blog.csdn.net/alitech2017/article/details/105096822</a></p><p>基础设施部门面经</p><p>8a100tianshu账号登录方式：<br>登录地址(需之江内网orVPN)：<a href="https://access.zhejianglab.com/">https://access.zhejianglab.com</a>  maokuang 密码请咨询毛旷，登录后：运维–主机运维—“登陆”栏目下的地球图<br>密码zjlab!@#</p><p><a href="https://github.com/SharingSource/LogicStack-LeetCode/wiki">https://github.com/SharingSource/LogicStack-LeetCode/wiki</a> 宫水三叶的刷题笔记</p><p>画图工具：<br><a href="https://draveness.me/sketch-and-sketch/">https://draveness.me/sketch-and-sketch/</a></p><p>hugo为后端的博客</p><p>做笔记的工具：notion 截图的工具：snipaste</p><p>可以将进程放在后台执行的软件 screen或者tmux</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>每天任务记录</title>
    <link href="/2021/11/15/%E6%97%A5%E5%B8%B8%E8%AE%B0%E4%BA%8B/%E6%AF%8F%E5%A4%A9%E4%BB%BB%E5%8A%A1%E8%AE%B0%E5%BD%95/"/>
    <url>/2021/11/15/%E6%97%A5%E5%B8%B8%E8%AE%B0%E4%BA%8B/%E6%AF%8F%E5%A4%A9%E4%BB%BB%E5%8A%A1%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>11-15<br>记得之后验证一下multiple是否支持只有loss这种情况，如果支持的话，sampler全部修改为一个，同时目前只修改和看BS这种情况</p><p>tune参数包括warm_up_epoch and sampling rate</p><p>完成情况：整理完之前的IOAS代码，将multi和single进行融合，同时使用字典形式来替换if-else多个flag的情况<br>记录：leetcode 刷题指南完成：贪心算法， 哈希表，双指针部分, 栈与队列部分</p><p>11-16<br>初步完成论文框架思维导图</p><p>修改代码，找到IO瓶颈场景</p><p>在代码中添加上视频分析这个场景</p><p>今天突然想到suprevision是用的什么anchor box，需要将数据下载完成后验证，猜测使用featmap_size??而不是预设的anchor</p><p>总结：<br>看完interviewtop上操作系统的八股文<br>下载coco数据<br>完成一版xmind思路调整<br>查看阿里基础架构面经</p><p>11-17<br>找到io为瓶颈的场景，并进行重要性采样实验<br>目前发现MS比BS精度高</p><p>BS：面临的问题  如何选择阈值 目前：搜索出初始thres_ratio, 之后使用历史+当前thres_ratio调整，//没有被计算的使用远程存储的模型进行计算,以及根据模型能力调整thres_ratio</p><p>MS: recall interval,不同等级之间的recall 时间差距是1 epoch 吗，新划分出来训练的类又如何根据阈值划分呢（等分感觉不科学）//建一个模型自动划分和确定等待的时间  （多个阈值和多个等待时间的确定）</p><p>现在只修改BS (1)实现在存储端计算样本重要性， （2）感觉样本的位置</p><p><a href="https://www.sigarch.org/the-new-bottlenecks-of-ml-training-a-storage-perspective/">https://www.sigarch.org/the-new-bottlenecks-of-ml-training-a-storage-perspective/</a> 这个讲得挺好<br>处理的浏览了一下FreqCheck 的源码 但是每太明白细节上是如何在torch.save()后面封装 fsync(),   以及如何根据runtime overhead的profile结果进行自适应的checkpointing frequency超参数的调节</p><p>目标：弄懂多进程异步/模型的异步训练， 参考autoassist 以及checkFreq，subprocess<br>以及另外开一个进程来进行io带宽的测量(profile)以及未读取数据的重要性更新，另外一个空闲节点</p><p>11-18</p><p>看了autoassist的多进程，但是他们在训练另外一个模型进行样本的现在是训练了另外一个二分模型，这个二分模型的目标是 loss大于均值为target或者target model判断错误的label=1</p><p>我要训练的另外一个模型是在存储节点训练的模型，无需训练只需要将模型每次最新权重穿过来，在checkpoint的时候将模型传给远端; screen 需要同时训练另外一个模型会加重CPU和GPU训练负担，同时也不是很好同步轻量级模型和远程target模型判断样本重要性的差距</p><p>完成另外一个进程异步训练模型的初步代码</p><p>11-22</p><p>完成情况：<br>完成主进程和子进程相互传输重要性分数，invalid list以及模型初步代码</p><p>明天需要解决的问题：<br>1）如果解决模型参数保存的时候使用model.cpu().state_dict() 但是计算的时候需要使用dp 或者cuda, 保存模型这个动作如何转为复制模型参数，而不是真正将模型保存到cpu</p><ol start="2"><li>如何减少推理时间太长的问题，如果使用原模型进行不重要样本重要性计算</li></ol><p>3）如果将一个节点转移到两个节点间的数据传输（远端存储系统情况）</p><p>4）把这个解决了，再解决如何修改io module 自定义一个缓冲区，然后在缓冲区/cache中实现TLB表，以及数据从缓冲区中读取</p><p>要解决的问题：1 分布式训练如何将另外一个进程计算得到的uni_score广播给其他进程<br>而且注意是多个分布式训练主进程对应一个子进程，不应该建立多个进行不重要样本重要性计算的子进程</p><p>目前遇到的问题：RuntimeError: module must have its parameters and buffers on device cuda:0 (device_ids[0]) but found one of them on device: cpu–&gt;解决，因为model.cpu().state_dict导致</p><p>11-23</p><p>完成情况：</p><p>1）使用一个copy.deepcopy完成在gpu上模型的拷贝到cpu<br>2) 解决子进程无法正常退出的问题<br>3）初步熟悉dataloader和dataset的代码</p><p>下一步：<br>如何解决判断数据是在缓存， 本地磁盘， 还是远端存储系统呢</p><p>11-24  </p><p>1）调整了lru_cache的逻辑<br>2）但是目前不知道如何将tlb得到的信息转为io_predict_time<br>3）初步使用多进程访问同一个cache,同时记录总访问次数和命中率，因为多进程需要共享一个数据结构，因此使用multiprocessing.Manager 因为LRUcache是自定义的一个数据结构，因此需要使用自定义的manager</p><p>目前发现worker越多，access 缓存次数越多</p><p>worker = 8<br>self.size:256<br>total_access_time:2432, hit_time:128</p><p>worker = 4<br>self.size:256<br>total_access_time:1048, hit_time:128</p><p>worker = 0<br>self.size:128<br>total_access_time:384, hit_time:256</p><p>如何只是对cache的每个变量使用multiprocessing进行加锁的话会导致出现None 结构remove错误，所以对于cache的get set函数都应该是一个原子操作（一个事务），所以需要对cache使用原子操作（加锁），而不仅仅是里面的一个变量加锁就可以了</p><p>11-25</p><p>验证多进程为什么总的访问次数会增加，以及为什么使用缓存的大小增加，但是命中率会减小<br>考虑如何将tlb功能转为IO score的计算<br>如何感知数据的位置，在其他节点的存储中，本地存储中，还是缓存中</p><p>发现：epoch=0和epoch=1的时候多进程取数据hit time=0， cache size=256 但是如果worker=0的话， epoch=1时候的命中率应该为128 cache size=128<br>解释：因为我在执行流程中间break了，但是数据还在提前取后面一轮的，所以导致cache size会满，同时命中率下降；第二轮本来要取的序列就减少了，所以多进程也没有讲缓存的数据冲走；也可以解释第0轮epoch就有2000多次的访问量</p><p>加上缓存：<br>Training done in 0.069387 hours<br>Training  done in 0.068791 hours</p><p>不加缓存：<br>Training  done in 0.017339 hours<br>Training  done in 0.035785 hours<br>Training  done in 0.037956 hours 命中率384</p><p>使用字典进行缓存，随机置换：<br>Training  done in 0.022509 hours<br>Training  done in 0.039637 hours  命中率 224</p><p>pyshmht 为python设计的基于hash表的共享内存</p><p>asyncio</p><p>目前结论：使用一个随机置换策略的缓存相比LRU置换效果更好  或者直接使用coodl的缓存后就固定不变</p><p>感觉应该是LRU每次加锁读写链表</p><p>明日安排：完成整个训练过程加缓存以及如何将缓存的位置转化为IO score</p><p>11-29</p><p>RPC小例子<br><a href="https://zhuanlan.zhihu.com/p/136372142">https://zhuanlan.zhihu.com/p/136372142</a></p><p>了解一下rpc pytorch， 打算使用nfs再使用orangefs来实现两个节点上worker的通信<br>看了两篇论文：1.是分析深度学习不同存储方式的性能 2.运用机器学习判断应用的IO模式，然后自适应的选择相应的优化策略（主要是针对有读写，以及I/O模式在整个应用生命过程中会改变，但深度学习是只读的，I/O模式似乎都是一样的）<br><a href="https://github.com/apachecn/apachecn-dl-zh/blob/master/docs/pt-tut-17/65.md">https://github.com/apachecn/apachecn-dl-zh/blob/master/docs/pt-tut-17/65.md</a></p><p>11-30<br>使用sudo aptitude install nfs-common 选择n y的时候安装失败，导致sudo无法使用，同时机器无法连接，修机器<br>参加rebuttal的会议</p><p>12-1</p><p>问题如何在orangefs上挂imagenet, 挂了之后仍然像ext4文件一样访问 /mnt/orangefs吗， 记得修改默认orangefs 服务器的文件目录，目前默认是/local500/storage-orangefs/吗<br>最后为什么是mount hec09的orangefs 为什么不是local500/storage-orangefs</p><p>12-2 </p><ol><li>完成 rebuttal的提交</li><li>初步在节点hec01 和hec03上实现 rpc测试  学长使用的是不同语言之间相互通信的grpc 先写一个.proto 文件，然后使用一个工具 将他编译为目标py文件或者go文件，然后分别在py和go文件里面使用这个编译好的文件</li></ol><p>在提交英文版本的时候一定要注意英语的拼写问题</p><p>pytorch官网上的rpc网络： <a href="https://github.com/pytorch/pytorch/blob/master/docs/source/rpc.rst">https://github.com/pytorch/pytorch/blob/master/docs/source/rpc.rst</a></p><p>12-3 现在的问题是：worker如何确定当前可以shutdown</p><p>目前遇到的问题是如果是将远程过程调用放在sampler，如果是多进程取sampler的话会导致 出错，因此应该把远程过程调用的逻辑放在主函数里面</p><p>多进程会有多个sampler副本吗  难道是多进程访问sampler会加锁？？</p><p>明天 1.实现在每个epoch前进行重要性计算 train_one_epoch前  2. score通过字典传递，而不是list</p><p>rpc在远程过程调用的时候，如果调用的函数和初始化不在main函数下面py文件(主要的train_main 文件里)内会导致调用函数不一样 本来打算调用worker, 调用到master端</p><p>12-7<br>实现使用nfs， 以及torch.distributed.rpc实现两个任务之间的通信， 阅读grpc 的route_guide example源码， 如果要使用grpc需要使用异步+call back函数，或者使用一个子进程+同步grpc，然后实现主进程和子进程之间通过共享内存实现数据的共享</p><p>12-13</p><p>在hec01使用setattr修改了文件dataset的属性<br>现在的问题是存储单元如何得知自己存储节点的数据，或者假设存储节点非常的近，那么存储节点只需要派一个节点进行训练就好了</p><p>现在可以实现在一个存储单元上挂载orangefs-client查看数据， 之后换到新机器上实验orangefs形式的存储单元和计算单元 通讯和传递消息，目前server端只需要一个节点来进行推理，不需要每个server对每个server端的数据进行推理</p><p>12-14<br>找到一个bug， loss.mean().backward应该在loss.cpu.detach()前面，否则就会训练的时候精度一直为0，怀疑是torch版本的问题<br>打算再新环境中使用orangefs，然后进行通讯任务训练<br>以及考虑加上cache + IO score 预先训练cache中的数据</p><p>今天leetcode练习到532题</p><p>明日安排：</p><ol><li><p>先profile一下cache time 是否真的的比ssd time小很多 </p></li><li><p>同时查看一下是不是每轮epoch 第一个iteration时间最长， 找到网上解答原因</p></li><li><p>multi-criterion到底应该怎么用。</p></li><li><p>写一个简单的用cache的信息加入到multi-criterion计算（不同的优先级给定一个分数），以及在cache中采样第一个batch, 以及随机置换的cache策略，先写一个版本</p></li><li><p>cache size以及cache的转换策略将对io score产生怎样的影响</p></li></ol><p>相同数据每次的load time是不是都是变化很大。我感觉应该用时间近似，而不应该用level,因为不同cache的ssd的远近可能导致这两个时间相差很大，有的ssd读取和cache时间差不多那么io score应该就差不多，否则就应该加大io score的差距</p><p>感觉多进程预取会抵消cache好处？？如果IO是瓶颈的话，那么预取的效果就比从cache中取数据的效果差</p><p>12-15 完成一个简易版本的cache-aware sampling</p><p>主要包含下面三个功能的实现：</p><ol><li>IO score的计算问题 使用profile的cache的时间和ssd时间近似替代训练序列的all_result_list[‘iotime’]</li><li>sampler的序列问题， 先使用cache 里面缓存的序列</li><li>cache的置换问题，初步使用self.vis字典实现先替换cache中vis的序列，但是问题是每个epoch都需要clear一下cache的vis序列</li></ol><p>但是现在还是在注释中</p><p>12-16<br>尝试在8a100上实验，可能会考虑到分布式训练的sampler的修改<br>使之适应于分布式+orangefs这种场景</p><p>完成情况：目前在多GPU上调试了之前hec上面的代码，可以跑通单机多卡加上cache, 和修改了cache time计算方式的代码<br>初步完成昨天1， 2， 3个功能，目前的问题就是DataParallel+ another model in storage side可能会有问题</p><p>发现4 worker的时候 每4个iteration 第一个时间最长， 之后的时间都递减</p><p>明日计划：</p><p>四叉树合集有时间看看</p><p>12-17 数据传输慢是因为传输的带宽被占满了吗？ 是否可以开不同的数据取线程？来为用于级别cache增加命中率<br>为什么4worker时每个iteration 4个中必有一个时间长 （已解决）<br>这个iteration time和worker的设置有关</p><p>12-20<br>TODO: 分布式情况，多个节点得有多个cache, 这样的话在进行取数据的时候首先取cache中缓存的数据就不对，需要通过RDMA 需要直接取其他节点的cache数据才行<br>目前分析原因是消耗比读取快，消耗了一轮回过来，还是没有讲一个batch读完，所以又会在worker1处阻塞住，同时在worker1阻塞的时候，其他worker也在读取，所以表现为每隔一段时间就会出现一个IO时间非常长</p><p>但是如果计算是瓶颈，应该不会出现这个<br>resnet152的时候io_time就能够被计算时间覆盖了，所以所有的iotime大概都是0.0003左右</p><p>那么可以找到一个比较便捷的io瓶颈测量是将，看是否iotime是否随着worker进行周期变化； 但是总体上来说都是第一个iteration的iotime时间最长为1.6左右，因为没有任何计算来对iotime进行覆盖<br>alexnet其他worker每隔一段时间大概为0.5；resnet大概为0.2；其余为0.0003</p><p><a href="https://kangsheng.xyz/2020/07/14/pytorch%E4%B8%ADdataloader%E7%9A%84num_workers%E8%AE%BE%E7%BD%AE/">https://kangsheng.xyz/2020/07/14/pytorch%E4%B8%ADdataloader%E7%9A%84num_workers%E8%AE%BE%E7%BD%AE/</a><br>这里的iotime包括进程开销，以及batch读取+batch处理开销 但是多进程加载数据包括读+处理两个部分， 而不是只读<br>8A100 2个物理CPU, 每个cpu 物理64核， 每个核有两个逻辑处理器；所以两个cpu一起就有256个逻辑处理器（2<em>2</em>64）<br>hec02是8个cpu, 每个cpu上面只有一个核</p><p><a href="https://zhuanlan.zhihu.com/p/91521705">https://zhuanlan.zhihu.com/p/91521705</a> 查看dataset多worker加载数据，每个worker负责一个batch,只有在当前batch消耗掉之后才会取下一个分配的任务，而不是一直取数据。同时这个worker取数据包括读+数据增强两个部分</p><blockquote><p>其实各个worker之间读取数据时间差不多，并且由于是多进程任务，所以每次第一个worker读完数据就绪以后其他也准备就绪了，主进程随即开始连续前向传递了，并轮询的向各worker发送读新一批数据的信号，只不过跑完上一轮次所有worker产生的数据（num_workers个batch）后，各worker中新一轮次数据还没就绪，所以阻塞住了。</p></blockquote><p>4worker的情况下；<br>io_time: 0.6680457592010498<br>io_time: 0.00039649009704589844<br>io_time: 0.0004131793975830078<br>io_time: 0.00040602684020996094<br>io_time: 0.7091846466064453</p><p>8worker的情况下：<br>io_time: 0.583601713180542<br>io_time: 0.00048732757568359375<br>io_time: 0.011454343795776367<br>io_time: 0.0005695819854736328<br>io_time: 0.00035643577575683594<br>io_time: 0.0003287792205810547<br>io_time: 0.0004932880401611328<br>io_time: 0.0003211498260498047<br>io_time: 0.5443663597106934</p><p>16worker的时候：<br>io_time: 0.6202142238616943<br>io_time: 0.0005917549133300781<br>io_time: 0.0004055500030517578<br>io_time: 0.00042128562927246094<br>io_time: 0.0004863739013671875<br>io_time: 0.00027370452880859375<br>io_time: 0.0002474784851074219<br>io_time: 0.0002865791320800781<br>io_time: 0.00033855438232421875<br>io_time: 0.00021886825561523438<br>io_time: 0.0002658367156982422<br>io_time: 0.00020456314086914062<br>io_time: 0.0001895427703857422<br>io_time: 0.0005667209625244141<br>io_time: 0.0004878044128417969<br>io_time: 0.013859033584594727</p><p>worker数量越小，出现io_time突然增加的可能性越高<br>现在的问题是：在worker数量不足的时候是否这种用另外的worker去取数据，是否会影响数据加载的性能；相当于增加了线程数量；这好像更多加一个worker，然后多加一个缓存空间，实现超前预取没有实质区别<br>另外一种合理的解释就是说利用data worker取数据的空闲时间来进行cache的换新，但是IO 瓶颈data worker空闲的时间也不多呀；只有计算密集的data worker才会空闲</p><p>而且cache如果这样设计的话和buffer没有什么区别，因为都是取一次用一次，结论在buffer里面实现预取进程无用! 而且可能增加磁盘带宽压力</p><p>coordl又讲使用cache的理由吗？感觉可以直接沿用coordl理由</p><p>Gist：在两次数据利用之间有长时间的gap，因此可以对数据进行压缩，之后要用的时候再解压缩， ==在cache里面对数据进行压缩解压== 问题是data没有稀疏性，如果较好的无损压缩</p><p>12-21<br>目前分别在hec 和 8a100上测试远程过程调用和cache的代码</p><p>看代码的时候注意一下几个方面：<br>1）远程过程调用现在不能使用dataparallel  create_file<br>2) cache代码里面可以使用DP, 需要确定cache大小<br>3）loss.backward一定要在loss.cpu/记录loss 之前，否则会报错<br>4）合起来的时候一定要注意将init_rpc 以及 有关worker和master的代码打开（train_evaluate）<br>5) 感觉增加worker数量就能消除IO瓶颈的问题如何解决</p><p>找到一个bug: 使用dp的时候，batch_size应该*gpu数量，因为是一个batch size拆分，但是ddp不是</p><p>明天任务：<br>如何实现多GPU情况下，多进程共享一个数据结构cache， 因为现在好像是多个进程，每个可能都会创建一个cache这个是不合理的</p><p>12.22 </p><p>看了以及整理了一下括号相关的leetcode题目</p><p>rpc在回调结果的时候遇到一个问题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">master使用远程过程调用的结果来更新criterion_history_list_dict<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;./imagenet_final_train_master.py&quot;</span>, line <span class="hljs-number">206</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>    train_main(args.gpu, ngpus_per_node, args, kwargs)<br>  File <span class="hljs-string">&quot;./imagenet_final_train_master.py&quot;</span>, line <span class="hljs-number">94</span>, <span class="hljs-keyword">in</span> train_main<br>    run_training(model, trainloader, testloader, trainset, testset,  optimizer, criterion, dirs, args.epochs, args, kwargs)<br>  File <span class="hljs-string">&quot;/nfs/home/shu/hushuang_all_files/ImageClassification/8a100-code/IOAS/imagenet/train_evaluate.py&quot;</span>, line <span class="hljs-number">177</span>, <span class="hljs-keyword">in</span> run_training<br>    refresh_uni_list( uni_score_rref, allscore_numpy_dict, args)<br>  File <span class="hljs-string">&quot;/nfs/home/shu/hushuang_all_files/ImageClassification/8a100-code/IOAS/imagenet/rpc_func.py&quot;</span>, line <span class="hljs-number">44</span>, <span class="hljs-keyword">in</span> refresh_uni_list<br>    uni_score_list = uni_score_rref.to_here().numpy().tolist()<br>RuntimeError: RPCErr:<span class="hljs-number">1</span>:RPC ran <span class="hljs-keyword">for</span> more than <span class="hljs-built_in">set</span> timeout (<span class="hljs-number">60000</span> ms) <span class="hljs-keyword">and</span> will now be marked <span class="hljs-keyword">with</span> an error<br><br><span class="hljs-comment"># worker 端</span><br><br>[W tensorpipe_agent.cpp:<span class="hljs-number">498</span>] RPC agent <span class="hljs-keyword">for</span> worker1 encountered error when sending response to request <span class="hljs-comment">#16 to worker0: EOF: end of file</span><br></code></pre></td></tr></table></figure><p>12.23<br>现在8a100端注释了master的和worker代码就可以实现 存储端计算重要性+主进程端使用cache缓存部分数据</p><p>主要逻辑：（cache 3+ 存储单元 1）</p><ol><li>0epoch冷启动， 在1epoch缓存端已经开始缓存数据， 每轮训练的时候将vis的数据打一个标记，置换策略将vis的数据随机置换出去</li><li>下一轮 sampler返回训练的时候将cache中的数据放在前面</li><li>在重要性采样开始前一轮epoch，开始搜集重要性metric设计的分数，如果有io 分数的话，通过profile 的iotime 来对cache time的ssd load time进行估计（求平均值），同时对下一轮样本的iotime进行预测</li><li>将计算出来的重要的样本下一轮训练，不重要的样本序列通过rpc传给存储端的计算单元，让master和worker分别更新重要的样本和不重要样本的分数。</li><li>然后之后在进行采样的使用用全部更新好的重要性分数，重复排序和训练更新步骤</li></ol><p>解决两个bug:</p><ol><li>之所以8a100上面使用分布式调用不起来，是因为我之前在使用torch.distributed.rpc的时候写了os[‘environment’] =hec01  导致分布式错误</li><li>训练精度很低， 修改criterion<br>criterion = nn.CrossEntropyLoss(reduce=False).cuda(args.gpu) hec02实验<br>目前是用这个解决了，但是assert语句显示一致, 不知道原因</li></ol><p>12-27<br>解决cache在mp.spawn 使用多进程训练的时候导致段错误或者信号接收错误<br>选择启动方式：mp.set_start_method(‘spawn’)</p><p>在进行调试的时候，break不应该放在args,rank==0下面，否则就会卡死</p><p>12-28<br>现在的任务就是看rpc是否能和分布式训练的mp.spawn同时存在, 应该主进程主要负责rpc</p><p>ssh需要输入密码的节点为何无法使用rpc进行通信</p><p>12-29<br>今天主要看了legoos这篇论文， 对调度相关的其他论文也进行了总结和分类，以及看了ppt下面的链接有关内容<br>明日安排，做一下最短路径（单源或者多源情况）， 练习今天学到的有关Dijstra, Bellman-Ford算法以及Floyd算法</p><h4 id="2022"><a href="#2022" class="headerlink" title="2022"></a>2022</h4><p>1-3<br>完成&gt;400目标<br>代码主要就是看分布式+rpc是否能够兼容(+cache目前通过mp.spawn解决)并调试通过，实在ddp+rpc无法完成，就只能使用dp+rpc</p><p>1-6 现在遇到的问题：1.有ssh密码登录的机器，使用rpc无法正常运行， 同时rpc在同一台机器好像也无法正常运行</p><p>解决！<br>注意在rpc中发出rpc_async请求的是worker, 接收请求的是master</p><p>hec上使用pytorch 1.8.1只能在没有gpu的节点上，如果在hec01 hec02上就会报错</p><p>现在问题 8a100和hec06节点连接会报错：<br>aster: ECONNREFUSED: connection refused<br>Failed to respond to ‘Shutdown Proceed’ in time, got error ECONNREFUSED: connection refused<br>Traceback (most recent call last):<br>  File “worker.py”, line 88, in <module><br>    rpc.shutdown()<br>  File “/nfs/home/anaconda3/envs/pytorch-shu/lib/python3.6/site-packages/torch/distributed/rpc/api.py”, line 78, in wrapper<br>    return func(*args, **kwargs)<br>  File “/nfs/home/anaconda3/envs/pytorch-shu/lib/python3.6/site-packages/torch/distributed/rpc/api.py”, line 284, in shutdown<br>    _get_current_rpc_agent().join()<br>RuntimeError: [/opt/conda/conda-bld/pytorch_1607370193460/work/third_party/gloo/gloo/transport/tcp/pair.cc:575] Connection closed by peer [10.5.30.42]:27806</p><p>Solution: Edit /etc/hosts and change 127.0.1.1 to your actual ip-address 目前看到的一个答案<br>分析：现在在hec上互相使用rpc（即使有密码）是可以的，但是在8a100就不行，所以现在怀疑的是需要在host里面添加目录，以及需要在两台机器上换成同一个用户才行<br>第二种解决方案，应该使用tpc的init_method，以及使用gloo后端，但是目前试验过，仍然会报错</p><p>感觉在分布式多台机器上训练也会出现相同的问题</p><p>找到的真正的解决方案：backend=rpc.BackendType.PROCESS_GROUP， 不需要加其他的<br>os.environ[‘TF_SOCKET_IFNAME’] = ‘ens3’ (x)<br>os.environ[‘GLOO_SOCKET_IFNAME’] = ‘ens3’ (x)</p><p>寒假安排：</p><ol><li>leetcode争取上500 可以先将宫水三叶的题刷完，应该都是经典题目</li><li>对之前写的leetcode进行总结，整理，转为每个知识点，先放总结的思路，或者针对的题型，然后放相应的例题，没道例题简答写一下解决方案，和总结的思路进行对应</li><li>回归操作系统，计网的基础知识, 转为笔试的xmind (408题目看看)<br>github和牛客网应该有许多资源，多看看多比较; 包括深度学习和目标检测相关的面试题目<br>牛客网上， 网友的总结：(CyC2018)<br>[<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E7%9B%AE%E5%BD%95.md]">https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E7%9B%AE%E5%BD%95.md]</a></li><li>补充面试的xmind</li><li>有时间学一下grpc</li><li>记得备份一下8a100上面的数据 (目前正在8a100使用rsync进行传输 到hec06 /nfs目录下)<br>7。一些公司名单和深度学习的资料<br><a href="https://github.com/amusi/CV-Company-List">https://github.com/amusi/CV-Company-List</a><br>注意关注一下春招信息，微软已经开始投递了，然后我因为错过了问卷，错过了提前批，之后注意准备面试和之后的问卷</li><li>修改简历，变为项目两个， research两个，将重要性采样自己的工作写上去zzw</li><li>项目一定要非常非常熟悉，整理面试可能问到的每一个问题，和自己优化的思考！！！</li></ol><p>刷完八股之后，进行自测：<a href="https://github.com/youngyangyang04/TechCPP">https://github.com/youngyangyang04/TechCPP</a><br><a href="https://github.com/youngyangyang04/leetcode-master">https://github.com/youngyangyang04/leetcode-master</a></p><p>leetcode暂时未看的条目：<br>买通行票的最低价格</p>]]></content>
    
    
    
    <tags>
      
      <tag>daily task</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/11/13/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/hello-world/"/>
    <url>/2021/11/13/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>工具相关</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>基本神经网络相关问题</title>
    <link href="/2021/11/13/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E5%9F%BA%E6%9C%AC%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/"/>
    <url>/2021/11/13/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E5%9F%BA%E6%9C%AC%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<ol><li><p>滤波和传统的图像算法 e.g. SIFT</p></li><li><p>CNN感受野定义以及计算方式<br>感受野指的是一个特定的 CNN 特征（特征图上的某个点）在输入空间所受影响的区域。<br>感受野的计算是输出图像的反向过程<br>out_put=(iput_size-kernel_size)/stride+1<br>input_size=(out_put-1)*stride+kernel_size</p></li></ol><ol start="3"><li><p>CNN矩阵乘法原理<br>参考链接：<a href="https://shuokay.com/2016/06/08/convolution/">卷积计算</a><br>img2col将卷积运算转为矩阵乘法<br>其中输入的矩阵：行方向对应特征图不同channel同一视野（位置）的向量展开；列方向代表不同的位置；<br>kernel的矩阵：行方向代表代表不同的卷积核，列方向代表一个滤波器每个channel的矩阵-&gt;向量，<br>输出矩阵</p></li><li><p>BatchNormalization与正则化的区别：<br> BatchNormalization主要是用于将神经网络中间输入特征图的均值和方差进行规范化，使输入分布拉到容易激活后面激活层中，解决梯度消失和梯度爆炸问题问题<br> 正则化，通常用于机器学习，在损失函数中加上参数的一阶或者二阶和，防止过拟合</p></li></ol><ol start="5"><li>产生梯度消失或爆炸的原因：<br>网络层数太深而引发的梯度反向传播中的连乘效应<br>解决梯度消失或者梯度爆炸问题的解决方案：<ul><li>batch BatchNormalization</li><li>梯度裁剪</li><li>修改激活函数，比如leaky relu</li><li>残差结构</li><li>每层预训练后微调</li></ul></li></ol><ol start="6"><li>机器学习：多分类如何转为多个二分类问题：需要训练N个分类器<br><a href="https://yuanxiaosc.github.io/2018/07/01/%E4%BA%8C%E5%88%86%E7%B1%BB%E3%80%81%E5%A4%9A%E5%88%86%E7%B1%BB%E4%B8%8E%E5%A4%9A%E6%A0%87%E7%AD%BE%E9%97%AE%E9%A2%98%E7%9A%84%E5%8C%BA%E5%88%AB%E2%80%94%E2%80%94%E5%AF%B9%E5%BA%94%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E7%9A%84%E9%80%89%E6%8B%A9/">参考链接</a><br>将每一次的一个类作为正例，其余作为反例，总共训练N个分类器。测试的时候若仅有一个分类器预测为正的类别则对应的类别标记作为最终分类结果，若有多个分类器预测为正类，则选择置信度最大的类别作为最终分类结果。<br>PS:目标检测的多标签二分类损失函数是使用每个标签的概率的求二分损失函数（逻辑损失）然后求平均值得到整体的损失<br>其他方案：<br>一对一，建立N(N-1)/2个分类器，然后进行投票<br>直接用softmax进行多分类任务训练</li></ol><ol start="7"><li><p>网络退化以及resnet为什么可以解决梯度消失和网络退化问题：<br>首先介绍什么是网络退化问题<br>举个例子，假设已经有了一个最优化的网络结构，是18层。当我们设计网络结构的时候，我们并不知道具体多少层次的网络时最优化的网络结构，假设设计了34层网络结构。那么多出来的16层其实是冗余的，我们希望训练网络的过程中，模型能够自己将这16层冗余层训练为恒等映射，也就是经过这层时的输入与输出完全一样。<br>但是往往模型很难将这16层恒等映射的参数学习正确，那么就不如最优化的18层网络结构的性能，这就是随着网络深度增加，模型会产生退化现象。它不是由过拟合产生的，而是由冗余的网络层学习了不是恒等映射的参数造成的。<br>也就是说神经网络学习恒等映射 F(x)=x 的效果不好，但是加上了skip connection 神经网络就用于学习F(x)=0</p></li><li><p>链式法则：<br>原本y对x求偏导，但是由于过程较为复杂，我们引入了一个中间层z，先利用y对z求偏导，在乘上z对x求偏导，这样会使整个计算更为简单。<br>当前error对当前层参数的导数，是error对当前输出（输出特征图）的倒数*当前节点的输入（输入特征图）</p></li></ol><ol start="9"><li>矩阵的反向传播算法/CNN的反向梯度传播算法</li></ol><ol start="10"><li>激活函数sigmoid，tanh，relu. 各自的优点和适用场景<br>[参考链接]（<a href="https://zhuanlan.zhihu.com/p/71882757%EF%BC%89">https://zhuanlan.zhihu.com/p/71882757）</a><br>激活函数的作用：主要是向神经网络中引入非线性的特征</li></ol><ul><li>sigmoid函数：主要运用在逻辑二分类中，缺点：计算复杂，不是0均值，同时容易出现梯度饱和，当输入是非常大的正值或者负值的时候，反向传播梯度为0；</li><li>tanh函数：是0均值，但是计算复杂，同时也容易出现梯度饱和问题</li><li>relu函数：计算简单，在输入大于0的时候不会出现梯度饱和，但是在输入小于0的时候会出现梯度为0，造成死的神经元，因此参数一直得不到更新</li></ul><ol start="11"><li><p>常见神经网络的结构特点和结构优势</p></li><li><p>牛顿法和SGD的各自原理，优势，区别</p></li><li><p>LR的梯度反向传播推导<br><a href="https://blog.csdn.net/ft_sunshine/article/details/105370528">https://blog.csdn.net/ft_sunshine/article/details/105370528</a></p></li></ol><p>方程：y=theta<em>x<br>激活函数 h(x)-1/(1+e^(-theta x))<br>损失函数 loss=1/m</em>求和(y^ilog(h(x)) - (1-y^i)log(1-h(x))))</p>]]></content>
    
    
    <categories>
      
      <category>项目相关</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>机器学习</title>
    <link href="/2021/11/13/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    <url>/2021/11/13/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<ol><li>xgboost与GDBT的区别</li></ol><p>xgboost属于GDBT的工程实现，但是相比于GDBT有更多的优化</p><ul><li>1.两者都是属于boosting方法，就是迭代串行求多个模型，每个模型不同权重，训练过程中样本也具有不同的权重</li><li>2.GDBT是使用多个决策树组成的，xgboost可以使用线性模型</li><li>3.xgboost使用了代价函数的一阶和二阶信息，同时可以用户自定义代价函数，同时xgboost在代价函数中加入了正则项，用于控制模型的复杂度</li><li>4.xgboost能够自动对缺失值进行处理</li></ul>]]></content>
    
    
    <categories>
      
      <category>项目相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>machine learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编程语言</title>
    <link href="/2021/11/13/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    <url>/2021/11/13/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<h4 id="python"><a href="#python" class="headerlink" title="python"></a>python</h4><ol><li><p>python GIL介绍</p></li><li><p>list tuple set的区别</p></li></ol><ol start="3"><li><p>python迭代器和生成器的区别是什么<br>生成器本质上还是一个迭代器，也是用在迭代操作中，因此它有和迭代器一样的特性，唯一的区别在于实现方式上不一样，后者更加简洁；<br>生成器只是在需要这个值再生成</p></li><li><p>迭代器<br>迭代器对象要求支持迭代器协议的对象。在Python中，支持迭代器协议就是实现对象的__iter__()和next()方法。<br>其中__iter__()方法返回迭代器对象本身；next()方法返回容器的下一个元素，在结尾时引发StopIteration异常。<br>iter是可迭代对象，可迭代对象才能调用next函数</p></li></ol><ol start="5"><li>生成器<br>生成器(generator)就是一个函数，它提供了一种实现迭代器协议的便捷方式。<br>生成器与普通函数的区别在于它包含 yield 表达式，并且不需要定义 <strong>iter</strong>()和__next__()。</li></ol><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><h5 id="1-vector"><a href="#1-vector" class="headerlink" title="1.vector"></a>1.vector</h5><p>find(vector.begin(), vector.end(), target_val)!=vector.end() find函数返回的是一个迭代器</p><p>vector.push_back(i)<br>vector.pop_back()</p><p>vec1.swap(vec2)//进行vector1和vector2的交换<br>vec2(vec1.begin(), vec1.begin()+4)表示截取vector的一部分，并赋值给vec2,注意后面的值表示vec不需要 也就是左闭右开模式</p><p>vector最后一个元素，vector.back()</p><p>vector.insert(vec.begin()+pos, target); // 将target元素插入到pos位置</p><p>auto pos=lower_bound(nums.begin(), nums.end(), target)<br>index = pos-nums.begin() //<br>lower_bound返回的是大于等于目标函数的数， upper_bound返回的是大于目标函数的数</p><p>注意和set的lower_bound不一样的<br>set.lower_bound(targets) 返回一个迭代器</p><p>mp的lower_bound也是不一样的<br>auto iter = mp.lower_bound(val)</p><p>set和map中的元素都是排好序的</p><h5 id="2-unordered-set-my-set"><a href="#2-unordered-set-my-set" class="headerlink" title="2.unordered_set my_set"></a>2.unordered_set my_set</h5><p>my_set.find(target_value)!=my_set.end() or my_set.count(target_value)!=0<br>my_set.insert(value)<br>my_set.erase(value)A</p><p>unordered_set查找元素的两种方式：（1）umap.find(target)!=-1  (2) umap[target]<br>unordered_set在进行查找的时候可以直接使用unordered_set[target]即使是target不存在也不会报错，<br>但是在vector中查找某一个元素就需要vec.find(target)!=vec.end() </p><h5 id="3-priority-queue-queue"><a href="#3-priority-queue-queue" class="headerlink" title="3. priority_queue / queue"></a>3. priority_queue / queue</h5><p>q.push()<br>q.pop()</p><h5 id="4-set-insert-value-erase-value-push-pop"><a href="#4-set-insert-value-erase-value-push-pop" class="headerlink" title="4. set insert(value) erase(value) push pop"></a>4. set insert(value) erase(value) push pop</h5><p>遍历 for(auto iter=set.begin(); iter!=set.end(); iter++)</p><p>用vector里面的元素初始化set unordered_set<int> nums_set(nums1.begin(), nums1.end());//其中nums1是vector</p><h5 id="5-map"><a href="#5-map" class="headerlink" title="5.map"></a>5.map</h5><p>插入元素：map[key]=value; 或者map.insert(make_pair(key, value))<br>删除元素：map.erase(key)//注意不是remove</p><p>查找元素：map.find(key)</p><p>复制：hash.insert(hash1.begin(), hash1.end())<br>PS： vector的复制是 vec.assign(vec1.begin(), vec1.end())</p><h5 id="6-其他语法"><a href="#6-其他语法" class="headerlink" title="6.其他语法"></a>6.其他语法</h5><p>判断字符是字母：isalpha()</p><p>判断字符是数字：isdigit()</p><p>判断字符是字母或数字：isalnum()</p><p>同时注意c++中，字符用单引号表示，字符串用双引号表示</p><p>注意c++中只有数组能够使用memset，在vector中不能使用</p><h5 id="7-string"><a href="#7-string" class="headerlink" title="7.string"></a>7.string</h5><p>find函数 pos=s.find(target)  pos=s.find(target,0)<br>如果没有找到返回s.npos 或者string::npos</p><p>原地移除数组上的元素，我们说到了数组上的元素，不能真正的删除，只能覆盖。array.erase(i)的时间复杂度是O(n)</p><h5 id="8-set-数组-map的选择"><a href="#8-set-数组-map的选择" class="headerlink" title="8.set 数组 map的选择"></a>8.set 数组 map的选择</h5><p>主要是看数据的范围，如果数据返回不确定那么尽量选择map or set，如果确定是小写字母的话，也就是26个字母，可以使用数组<br>set包含 unordered_set（无序， 哈希表，不能重复， 查询和增删效率O(1)）, multiset（有序，红黑树，可以重复 O(nlogn)）, set(有序， 红黑树，不能重复， O(nlong))； map类似<br>三种都是只能erase和insert不能修改数值， map不能修改key但是可以修改value</p><h5 id="9-stack"><a href="#9-stack" class="headerlink" title="9. stack"></a>9. stack</h5><p>栈的底层实现可以是vector, dequeue, list<br>栈只能获取最后一个元素，无法直接获取第一个元素<br>top()    返回栈顶元素的引用，类型为 T&amp;，如果栈为空，返回值未定义<br>pop()    栈顶元素出栈<br>size()    返回栈中元素的个数<br>empty()    栈中没有元素时返回 true<br>emplace()    使用传入的参数调用构造函数，在栈顶生成对象<br>push(const T&amp; obj)    将对象副本压入栈顶，通过调用底层容器的 push_back() 函数实现<br>push(T&amp;&amp; obj)    以移动对象的方式将对象压入栈，通过调用底层容器的有右值引用参数的 push_back() 函数实现<br>swap(stack<T> &amp; other_stack)    将当前栈中的元素和参数中的元素交换，参数所包含元素的类型必须和当前栈的相同，对于 stack 对象有一个特例化的全局函数 swap() 可以使用</p><p>可以出一道面试题：栈里面的元素在内存中是连续分布的么？</p><p>这个问题有两个陷阱：<br>陷阱1：栈是容器适配器，底层容器使用不同的容器，导致栈内数据在内存中是不是连续分布。<br>陷阱2：缺省情况下，默认底层容器是deque，那么deque的在内存中的数据分布是什么样的呢？答案是：不连续的，下文也会提到deque。</p><h5 id="10-queue-队列"><a href="#10-queue-队列" class="headerlink" title="10.queue 队列"></a>10.queue 队列</h5><p>可以访问队列最后一个元素，但是无法pop最后一个元素<br>queue入队，如例：q.push(x); 将x 接到队列的末端。</p><p>queue出队，如例：q.pop(); 弹出队列的第一个元素，注意，并不会返回被弹出元素的值。</p><p>访问queue队首元素，如例：q.front()，即最早被压入队列的元素。</p><p>访问queue队尾元素，如例：q.back()，即最后被压入队列的元素。</p><p>判断queue队列空，如例：q.empty()，当队列空时，返回true。</p><h5 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h5><p>pair&lt;int, int&gt; 访问元素不是用下标而是用first second; 创建一个pair用pair&lt;int, int&gt; res = make_pair&lt;a, b&gt;<br>或者用括号 pair&lt;int, int&gt; b(1, 2);</p><h5 id="新建一个未知长度的数组"><a href="#新建一个未知长度的数组" class="headerlink" title="新建一个未知长度的数组"></a>新建一个未知长度的数组</h5><p>int *queue;<br>queue=new int[k+1] 主要是用于类构建动态数组的这种情况</p><h4 id="向上取整"><a href="#向上取整" class="headerlink" title="向上取整"></a>向上取整</h4><p>(x+(b-1))/b*b</p><h4 id="malloc和new的区别"><a href="#malloc和new的区别" class="headerlink" title="malloc和new的区别"></a>malloc和new的区别</h4><p><img src="%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/image-20220122202312622.png" alt="image-20220122202312622"></p><h4 id="hashMap原理"><a href="#hashMap原理" class="headerlink" title="hashMap原理"></a>hashMap原理</h4>]]></content>
    
    
    <categories>
      
      <category>项目相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python, C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试</title>
    <link href="/2021/11/13/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E9%9D%A2%E8%AF%95/"/>
    <url>/2021/11/13/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E9%9D%A2%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p>回答问题模板：<br>a) 我为什么要做这个项目？要达到什么目标？<br>b) 学术上，或者工业上 有哪些方法？能达到什么目标？这些方法分别有什么优缺点？<br>c) 我为什么要选择这个方法？项目上做了哪些取舍？<br>d) 这里面，我做了哪些创新点/亮点？为什么我要做这个创新点？<br>e) 最后项目达到了什么样的结果</p></blockquote><p>发现、动机、实践和验证</p><h4 id="计算机视觉"><a href="#计算机视觉" class="headerlink" title="计算机视觉"></a>计算机视觉</h4><p>对于自己的工作，尤其是准备重点介绍的工作，每一个细节都要很熟悉，要能解释清楚做了什么，为什么这么做，效果怎么样。<br>对实习能力有哪些要求：自学能力+基础知识扎实<br>每个项目都按照STAR法则（背景-任务-行动-结果）的结构都写下来</p><p>如何解决小目标问题：<br>使用多尺度或者增大输入的scale(在可以选择的scale范围中选择更大的)，以及focal loss</p><p>每次面试都需要串一篇检测模型</p><p>RCNN/Fast RCNN/Faster RCNN/Mask RCNN</p><p>Yolov123</p><h5 id="首先介绍自己的工作"><a href="#首先介绍自己的工作" class="headerlink" title="首先介绍自己的工作"></a>首先介绍自己的工作</h5><ol><li>熟悉平台和公司内部算法框架</li><li>熟悉数据，了解训练模型的数据处理流程，包括相关标注文档撰写， 数据发标， review, 完善标注质量评估的相关代码</li><li>多任务分类代码阅读理解</li><li>主要是训练一个目标检测模型</li></ol><h5 id="实习-项目遇到的问题，是如何解决的？"><a href="#实习-项目遇到的问题，是如何解决的？" class="headerlink" title="实习/项目遇到的问题，是如何解决的？"></a>实习/项目遇到的问题，是如何解决的？</h5><blockquote><p>你其实可以运用STAR的总结回答你的问题，项目背景——遇到啥问题——你怎么做——有什么结果？<br>  eg:<br>  背景：现在要做一个考勤的功能，统计公司人员的打卡情况。<br>  问题：在评审会议中涉及考勤的功能时对于统计与开发有不同意见。<br>  怎么做：对两种统计结果、开发难度等维度进行分析，形成分析报告，再下次评审中与开发进行沟通处理。<br>  结果：达成一致意见，在会后对自己这件事进行复盘总结方法论，避免下次出现该问题</p></blockquote><p>  实习中遇到的困难，如何解决？<br>  最开始遇到的困难：</p><ol><li>训练模型精度不高。排查查看训练输入数据的格式是否正确。数据格式确认后，分析精度主要是因为一类的精度非常小导致的， 之后分析数据发现主要是1）该类数据量非常少 2) 该类的目标框非常小，之后修改损失为focal loss以及多维度输入的时候，尽量选择比较大的scale范围（rescale的时候增大scale）</li><li>训练模型主要关注的如何调节参数提升模型的精度，参数搜索空间非常大，如何找到一个合适的调节参数的方向；解决：先询问身边的同事，因为他们比我更有经验，一定知道调节什么参数对模型的精度影响更大；第二个在明确大致的参数调节方向后，自己实践，需要用一个表格记录自己所做的实验，方便之后进行结果对比和进一步修正,最终在crop size mAP大概为92%-93% 在原图mAP 95%.</li></ol><p>  研究过程中遇到的困难？</p><p>  毕业设计/模型量化和剪枝中遇到的困难？<br>  1.使用distiller的库的时候，发现剪枝训练精度最后为0，效果突然变差，解决方案。1）是在github issue/ stack overflow 中查找相关问题的解决方案，没有则进行提问<br>  2.实验结果不理想和预期差距大。最开始实验的结构化剪枝精度下降会非常快，查看其它文献，分析差距主要在哪里，然后调整自己的实验，最后解决方案：在论文中加入敏感性分析+同时明白结构化剪枝局限性：主要适用于参数量比较多的网络</p><p>  新加坡项目遇到的困难？<br>  1.实验结果不理想。分析原因，查找数据/代码是否有问题，调整算法实现</p><p>椒盐噪声，怎么处理？<br>椒盐噪声就是根据输入的信噪比参数，随机在图像中加入0和225（黑点和白点）</p><p>中值滤波是如何做的？</p><p>一、目标检测<br>suprevision  解决图像太少的问题，混合公开数据集一起训练<br>1.faster-RCNN<br>faster-rcnn的整个从输入到输出的框架流程，然后是rpn的原理，列举一下针对小目标的解决措施，如何解决类内的检测，还有项目中有无其他困难<br>如何提高小目标检出率（RPN哪里也可以提升小目标检出率）</p><p>2.RNN的损失如何求</p><p>3.写IOU函数</p><ol start="4"><li>在suprevision中的anchor 的anchor.ratio是如何产生的，是根据feature size 还是随机产生的</li></ol><p>做了什么优化使 mAP 提高了2个百分点</p><h5 id="现有的一些目标检测的算法优缺点对比"><a href="#现有的一些目标检测的算法优缺点对比" class="headerlink" title="现有的一些目标检测的算法优缺点对比"></a>现有的一些目标检测的算法优缺点对比</h5><p><a href="https://zhuanlan.zhihu.com/p/354060133?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=1113097318299123712&amp;utm_campaign=shareopn">https://zhuanlan.zhihu.com/p/354060133?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=1113097318299123712&amp;utm_campaign=shareopn</a></p><p>二、图像分类<br>vehicle attributes<br>多任务共同学习：<br>因为训练数据集相对较小，容易产生过拟合，为了避免这种情况的发生，合并多个数据集。</p><p>三、视频分类</p><h4 id="模型压缩"><a href="#模型压缩" class="headerlink" title="模型压缩"></a>模型压缩</h4><p>1.常用的模型压缩和量化方法</p><p>2.知识蒸馏采用的具体方法如下：<br>1、训练复杂的教师模型（teacher model）：先用硬目标（hard target），也就是正常的标签（label）训练大模型。<br>2、计算软目标（soft target）：利用训练好的大模型来计算软目标（soft target），也就是大模型“软化后”再经过softmax层的输出。<br>3、训练小模型，在小模型的基础上再加一个额外的软目标（soft target）的损失函数，通过比例参数来调节两个损失函数的比重。<br>4、预测时，将训练好的小模型来进行实验。</p><h4 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h4><p>在项目中得到了什么提升/相比于本科，研究生阶段有什么新的收获？<br>1.代码规范与记录，注意细节，代码的可理解性<br>2.实践工程能力与计算机思维，手动思维想自动思维的转换，图形界面转为命令行，计算机专业的人主要就是让更多的手动工作变为一键操作<br>3.实际场景的数据可能不是像标准训练数据那样 每个类别都非常均衡，因此在实际场景中要注意类别标签不均衡问题<br>4.懂得记录 博客/github上代码整理<br>5.更加关注底层和原理，以及现有方法为什么这么做，有什么问题，以及如何改进这些问题</p><h4 id="开放的针对深度学习的理解的题目"><a href="#开放的针对深度学习的理解的题目" class="headerlink" title="开放的针对深度学习的理解的题目"></a>开放的针对深度学习的理解的题目</h4><p>给了一个情景，如何训练模型、调优。（题目很空，主要考察你对深度学习的理解）<br>根据需求（前向传播时间、模型大小），确定模型和基础网络，跑第一版模型。（举了个栗子）<br>判断模型是否出现过拟合的情况，来决定下一步的优化方向。<br>结果分析(confusionMatrix等)，分析问题，将论文中的方法套上去，如果没有自己创造。（又举了个栗子）</p><h4 id="凸优化了解吗？-牛顿法、SGD、最小二乘法，各自的优势。"><a href="#凸优化了解吗？-牛顿法、SGD、最小二乘法，各自的优势。" class="headerlink" title="凸优化了解吗？ 牛顿法、SGD、最小二乘法，各自的优势。"></a>凸优化了解吗？ 牛顿法、SGD、最小二乘法，各自的优势。</h4><p>牛客实习生论坛</p><p>四、 应用开发</p><p>遇到的困难：从bomb请求数据的时候，数据还没有请求得到，已经开始执行后面的语句，无法正确获取到最新的数据并显示，后来发现是异步执行流程的原因导致</p><h4 id="推荐系统算法总结"><a href="#推荐系统算法总结" class="headerlink" title="推荐系统算法总结"></a>推荐系统算法总结</h4><p><a href="https://cloud.tencent.com/developer/article/1614209">https://cloud.tencent.com/developer/article/1614209</a> </p>]]></content>
    
    
    <categories>
      
      <category>项目相关</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>笔试</title>
    <link href="/2021/11/13/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E7%AC%94%E8%AF%95/"/>
    <url>/2021/11/13/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E7%AC%94%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/lcylmhlcy/Awesome-algorithm-interview/blob/master/README.md#1-interview-1">Awesome algorithm interview</a></p><h4 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h4><p>TCP连接为什么要三次握手，TCP关闭为什么要4次挥手？<br>三次握手是为了防止服务器资源的浪费，因为如何是两次的话，如果客户端发送请求连接，但是不发送请求数据，就可能造成服务器端口占用，资源被浪费；四次回收是因为客户端和服务器可以各自关闭，比如客户端告诉服务器FIN，表示自己不发送数据，但是仍然可以接收数据，因此服务器可以继续发送，服务器将数据发送完了之后，再发出关闭信号，因此四次挥手允许客户端和服务器各自分别关闭</p><h4 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h4><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><p>搜索github 上面的面试八股文</p><p><a href="https://github.com/cosen1024/Java-Interview">https://github.com/cosen1024/Java-Interview</a> java面试小抄书</p><p>JVM内存结构，什么是hash 冲突，如何解决</p><p>语言/数据结构/操作系统/网络/分布式/系统设计</p><p>考研408</p>]]></content>
    
    
    <categories>
      
      <category>项目相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>八股文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>哈希相关</title>
    <link href="/2021/11/13/leetcode/%E5%93%88%E5%B8%8C%E7%9B%B8%E5%85%B3/"/>
    <url>/2021/11/13/leetcode/%E5%93%88%E5%B8%8C%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h4 id="前缀和-hash题目汇总"><a href="#前缀和-hash题目汇总" class="headerlink" title="前缀和 + hash题目汇总"></a>前缀和 + hash题目汇总</h4><p>一定要注意先判断hash[presum-target]是否存在并更新结果，再更新hash[presum]++， 因为可能nums[i]=0</p><p>例题：<br>面试题 17.05.  字母与数字，要求字母和数字个数相同，那么就是将字母转为1， 数字转为-1的时候，前缀和为0的最长序列；<br>另外使用这种思想是的”和等于 k 的最长子数组长度“ ”和等于k子数组“<br> ”1371. 每个元音包含偶数次的最长子字符串“:<br>题解：为了表明每个元音出现了偶数次，可以使用二进制数，如果一个位经过一轮之后仍然为当前的值，那么说明这个位出现了偶数次或者没出现过，<br>通过这种方法可以类推到特定字符出现k数次，那么就使用k进制；同时注意是每个元音出现偶数次，而不是元音总个数为偶数次，如果是第二种情况<br>可以使用元音为奇数表示，sum%2==0表示元音个数为偶数）</p><ol><li><p>连续的子数组和 注意这道题不是说连续的子数组为目标数，而是为目标数的倍数，但是仍然可以用这种方法来做，因为为目标数的倍数，意味着前缀和%该数得到的余数相同，因为可以用hash记录第一次出现该余数的下标，然后再次出现时，判断数组长度是否大于等于2， 一定要注意在开始的时候hash[0]=-1!!!</p></li><li><p>连续数组 相同的0和1的个数，其实也是前缀和，只不过遇到0变为-1</p></li><li><p>和相同的二元子数组<br>注意一定要先查找hash[presum-target]，更新hash[presum]++<br>主要是针对0的情况，如果先更新hash就会报错<br>注意最开始要设置hash[0]要为1</p></li><li><p>统计「优美子数组」<br>将奇数转为1， 偶数转为0， 然后求和为k的子数组个数</p></li></ol><h4 id="hash-双指针"><a href="#hash-双指针" class="headerlink" title="hash + 双指针"></a>hash + 双指针</h4><p>一定要注意返回的是元素还是元素的下标，一个可以排序使用指针，一个不能使用指针<br>两数之和：用双指针只能针对已经排好序的数组，没有排好序的数组，但是要求要返回下标，那么就用hash (unordered_set)<br>三数之和<br>四数之和：三重循环，因此有是三个去重的部分，不要只去重最后一层循环，忘了i j 层循环的去重</p><p>注意！！！</p><ol><li>hash方法是不能去重的，要去重只能使用循环+双指针；同时返回坐标不能用双指针，返回值才能使用双指针</li><li>去重放在==target的if语句之内（==循环去重==），同时可以用一些剪枝策略，但是要记得四个数相加可能出现溢出，所以如果要剪枝，记得强转为long型<figure class="highlight c++"><figcaption><span>去重模板</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">while</span>(i &lt; j &amp;&amp; nums[i] == nums[++i]);<span class="hljs-keyword">while</span>(i &lt; j &amp;&amp; nums[j] == nums[--j]);<br><br></code></pre></td></tr></table></figure></li><li>数组不一定是排好序的，因此需要先对数组进行排序</li></ol><p>变形：数组中的k-diff数对，这里只是换成了绝对值差，而不是目标值; 而且因为数组中存在重复的数字，因此需要先用set记录结果，然后再返回set.size<br>这道题也可以用排序+二分查找（找到目标的k+nums[i]），同时需要过滤掉已经找的数据</p><p>拓展：<br>注意前面三个题是可能包含重复的元素，但是需要返回不重复的元组对，下面这个题是找出所有的元组对，因此是包含重复的元组对的<br>题目：三数之和的多种可能<br>解决方案：仍然是三数之和的方法的，但是在进行计算的时候如果arr[left]!=arr[right]那么res+=hash[left]<em>hash[right] (用while循环找到hash[left]，或者提前计算)<br>如果arr[left]==arr[right] res+=(right-left+1)</em>(right-left)/2</p><h4 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> size=nums.<span class="hljs-built_in">size</span>();<br><span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-3</span>;i++)&#123;<br>    <span class="hljs-keyword">while</span>(i<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>&amp;&amp;nums[i]==nums[i<span class="hljs-number">-1</span>])&#123;<br>        <span class="hljs-keyword">continue</span>; <span class="hljs-comment">//去重</span><br>    &#125;<br>    <span class="hljs-keyword">if</span>((<span class="hljs-keyword">long</span>) nums[i]+nums[i+<span class="hljs-number">1</span>]+nums[i+<span class="hljs-number">2</span>]+nums[i+<span class="hljs-number">3</span>]&gt;target)&#123;<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>((<span class="hljs-keyword">long</span>) nums[i]+nums[size<span class="hljs-number">-3</span>]+nums[size<span class="hljs-number">-2</span>]+nums[size<span class="hljs-number">-1</span>]&gt;target)&#123;<br>            <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i+<span class="hljs-number">1</span>;j&lt;nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-2</span>;j++)&#123;<br>        <span class="hljs-keyword">if</span> (j &gt; i + <span class="hljs-number">1</span> &amp;&amp; nums[j] == nums[j - <span class="hljs-number">1</span>]) &#123;<br>                    <span class="hljs-keyword">continue</span>; <span class="hljs-comment">//去重</span><br>        &#125;<br>        <span class="hljs-keyword">if</span>((<span class="hljs-keyword">long</span>) nums[i]+nums[j]+nums[j+<span class="hljs-number">1</span>]+nums[j+<span class="hljs-number">2</span>]&gt;target)&#123;<br>                <span class="hljs-keyword">break</span>; <span class="hljs-comment">//注意是break不是continue</span><br>        &#125;<br>        <span class="hljs-keyword">if</span>((<span class="hljs-keyword">long</span>) nums[i]+nums[j]+nums[size<span class="hljs-number">-2</span>]+nums[size<span class="hljs-number">-1</span>]&gt;target)&#123;<br>                <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> k=j+<span class="hljs-number">1</span>, q=size<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">int</span> find_num=target-nums[i]-nums[j];<br>        <span class="hljs-keyword">while</span>(k&lt;q)&#123;<br>            <span class="hljs-keyword">if</span>(nums[k]+nums[q]&gt;find_num)&#123;<br>                q--;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[k]+nums[q]&lt;find_num)&#123;<br>                k++;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[k]+nums[q]==find_num)&#123;<br>                res.<span class="hljs-built_in">push_back</span>(&#123;nums[i], nums[j], nums[q], nums[k]&#125;);<br>                k++;<br>                q--;<br>                <span class="hljs-keyword">while</span>(k&lt;q&amp;&amp;nums[k]==nums[k<span class="hljs-number">-1</span>])&#123;<br>                    k++;<br>                &#125;<br>                <span class="hljs-keyword">while</span>(k&lt;q&amp;&amp;nums[q]==nums[q+<span class="hljs-number">1</span>])&#123;<br>                q--;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>参考链接：<a href="https://leetcode-cn.com/problems/4sum/solution/si-shu-zhi-he-by-leetcode-solution/">四数之和答案</a></p></blockquote><h4 id="hash-动态规划"><a href="#hash-动态规划" class="headerlink" title="hash+动态规划"></a>hash+动态规划</h4><ol><li>最长定差子序列<br>转移方程： dp[arr[i]]=dp[arr[i]-diff]+1<br>因为不知道arr[i]的最大值，以及可能出现负数的下标， 所以直接使用hash，而不是数组<br>dp[x] 表示以 x 结尾的最长等差子序列的长度；</li></ol>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>回溯_DFS_BFS</title>
    <link href="/2021/11/13/leetcode/%E5%9B%9E%E6%BA%AF_DFS_BFS/"/>
    <url>/2021/11/13/leetcode/%E5%9B%9E%E6%BA%AF_DFS_BFS/</url>
    
    <content type="html"><![CDATA[<h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><ol><li><p>字符串的转换路径问题:<br> 标准答案是既用到了深度优先搜索，也用到了宽度优先搜索<br> 1.构建nexts数组（图）2.使用BFS求每个节点到start的最短距离 3.DFS求具体路径，同时在进入下层循环是需要判断，当前的距离是不是当前节点到start的最短距离，如果是进入循环，否则剪枝<br> 我之前的答案是用的BFS+vis数组+pre数组，同时vis数组更新和向队列中添加新的元素是遍历完了当前队列中的所有元素再开始的，这样pre数组就不会漏掉一些解</p></li><li><p>单词转换<br><a href="https://leetcode-cn.com/problems/word-transformer-lcci/solution/c-python3-dfsbu-neng-hui-su-yin-wei-bu-s-u45m/">leetcode链接</a><br>求其中一条路径使用DFS<br>求所有的路径使用BFS+DFS 再一轮访问完之后再赋值vis以及去重<br>求最短的路径，用BFS</p></li></ol><p>PS: 其他解决字符串的相关问题的方案<br>使用动态规划+Trie树，或者暴力string find，或者转为数组（数字）等等，</p><p>PS类似的题目： 单词接龙和最小基因变化， 最小基因变化的这道题在进行单词转换的时候，(1)对每个字符，4种情况 ACGT都进行测试（也就是每个字符需要验证4n次）， (2)在单词库中查找只有一个字符变化的</p><ol start="3"><li>组合总数 ：一定要注意如果给出的列表中包含重复的数据的话，一定要记得去重，以及通过一些条件可以提前剪枝</li></ol><p>组合总数I， II, III, VI 在进行回溯的时候需要注意的几个点：</p><ul><li>每类的数据是否可以重复选择，如果可以重复选择，那么需要在递归到某一个类的时候，将这个类的所有的数据（一个或者target/candidate[i]个）都选择完</li><li>是只求总数还是求所有的序列，如果只求总数可以使用动态规划，如果求序列需要使用递归回溯剪枝</li><li>相同结果不用元素组合算一种还是多种（2，2，3）和（2，2，3） 原数据为（2，2，2，2，3）</li><li>给的列表是否包含重复的数据，如果包含需要对数据进行排序后，再进行回溯</li><li>给的列表是否可以重复取，如果可以那么 改为 dfs(candidates,target-k*candidates[i],i+1,count);其中count[i]=k<br>为了防止递归层数太深</li></ul><ol start="4"><li>将数组拆分为斐波拉切数列 </li></ol><ul><li><p>可以使用stoi将字符串转为整数（一定要注意stoi字符溢出的问题， 以及stol溢出可能性）</p><p>long long tmp=stoi(a)+stoi(b) 如果整数相加超过了INT_MAX还是会报错，所以左边的写法是错误的，应该写为 long long tmp=stol(a)+stol(b)</p></li><li><p>也可以使用 回溯一个字符一个字符的累加，如果size&gt;2的情况下计算当前数+pre是否能够达到target,如果小于那么继续循环，如果大于那么退出循环 cur = cur*10 + S[i] - ‘0’;</p></li></ul><ol start="5"><li><p>求图长度，或者多叉树的树高</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//注意开始遍历每个节点的时候，一定要记得将根节点设置为vis</span><br>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cur, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; graph, vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;vis)</span></span>&#123;<br>          <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;<br>          <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;graph[cur].<span class="hljs-built_in">size</span>();i++)&#123;<br>              <span class="hljs-keyword">if</span>(!vis[graph[cur][i]])&#123;<br>                  vis[graph[cur][i]]=<span class="hljs-number">1</span>;<br>                  ans= <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">dfs</span>(graph[cur][i], graph, vis));<br>              &#125;<br>          &#125;<br>          <span class="hljs-keyword">return</span> ans+<span class="hljs-number">1</span>;<br>      &#125;<br><br></code></pre></td></tr></table></figure></li><li><p>最小高度树， 使用的是拓扑排序<br>如果求以每个节点为根节点的树，会导致超出时间限制，因此需要使用拓扑排序，每次删除叶节点，求到最中间的几个点</p></li></ol><ol start="7"><li><p>水壶问题，使用深度优先搜索，或者数学推导<br>深度优先搜索，因为超过了系统的搜索的层数，所以需要自己模拟压栈和出栈， 同时需要知道当前状态可以转化为其他状态，其他状态包括，将X倒满，将Y倒满，将X倒空，将Y倒空，将x的水导入Y中，将Y的水倒数X中 6种撞他<br>或者使用数学方式解决，每次水的变化量（X+Y）一定是X或者Y, 那么有不等式 ax+by=z; 那么z一定x和y最小公因数的倍数</p></li><li><p>字典序 或者 全排列使用深度优先搜索</p></li><li><p>01矩阵<br>找到1距离0的距离是从0开始进行bfs，而不是从1开始<br>解法：</p></li><li><p>广度优先搜索+记忆数组（将为0的点放入栈中，然后一层层向外扩散，记得访问过的点记得标记为visit, 或者用matrix !=-1来判定该点时候被访问过）</p></li><li><p>左上到右下；再从右下到左上</p></li><li><p>大礼包。注意这道题可以学习的是状态的记忆过程，使用map&lt;vector<int>, int&gt;, 当然这道题直接用dfs搜索每一个状态也是可以的<br>注意这道题在dfs的时候，除了要循环选择每个大礼包，退出循环后，还要判断当前计算值和==全部不用大礼包==谁更小！！！<br>无法使用完全背包+dp解决，因为dp的内层循环无法枚举，因为是一个vector, 而不是一个简单的int</p></li><li><p>划分为k个相同的子集：<br>这道题既可以使用状态压缩的dp也可以使用回溯+贪心<br>方法一：</p></li></ol><ul><li>需要对数组排序，从大的数最开始进行匹配，贪心策略（这样压栈次数会更少）</li><li>使用回溯的时候需要使用一个vis数组，如果当前值小于target 那么继续向前遍历；如果==target那么从头开始遍历，同时k-1;如果大于target,那么循环内部判断数组下一个数是否合适 </li></ul><p>方法二：<br>建立n个桶，然后判断每个数应该放在哪个桶内；如果当前这个数放在哪个桶都不行，那么当前循环return false；仍然使用贪心减少遍历次数<br><a href="https://zhuanlan.zhihu.com/p/78031844">https://zhuanlan.zhihu.com/p/78031844</a></p><ol start="12"><li>地图分析，多源DFS的例题<br>和正向题目描述的思路反过来，从为1的陆地出发，而不是从每个海洋出发求最短距离。先将所有为1的节点的位置放在队列中，每访问一个节点，就修改节点位置的值，那么就不需要使用vis数组</li></ol><p>13.组合总数||<br>因为这个是要求具体的组合，用dfs,同时注意去重</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=index;i&lt;size;i++)&#123;<br>    <span class="hljs-keyword">if</span>(i&gt;index&amp;&amp;candidates[i]==candidates[i<span class="hljs-number">-1</span>])&#123;<span class="hljs-comment">//去重</span><br>        <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    path.<span class="hljs-built_in">push_back</span>(candidates[i]);<br>    <span class="hljs-built_in">dfs</span>(candidates, target-candidates[i], i+<span class="hljs-number">1</span>, path);<br>    path.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-comment">// dfs(candidates, target, i+1, path); //注意这个一定不能要</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>注意dfs和回溯还是有区别的，dfs，遇到不合适的条件可以直接退出，但是回溯哦，退出前要将之前的状态修改<br>dfs如果状态比较多，可以使用记忆化数组，同时如果状态都是某一个数的倍数，那么可以对数据进行归一化后再进行dfs<br>例如：分汤</p><p>如果要求岛屿的形状相同，那么可以将岛屿的位置使用string的形式存储下来，然后使用set<string>来存储，返回size就是形状不同的岛屿（忽略翻折和旋转）</p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回溯算法, DFS, BFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串相关问题</title>
    <link href="/2021/11/13/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2021/11/13/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h4 id="常见字符串解决套路"><a href="#常见字符串解决套路" class="headerlink" title="常见字符串解决套路"></a>常见字符串解决套路</h4><ol><li><a href="./%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%A2%98%E5%9E%8B.md">用动态规划求解</a></li><li><a href="./%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.md">用滑动窗口求解</a></li><li><a href="./%E5%8F%8C%E6%8C%87%E9%92%88.md">用双指针求解</a></li><li><a href="./%E5%9B%9E%E6%BA%AF_DFS_BFS.md">使用DFS/BFS求一个字符串转为另外一个字符串的路径问题</a></li></ol><h4 id="扩展：字符串hash"><a href="#扩展：字符串hash" class="headerlink" title="扩展：字符串hash"></a>扩展：字符串hash</h4><p>abcde<br>转为为多项式<br>f(5)= a* p^5 + b*p^4 +c *p^3 +d <em>p^2 +e <em>p^1<br>f(3)= a</em> p^3 + b</em>p^2 +c *p^1<br>f(4, 5)=f(5)-f(3)*p^(5-4+1)</p><p>c++用unsigned long long 自然溢出，可以不用取模，如果使用取模方式可能会导致溢出</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++">p[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>h[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;size;i++)&#123;<br>  h[i]=h[i<span class="hljs-number">-1</span>]*p+s[i<span class="hljs-number">-1</span>]; <span class="hljs-comment">//0到i-1之间的hash值</span><br>  p[i]=p[i<span class="hljs-number">-1</span>]*p;  <span class="hljs-comment">//不同长度字符串的p值</span><br>&#125;<br><br>hash_val_m_n=h[m]-h[n<span class="hljs-number">-1</span>]*p[m-n+<span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure><p>最长重复子串（hard）<br>使用字符串hash+二分，如果hash的key是字符串的话，时间复杂度为O(n*len))， 只有key为整数类型，时间复杂度才为 O(n))</p><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><ol><li><p>最大数：注意使用str.substr以及位移操作时候一定要记得赋值，否则结果是不会改变的 res=res.substr(start, len), 以及注意最后的结果包含首0的情况，一定要记得去除首零</p></li><li><p>最大单词长度乘积<br>使用掩码判断字符串是否有相似的字符，然后掩码&amp;</p></li><li><p>打开转盘锁<br>使用bfs<br>值得学习的地方：</p></li><li><p>使用unordered_set代替vector<br>主要在判断一个字符之前是否在一个集合中, 使用unordered_set比vector更快 if(!set.count())  表示集合中没有这个元素</p></li><li><p>在查找当前字符变形后的字符，一定要及得保留当前的字符再做修改！！</p></li><li><p>匹配子序列的单词数<br>查看多个字符串中，有几个是字符串s的子序列<br>使用二分查找，先通过hash，将不同字符对应的下标值进行存储，然后遍历需要查询的每个字符串，分别从hash里面多个vector进行查找，同时下次查找的下标，应该比当前下标至少+1</p></li></ol><ol start="4"><li>反转每对括号间的子串 (华为机试)</li></ol><p><strong>重要</strong><br>注意这道题我最开始还没想出来<br>解决方案：<br>  str为最后的结果<br>  遇到（ 那么将str的元素压入栈中，然后str转为“”<br>  遇到）那么将str元素翻转，==然后加在栈顶元素的后面==，同时从栈中弹出一个元素<br>  其余的直接追加在str后面<br>  最后返回str<br>也就是拼接好的字符串直接放在str中，不需要再压入栈中, 多了一个 “每次遇到]将当前字符串reverse 并加在栈顶元素的后面” 的步骤</p><p>PS：类似的一道题: 字符串解码 (2021年4399后端开发笔试原题)<br>仍然使用栈, 思路和4相似，只不过多了一个数字<br>另一种解法：数字存放在数字栈，字符串存放在字符串栈，遇到右括号时候弹出一个数字栈，字母栈弹到左括号为止。</p><ol start="5"><li>字符串分组<br>并查集对字符串进行分组和记录组数（带size的并查集，同时要考虑可能存在相同字符串的情况），状态压缩+位运算实现字符串关联判断和查找</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span> x := range fa &#123; <span class="hljs-comment">// 枚举所有字符串（二进制表示）</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++ &#123;<br><span class="hljs-built_in">merge</span>(x, x^<span class="hljs-number">1</span>&lt;&lt;i) <span class="hljs-comment">// 添加或删除字符 i</span><br><span class="hljs-keyword">if</span> x&gt;&gt;i&amp;<span class="hljs-number">1</span> == <span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">26</span>; j++ &#123;<br><span class="hljs-keyword">if</span> x&gt;&gt;j&amp;<span class="hljs-number">1</span> == <span class="hljs-number">0</span> &#123;<br><span class="hljs-built_in">merge</span>(x, x^<span class="hljs-number">1</span>&lt;&lt;i|<span class="hljs-number">1</span>&lt;&lt;j) <span class="hljs-comment">// 替换字符 i 为 j</span><br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol start="6"><li><p>最长的美好子字符串<br>也是使用二进制对字符串进行压缩<br>枚举/分治/枚举typenum(至少有K个重复字符的最长子串, 不建议用这种方法，因为比较难)</p></li><li><p>不同字符的最小子序列<br>去除重复的字符串，使得子序列包含所有的字符，同时字典序有最少<br>solution:<br>需要有一个num来记录一个字符的剩余出现次数<br>如果栈中没找到，从栈中弹出剩余出现次数大于0，而且大于当前字符的字符，然后压入当前字符<br>如果栈中没找到，直接将num[当前字符]–</p></li></ol><p>8.序列自动机<br>在进行判断一个字符串a是否是另外一个字符串b的子序列的时候，可以使用双指针，判断a的指针是否能走到末尾<br>也可以使用dp<br>dp[i][j]=i  s[i]==j （表示s从i开始第一个等于字符j的下标）<br>dp[i][j]=dp[i+1][j]  s[i]!=j<br>从后往前更新</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"> Arrays.fill(f[m], m);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = m - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">26</span>; ++j) &#123;<span class="hljs-comment">//只包含小写字符</span><br><span class="hljs-keyword">if</span> (s.charAt(i) == (<span class="hljs-keyword">char</span>) (<span class="hljs-string">&#x27;a&#x27;</span> + j)) &#123;<br>f[i][j] = i;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>f[i][j] = f[i + <span class="hljs-number">1</span>][j];<br>&#125;<br>&#125;<br>&#125;<br>String res = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">for</span> (String t : dictionary) &#123;<br><span class="hljs-keyword">boolean</span> match = <span class="hljs-keyword">true</span>;<br><span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; t.length(); ++i) &#123;<br><span class="hljs-keyword">if</span> (f[j][t.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>] == m) &#123;<br>match = <span class="hljs-keyword">false</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>j = f[j][t.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>] + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (match) &#123;<br><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>在对字符串进行操作通常可以朝栈，递归， bfs等方向思考<br>尤其是左右括号对应的这种情况-&gt; 栈和递归<br>状态压缩：如果字符串的每一个字符串都至多包含每个字母一次，并且字母的顺序无关紧要，因此我们可以使用一个 262的二进制数 mask 表示一个字符串。<br>同时如何两两判断两个字符串是否有关联的时间复杂度太高O(n^2^len(str)), 那么可以转为「枚举一个节点」+「枚举可能的相邻节点」+「使用哈希表判断相邻节点是否真正存在」的方法得到所有关联的边，（也就是猜测字符串的每个数的时间复杂度可能小于两层循环遍历+判断）</p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>暂时未看</title>
    <link href="/2021/11/13/leetcode/%E6%9A%82%E6%97%B6%E6%B2%A1%E7%9C%8B%E5%86%85%E5%AE%B9/"/>
    <url>/2021/11/13/leetcode/%E6%9A%82%E6%97%B6%E6%B2%A1%E7%9C%8B%E5%86%85%E5%AE%B9/</url>
    
    <content type="html"><![CDATA[<ol><li>堆排序和其他排序内容，面试前过一次</li></ol><p>堆排序已经看，主要思路：<br>先对每个内部节点进行heap_build,然后每次将0交换到i位置（n-1 到0），然后对0~i-1进行heap_build；<br>heap_build：先对左右排序，在对root排序，如果当前root没有交换，那么退出递归程序，否则递归root=flag, heap_build</p><ol start="2"><li>字典树<br>前缀树也不一定要有value字段，当value的数字的时候，也可以直接用下标代表value，而不用记录value这个字段</li></ol><p>   例题：子数组的最大异或和：</p><ul><li>方法一：可以求前缀异或和，然后遍历每个下标j前面的i XOR(i,j)=XOR(o,j)^XOR(0,j) 时间复杂度O(N^2)</li><li>方法二：建立XOR的前缀树，然后计算每个以j结尾的数组能够获得的最大异或值，使用，遍历当前j值的二进制位（从31-0），比如j=00111, 那么走过的路径最好为01000，也就是符号相同，其余位置相反最好，<br>如果之前值没有这个路径那么就取有的唯一那条路径（因为每个节点只有0 1两种情况</li></ul><ol start="3"><li>布隆过滤器，判断一个值是否在集合中：<br>使用多个hash函数将输入映射到布隆过滤器 bitMap的多个位置，那么在进行判断一个输入是否存在的时候，可以根据如果计算出位置有一个位置没有被标记，说明这个数一定不在集合中，如果都被标记，那么说明可能在集合中。<br>何根据失误率 p 和样本数 n 来确定布隆过滤器大小 m</li></ol><ol start="4"><li>Dijstra算法，单源和多源最短路径</li></ol><ol start="5"><li>查找无序数组的最小k个数，使用BFPRT算法，相当于快速排序，但是在寻找pivot上进行了修改，将数组按照5<br>个一组，找到每个组内的中位数，然后重复上述过程（也就是找中位数的中位数，直到最后只有一个数）</li></ol><ol start="6"><li><p>skyline问i<br>P446</p></li><li><p>位运算相关：下一个数</p></li></ol><ol start="8"><li><p>大数运算的相关题目，运用字符串进行加减乘除</p></li><li><p>面试题 16.09. 运算 只使用加法，不使用位运算实现减法，乘法，除法<br>因为不使用位运算，因此只能累加，不能使用幂积法，因此需要将count对应value值存在vector之中，然后计算的时候，倒着计算，因为无法计算当前count/2是多少，不能正着加<br>因此只能倒着减</p></li></ol><ul><li>易错点：1.注意特殊情况，可以直接返回结果；2.注意数据可能有正负，因此需要都转为正数，然后最后结果判断是否需要加上符号<br>if(neg%2!=0){<br>  return -res;<br>} 可以用计数法判断正负号</li></ul>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>位运算</title>
    <link href="/2021/11/13/leetcode/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <url>/2021/11/13/leetcode/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>注意位运算的优先级问题：使用位运算一定要多打括号</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 错误写法</span><br><span class="hljs-keyword">if</span> (a &amp; b == <span class="hljs-number">0</span>) &#123;<br>    ...;<br>&#125;<br><br><span class="hljs-comment">// 正确写法</span><br><span class="hljs-keyword">if</span> ((a &amp; b) == <span class="hljs-number">0</span>) &#123;<br>    ...;<br>&#125;<br></code></pre></td></tr></table></figure><p>a + (b&amp;c) 不管是+/-/*/ 还是==， 只要和位运算在一起，位运算都应该大括号！！！！</p><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><ol><li><p>使用位运算来判断a b的大小（注意出现溢出的情况）<br>位运算可以用来判断a b的正负，以及a-b的正负，因此分情况讨论a b的符号是否相等，如果相等，a-c大于0返回a;如果不等，a的符号大于0返回a<br>其余情况(flip(return A))返回B</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">flip</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a^<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>用位运算实现加减法：注意不用区分正负<br>左移，正负数都是右边添加0（也就是负数左移，是会移走最左边的符号位）<br>右移若干位，正数左补0，负数左补1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(a, b)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> sum=a;<br>    <span class="hljs-keyword">while</span>(b!=<span class="hljs-number">0</span>)&#123;<br>        sum=a^b;<br>        b= (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)(a&amp;b)&lt;&lt;<span class="hljs-number">1</span>; <span class="hljs-comment">//unsigned int非常重要</span><br>        a=sum;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">neg</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">add</span>(~a, <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sub</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">add</span>(a, <span class="hljs-built_in">neg</span>(b));<br>&#125;<br><br>用位运算实现乘除法：<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">multi</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(b!=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">if</span>((b&amp;<span class="hljs-number">1</span>)!=<span class="hljs-number">0</span>)&#123;<br>             res=<span class="hljs-built_in">add</span>(res, a);<br>        &#125;<br>        a=a&lt;&lt;<span class="hljs-number">1</span>;<br>        b=b&gt;&gt;<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//注意div考虑如果是负数是INT_MIN如何处理，不能直接转为整数</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sign</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a&lt;<span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">div</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> x=<span class="hljs-built_in">sign</span>(a)? <span class="hljs-built_in">neg</span>(x):x;<br>    <span class="hljs-keyword">int</span> y=<span class="hljs-built_in">sign</span>(b)? <span class="hljs-built_in">neg</span>(y):y;  <span class="hljs-comment">//转为整数进行运算</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">31</span>;i&gt;=<span class="hljs-number">0</span>;<span class="hljs-built_in">sub</span>(i, <span class="hljs-number">1</span>))&#123;<br>        <span class="hljs-keyword">if</span>((x&gt;&gt;i)&gt;=y)&#123; <span class="hljs-comment">//注意这里不是y&lt;&lt;i  因为可能出现溢出</span><br>            res|= （<span class="hljs-number">1</span>&lt;&lt;i）;<br>            x = <span class="hljs-built_in">sub</span>(x, y&lt;&lt;i);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sign</span>(a)^<span class="hljs-built_in">sign</span>(b)? <span class="hljs-built_in">neg</span>(res): res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(b==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> error;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a==INT_MIN&amp;&amp;b==INT_MIN)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(b==INT_MIN, <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> <br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a==INT_MIN)&#123;<br>        <span class="hljs-keyword">int</span> tmp=<span class="hljs-built_in">div</span>(<span class="hljs-built_in">add</span>(a, <span class="hljs-number">1</span>),b);<br>        <span class="hljs-keyword">int</span> rest=<span class="hljs-built_in">div</span>(<span class="hljs-built_in">sub</span>(a, <span class="hljs-built_in">mul</span>(tmp, b)), b);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">add</span>(tmp, rest); <span class="hljs-comment">//相当于分成两个部分计算</span><br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">div</span>(a, b);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>一些位运算技巧</p></li></ol><ul><li><p>移除最右边的1<br><code>n = n&amp;(n-1)</code></p></li><li><p>得到最右边的1<br><code>n &amp; (~n + 1)</code></p></li><li><p>用位运算计算一个二进制数的1个数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(n!=<span class="hljs-number">0</span>)&#123;<br>    n=n&amp;(n<span class="hljs-number">-1</span>);<span class="hljs-comment">//不断消掉右边的1，但是问题是当n=-INT_MIN n-1不会溢出么，那么如何计算最左边的1呢</span><br>    res+=<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><ol start="4"><li><p>使用位运算实现八皇后</p></li><li><p>绘制直线，bit计算对应的int数组的下标</p></li><li><p>两整数之和，不使用+实现两个整数之和 使用异或以及与运算，一定要注意 carry要使用unsigned int 使用int会报错<br>(unsigned int) carry=(unsigned int) (a&amp;b)&lt;&lt;1</p></li><li><p>数组中两个数的最大异或值</p></li></ol><ul><li>方法一：对异或结果的每一位(32位，从31-0)从大到小进行猜测可以取到的数1或者0 运用了a^b=x 那么x^a=b,也就是查看猜测的这个数和集合里面的进行异或是否能够在集合里面找到另外一个数</li><li>方法二：使用字典树，然后遍历每个数，得到针对这个数可以取到的异或最大值i，然后取最大</li></ul>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>贪心算法</title>
    <link href="/2021/11/13/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    <url>/2021/11/13/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h4 id="相关例题"><a href="#相关例题" class="headerlink" title="相关例题"></a>相关例题</h4><ol><li>摆动序列：使用贪心算法，或者动态规划 当前状态可以用前面的一个状态转移过来（可以证明得到，down是由up转移过来，up是由down转移过来），所以时间复杂度只有O(1)<br>或者使用diff来进行理解，当前的diff一定要和前一个diff相反<br>注意和最长上升子序列的区别，最长上升子序列，当前的状态不能从上一个状态转移过来，所以只能使用内外循环</li></ol><p>其实摆动序列也属于动态规划  down[i], up[i]: 0-i之间的最后为up的最长序列，和最后为down的最长序列;一定要注意<br>down[i]=max(down[i-1], up[i-1]+1)//一定要记得和down[i-1]进行比较</p><ol start="2"><li><p>最大子序列和</p></li><li><p>加油站</p></li><li><p>买卖股票最佳时机</p></li><li><p>跳跃游戏</p></li><li><p>区间相关的题目：主要是判断如何对区间进行排序（左区间还是右区间，遇到重叠该如何处理）</p></li><li><p>用最少数量的箭引爆气球: 先按照气球的右区间对气球的进行排序，如果遍历到的当前左区间小于end,那么continue；否则更新end, res++</p></li><li><p>划分字母区间，注意读懂题意: 是同一个字母最多出现在一个区间，而不是一个字母只出现在一个区间！！<br>用hash统计一个字母的最后位置，当当前遍历的位置==之前区间达到的最大位置，说明需要划分一个区间了</p></li><li><p>无重叠区间: 需要以右边界排序，在两个区间重叠的时候，保留右边界更小的区间</p></li><li><p>合并区间：以左边界进行排序，注意在修改vector back的右边界的时候可以不用pop_back 然后push_back可以直接使用vec.back()[1]=interval[i][1]</p></li><li><p>分割数组为连续子序列<br>关键点，每次往前往后看是否能凑齐一个最小合格序列<br>两种解法：</p></li></ol><ul><li><p>使用优先队列的方式，用一个map记录以x结尾的序列，同时这个序列需要根据长度从小到大进行排序，就是说相同的长度末尾，更倾向于将当前的x追加到长度更短的以x-1的序列上</p></li><li><p>如果使用贪心算法，那就是用两个hash表，一个表记录数据的个数，另外一个表记录以某一个数结尾的合格序列个数。每次都先凑齐一个合格序列，然后在判断后面的数， 首先看有没有x-1的合格序列，有就当前数-1， 否则从当前数开始从后面凑齐一个合格序列</p></li></ul><ol start="12"><li><p>环形子数组的最大值<br>分为两种情况，一个区间加起来最大，或者左右两端加起来最大<br>那么就是 max(res1, total-res2) res1是中间加起来最大， res2的中间加起来最小<br>但是注意！！！ 当total==res2的时候，直接返回res1, 不应该返回max(res1, total-res2) </p></li><li><p> 使数组唯一的最小增量<br>有点偏向找规律，使得数组中数据各不相同的最小操作次数（加的次数）<br>方法一：可以将多余的数，变为它==后面==相同个数个没有vis的数，返回结果其实就是没有vis数之和-多余数之和<br>方法二：先排序，再依次遍历数组元素，若当前元素小于等于它前一个元素，则将其变为前一个数 +1。</p></li><li><p>吃苹果的最大数目<br>注意这个和跳跃问题不一样<br>[2,1,10] [2,10,1] 答案是4<br>第四天可以吃第2天产的苹果，如果是跳跃的话，答案为3<br>使用贪心+优先队列<br>最先吃掉最先腐烂的水果，在前n个水果，因为每天可能会产生新的水果，最先腐烂的水果会改变，所以i一天一天相加；在n之后因为不会产生新的水果，所以i+=min(水果个数，腐烂截止-当前天数</p></li></ol><p>优先队列的一些操作：q.top(), q.push() q.pop()<br>注意不能直接修改优先队列元素的值，比如q.top().num– 的操作是错误</p><h4 id="区间相关问题"><a href="#区间相关问题" class="headerlink" title="区间相关问题"></a>区间相关问题</h4><p>区间子数组个数 一共有n个数的子区间个数是1+2+3+…+n 也就是(1+n)*n/2<br>这道题是最大值在[left, right]的区间个数，可以找到每个数都是&lt;=right的区间个数-每个数都是&lt; left的区间个数</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>贪心算法就是知道当前能够如何优先选择，使得最后的结果不会比当前的结果差<br>常见的题型：区间，优先队列，背包其实也是一种贪心</p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>其他问题</title>
    <link href="/2021/11/13/leetcode/%E5%85%B6%E4%BB%96/"/>
    <url>/2021/11/13/leetcode/%E5%85%B6%E4%BB%96/</url>
    
    <content type="html"><![CDATA[<h4 id="数组相关问题"><a href="#数组相关问题" class="headerlink" title="数组相关问题"></a>数组相关问题</h4><p>要将数字放在对应的位置上，使用原地交换的方式</p><ol><li>旋转矩阵  这个好像不行，需要记录交换过来的值的同时，记录交换过来的下标</li><li>自然数数组的排序</li><li>奇数下标是奇数，偶数下标是偶数</li></ol><ul><li>第一种方法，使用一个环来进行数据的交换</li><li>第二种方法，每个数据与当前的数据进行交换，然后判断当前交换过来的数据应该放到的位置，重复这样的过程，知道当前交换过来的数是应该放置的数</li></ul><p>举个例子：<br>//如果下标i应该放的数据是 i+1 index和value之间存在映射</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++">tmp=a[i];<br><span class="hljs-keyword">while</span>(a[i]!=i+<span class="hljs-number">1</span>)&#123;<br>    <span class="hljs-keyword">int</span> next=a[tmp<span class="hljs-number">-1</span>];<br>    a[tmp<span class="hljs-number">-1</span>]=tmp;<br>    tmp=next;<br>&#125;<br><br><span class="hljs-keyword">while</span>(a[i]!=i+<span class="hljs-number">1</span>)&#123;<br>    <span class="hljs-built_in">swap</span>(a[i], a[a[i]<span class="hljs-number">-1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li><p>最大子矩阵的和转为最大子数组的和，枚举每一行开始  i从0 ~ n-1,每次换开始的时候重新初始化数组s; j从i ~ n-1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;matrix.<span class="hljs-built_in">size</span>();i++)&#123;<br>    <span class="hljs-keyword">int</span> s[matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i;j&lt;matrix.<span class="hljs-built_in">size</span>();j++)&#123;<br>        <span class="hljs-keyword">int</span> cur=<span class="hljs-number">0</span>;<span class="hljs-comment">//从头开始</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();k++)&#123;<br>            cur+=matrix[j][k]; <span class="hljs-comment">//利用之前加的值，加上现在的值</span><br>            res=<span class="hljs-built_in">max</span>(res, cur);<br>            <span class="hljs-keyword">if</span>(cur&lt;<span class="hljs-number">0</span>)&#123;<br>                cur=<span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>边界都是1的最大正方形：<br>这种问题先想个暴力算法，然后考虑如何用空间换时间，加速判断的过程</p></li></ol><ul><li>1.先循环，找到每个点的right down数组，注意边界要单独赋值，从右往左，从下网上计算</li><li>2.遍历size（最开始初始化为m.size()和m[0].size()的最小值）, 每个size下遍历每个点，看左右边长以及右上角和左下角的right down是否都大于size,<br>如果是返回true,否则返回false</li></ul><ol start="6"><li>数组partition的调整<br>使用双指针，一个指针指向排序好的末尾，一个指针指向待排序序列的头结点<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> left=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> right=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(right&lt;length)&#123;<br>    <span class="hljs-keyword">if</span>(arr[left]!=arr[right])&#123;<br>        left++;<br>        <span class="hljs-built_in">swap</span>(arr[left], arr[right]);<br>        right++;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>此类型的拓展问题，红蓝白球的排序，以及 0 1 2的排序<br>解决方案：记录一个左节点（初始化-1）右节点（length）中间节点：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> left=<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">int</span> right=length;<span class="hljs-comment">//排好序的头</span><br><span class="hljs-keyword">int</span> index=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(index&lt;right)&#123;<br>    <span class="hljs-keyword">if</span>(arr[index]==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">swap</span>(arr[++left], arr[index]);<br>        index++;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr[index]==<span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-built_in">swap</span>(arr[--right], arr[index]);<span class="hljs-comment">//注意这种情况index还要继续判断，因此不能index++</span><br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        index++;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol start="7"><li>网格中的最短路径和最短通路问题：</li></ol><ul><li>1.一定要分清楚是用dp还是bfs</li><li>2.如果是只能从左上往右下走，那么是dp,否则应该用bfs,同时因为是路径，因此需要一个额外的二维数组判断到当前节点需要的步数，或者另外申明一个node,<br>这个node里面记录到这个节点的步数</li></ul><ol start="8"><li>缺失的第一个正数：</li></ol><ul><li>方法一：如何在原数组上进行hash,但是保留那个位置的数不变使用- 符号；<br>同时如果原来有符号，那么为了避免混淆，将原来为符号的数变为我们不关心的正数</li><li>方法二：使用置换的方式，这种方式一定要注意进入死循环的方式因此在交换的时候判断。nums[nums[i]-1]!=nums[i]</li></ul><h5 id="random类似题目总结："><a href="#random类似题目总结：" class="headerlink" title="random类似题目总结："></a>random类似题目总结：</h5><p>rand5 to rand7<br>rand01p to rand6<br>rand1toM to rand1toN</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-number">1</span>）<br>    <span class="hljs-keyword">do</span>&#123;<br>        row=<span class="hljs-built_in">rand5</span>()<span class="hljs-number">-1</span>;<br>        col=<span class="hljs-built_in">rand5</span>()<span class="hljs-number">-1</span>;<br>        num=row*<span class="hljs-number">5</span>+col <span class="hljs-comment">//0-24之间</span><br>    &#125;<span class="hljs-keyword">while</span>(num&gt;=<span class="hljs-number">21</span>)<br><br>    <span class="hljs-keyword">return</span> num%<span class="hljs-number">7</span>+<span class="hljs-number">1</span>;<br><br></code></pre></td></tr></table></figure><p>2)<br>首先等概率产生0-1  01 10是等概率残生的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rand01</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">do</span>&#123;<br>        num=<span class="hljs-built_in">rand01p</span>();<br>    &#125;<span class="hljs-keyword">while</span>(num==<span class="hljs-built_in">rand01p</span>());<br>    <span class="hljs-keyword">return</span> num;<br>&#125;<br><br>那么rand03=<span class="hljs-built_in">rand01</span>()*<span class="hljs-number">2</span>+<span class="hljs-built_in">rand01</span>();<br>rand0<span class="hljs-number">-15</span>=<span class="hljs-built_in">rand03</span>()*<span class="hljs-number">4</span>+<span class="hljs-built_in">rand03</span>(); <span class="hljs-comment">//倍数+插空  用进制的方法可以产生rand07()=rand03()+rand01()*4</span><br>那么rand6可由如下产生:<br><span class="hljs-keyword">do</span>&#123;<br>    num=rand0<span class="hljs-number">-15</span>;<br>&#125;<span class="hljs-keyword">while</span>(num&gt;=<span class="hljs-number">12</span>)<br><span class="hljs-keyword">return</span> num%<span class="hljs-number">6</span>+<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>3）其实就是用M进制的数来表示N-1，如果随机生成的数是大于N，那么从头进行生成（注意是从头，而不是从当前数重新生成），否则返回这个数<br>步骤：<br>   1、将n-1转换成m进制数，假设结果转换成数组为 k = [a,b,c,d,e]<br>　　2、使用rand1ToM(m)函数产生结果数组 res = [A,B,C,D,E]，如果res所表示的数值大于k所表示的数值，将res丢掉重新随机，直到产生的结果小于或等于k，这时产生的res的范围就在0～n-1之间，但是此时res所表示的数还是m进制的。<br>　　3、将res数组转换成10进制整数。<br>　　4、将步骤3的结果加1就是最终的结果。</p><h5 id="数学相关问题"><a href="#数学相关问题" class="headerlink" title="数学相关问题"></a>数学相关问题</h5><ol><li><p>求num阶层中最后的包含0的个数，因为包含因子2的个数一定比5多，因此可以直接求包含因子5的个数<br>每5个数有一个5，每25个数中有一个数包含两个5<br>同样下面的模板可以用于求任何因子的个数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(num)&#123;<br>        res+=num/<span class="hljs-number">5</span>;<br>        num=num/<span class="hljs-number">5</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>判断一个点是否在矩形中：对角向量叉积的点积&gt;=0,（对角向量的叉积方向相同），使用叉积的原因是：一个点在线外还是在线内，叉积的正负不同<br>使用叉积可以判断方向，A = &lt;a1, a2&gt;，B = &lt;b1, b2&gt;<br>AXB=a1<em>b2-a2</em>b1, 叉积向量的方向为法线的方向，上下为第一个向量指向第二个向量，大手指的方向<br>叉乘加内积</p></li><li><p>相同的题型：判断点是否在三角形中<br>1）先判断三个点的顺序是否是逆时针方向:逆时针方向叉积小于0；顺时针方向叉积大于等于（注意顺序可能导致结果不同！！！）；如果是顺时针正方向，那么调整点位置<br>2）然后判断这个点x是否都是在三角形每条边的左边，判断过程：三角形每个顶点和边的叉积小于0</p></li></ol><p>求三个三角形不推荐，因为double类型可能出现误差</p><ol start="4"><li>路径数组转为统计数组的题目：<br>要求额外的空间复杂度为O(1)<br>如果要实现空间复杂度为O(1),那么需要在原来的数据上进行运算，那么每个位置存储跳过来的位置（最开始节点存储为-1），直到当前的数为一个负数（表示已经求过距离），然后跳回去的时候就知道来的位置，同时更新当前的距离，<br>为了区分已经判断过的值和未判断过的值，使用负数；求到距离矩阵之后再计算每个距离出现的次数，仍然是使用跳的方式，开始节点记得赋值为0，表示已经访问计算过</li></ol><p>这种方式也出现在”第一个未出现的正数“这道题解决方案中（值与下标相互映射）</p><ol start="5"><li>正数数组的最小不可组成和：<br>dp[0][0]=1<br>使用动态规划<br>for i = sum to min: //注意反着<br> for j=0; j=arr.size(); j++:<pre><code> if(i&gt;=arr[i]):     dp[i]=dp[i-arr[j]]?True:dp[i]//注意是dp[i]而不是false,也不是dp[i]=dp[i-arr[i]]//因为可能一个数一种方式可以组成，但是另一种不行</code></pre></li></ol><p>PS:没有思路就想暴力算法，然后递归考虑是否能转为动态规划，类似背包问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++">dp[i][j]=dp[i<span class="hljs-number">-1</span>][j-arr[i]]||dp[i<span class="hljs-number">-1</span>][j];<br><br><span class="hljs-keyword">for</span> i in min to sum:<br>    <span class="hljs-keyword">if</span> dp[n][i] == <span class="hljs-literal">false</span>:<br>        <span class="hljs-keyword">return</span> i<br></code></pre></td></tr></table></figure><ol start="6"><li>累加出整个范围最少还需要的数:<br>使用当前可以累加得到的范围，如果范围超过了当前遍历到的arr的第一个数，那么下一个可以累加得到的范围是当前的范围+arr[i];否则下一个差的数应该是touch+1,可以累加得到的数是touch+1+touch</li></ol><p>可以累加得到的数是touch,下一个差的数是touch+1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++">touch=<span class="hljs-number">0</span>;<br>cnt=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;arr.<span class="hljs-built_in">size</span>();i++)&#123;<br>    <span class="hljs-keyword">if</span>(touch+<span class="hljs-number">1</span>&lt;arr[i])&#123;<br>        <span class="hljs-keyword">while</span>(touch&lt;arr[i])&#123;<br>            touch+=touch+<span class="hljs-number">1</span>;<br>            cnt++;<br>            <span class="hljs-keyword">if</span>(touch&gt;=range)&#123;<br>                <span class="hljs-keyword">return</span> cnt;<br>            &#125;<br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        touch+=arr[i];<br>        <span class="hljs-keyword">if</span>(touch&gt;=range)&#123;<br>            <span class="hljs-keyword">return</span> cnt;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">while</span>(touch&lt;range)&#123;<br>        touch+=touch+<span class="hljs-number">1</span>;<br>        cnt++;    <br>&#125;<br><br>    <span class="hljs-keyword">return</span> cnt;<br></code></pre></td></tr></table></figure><ol start="7"><li>一种字符串和数字对应的关系<br>注意是K伪进制数，也就是每一个伪至少为1不能为0，因此需要先从右往左计算位数，然后从左往右分剩下的数字<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">int2str</span><span class="hljs-params">()</span></span>&#123;<br>    cur=<span class="hljs-number">1</span>;<span class="hljs-comment">//代表进制的基数</span><br>    k=<span class="hljs-number">0</span><span class="hljs-comment">//代表位数</span><br>    base=<span class="hljs-number">3</span><span class="hljs-comment">//代表进制数，多少个字符就是多少进制</span><br>    <span class="hljs-keyword">while</span>(n&gt;=cur)&#123;<br>        k++;<br>        n-=cur;<br>        cur*=base;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> index=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(k)&#123;<br>        cur/=base;<br>        res[index++]=<span class="hljs-built_in">getchar</span>(n/cur);  <span class="hljs-comment">//当前base的数量应该为n/cur+1,对应的下标就是n/cur</span><br>        n=n%cur; <span class="hljs-comment">//剩下的数可以分多少到下一个进制位中</span><br>        k--;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>str2int类似于K进制</li></ol><p>从N个数中等概率打印M个数,空间复杂度为O(1)：将每次打印的数每次交换到整个数组的末尾，然后下次在生成随机数的时候，减少生成范围（1，n-count）</p><ol start="8"><li>数字的中文表达和英文表达：</li></ol><ul><li>1.中文表达：对于零特殊处理</li><li>2.英文表达：每三个一组进行处理；使用递归或者迭代。递归方式就是分别求出billion million和thousand三个部分的数字，然后加起来，<br>在求每个部分的时候，先判断百位，如果百位有数字的话，那么加上”hundred“,否则分为数字&lt;=10 &lt;20; &lt;=20 &lt;100 and &lt;10 三种情况进行处理</li></ul><ol start="9"><li>实现sqrt函数</li></ol><ul><li><p>方法一：使用二分算法（一个数的平方根不会大于 n/2+1），标准二分，返回right</p></li><li><p>方法二：牛顿迭代算法： y=f(x0)+k(x-x0)<br>令y=0, 得到 x_i+1=(x_i+ C/x_i)  其中C为要求的目标</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">double</span> C = x, x0 = x;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">double</span> xi = <span class="hljs-number">0.5</span> * (x0 + C / x0);<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(x0 - xi) &lt; <span class="hljs-number">1e-7</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            x0 = xi;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(x0);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><ol start="10"><li>小数的十进制转为二进制是*2 取整数部分，如果整数&gt;=1, 那么num-=1,否则当前位为0， 直到num=0; 也可以1连除2，num如果num&gt;base,那么减去base<br>十进制整数转换为二进制整数采用”除2取余，逆序排列”法<br>十进制小数转换成二进制小数采用”乘2取整，顺序排列”法</li></ol><ol start="11"><li>全排列问题，使用交换或者vis+回溯，一定要注意是否有重复的字符，如果有重复的字符，那么下一个交换或者选择的数，一定是当前没有选择的</li></ol><ol start="12"><li><p>树状数组例题：数字流的秩 线段树<br>树状数组主要是用于求前缀和，求index的前缀和其实就是不断将index的二进制数的最后一个一个1逐渐变为0 的数据对应的值相加；（x-(x&amp;-x)）<br>更新一个index需要更新的其他下标的值相当于 不断加上最后一个1所代表的数字下标对应的值 （x+(x&amp;-x)）<br>其中存储值的下标从1开始，0下标主要是判断循环的终点，不被用来存储值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++">建立树状数组：<br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">int</span> a[<span class="hljs-number">1005</span>],c[<span class="hljs-number">1005</span>]; <span class="hljs-comment">//对应原数组和树状数组</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> x&amp;(-x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">updata</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> k)</span></span>&#123;    <span class="hljs-comment">//在i位置加上k</span><br>    <span class="hljs-keyword">while</span>(i &lt;= n)&#123;<br>        c[i] += k;<br>        i += <span class="hljs-built_in">lowbit</span>(i);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getsum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;        <span class="hljs-comment">//求A[1 - i]的和</span><br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i &gt; <span class="hljs-number">0</span>)&#123;<br>        res += c[i];<br>        i -= <span class="hljs-built_in">lowbit</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>最佳直线，使用暴力枚举的方式，使用map存储斜率，同时在求斜率的时候注意：1）斜率不存在情况的处理 2）斜率有负数，以及斜率是倍数情况的处理</p></li></ol><ol start="14"><li>枚举题：模式匹配问题，暂时未做，主要是通过a和b的数量来枚举a匹配的字符的长度和b字符的长度，主要是注意边界情况应该先于长度的枚举进行判断</li></ol><ol start="15"><li>大数相乘的题目</li></ol><ul><li>使用第二个数的每一位数和第一个数相乘&lt;&lt; i 位，然后将求得的结果相加</li><li>使用第一个数的每一位和第二个数相乘，更新结果的 arr[i+k]位</li></ul><ol start="16"><li>矩形面积： 公式为area1+area2-inter_area<br>inter_area = max((最小 右上横坐标 - 最大左下横坐标), 0)* max(（最小右上纵坐标 -  最大左下纵坐标, 0)</li></ol><p>注意一定要和0进行比较</p><ol start="16"><li>找众数II:</li></ol><ul><li>使用hash算法</li><li>使用摩尔投票算法</li></ul><p>找到超过 (n/3) 向下取整的数：数学证明这样的数最多2个，选两个数，如果当前的数都不等于前两个数，那么两个投票数都–<br>这种投票算法同样适用于找到超过 n/2</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">majorityElement</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; ans;<br>        <span class="hljs-keyword">int</span> element1 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> element2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> vote1 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> vote2 = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp; num : nums) &#123;<br>            <span class="hljs-keyword">if</span> (vote1 &gt; <span class="hljs-number">0</span> &amp;&amp; num == element1) &#123; <span class="hljs-comment">//如果该元素为第一个元素，则计数加1</span><br>                vote1++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (vote2 &gt; <span class="hljs-number">0</span> &amp;&amp; num == element2) &#123; <span class="hljs-comment">//如果该元素为第二个元素，则计数加1</span><br>                vote2++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (vote1 == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 选择第一个元素</span><br>                element1 = num;<br>                vote1++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (vote2 == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 选择第二个元素</span><br>                element2 = num;<br>                vote2++;<br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//如果三个元素均不相同，则相互抵消1次</span><br>                vote1--;<br>                vote2--;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> cnt1 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> cnt2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp; num : nums) &#123;<br>            <span class="hljs-keyword">if</span> (vote1 &gt; <span class="hljs-number">0</span> &amp;&amp; num == element1) &#123;<br>                cnt1++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (vote2 &gt; <span class="hljs-number">0</span> &amp;&amp; num == element2) &#123;<br>                cnt2++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 检测元素出现的次数是否满足要求</span><br>        <span class="hljs-keyword">if</span> (vote1 &gt; <span class="hljs-number">0</span> &amp;&amp; cnt1 &gt; nums.<span class="hljs-built_in">size</span>() / <span class="hljs-number">3</span>) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(element1);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (vote2 &gt; <span class="hljs-number">0</span> &amp;&amp; cnt2 &gt; nums.<span class="hljs-built_in">size</span>() / <span class="hljs-number">3</span>) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(element2);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><ol start="17"><li>为运算表达式计算优先级<br>使用分治算法, 遍历表达式，找到运算符，将结果分成两个部分， 递归查找。类似二叉树的组成方式查找<br>如果求具体的结果，那么需要使用vector将结果进行push_back,否则可以直接使用动态规划，计算总数</li></ol><ol start="18"><li>摆动序列 如果是需要相邻两个数不能等于的话，只能两个字符串都进行翻转，如果可以相邻等于的话，可以后面的字符串进行翻转就行了 </li></ol><h5 id="19-交换数据的位置"><a href="#19-交换数据的位置" class="headerlink" title="19.交换数据的位置"></a>19.交换数据的位置</h5><p>（1）打标记方法： 这种方式理解起来更轻松, 注意这种方式，如果元数据中包含0或者小于0，但是目标数据中是大于0的([1, size])， 那可以将0，负数转为size+1; 否则如果元数据有0， 目标数据也有0的话，打标记是无法解决的</p><ol><li>缺失的第一个正数 （用负号在原地打标记代替hash方法，或者用置换方法，一定要将负数和&gt;size都转为size+1；同时对于target_index和当前index数据相同时，退出循环）</li><li>丢失的数字</li><li>数组中重复的数据</li></ol><p>将当前的数在对应的下标中打上标记，同时为了找到被覆盖数据的元数据，可以使用+n（这种可以找到重复3次， 4次都可以）,或者变为负数的这种做法<br>但是变负数的这种方式，不能适用于含有0的这种情况，因为-0和0是一样的，无法判断是否出现过这个数字</p><p>找到的条件是 nums[i]&gt;=0 退出</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">firstMissingPositive</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>     <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>&amp; num: nums) &#123;<br>         <span class="hljs-keyword">if</span> (num &lt;= <span class="hljs-number">0</span>) &#123;<br>             num = n + <span class="hljs-number">1</span>;<br>         &#125;<br>     &#125;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>         <span class="hljs-keyword">int</span> num = <span class="hljs-built_in">abs</span>(nums[i]);<br>         <span class="hljs-keyword">if</span> (num &lt;= n) &#123;<br>             nums[num - <span class="hljs-number">1</span>] = -<span class="hljs-built_in">abs</span>(nums[num - <span class="hljs-number">1</span>]);<br>         &#125;<br>     &#125;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>         <span class="hljs-keyword">if</span> (nums[i] &gt; <span class="hljs-number">0</span>) &#123;<br>             <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>         &#125;<br>     &#125;<br>     <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;<br> &#125;<br><br></code></pre></td></tr></table></figure><p>（2）置换</p><ol><li>缺失的第一个正数 把数据放在对应的位置</li></ol><p>将当前的数放在当前数据对应的下标中</p><p>找到的条件是 nums[i]！=i+1 退出</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">firstMissingPositive</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">while</span> (nums[i] &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[nums[i] - <span class="hljs-number">1</span>] != nums[i]) &#123;<br>            <span class="hljs-built_in">swap</span>(nums[nums[i] - <span class="hljs-number">1</span>], nums[i]); <span class="hljs-comment">//要和它交换的数不能等于它本身</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] != i + <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>（3）按照字典序排列数字：<br>我们输入两个值n和k，n表示我们有从1到n个整数，然后将这些整数都字符串化之后按字典排序，找出其中第K大的。例如:n=15,k=5.那么1-15字符串化之后排序如下:1,10,11,12,13,14,15,2,3,4,5,6,7,8,9。其中第5大的就为13。<br>实际上多叉树从到右进行计数</p><p>每次求解二叉树相邻两个节点之间包含的数据，如果k&gt;num那么直接更新k 然后当前数+1, 否则递归求里面的数据</p><h5 id="20-字符串相乘："><a href="#20-字符串相乘：" class="headerlink" title="20. 字符串相乘："></a>20. 字符串相乘：</h5><p>知识点：字符ASCII码和数字的相互转换<br>char a=’0’+81;<br>char b=a-81;<br>int c=a-‘0’;<br>cout&lt;&lt;a&lt;&lt; “ “&lt;&lt;b&lt;&lt;” “&lt;&lt;c&lt;&lt;endl;<br>注意c最终打印的结果为-175, 而不是81！！！！ 所以在初始化字符串相乘的数组只能用int类型不能用string类型</p><p>初始化一个m+n的数组（注意一定要为int类型，不能为string类型），然后循环计算每一位应该的值，最后从低位到高位进行进位更新<br>易错点：str1和str2需要翻转，之后的结果需要去前缀零以及翻转回来<br>如果不翻转，那么nums1[i]和nums2[j]对应nums[i+j+1]的数组</p><ol start="21"><li>分数到小数，模拟除法<br>使用hash记录遇到到下标的隐射，如果出现重复余数，说明出现了重复的小数循环体<br>注意易错点：1.可能存在负数，但是不能直接对负数取反（因为可能为INT_MIN），需要转为long型<br>判断结果为负数使用异或<br>if (numeratorLong &lt; 0 ^ denominatorLong &lt; 0) {<br>sb.append(‘-‘);<br>}</li></ol><h4 id="分而治之专题"><a href="#分而治之专题" class="headerlink" title="分而治之专题"></a>分而治之专题</h4><ol><li><p>超级次方， 也类似观察规律的题目，就是在定义一种新的运算的时候，将它化简为熟知的运算。同时运用规律“对乘法的结果求模，等价于先对每个因子都求模，然后对因子相乘的结果再求模”<br>不能直接使用系统自带的pow,只能自己实现pow因为，在求乘方过程随时会出现溢出，所以要为每一个中间结果取模</p></li><li><p>第K个语法符号<br>找第n个的数的第k个字符是什么，转为找第n-1个数的对应f(k)位上面的数据</p></li></ol><h4 id="递归相关，表达式相关专题"><a href="#递归相关，表达式相关专题" class="headerlink" title="递归相关，表达式相关专题"></a>递归相关，表达式相关专题</h4><ol><li>迷你语法分析器： 注意在进行递归的时候一定要在主函数判断时候有[,如果有[再进入递归，否则直接返回结果，不用进入递归程序，另外一个易错点是，注意负数的处理</li></ol><h4 id="蓄水池抽样算法"><a href="#蓄水池抽样算法" class="headerlink" title="蓄水池抽样算法"></a>蓄水池抽样算法</h4><p>模板</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><br>class Solution &#123;<br>public:<br>    Solution(ListNode* head) &#123;<br>        this-&gt;<span class="hljs-attribute">head</span>=head;<br>    &#125;<br>    <br>    int getRandom() &#123;<br>        ListNode<span class="hljs-number">*c</span><span class="hljs-attribute">ur</span>=this-&gt;head;<br>        int <span class="hljs-attribute">pool</span>=-1;<br>        int <span class="hljs-attribute">i</span>=1;<br>        <span class="hljs-keyword">while</span>(cur)&#123;<br>            <span class="hljs-keyword">if</span>(rand()%<span class="hljs-attribute">i</span>==0)pool=cur-&gt;val;<br>            i++;<br>            <span class="hljs-attribute">cur</span>=cur-&gt;next;<br>        &#125;<br>        return<span class="hljs-built_in"> pool;</span><br><span class="hljs-built_in"></span>    &#125;<br><br>private:<br>    ListNode*head;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>例题：</p><ol><li>链表随机节点</li><li>随机索引数 ，找到target数的随机一个index</li></ol><h4 id="并查集专题"><a href="#并查集专题" class="headerlink" title="并查集专题"></a>并查集专题</h4><p>相关例题：</p><p>除法求值：并查集的变形，除了要判断各个数字是否连通，还需添加一个数组记录节点之间的权重 weight(当前节点到其父节点的权重); 而且注意如何a/b那么应该是a的父亲节点是b, a指向b的权重为a/b, 反过来的话不对 <strong>一定要注意这个权重的更新，应该为当前的权重 * 他原来父亲的现在的权重</strong></p><p>易错点：</p><ul><li>在进行节点merge的时候一定要注意权重的更新，weight代表的是两个节点之间的权重，而不是一个节点到根节点的权重</li><li>find的时候返回的是father[a]而不是a !!!!!!</li></ul><p>并查集模板：具体可见vscode里面的代码，两个模板 带size和不带size的情况</p><h4 id="图相关"><a href="#图相关" class="headerlink" title="图相关"></a>图相关</h4><p>竞赛第四题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    map&lt;<span class="hljs-keyword">int</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; mp;<br>    map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; deg;<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; ans;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sn)</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;e = mp[sn]; <span class="hljs-comment">// 注意这个是引用</span><br>        <span class="hljs-keyword">while</span> (!e.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">int</span> fn = e.<span class="hljs-built_in">back</span>();<br>            e.<span class="hljs-built_in">pop_back</span>();<br>            <span class="hljs-built_in">dfs</span>(fn);<br>            ans.<span class="hljs-built_in">push_back</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;&#123;sn, fn&#125;);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//为什么要先dfs再push_back没看明白</span><br><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">validArrangement</span>(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; pairs) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;pair : pairs) &#123;<br>            mp[pair[<span class="hljs-number">0</span>]].<span class="hljs-built_in">push_back</span>(pair[<span class="hljs-number">1</span>]);<br>            deg[pair[<span class="hljs-number">0</span>]]--; deg[pair[<span class="hljs-number">1</span>]]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = deg.<span class="hljs-built_in">begin</span>(); it != deg.<span class="hljs-built_in">end</span>(); it++) <span class="hljs-keyword">if</span> (it-&gt;second == <span class="hljs-number">-1</span>) <span class="hljs-built_in">dfs</span>(it-&gt;first);<br>        <span class="hljs-keyword">if</span> (ans.<span class="hljs-built_in">empty</span>()) <span class="hljs-built_in">dfs</span>(deg.<span class="hljs-built_in">begin</span>()-&gt;first);<br>        <span class="hljs-built_in">reverse</span>(ans.<span class="hljs-built_in">begin</span>(), ans.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h5 id="有关于有向图和无向图的最短路径，以及有负边和无负边的最短路径"><a href="#有关于有向图和无向图的最短路径，以及有负边和无负边的最短路径" class="headerlink" title="有关于有向图和无向图的最短路径，以及有负边和无负边的最短路径"></a>有关于有向图和无向图的最短路径，以及有负边和无负边的最短路径</h5><ol><li><p>Dijstra算法，适用于单源，有向或者无向的最短路径，不能适用于有负边（注意不是负环，负环情况下，无最短路径）的情况：例子：-1， -5， 2<br>时间复杂度O(n^2))</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><br><br><span class="hljs-keyword">int</span> e[Max][Max];<span class="hljs-comment">//e[i][j]代表从i-&gt;j的距离，不通设为无穷大</span><br><span class="hljs-keyword">int</span> dis[Max];<span class="hljs-comment">//dis[i]代表从起点到i的最短距离</span><br><span class="hljs-keyword">bool</span> book[Max];<span class="hljs-comment">//book[i]代表点i是否在S中</span><br><span class="hljs-keyword">int</span> n;<span class="hljs-comment">//n个顶点</span><br><span class="hljs-keyword">int</span> s;<span class="hljs-comment">//起点</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-comment">//初始化dis数组</span><br>        dis[i]=e[s][i];<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-comment">//初始化book数组</span><br>        book[i]=<span class="hljs-number">0</span>;<br>    dis[s]=<span class="hljs-number">0</span>;<br>    book[s]=<span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n<span class="hljs-number">-1</span>;i++)<span class="hljs-comment">//Dijkstra算法核心语句  注意也是n-1次</span><br>    &#123;<br>        <span class="hljs-keyword">int</span> minDis=INF;<br>        <span class="hljs-keyword">int</span> k;<span class="hljs-comment">//找到与s最近的顶点k</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(book[j]==<span class="hljs-number">0</span> &amp;&amp; dis[j]&lt;minDis)<br>            &#123;<br>                minDis=dis[j];<br>                k=j;<br>            &#125;<br>        &#125;<br>        book[k]=<span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<span class="hljs-comment">//“松弛”过程</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(e[k][j]&lt;INF)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(dis[j]&gt;dis[k]+e[k][j])<br>                    dis[j]=dis[k]+e[k][j];<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>Bellman-ford算法：适用于单源，可有负权，有向或者无向的最短路径 记住只松弛n-1次<br>能够检测出有负环情况<br>dp[i][dst]=min(dp[i][dst], dp[i-1][src]+dist[src][dst]) i==1的时候表示经过的中转站为0</p></li></ol><p>时间复杂度O(n*m)/O(VE)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span>&#123;</span><br>    <span class="hljs-keyword">int</span> u;<span class="hljs-comment">//起</span><br>    <span class="hljs-keyword">int</span> v;<span class="hljs-comment">//终</span><br>    <span class="hljs-keyword">int</span> weight;<span class="hljs-comment">//长度</span><br>&#125;;<br><br>Edge edge[maxm];<span class="hljs-comment">//用来存储所有的边</span><br><span class="hljs-keyword">int</span> dis[maxn];<span class="hljs-comment">//dis[i]表示源点到i的最短距离</span><br><span class="hljs-keyword">int</span> n,m;<span class="hljs-comment">//n个点，m条边</span><br><span class="hljs-keyword">int</span> s;<span class="hljs-comment">//源点</span><br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Bellmen_ford</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-comment">//初始化</span><br>        dis[i]=INF;<br><br>    dis[s]=<span class="hljs-number">0</span>;<span class="hljs-comment">//源节点到自己的距离为0</span><br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)<span class="hljs-comment">//松弛过程，计算最短路径 </span><br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(dis[edge[j].v]&gt;dis[edge[j].u]+edge[j].weight)<span class="hljs-comment">//比较s-&gt;v与s-&gt;u-&gt;v大小</span><br>                dis[edge[j].v]=dis[edge[j].u]+edge[j].weight;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)<span class="hljs-comment">//判断是否有负边权的边</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(dis[edge[j].v]&gt;dis[edge[j].u]+edge[j].weight)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>SPFA算法：是Bellman-ford算法的队列优化，适用于单源，可有负权，有向或者无向的最短路径 （自身其实无法处理负权）<br>设立一个队列用来保存待优化的点，优化时每次取出队首结点u，并且用u点当前的最短路径估计值对u点所指向的结点v进行松弛操作，如果v点的最短路径估计值有所调整，且v点不在当前的队列中，就将v点放入队尾。这样不断从队列中取出结点来进行松弛操作，直至队列空为止。</li></ol><p>注意，一旦从队列中弹出来，vis就设置为false，感觉负权的情况就会一直循环下去，不会跳出；遍历点，与边无关</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><br><br><span class="hljs-keyword">int</span> dis[MAX];<span class="hljs-comment">//dis[i]表示起点到i的最短距离</span><br><span class="hljs-keyword">bool</span> vis[MAX];<span class="hljs-comment">//是否访问过点i</span><br><span class="hljs-keyword">int</span> e[MAX][MAX];<span class="hljs-comment">//矩阵</span><br><br><span class="hljs-keyword">int</span> n,m;<span class="hljs-comment">//点和边的数量</span><br><span class="hljs-keyword">int</span> s;<span class="hljs-comment">//源点</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SPFA</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-comment">//初始化</span><br>    &#123;<br>        dis[i]=INF;<br>        vis[i]=<span class="hljs-literal">false</span>;<br>    &#125;<br>    queue&lt;<span class="hljs-keyword">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(s);<br>    dis[s]=<span class="hljs-number">0</span>;<br>    vis[s]=<span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        <span class="hljs-keyword">int</span> cur=q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        vis[cur]=<span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-comment">//遍历每一个节点</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(e[cur][i]!=INF&amp;&amp;dis[i]&gt;=dis[cur]+e[cur][i])<br>            &#123;<br>                dis[i]=dis[cur]+e[cur][i];<br>                <span class="hljs-keyword">if</span>(!vis[i])<br>                &#123;<br>                    vis[i]=<span class="hljs-literal">true</span>;<br>                    q.<span class="hljs-built_in">push</span>(i);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>Floyd算法： Floyd算法是一种利用动态规划思想的计算加权图中多源点之间最短路径的算法。可以正确处理有向图或负权的最短路径问题。</li></ol><p>时间复杂度：O(N^3）</p><p>空间复杂度：O(N^2）</p><p>处理问题：多源、可有负权、有向图、无向图最短路径 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> e[Max][Max];<span class="hljs-comment">//e[i][j]代表从i-&gt;j的距离，不通设为无穷大</span><br><span class="hljs-keyword">int</span> n;<span class="hljs-comment">//n个顶点</span><br><span class="hljs-comment">//Floyd算法</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Floyd</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;k++)<span class="hljs-comment">//遍历所有的中间点</span><br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-comment">//遍历所有的起点</span><br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<span class="hljs-comment">//遍历所有的终点</span><br>            &#123;<br>                <span class="hljs-keyword">if</span> (e[i][j]&gt;e[i][k]+e[k][j])<span class="hljs-comment">//如果当前i-&gt;j的距离大于i-&gt;k-&gt;j的距离之和</span><br>                    e[i][j]=e[i][k]+e[k][j];<span class="hljs-comment">//更新从i-&gt;j的最短路径</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最短路衍生拓展的一类题目：</p><ol><li>最长路径问题：<br>图不为非负权图：当存在正环时无解。<br>如果不存在正环，边权取负后使用Bellman-Ford算法求最短路。</li><li>最长路径，但是路径的计算是权重之间的乘积，而且权重都是0-1之间的值，使用Dijstra算法 （e.g概率最大的路径）<br>Solution:<br> 单独使用Dijstra会导致超时，因此需要结合Dijstra+优先队列<br> 1.现将src点push 到堆进行<br> 2.然后遍历堆中的每个节点，如果当前节点能够松弛它的邻接节点，那么就放入堆中，否则不放入类似于SPFA,但是不同的是，<ul><li>这个使用的优先队列，而SPFA是用的是一般的堆</li><li>这个不仅仅push了节点，也push了当前节点的最大概率，因此没有vis数组来标记当前节点是否在堆中，因为即使在堆中， 概率也可能是不一样的。<br>总的来说这道题使用bellman-ford算法更简单，只要当前没有任何松弛的边，那么直接退出循环</li></ul></li></ol><p>颜色交替的最短路径：使用bellman-ford算法（本质是动态规划）， 只是在距离的转换是需要讨论两种情况<br>dstEndWithRed[end]=min(dstEndWithRed[end], dstEndWithBlue[start]+1);<br>dstEndWithBlue[end]=min(dstEndWithBlue[end], dstEndWithRed[start]+1);</p><h3 id="前缀和和差分数组相关"><a href="#前缀和和差分数组相关" class="headerlink" title="前缀和和差分数组相关"></a>前缀和和差分数组相关</h3><p>一般是有关于矩阵的一维前缀和， 二维前缀和， 一维差分数组和二维差分数组<br>如果要计算差分数组和前缀和数组最好是将坐标转为 1-n，更好计算；不然sum i j对应的grid为i-1,j-1</p><p>一维差分数组中，如果数组中一段数据加上或者减去某一个元素，在差分数组中只有两头的元素进行了修改，中间的元素都没有修改<br>二维差分数组中，如果包含左上角（x1, y1）, 右下角（x2, y2）这一部分都+C, 那么对应的差分数组d[x1][y1]+c d[x2+1][y2+1]+c d[x1][y1+1]-c d[x2]+1[y1]-c<br>(上升的对角线两端元素-c, 下降的对角线元素+c)</p><p>二维差分数组公式:<br>nums[i][j]-nums[i-1][j]-nums[i][j-1]+nums[i-1][j-1]=d[i][j]<br>从差分数组还原原来的数组<br>nums[i][j]=nums[i-1][j]+nums[i][j-1]-nums[i-1][j-1]+d[i][j]</p><p>例题：</p><ol><li><ol start="5931"><li>用邮票贴满网格图 (hard)</li></ol></li></ol><p>方法一: 使用二维前缀和，对原来矩阵中每个左上角为0，且邮票区域都为0的位置，贴上邮票，为了减少贴这个过程的时间开销，使用二元差分数组<br>贴完后，对二元差分数组进行还原，如果仍然遇到为0的位置，那么返回false<br>注意这道题没必要求差分数组，差分数组可以全部直接初始化为0， 那么还原回来的也是填充数组<br>方法二: 不使用二维差分数组，使用另外一个数组，标记贴邮票的左上角，然后针对每个grid中为0的位置，计算邮票部分区域的前缀和，如果为0，表示这个区域没有被贴上邮票，返回false</p><ol start="2"><li>航班预订统计 (middle)<br>一维差分数组的题目<br>如果原来数组的下标就是1-n的话，那么修改n-m部分的数据， 就会修改等差数列的d[n]和d[m+1]两个端点的数据</li></ol><ol start="3"><li>拼车<br>这道题类似于天际线问题，使用hash, 左断点加入m个人，右端点减去m个人<br>然后遍历hash的每个key,如果有个时刻是大于capacity, 那么返回false</li></ol><h3 id="前缀异或值"><a href="#前缀异或值" class="headerlink" title="前缀异或值"></a>前缀异或值</h3><p>在求前缀异或的时候，结果数组可以从1开始取，这样的话就不用对边缘单独进行赋值操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++j) &#123;<br>        pre[i][j] = pre[i - <span class="hljs-number">1</span>][j] ^ pre[i][j - <span class="hljs-number">1</span>] ^ pre[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] ^ matrix[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>        results.<span class="hljs-built_in">push_back</span>(pre[i][j]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="分类讨论题"><a href="#分类讨论题" class="headerlink" title="分类讨论题"></a>分类讨论题</h3><ol><li> K 次串联后最大子数组之和<br>分类分析<br>k=1;<br>k=2;<br>k&gt;2 如果array之和小于0，那么结果就是k=2情况，否则k=2+(k-2)*sum(one array)</li></ol><h4 id="摩尔投票算法"><a href="#摩尔投票算法" class="headerlink" title="摩尔投票算法"></a>摩尔投票算法</h4><p>1.求众数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> target_num=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>    <span class="hljs-keyword">if</span>(k==<span class="hljs-number">0</span>)&#123;<br>        target_num=nums[i];<br>        k=<span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">if</span>(nums[i]==target_num)&#123;<br>            k++;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            k--;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//判断target_num的数是否大于n/2;</span><br><span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>    <span class="hljs-keyword">if</span>(nums[i]==target_num)&#123;<br>        cnt++;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">if</span>(cnt&gt;n/<span class="hljs-number">2</span>)&#123;<br>    <span class="hljs-keyword">return</span> target_num;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.求大于n/3 的数<br>这样的数最多只有两个</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> k1=<span class="hljs-number">0</span>;<span class="hljs-comment">//投票的数量</span><br><span class="hljs-keyword">int</span> k2=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> target_num1;<span class="hljs-comment">//具体的数</span><br><span class="hljs-keyword">int</span> target_num2;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>    <span class="hljs-keyword">if</span>(k1&gt;<span class="hljs-number">0</span>&amp;&amp;target_num1==nums[i])&#123;<br>        k1++;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(k2&gt;<span class="hljs-number">0</span>&amp;&amp;target_num2==nums[i])&#123;<br>        k2++;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(k1==<span class="hljs-number">0</span>)&#123;<br>        target_num1=nums[i];<br>        k1=<span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(k2==<span class="hljs-number">0</span>)&#123;<br>        target_num2=nums[i];<br>        k2=<span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        k1--;<br>        k2--;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">int</span> cnt1=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> cnt2=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>    <span class="hljs-keyword">if</span>(k1&gt;<span class="hljs-number">0</span>&amp;&amp;nums[i]==target_num1)&#123;<br>        cnt1++;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(k2&gt;<span class="hljs-number">0</span>&amp;&amp;nums[i]==target_num2)&#123;<br>        cnt2++;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">if</span>(cnt1&gt;n/<span class="hljs-number">3</span>)&#123;<br>    res.<span class="hljs-built_in">push_back</span>(target_num1);<br>&#125;<br><span class="hljs-keyword">if</span>(cnt2&gt;n/<span class="hljs-number">3</span>)&#123;<br>    res.<span class="hljs-built_in">push_back</span>(target_num2);<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>二维差分数组常用在对数组中的某一个块的区域进行操作， 比如这道题的贴邮票， 对整块数组+1</p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>其他</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>双指针</title>
    <link href="/2021/11/13/leetcode/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    <url>/2021/11/13/leetcode/%E5%8F%8C%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><h5 id="双指针-字符串"><a href="#双指针-字符串" class="headerlink" title="双指针+字符串"></a>双指针+字符串</h5><p>// 反转字符串s中左闭又闭的区间[start, end]<br>void reverse(string&amp; s, int start, int end) {<br>    for (int i = start, j = end; i &lt; j; i++, j–) {<br>        swap(s[i], s[j]);<br>    }<br>}</p><ol start="2"><li>替换后的最长重复字符<br>如果k=0就是求连续的最长重复字符， 注意使用maxn保存滑动窗口内相同字母出现次数的 历史 最大值(注意不是当前最大值，而是历史最大值)， 所以窗口的长度只会增加或者保持不变不会减少；</li></ol><p>注意不是找当前窗口重复字符的最长，而是历史最长！！！</p><ol start="3"><li>字符串的排列<br>滑动窗口和双指针都可以，注意这道题只需要记录needle数组就可以了，不需要记录count<br>因为这道题不是找到包含目标子串的子串，而是一定要包含子串，而且不多出额外字符（目标子串的任意排列）<br>所以这道题也可以用固定长度的窗口</li></ol><p>所以只需要needle, needle小于0，就可以收缩窗口了。但是如果是包含关系，那么needle&lt;0还不能收缩窗口，之后count==0才能收缩（题意应该为：包含目标子串的最短字符串）</p><h5 id="双指针与数组-hash"><a href="#双指针与数组-hash" class="headerlink" title="双指针与数组/hash"></a>双指针与数组/hash</h5><p>两数之和<br>三数之和<br>四数之和</p><p>有效三角形的个数</p><ul><li>排序后使用二分查找</li><li>或者使用双指针， 类似于三数之和，只不过这道题求的是两数之和大于第三数， 而不是两数之和等于第三数，因此也不需要hash</li></ul><p>01交换<br>我的思路：所有1全部往右移动，1的顺序不变<br>答案：右边第一个0，左边第一个1，如果左边_index&lt;右边_index，那么res+=right-left+1(1的顺序是可以打乱的)</p><h5 id="其他（与栈有关）"><a href="#其他（与栈有关）" class="headerlink" title="其他（与栈有关）"></a>其他（与栈有关）</h5><ol><li><p>盛最多水的容器<br>因为水的容量=左右较小值*len;那么移动较大值是不会增加容量的大小的<br>双指针的问题，常用于排序数组中找target数，特征就是知道当前的值，能够容易的判断，下一个是移动左边还是右边指针</p></li><li><p>通过删除字母匹配到字典里最长单词<br>双指针来查找一个字符串是否为另一个字符串的子序列。<br>同时这道题可以使用序列自动机来避免重复的字符查找。dp[i][j]  就是存储 s字符串从大于等于i开始的 第一个等于j的下标，如果s[i]==j那么dp[i][j]=i, 否则，dp[i][j]=dp[i+1][j]， 应该从后向前计算dp数组</p></li></ol><h5 id="双指针与枚举子集"><a href="#双指针与枚举子集" class="headerlink" title="双指针与枚举子集"></a>双指针与枚举子集</h5><ol><li>乘机小于K的数组<br>找到符合条件的子集的个数<br>模板代码<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> left=<span class="hljs-number">0</span>, right=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> cur=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span>(k==<span class="hljs-number">0</span>||k==<span class="hljs-number">1</span>)&#123;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-keyword">while</span>(right&lt;size)&#123;<br>    cur=cur*nums[right];<br>    <span class="hljs-keyword">if</span>(cur&lt;k)&#123;<br>        res+=right-left+<span class="hljs-number">1</span>; <span class="hljs-comment">//注意需要+1</span><br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">while</span>(cur&gt;=k)&#123;<br>            cur/=nums[left];<br>            left++;<br>        &#125;<br>        res+=right-left+<span class="hljs-number">1</span>;<br>        <br>    &#125;<br>    right++;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br></code></pre></td></tr></table></figure></li></ol><p>另外一种求所有子集的方式是使用统计计算，比如有窗口有cnt个数据，那么子集个数为cnt*(cnt+1)/2</p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序算法</title>
    <link href="/2021/11/13/leetcode/%E6%8E%92%E5%BA%8F%E9%A2%98/"/>
    <url>/2021/11/13/leetcode/%E6%8E%92%E5%BA%8F%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><h5 id="堆排序的基本思路"><a href="#堆排序的基本思路" class="headerlink" title="堆排序的基本思路"></a>堆排序的基本思路</h5><p>a.先所有的内部节点的每个，从下到上进行往下沉的操作heap_build<br>b.然后根节点和最后一个节点交换，然后从根节点向下沉（0,n-1），然后根节点和倒数第二个节点交换，然后往下沉(0,n-2)然后重复上述的过程</p><p>也就是先build最大堆，然后逐渐交换，然后重复build</p><p>优先队列默认是从大到小进行排序；multiset 基于红黑树实现，默认是从小到大进行排序<br>priority&lt;int, vector<int>, greater<int> &gt; q;//最小堆<br>multiset&lt;int, greater<int> &gt; //最大堆</p><p>使用归并排序可以求逆序对的数量以及“计算数组的小和”问题:<br>特征，如果一个数组中两个元素，nums[i]&lt;nums[j]或者nums[i]&gt;nums[j]再执行某个操作，而且数组元素之间的连续性等没有其他要求，那么使用归并排序计算</p><h5 id="堆排序的相关例题："><a href="#堆排序的相关例题：" class="headerlink" title="堆排序的相关例题："></a>堆排序的相关例题：</h5><p>1.打印N个数组的最大TopK (topk类似题使用堆)</p><p>用N个最后的元素建立一个最大堆，然后移去堆顶元素，然后用移去元素的下一个元素放在堆顶调整堆，重复上面的过程；<br>如果被移去元素数组中没有下一个元素，那么用堆的最后一个元素移到堆顶，让堆的size-1</p><p>注意堆排序都是下沉的过程，但是如果向堆中一个一个插入元素，是插入到最后一个位置，heapsize++, 然后上浮过程<br>同时也可以先全部放入数组中，然后从内部节点倒叙下沉</p><p>*****在进行代码编写的时候，可以不直接实现堆，而是用STL的priority_queue（默认最大堆） ******</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">int</span> row;<br>    <span class="hljs-keyword">int</span> val; <span class="hljs-comment">//因为是pop_back所以不用记录下标</span><br>    <span class="hljs-built_in">node</span>(<span class="hljs-keyword">int</span> _r,<span class="hljs-keyword">int</span> _v)<br>    &#123;<br>        row=_r;<br>        val=_v;<br>    &#125;<br>    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-keyword">const</span> node&amp; b)<span class="hljs-keyword">const</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;val&lt;b.val;<br>    &#125;<br>   <br>&#125;;<br>priority_queue&lt;node,vector&lt;node&gt;&gt; heap；<br><br>因此这道题的解答方案<br><span class="hljs-comment">//首先初始化 n个末尾各自的最大元素入堆</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(arr[i].<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">continue</span>;<br>        heap.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">node</span>(i,arr[i][arr[i].<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>]));<br>        arr[i].<span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">//最后一个元素入堆</span><br>    &#125;<br>    <span class="hljs-comment">//开始从末尾遍历</span><br>   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)  <span class="hljs-comment">//从堆中选举k个最大的元素</span><br>   &#123;<br>       cout&lt;&lt;heap.<span class="hljs-built_in">top</span>().val&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<span class="hljs-comment">//打印出最大的那个元素</span><br>       <span class="hljs-keyword">int</span> row=heap.<span class="hljs-built_in">top</span>().row;<span class="hljs-comment">//那个元素所在行</span><br>       heap.<span class="hljs-built_in">pop</span>();<br>       <span class="hljs-keyword">if</span>(arr[row].<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">0</span>) <span class="hljs-comment">//最大的那个元素弹出后 用所在行的下一个元素顶上（因为第二大元素一定在已有的元素 + 下一个顶上的元素 中产生）</span><br>       &#123;<br>           heap.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">node</span>(row,arr[row][arr[row].<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>]));<span class="hljs-comment">//下一个接替的node</span><br>           arr[row].<span class="hljs-built_in">pop_back</span>();<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p>PS:类似的一个题：两个有序数组的整体中位数（或者第K位数）<br>1.使用归并排序，但是只需要记录一个pre cur O(n/2)<br>2.使用类似二分的删除的方法，先求出中位数的位置k<br>然后比较两个数组nums1[k/2] nums2[k/2]，较小的那个数组，直接跳过k/2个数 index_next=before_index + k/2</p><h5 id="补充知识："><a href="#补充知识：" class="headerlink" title="补充知识："></a>补充知识：</h5><p>priority_queue的自定义排序函数：<br><a href="https://www.cnblogs.com/shona/p/12163381.html">https://www.cnblogs.com/shona/p/12163381.html</a> 记住priority_queue排序大小和排序函数都是和正常反着的<br>建议使用struct cmp方式，重载operator &lt; 会报错，如果是在solution 类中重载的话</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cmp</span>&#123;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">const</span> node &amp;a, <span class="hljs-keyword">const</span> node &amp;b)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> a.val&gt;b.val; <span class="hljs-comment">//从小到大排序</span><br>    &#125;<br>&#125;;<span class="hljs-comment">//一定要注意结构体后面添加;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>查找和最小的K对数字，使用最大堆，以及每个数组最大循环k次</li></ol><h4 id="基数排序和桶排序"><a href="#基数排序和桶排序" class="headerlink" title="基数排序和桶排序"></a>基数排序和桶排序</h4><p>时间复杂度为O(n)的排序算法：基数排序和桶排序<br>例题：最大间距问题<br>桶排序：需要确定桶的数量，然后遍历每一个数，求当前数应该放的桶的位置，有点时候并不一定要明确每个桶里面有哪些数据，只需要知道桶<br>里面是否有数据（bucket[i]），以及每个桶里面的最大最小值(max_bucket[i], min_bucket[i])，那么就不需要用二维数组记录每个桶里面的具体数据（如例题），然后遍历桶里面的元素，用当前桶的最小值，减去上一个有数据的桶的最大值</p><h5 id="基数排序的主要思想："><a href="#基数排序的主要思想：" class="headerlink" title="基数排序的主要思想："></a>基数排序的主要思想：</h5><p>1.每次排序都是从最低位到最高位进行排序，因此求最大数的位数，作为基数排序循环的次数<br>2.在每次循环，求当前基数位的count<br>3.将count进行累加，求在整个count数组中排列的具体位置<br>4.从大到小重复计算count数组的过程，将data数据排好后放入tmp数组 count[k]–<br>5.将tmp数组赋值为data数组 基数*10，重复上面的步骤</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxbit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data[], <span class="hljs-keyword">int</span> n)</span> <span class="hljs-comment">//辅助函数，求数据的最大位数</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> maxData = data[<span class="hljs-number">0</span>];              <span class="hljs-comment">///&lt; 最大数</span><br>    <span class="hljs-comment">/// 先求出最大数，再求其位数，这样有原先依次每个数判断其位数，稍微优化点。</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (maxData &lt; data[i])<br>            maxData = data[i];<br>    &#125;<br>    <span class="hljs-keyword">int</span> d = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> p = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">while</span> (maxData &gt;= p)<br>    &#123;<br>        <span class="hljs-comment">//p *= 10; // Maybe overflow</span><br>        maxData /= <span class="hljs-number">10</span>;<br>        ++d;<br>    &#125;<br>    <span class="hljs-keyword">return</span> d;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">radixsort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data[], <span class="hljs-keyword">int</span> n)</span> <span class="hljs-comment">//基数排序</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> d = <span class="hljs-built_in">maxbit</span>(data, n);<br>    <span class="hljs-keyword">int</span> *tmp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>    <span class="hljs-keyword">int</span> *count = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>]; <span class="hljs-comment">//计数器</span><br>    <span class="hljs-keyword">int</span> i, j, k;<br>    <span class="hljs-keyword">int</span> radix = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i &lt;= d; i++) <span class="hljs-comment">//进行d次排序</span><br>    &#123;<br>        <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++)<br>            count[j] = <span class="hljs-number">0</span>; <span class="hljs-comment">//每次分配前清空计数器</span><br>        <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>        &#123;<br>            k = (data[j] / radix) % <span class="hljs-number">10</span>; <span class="hljs-comment">//统计每个桶中的记录数</span><br>            count[k]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(j = <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">10</span>; j++)<br>            count[j] = count[j - <span class="hljs-number">1</span>] + count[j]; <span class="hljs-comment">//将tmp中的位置依次分配给每个桶</span><br>        <span class="hljs-keyword">for</span>(j = n - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) <span class="hljs-comment">//将所有桶中记录依次收集到tmp中</span><br>        &#123;<br>            k = (data[j] / radix) % <span class="hljs-number">10</span>;<br>            tmp[count[k] - <span class="hljs-number">1</span>] = data[j];<br>            count[k]--;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; n; j++) <span class="hljs-comment">//将临时数组的内容复制到data中</span><br>            data[j] = tmp[j];<br>        radix = radix * <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">delete</span> []tmp;<br>    <span class="hljs-keyword">delete</span> []count;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="乱序数据使用多进程进行排序"><a href="#乱序数据使用多进程进行排序" class="headerlink" title="乱序数据使用多进程进行排序"></a>乱序数据使用多进程进行排序</h5><p>每个进程进行各种的快速排序，然后将所有进程排序好的结果进行两两归并<br>使用pthread_t 和pthread_create</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> <span class="hljs-title">s</span>[10];</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)<br>    &#123;<br>        s[i].id = i;<br>        s[i].l = i*<span class="hljs-number">10</span>;<br>        s[i].r = i*<span class="hljs-number">10</span>+<span class="hljs-number">9</span>;<br>    &#125;<br> <br>    <span class="hljs-keyword">pthread_t</span> t[<span class="hljs-number">10</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)<br>        <span class="hljs-built_in">pthread_create</span>(&amp;t[i],<span class="hljs-literal">NULL</span>,__sort,(<span class="hljs-keyword">void</span> *)&amp;s[i]);<br> <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)<br>        <span class="hljs-built_in">pthread_join</span>(t[i],<span class="hljs-literal">NULL</span>);<br><br>[完整代码参考链接](https:<span class="hljs-comment">//blog.csdn.net/Return_nellen/article/details/79937320)</span><br><br></code></pre></td></tr></table></figure><h5 id="桶排序例题"><a href="#桶排序例题" class="headerlink" title="桶排序例题"></a>桶排序例题</h5><p>存在重复元素 III: 使用二分查找（set.lower_bound）和滑动窗口，或者桶排序和滑动窗口，比较经典<br>主要思路：查找当窗口元素中是否存在大于等于nums[i]-t的元素，如果存在，判断这个元素是否是小于等于 nums[i]+t 如果存在返回true;<br>如果是桶排序解决，就设定每个桶的大小为t+1 计算每个nums[i]应该在的桶的编号，判断这个桶是否有数据，如果有数据直接返回true； 如果没有，那么判断左右两边桶的数据之间的abs差是否 &lt;=t，同时在<br>循环向前的时候记得删除范围大于k的桶里面的数据</p><p>易错点：<br>1.滑动窗口记得删除窗口之外的数据<br>2. nums[i]-t可能超出了整数的范围，一定要记得判断范围</p><h4 id="其他排序例题"><a href="#其他排序例题" class="headerlink" title="其他排序例题"></a>其他排序例题</h4><ol><li>寻找两个正序数组的中位数 (寻找两个正序数组的第k个数)</li></ol><p>注意k表示的第k个数，而不是下标为k<br>同时注意算法是一边在进行移动，而不是两边都移动</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums2)</span></span>&#123;<br>   <span class="hljs-keyword">int</span> size1 = nums1.<span class="hljs-built_in">size</span>();<br>   <span class="hljs-keyword">int</span> size2 = nums2.<span class="hljs-built_in">size</span>();<br>   <span class="hljs-keyword">int</span> total = size1+size2;<br>   <span class="hljs-keyword">if</span>(total%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)&#123;<br>       <span class="hljs-keyword">return</span> (<span class="hljs-built_in">findKthElement</span>(nums1, nums2, total/<span class="hljs-number">2</span>) + <span class="hljs-built_in">findKthElement</span>(nums1, nums2, total/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>))/<span class="hljs-number">2</span>;<br>   &#125;<span class="hljs-keyword">else</span>&#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-built_in">findKthElement</span>(nums1, nums2, total/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>);<br>   &#125;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">findKthElement</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums2, <span class="hljs-keyword">int</span> k)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> size1=nums1.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">int</span> size2=nums2.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>        <span class="hljs-keyword">if</span>(i==size1)&#123;<br>            <span class="hljs-keyword">return</span> nums2[j+k<span class="hljs-number">-1</span>];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(j==size2)&#123;<br>            <span class="hljs-keyword">return</span> nums1[i+k<span class="hljs-number">-1</span>];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(k==<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(nums1[i], nums2[j]);<br>        &#125;<br>        <span class="hljs-keyword">int</span> tmpi=<span class="hljs-built_in">min</span>(size1<span class="hljs-number">-1</span>, i+k/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">int</span> tmpj=<span class="hljs-built_in">min</span>(size2<span class="hljs-number">-1</span>, j+k/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">if</span>(nums1[tmpi]&lt;nums2[tmpj])&#123;<br>            i=tmpi+<span class="hljs-number">1</span>;<br>            k-=(tmpi-i+<span class="hljs-number">1</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            j=tmpj+<span class="hljs-number">1</span>;<br>            k-=(tmpj-j+<span class="hljs-number">1</span>);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>排序和优先队列结合！！<br>两个最好的不重叠活动<br>步骤：</li></ol><ul><li>先将活动按起始时间从小到大进行排序</li><li>维护一个最小堆，堆内元素代表活动的结束时间和对应价值</li><li>遍历所有活动，如果堆内的活动结束时间小于当前活动的起始时间，又因为活动时间是从小到大进行排序的，所以当前堆内的活动是可以与后面任意活动一起参与的，因此我们可以维护maxVal记录下当前活动开始前，我们可以选择的最大价值</li></ul><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>快速排序找出第k个数的代码模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minMoves2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> mid = nums.length / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">int</span> mid_num = <span class="hljs-built_in">quickSort</span>(nums, mid); <span class="hljs-comment">//这道题中k为mid</span><br>        <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;<br>            ret += Math.<span class="hljs-built_in">abs</span>(mid_num - num);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> h = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt; h) &#123;<br>            <span class="hljs-keyword">int</span> ret = <span class="hljs-built_in">partion</span>(nums, l, h);<br>            <span class="hljs-keyword">if</span> (ret == k) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (ret &lt; k) &#123;<br>                l = ret + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                h = ret - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[k];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partion</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> h)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Random</span>().<span class="hljs-built_in">nextInt</span>(h - l + <span class="hljs-number">1</span>) + l;<br>        <span class="hljs-keyword">int</span> temp = nums[p];<br>        nums[p] = nums[l];<br>        nums[l] = temp;<br>        <br>        <span class="hljs-keyword">while</span> (l &lt; h) &#123;<br>            <span class="hljs-keyword">while</span> (l &lt; h &amp;&amp; nums[h] &gt;= temp) &#123;<br>                h--;<br>            &#125;<br>            nums[l] = nums[h];<br>            <span class="hljs-keyword">while</span> (l &lt; h &amp;&amp; nums[l] &lt;= temp) &#123;<br>                l++;<br>            &#125;<br>            nums[h] = nums[l];<br>        &#125;<br>        nums[l] = temp;<br>        <span class="hljs-keyword">return</span> l;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="各种排序算法的总结链接："><a href="#各种排序算法的总结链接：" class="headerlink" title="各种排序算法的总结链接："></a>各种排序算法的总结链接：</h4><p><a href="https://www.runoob.com/w3cnote/ten-sorting-algorithm.html">https://www.runoob.com/w3cnote/ten-sorting-algorithm.html</a><br>快速排序的额外空间复杂度是O(logn)， 因为每次递归只使用运用了常数时间的额外空间</p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>滑动窗口</title>
    <link href="/2021/11/13/leetcode/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    <url>/2021/11/13/leetcode/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><ol><li>最小覆盖子串（两个字符串）</li><li>不同字符的最小子序列（一个字符串）</li><li>窗口内的最大值，使用的是单调栈</li><li>未排序数组中，累加和为给定值的最长子数组</li></ol><ul><li><p>方法一： 滑动窗口  </p></li><li><p>方法二： 使用hash记录一个sum出现的最早index,同时要记得压入hash[0]=-1<br>(PS: 累加和为给定值的子数组个数-&gt;hash)</p></li><li><p>补充问题1，正数和负数个数相等的最长子数组<br>  将正数转为1，负数转为0，求累加和为0最长子数组</p></li><li><p>补充问题2： 元素只有0和1的情况下，求0 和 1个数相等的最长子数组<br>  将0转为-1，1不变，求累加和为0的最长子数组</p></li></ul><ol start="5"><li><p>未排序数组中，累加和小于等于给定值的最长子数组</p></li><li><p>和小于等于K的最长子数组  以及 和不小于k的最短子数组（滑动窗口）</p></li><li><p>至少有 K 个重复字符的最长子串<br>解决方案： </p></li></ol><ul><li><p>滑动窗口，遍历包括1-26个字符26种情况下（字符总数是1-26种任意一个，每个字符至少k个）的最大长度，当当前窗口包含的字符数大于遍历的这种情况的话，收缩窗口</p></li><li><p>分治算法，先统计当前字符串，每个字符的频率，然后以小于k 的字符的任意一个作为划分点（感觉也可以放在一个集合，判断字符是否在集合内），将当前字符分为多个段，然后递归求解</p></li></ul><ol start="8"><li><p>等差数列的划分，求个数问题 每个窗口包含的等差数列的个数=左右指针差-1</p></li><li><p>找到字符串的所有异位词，注意这个是两个指针之间只能包含这个词</p></li></ol><ul><li>解法1：类似于needle数组，只有count==0判断right-left+1是否等于p.size() 然后收缩窗口，每次收缩的时候都需要重新判断 len是否相等</li><li>解法2：维护一个和p 一样长度的窗口，如果当前字符频率数组==p的字符频率数组（vec1==vecb），那么说明找到一个异位词</li></ul><p>PS:类似的题 最小覆盖子串（可以包含其他字符）， 包含k个无重复字符的最长子串</p><p>模板</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python">总结：count == <span class="hljs-number">0</span>的时候，先收缩不必要的字符再进行判断！！！！<br><span class="hljs-built_in">int</span> left=<span class="hljs-number">0</span>, right=<span class="hljs-number">0</span>;<br>        //right最好是包含这个字符<br><span class="hljs-keyword">while</span>(right&lt;len1)&#123;<br><br>    <span class="hljs-keyword">if</span>(needle[s[right]]&gt;<span class="hljs-number">0</span>)&#123;<br>        count--; <br>    &#125;<br>    needle[s[right]]--; //先减再判断<br>    <span class="hljs-keyword">if</span>(count==<span class="hljs-number">0</span>)&#123;<br>        //收缩字符<br>        <span class="hljs-keyword">while</span>(needle[s[left]]&lt;<span class="hljs-number">0</span>)&#123;<br>            needle[s[left]]++;<br>            left++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(right-left+<span class="hljs-number">1</span>&lt;min_len)&#123;<br>            min_len = right - left+<span class="hljs-number">1</span>;<br>            start = left;<br>        &#125;<br>            needle[s[left]]++;<br>            count++;<br>            left++;<br>        &#125;<br>        <br>        right++;<br>  &#125;<br></code></pre></td></tr></table></figure><ol start="10"><li><p>最少交换次数来组合所有的 1 II<br>固定滑动窗口len=数组中1的个数，然后滑动，查看窗口内能包含的最大1的个数<br>注意初始化max_len为第一个窗口的1的个数，而不是INT_MIN</p></li><li><p>水果成篮<br>题意是包含两种数据类型的最长子数组;使用typecnt， hash_cnt 和left right指针；当typecnt&lt;=2对窗口进行扩， 否则进行收缩<br>用滑动窗口<br>注意是hash[fruit[left]]++/–不是hash[left]++/–</p></li></ol><ol start="12"><li><p>最大连续1的个数III<br>滑动窗口，当当前的0的个数比k大，就收缩窗口，否则扩展窗口</p></li><li><p>爱生气的书店老板<br>先将满意时的数据加起来，然后这些位置的值置为0，剩下的就是求滑动窗口的最大值</p></li><li><p>尽可能使字符串相等<br>这道题转化的题意是，使得子数组（连续的数）的和小于maxCost的最长子数组的长度<br>使用滑动窗口</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">while</span>(right&lt;size)&#123;<br>     sum+=dist[right];<br>     <span class="hljs-keyword">while</span>(sum&gt;maxCost&amp;&amp;left&lt;=right)&#123;<br>         sum-=dist[left];<br>         left++;<br>     &#125;<br>     res=<span class="hljs-built_in">max</span>(res, right-left+<span class="hljs-number">1</span>);<br>     right++;<br> &#125;<br></code></pre></td></tr></table></figure></li></ol><p>另外一种方法是前缀和+二分，对于每个index, 二分找到前缀和大于等于presum[index]-maxCost的最小下标（lower_bound）</p><ol start="13"><li><p>可获得的最大点数<br>题意：只能从两端取数据，取得k个数据的最大值<br>solution: 滑动窗口内元素之和的最小值, 其实也可以用区间dp解决，但是因为为造成三维dp[left][right][k]，因此会超出内存</p></li><li><p>最高频元素的频数<br>将整个数组进行排序，使用滑动窗口，枚举将窗口内所有的数转为右边界这个数的最长长度， l只会递增不会减少， r就是当前遍历的下标，因为之前的元素都已经转为num[r-1]，因此还需要消耗的数据只有(nums[r]-nums[r-1])*(r-l)</p></li><li><p>查找给定哈希值的子串<br>这个就是 字符串hash的一个例子，但是和常规的字符串hash不一样的是，字符串hash计算方式为<br>hash(s, p, m) = (val(s[0]) * p0 + val(s[1]) * p1 + … + val(s[k-1]) * pk-1) mod m.</p></li></ol><p>但是因为除法不满足取余的恒等性质，如果正序的话就会导致需要减去第一个数然后/power+最后一个数的值，会发生错误<br>因此需要倒序，减去当前的值，乘以power再加上新元素的值。（乘法满足取余恒等）<br>solution: 从右到左，滑动窗口计算k字符串里面的hashvalue</p><p>另一种解法，适用于任何长度的字符串，仍然需要反向计算<br>与标准的不同之处：sum[i] 从sum[i-1]变为从sum[i+1], 计算hash由hash[right]-hash[left]变为hash[left]-hash[right]<br><a href="https://leetcode-cn.com/problems/find-substring-with-given-hash-value/solution/zi-fu-chuan-ha-xi-zi-fu-chuan-chu-li-cha-v809/">https://leetcode-cn.com/problems/find-substring-with-given-hash-value/solution/zi-fu-chuan-ha-xi-zi-fu-chuan-chu-li-cha-v809/</a></p><p>PS:取模和乘法同一优先级：乘法都要在后面加一个%运算符， 减了一个元素，需要在取模前加上这个modulo；这道题也不能直接套用以前封装的的字符串哈希类，因为POWER 与 MOD 要互质(存在逆元) 才能调RK算法</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>涉及连续子数组的两种方法：1.滑动窗口 2.前缀和+hash<br>如果是小于等于K的最长，那么使用二分查找，查找大于等于sums[i]-target的第一个下标index（向前查找）i-index+1  lower_bound 最后返回时候判断一下是否&gt;=target<br>如果是大于等于K的最短，那么使用二分查找，查找大于等于sums[i]+target的第一个下标index（向后查找）index-i+1</p><p>滑动串口count==0 先收缩再判断</p><p>求子数组的个数，以及最长子数组， 可能使用滑动窗口(右边固定，左边每个都可以，子数组的所有个数)，可能使用hash+前缀和（和为k， 右边固定，左边部分可，部分不行），也可能两种都可以，注意区别。<br>如果固定了left到right之间的间距，一般用滑动窗口<br>而且区分子序列（不连续）， 子数组（连续）</p><p>滑动窗口适合字符串/数组是连续场景，滑动窗口里面的字符是可能都需要，也能只需要子序列满足条件就可以</p><p>如果字符串连续+长度固定，使用滑动窗口</p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>二分算法</title>
    <link href="/2021/11/13/leetcode/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/"/>
    <url>/2021/11/13/leetcode/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><blockquote><p>参考链接：[二分查找专题]（<a href="https://blog.csdn.net/qq_41221520/article/details/108277801%EF%BC%89">https://blog.csdn.net/qq_41221520/article/details/108277801）</a></p></blockquote><ol><li>如果找左右边界2 4 4 4 4 5（第一个等于，最后一个等于），那么使用left&lt;right以及找左右边界，控制右边；找右边界，控制左边的口诀；</li><li>如果找第一个大于target,第一个大于等于target；小于target, 最后一个小于等于target<br>那么使用常规二分算法，left&lt;=right 以及题目中有等号，等式中无，以及大于对应left=mid+1在前，小于对应right=mid-1在前的口诀</li></ol><p>这个是否能统一为一个：<br>就是第一个大于target,第一个大于等于target，转为左边界；目前看是可以的<br>小于target, 最后一个小于等于target，转换为右边界.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++">左右边界<br><span class="hljs-comment">//左边界</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">left_bound</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> arr, <span class="hljs-keyword">int</span> target)</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>        <span class="hljs-keyword">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(arr[mid]&lt;target)&#123;<br>            left=mid+<span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            right=mid;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr[left];<br>&#125;<br><br><span class="hljs-comment">//右边界</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">right_bound</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> arr, <span class="hljs-keyword">int</span> target)</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>        <span class="hljs-keyword">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(arr[mid]&lt;=target)&#123;<br>            left=mid;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            right=mid<span class="hljs-number">-1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr[right];<br>&#125;<br><br><br>标准：<br><span class="hljs-keyword">while</span>(left&lt;=right)&#123;<br>    <span class="hljs-keyword">int</span> mid=(left+right)/<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(arr[mid]&lt;target)&#123;<br>        left=mid+<span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr[mid]&gt;target)&#123;<br>        right=mid<span class="hljs-number">-1</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> mid;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><ol><li>在数组中找到一个局部最小值（不一定要在排序数组中使用二分算法，只要能确定二分两侧的某一侧肯定存在你要找的内容，就可以使用二分查找。</li></ol><ol start="2"><li><p>寻找旋转排序数组中的最小值（一个是可能包含重复数据，一个是不包含重复数据）<br>两个都是arr可能经过一次旋转处理，可能没有<br>(1)不包含重复，那么比较中间的值和右边的值，如果小于则说明右边顺序没变，right=mid,否则，left=mid+1<br>(2)可能包含重复数据就是在不包含重复数据基础上 添加一个如果nums[r]==nums[mid]，那么r–,一直到右边不等于mid</p><p> <strong>注意</strong>: 一定是右边的数和中间的数进行比较，因为要考虑没有旋转的这种情况</p></li><li><p>有序旋转数组中找到一个数 target<br>Solution:为了方便记忆，仍然使用右边的数和中间的数进行对比</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">while</span>(left&lt;=right)&#123;<br>    <span class="hljs-keyword">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(arr[mid]==target)&#123;<br>        <span class="hljs-keyword">return</span> arr[mid];<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">if</span>(arr[mid]==arr[right])&#123;<br>            right--;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr[mid]&lt;arr[right])&#123;<br>            <span class="hljs-keyword">if</span>(target&gt;arr[mid]&amp;&amp;target&lt;=arr[right])&#123;<br>                left=mid+<span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                right=mid<span class="hljs-number">-1</span>;<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(target&gt;=arr[left]&amp;&amp;target&lt;arr[mid])&#123;<br>                right=mid<span class="hljs-number">-1</span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                left=mid+<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br></code></pre></td></tr></table></figure></li><li><p>H指数 计数排序 O(n)（计数的数组应该为size+1, 每个index的数量，如果&gt;=n全部计算为count[n]）或者二分查找(O(logn))</p></li></ol><ol start="5"><li><p>寻找排序矩阵中的第k个数<br>二分查找算法， 计算mid值，查找，大于等于这个数的数量，然后right=mid  如果数量小于这个数量， left=mid+1<br>注意抓住矩阵横向和纵向都是有序的特点<br>同时在计算小于k的数量的时候，是每列每列的计算（从左下角）,因为是mid对矩阵进行划分</p></li><li><p>蜡烛之间的盘子,可以直接使用vector自带的函数进行二分查找<br>lower_bound(vec.begin(), vec.end(), target)-vec.begin()</p></li><li><p>寻找右区间， 二分查找+hash</p></li><li><p>我的日程安排表I<br> 方法一：暴力算法<br> 方法二：使用map对key进行排序，之后使用二分查找，查找当前区间应该插入的位置<br> 两个考点：<br> 1.map的lower_bound and upper_bound</p><ol start="2"><li>插入的时候使用mp[end]=start<br>查找的时候查找start所在的位置，这样的话就不用和左右两边进行对比，只需要对比一边就好了<br>方法三：使用二叉搜索树, 每个数节点，包含left,right指针，以及start,和end两个val</li></ol></li></ol><p>PS 我的日程安排II III都是使用边界计数来实现，就是mp[start]++ mp[end]–</p><ol start="9"><li><p>在 D 天内送达包裹的能力<br>使用二分搜索，查找船最低的容量，使得能在days内完成传输<br>易错点：一定要记得left 应该为里面最大的val，而不是0</p></li><li><p>制作 m 束花所需的最少天数<br>二分查找天数的下限，使得至少能够制作要求的花束<br>PS: 一定要注意没有找到的情况下，应该返回-1</p></li></ol><ol start="11"><li><p>同时运行 N 台电脑的最长时间(hard)<br>S=min(barries[i], mid)  S/mid&gt;=n<br>left=1, right=sum(barries)/n<br>也就是如果当前假设的值大于电池容量，电池就会被榨干，否则电池会被用掉mid (因此电池不会同时被多台电脑用，因此最多用掉假设t这么多的电量)</p></li><li><p> 转变数组后最接近目标值的数组和<br>第一种思路： 这道题使用二分，但是因为是找target更近的点，因此mid的和是大于target或者小于target都有可能，虽然整体上left和right应该向target靠拢，但是最终的结果应该有另外的变量记录。==/&lt;/&gt; target的时候都不是找到了最终结果，而是候选结果。</p></li></ol><p>也就是结果和left/right的变化是两个逻辑，不在一条线上</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(sum-target)&lt;dist)&#123;<br>    res=mid;<br>    dist=<span class="hljs-built_in">abs</span>(sum-target);<br>&#125;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(sum-target)==dist)&#123;<br>    <span class="hljs-keyword">if</span>(res&gt;mid)&#123;<br>        res=mid;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第二种思路: 要想确定差的绝对值最小，可以先求出比target大的最小值，结果必出在最小值和最小值-1，二选一，比较下即可</p><h4 id="二分查找总结"><a href="#二分查找总结" class="headerlink" title="二分查找总结"></a>二分查找总结</h4><p>结果是整数<br>数组排好序<br>时间复杂度要求O(nlogn)<br>类似于一种缩小范围的随机查找</p><p>寻找类型题，可以考虑二分，如果是最大最小题，可以试试动态规划或者二分算法</p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划</title>
    <link href="/2021/11/13/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%A2%98%E5%9E%8B/"/>
    <url>/2021/11/13/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%A2%98%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h4 id="求总数问题"><a href="#求总数问题" class="headerlink" title="求总数问题"></a>求总数问题</h4><ol><li>回文字符串的个数</li><li>表达式为期望结果的总数(也是区间dp, dp[i][j][0]或者dp[i][j][1])<br>因为不是表达式的个数，而是达到期望值的个数，因此要记录一个表达式的值，用三维数组</li><li>能够组成的二叉树的个数</li><li>打气球的最大分数(区间dp)<br>虽然不是求个数，而是求最大，但是也是与当前状态的左右边界有关。因为最终结果和左右两边有关，因此都是枚举的长度+右边界，计算左边界，进行动态规划<br>转移方程：考虑这个区间上最后一个气球的打破方式，即最后一个气球的打破位置。在左边右边和中间</li><li>旋变字符串问题 (区间dp)<br>这道题不是求个数，而是求是否，但是仍然是需要枚举长度的问题，因为是两个字符串，所以应该有4个边，但是运用长度相等的信息，将思维坐标转为左边坐标+size, 成为三维问题<br>dp[start1][start2][len] 而且这道题有两个长度：一个是总字符串长度，一个是总字符串化为为两个旋变字符串的长度 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> size = <span class="hljs-number">2</span>; size &lt;= n; size++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> l1 = <span class="hljs-number">0</span>; l1 &lt;= n - size; l1++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> l2 = <span class="hljs-number">0</span>; l2 &lt;= n - size; l2++)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> leftPart = <span class="hljs-number">1</span>; leftPart &lt; size; leftPart++)&#123;<br>                    <span class="hljs-keyword">if</span>((dp[l1][l2][leftPart] &amp;&amp; dp[l1 + leftPart][l2 + leftPart][size - leftPart]) || <br>                        (dp[l1][l2 + size - leftPart][leftPart] &amp;&amp; dp[l1 + leftPart][l2][size - leftPart]))&#123;<br>                        dp[l1][l2][size] = <span class="hljs-literal">true</span>;      <span class="hljs-comment">// 只要有一个leftPart满足旋变串条件就可以break出去</span><br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></li><li>数字字符串转为字母组合的总数<br>因为只是与之前的结果或者后面的结果有关，因此只需要从左到右枚举下标就可以了<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++">递推式<br><span class="hljs-comment">// 第 i 个字符只能单独转换为一个 字母</span><br><span class="hljs-comment">// dp[i-1] ：第 i 个字符单独转换的方案数</span><br>dp[i]=dp[i<span class="hljs-number">-1</span>];<br><span class="hljs-comment">// 第 i 个字符 可以和 第 i-1 个字符 共同转换为一个 字母</span><br><span class="hljs-comment">// dp[i-1] ：第 i 个字符单独转换的方案数</span><br><span class="hljs-comment">// dp[i-2] ：第 i 个字符，结合第 i-1 个字符组合转换为一个字母的方案数</span><br>dp[i]=dp[i<span class="hljs-number">-1</span>]+dp[i<span class="hljs-number">-2</span>];<br><span class="hljs-comment">//如果第i个字符不能单独存在那么</span><br>dp[i]=<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure></li><li>组合总数IV，<br>总结：如果排序不同算不同的排列组合的话那么 target循环在外侧， nums总数循环在内侧<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=target;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;size;j++)&#123;<br>            <span class="hljs-keyword">if</span>(i&gt;=nums[j]&amp;&amp;dp[i - nums[j]] &lt; INT_MAX - dp[i])&#123;<br>                dp[i]+=dp[i-nums[j]];<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>如果排序不同算相同的排列祝贺的话那么， target循环在内侧，nums总数循环在外侧, 完全背包问题<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=size;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=target;j++)&#123;<br>        dp[i][j]+=dp[i<span class="hljs-number">-1</span>][j];<br>        <span class="hljs-keyword">if</span>(j&gt;=nums[i<span class="hljs-number">-1</span>])&#123;<br>            dp[i][j]+=dp[i][j-nums[i<span class="hljs-number">-1</span>]];<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li>删除回文子数组（区间dp/枚举长度的dp）<br>数组，每次可以删除一个数字，或者删除掉一个回文串，求删除需要的最少次数<br>dp[i][j]=min(dp[i+1][j-1], dp[i][j]) if a[i]==a[j]<br>dp[i][j]=min(dp[i][k]+dp[k+1][j], dp[i][j])<br>dp长度从3开始，dp长度为1， 2的时候使用初始化</li></ol><p>答案见：<a href="https://cloud.tencent.com/developer/article/1659691">https://cloud.tencent.com/developer/article/1659691</a> 可以作为区间dp模板，但是枚举长度和转移方程那里可以修改一下</p><h4 id="求最大最小问题"><a href="#求最大最小问题" class="headerlink" title="求最大最小问题"></a>求最大最小问题</h4><p>PS: 子串都是要求连续的，而子序列是不要求连续的</p><ol><li><p>扔鸡蛋</p></li><li><p>最长递增子串</p></li><li><p>最长递增子序列<br> 两种方法：</p><ul><li>两重循环</li><li>单调栈+二分查找<br>扩展 最长递增子序列的个数，时间复杂度仍然是O(n^2)，只是多了一个cnt, 每次出现最大就更新，否则进行cnt的累加</li></ul><p> 另外类似的题目: 1027. 最长等差数列<br> dp[i][j]表示以i结尾而且差为j的最长数列</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;i;j++)&#123;<br>        <span class="hljs-keyword">int</span> tmp=nums[i]-nums[j];<span class="hljs-comment">//因为差可能是负数</span><br>        dp[i][tmp+<span class="hljs-number">1000</span>]=dp[j][tmp+<span class="hljs-number">1000</span>]+<span class="hljs-number">1</span>;<br>        res=<span class="hljs-built_in">max</span>(res, dp[i][tmp+<span class="hljs-number">1000</span>]);   <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>最长公共子串（要求连续）<br> 注意和子序列的区别：动态规划转移方程是 dp[i][j]=dp[i][j]+1 or dp[i][j]=0表示以i或者j结尾的子串， 最后遍历二维数组求最大值<br> 求具体的最长公共子串，只需要动态规划的时候，记录最长的公共子串的下标，然后s.substr(start_pos = index-maxlen+1, len = maxlen)就可以了</p></li><li><p>最长公共子序列<br> 题意改变，但是代码不变的题目–不相交的线<br> 相似的题目：<br> 1）编辑距离<br> 2）两个字符串的删除操作， 可以直接动态规划求最少的删除字符数量，也可以用最长公共子序列，然后用m+n-2*lcs<br> 如果要求具体删除的是哪些字符串，两种方法应该都是可以的<br> 动态规划转移方程是 dp[i][j]=dp[i][j]+1 or dp[i][j]=max(dp[i][j-1], dp[i-1][j])  示以i或者j结尾的子串中包括的最长公共子序列（不一定是以i j结尾）， 所以最后只用直接返回dp[m][n]<br> 在求最长的公共子序列的时候，需要使用dp转换等式 i–,j– 或者j–, 或者i–来进行查找最长的公共子序列， 同时也可以求最短的删除的字符具体是哪些</p></li><li><p>最长回文子序列（不要求连续，枚举长度）<br> 初始化长度为1和2的情况，然后</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> len=<span class="hljs-number">3</span>;len&lt;=s_len;len++)&#123;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> left=<span class="hljs-number">0</span>;left&lt;s_len;left++)&#123;<br>           <span class="hljs-keyword">int</span> right=left+len<span class="hljs-number">-1</span>;<br>           <span class="hljs-keyword">if</span>(right&lt;s_len)&#123;<br>               dp[left][right]=<span class="hljs-built_in">max</span>(dp[left+<span class="hljs-number">1</span>][right], dp[left][right<span class="hljs-number">-1</span>]);<br>               <span class="hljs-keyword">if</span>(s[left]==s[right])&#123;<br>                   dp[left][right]=<span class="hljs-built_in">max</span>(dp[left][right],dp[left+<span class="hljs-number">1</span>][right<span class="hljs-number">-1</span>]+<span class="hljs-number">2</span>);<br>               &#125; <br>           &#125;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure></li><li><p>最长回文子串的问题<br> 可以用动态规划也可以用从中间向两边扩展的方法<br> 动态规划dp[left][right]不是表示长度，而是表示是否为回文子串，在求长度使用一个公共变量max_len,每求出dp 如果dp为1那么更新max_len</p></li><li><p>最长有效括号子串</p></li></ol><ul><li>方法一：动态规划<br>  转移方程 dp[i]:以i结尾的最长有效括号子串 转移方程如下  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;s_len;i++)&#123;<br>    <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;)&#x27;</span>)&#123;<br>        <span class="hljs-keyword">int</span> j=i-dp[i<span class="hljs-number">-1</span>]<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">if</span>(j&gt;=<span class="hljs-number">0</span>&amp;&amp;s[j]==<span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>            dp[i]=dp[i<span class="hljs-number">-1</span>]+<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(j<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>)&#123;<br>                dp[i]+=dp[j<span class="hljs-number">-1</span>];<br>            &#125;<br>        &#125;<br>        result=<span class="hljs-built_in">max</span>(result, dp[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>方法二：下标栈，栈低维护的是最后一个没有被匹配的右括号下标，如果s[i]==’(‘入栈下标; 如果s[i]==’)’, 栈中弹出一个元素，如果栈为空，直接push(i) continue，否则更新ans=max(ans, i-s.peek())</li></ul><ol start="9"><li><p>分割回文串系列题目<br> a.分割回文串1<br> 动态规划+回溯dfs，求所有i， j之间的子字符串p[i][j]是否是回文 </p><p> b.分割回文串2<br> 求最少分割次数<br> 这道题不能使用枚举长度和左边界+枚举分割点的方式，时间复杂度太高（O(N^3)）<br> 正确的解决方案是，求dp[i] 从0到i需要分割的最少次数，同时事先需要使用动态规划求出任意i j之间是否是回文串；如果0-i是回文串，直接结果为0，否则依次遍历i之后的字符串，找到回文串j+1-i，同时更新dp[i]=min(dp[i], dp[j]+1)<br> 这道题可以和“子数组异或值为0的最多划分”进行类比（动态规划+map映射上一个位置）；不同之处这道题通过回文串映射到上一个位置，异或和是通过异或值为和当前值相同隐射到上一个位置</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;s_len;i++)&#123;<br>    dp[i]=INT_MAX;<br>&#125;<br>dp[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;s_len;i++)&#123;<br>    <span class="hljs-keyword">if</span>(p[<span class="hljs-number">0</span>][i])&#123;<br>        dp[i]=<span class="hljs-number">0</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;i;j++)&#123;<br>            <span class="hljs-keyword">if</span>(p[j+<span class="hljs-number">1</span>][i])&#123;<br>                dp[i]=<span class="hljs-built_in">min</span>(dp[i], dp[j]+<span class="hljs-number">1</span>);<span class="hljs-comment">//每一个被分割的子字符串都必须要为回文</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>&#125;<br><span class="hljs-keyword">return</span> dp[s_len<span class="hljs-number">-1</span>];<br></code></pre></td></tr></table></figure></li></ol><ol start="10"><li><p>背包问题<br>比较难的例题：货物转移（lintcode-困难） 反向dp（求背包数最少）+滚动数组+额外条件<br>相当于转为两个题：1. 从n个背包里面选择最少的背包使得背包容量大于等于sum（与选最大价值使得，重量小于sum相反）</p><ol start="2"><li>假设1求出来的结果为m, 从n个背包里面选择m个背包使得转移最少–&gt;选出的n个背包里面包含货物最多（weight最大）<br>相当于在状态转移方程再加上了一个weight数组的更新，具体代码如下：<br>dp[i]表示使得容量达到i（大于等于i），选择的最少的背包；<br>weight[i]表示使得背包容量达到i（大于等于i），在选择的背包最少的前提下，背包里原本包含的货物最多。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=sum;j&gt;=<span class="hljs-number">1</span>;j--)&#123;<br>            <span class="hljs-keyword">int</span> tmp=<span class="hljs-built_in">max</span>(j-b[i], <span class="hljs-number">0</span>);<br>            <span class="hljs-comment">// dp[j]=min(dp[tmp]+1, dp[j]); 实际上的状态转移</span><br>            <span class="hljs-keyword">if</span>(dp[j]&lt;dp[tmp]+<span class="hljs-number">1</span>)&#123;  <span class="hljs-comment">//拆分后的状态转移</span><br>                <span class="hljs-comment">// weight[j]=weight[tmp];</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dp[j]==dp[tmp]+<span class="hljs-number">1</span>)&#123;<br>                weight[j]=<span class="hljs-built_in">max</span>(weight[j], weight[tmp]+a[i]);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dp[j]&gt;dp[tmp]+<span class="hljs-number">1</span>)&#123;<br>                dp[j]=dp[tmp]+<span class="hljs-number">1</span>;<br>                weight[j]=weight[tmp]+a[i];<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></li></ol></li><li><p>换钱问题</p></li><li><p>通配符匹配问题，一定要注意动态规划的状态转移方程式是i j 从 i-k j-k转移过来，不能出现i+k j+k(如果出现，一定是枚举的长度，例如回文串和打气球问题)<br>易错点：<br>字符串的匹配问题，通常会在字符前面加上” “ dp[0][0]=1<br>同时如果i j从1开始取的话，需要初始化赋值dp[0][i] 和dp[i][0]</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs prolog">for(int i=<span class="hljs-number">2</span>;i&lt;p_len;i++)&#123;<br>    if(p[i]==<span class="hljs-string">&#x27;*&#x27;</span>)&#123;<br>        dp[<span class="hljs-number">0</span>][i]=dp[<span class="hljs-number">0</span>][i<span class="hljs-number">-2</span>]; // or dp[<span class="hljs-number">0</span>][i]=dp[<span class="hljs-number">0</span>][i<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果不好赋值dp[i][0] or dp[0][i] 可以让i j 从0开始取，但是在状态转移的时候注意进行j 或者i的判断 if j&gt;=1  dp[j-1]<br>a. 问题1：<em>可以匹配任意字符<br>b. 问题2，</em>只能匹配前面字符的0个1个或多个(正则表达式匹配) 需要判断s[i] p[j-1]是否相等</p></li><li><p>打家劫舍，求能够得到金额的最大值。环形可以转为dp[0][size-2]和dp[1][size-1]两者之中求最大值</p></li><li><p>整数拆分 可以使用动态规划 二层循环 dp[i]= max(j*(i-j), j* dp[i-j])， 因为存在i-j &gt; dp[i-j]的情况<br>或者使用数据规划，将余数为2（2<em>） 1（4</em>） 0情况区别对待</p></li><li><p>最大整除子集 （和最长递增序列有相似之处）注意：在进行倒推序列的时候，需要记录当前的maxval 以及target_dpval, 这两者都需要在压入每个元素的时候更新</p></li><li><p> 摆动序列 （序列最长问题）</p></li><li><p>无重叠区间 可以使用动态规划，找到以每个区间结尾的最长子序列（O(N^2)） 或者贪心，对区间右边进行排序然后选择 O(nlogn)</p></li><li><p>最后一块石头的重量 II<br>需要理解题意之后转为背包问题，也就是最大最小问题<br>求两个子集相差的最小值 -&gt; 转为背包问题，背包容量是sum/2，求能够放入背包的最大数<br>dp[i][j]=max(dp[i-1][j], dp[i-1][j-stone[i]]+stone[i])</p></li></ol><p>0-1的最大背包问题，逆向枚举<br>多重背包问题也是，只能逆向枚举<br>完全背包（无限个）才是正向枚举！！！</p><ol start="19"><li>乘积为正数的最长子数组长度 (最长子数组系列题目)<br>注意这道题是求最长的长度，不是最大的乘积，但是这两个问题都可以使用动态规划完成<br>1）最长的长度，positive[i]表示以i结尾的为正数的子数组，negtive[i] i结尾的为负数的子数组，<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span> (nums[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">0</span>) &#123;<br>    positive[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[<span class="hljs-number">0</span>] &lt; <span class="hljs-number">0</span>) &#123;<br>    negative[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">int</span> maxLength = positive[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; length; i++) &#123;<br>    <span class="hljs-keyword">if</span> (nums[i] &gt; <span class="hljs-number">0</span>) &#123;<br>        positive[i] = positive[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>        negative[i] = negative[i - <span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span> ? negative[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span> : <span class="hljs-number">0</span>; <span class="hljs-comment">//注意一定要和0判断</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] &lt; <span class="hljs-number">0</span>) &#123;<br>        positive[i] = negative[i - <span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span> ? negative[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        negative[i] = positive[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        positive[i] = <span class="hljs-number">0</span>;<br>        negative[i] = <span class="hljs-number">0</span>;<br>    &#125;<br>    maxLength = Math.<span class="hljs-built_in">max</span>(maxLength, positive[i]);<br>&#125;<br></code></pre></td></tr></table></figure>我的思路：转为前缀和+hash<pre><code>题意转为：负数为1，正数为0， 0单独处理，相加和为偶数的最长子数组如果&lt;0, 那么sum+=1；如果&gt;0, 那么sum不变；如果=0, 那么sum=0，  hash.clear(), hash[0]=i；如果sum为偶数：res=max(res, i-hash[0])如果sum为奇数：如果hash[1]存在res=max(res, i-hash[1]) 否则hash[1]=i;</code></pre></li></ol><p>2）最大乘积，dp1[i]表示以i结尾乘积最大子数组，dp2[i]的乘积最小(注意不一定为负数)的子数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=size;i++)&#123;<br>    <span class="hljs-keyword">if</span>(nums[i<span class="hljs-number">-1</span>]&gt;<span class="hljs-number">0</span>)&#123;<br>        dp1[i]=<span class="hljs-built_in">max</span>(dp1[i<span class="hljs-number">-1</span>]*nums[i<span class="hljs-number">-1</span>], nums[i<span class="hljs-number">-1</span>]);<br>        dp2[i]=<span class="hljs-built_in">min</span>(dp2[i<span class="hljs-number">-1</span>]*nums[i<span class="hljs-number">-1</span>], nums[i<span class="hljs-number">-1</span>]);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[i<span class="hljs-number">-1</span>]&lt;<span class="hljs-number">0</span>)&#123;<br>        dp1[i]=<span class="hljs-built_in">max</span>(dp2[i<span class="hljs-number">-1</span>]*nums[i<span class="hljs-number">-1</span>], nums[i<span class="hljs-number">-1</span>]);<br>        dp2[i]=<span class="hljs-built_in">min</span>(dp1[i<span class="hljs-number">-1</span>]*nums[i<span class="hljs-number">-1</span>], nums[i<span class="hljs-number">-1</span>]);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        dp1[i]=<span class="hljs-number">0</span>;<br>        dp2[i]=<span class="hljs-number">0</span>;<br>    &#125;<br>    res=<span class="hljs-built_in">max</span>(res, dp1[i]);<br></code></pre></td></tr></table></figure><ol start="20"><li>最低票价<br>找到能够让days天都观光的最低票价，类似完全背包问题， 最少兑换钞票<br>dp[i]定义为至少让index==i天观光所需要的最低票价， 分别遍历决策1，决策2， 决策3需要的最低票价</li></ol><p>solution 1：每天进行dp + 从后往前</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> len = days.length, maxDay = days[len - <span class="hljs-number">1</span>], minDay = days[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[maxDay + <span class="hljs-number">31</span>]; <span class="hljs-comment">// 多扩几天，省得判断 365 的限制</span><br><span class="hljs-comment">// 只需看 maxDay -&gt; minDay，此区间外都不需要出门，不会增加费用</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> d = maxDay, i = len - <span class="hljs-number">1</span>; d &gt;= minDay; d--) &#123;<br>    <span class="hljs-comment">// i 表示 days 的索引</span><br>    <span class="hljs-comment">// 也可提前将所有 days 放入 Set，再通过 set.contains() 判断</span><br>    <span class="hljs-keyword">if</span> (d == days[i]) &#123;<br>        dp[d] = Math.<span class="hljs-built_in">min</span>(dp[d + <span class="hljs-number">1</span>] + costs[<span class="hljs-number">0</span>], dp[d + <span class="hljs-number">7</span>] + costs[<span class="hljs-number">1</span>]);<br>        dp[d] = Math.<span class="hljs-built_in">min</span>(dp[d], dp[d + <span class="hljs-number">30</span>] + costs[<span class="hljs-number">2</span>]);<br>        i--; <span class="hljs-comment">// 别忘了递减一天</span><br>    &#125; <span class="hljs-keyword">else</span> dp[d] = dp[d + <span class="hljs-number">1</span>]; <span class="hljs-comment">// 不需要出门</span><br>&#125;<br><span class="hljs-keyword">return</span> dp[minDay]; <span class="hljs-comment">// 从后向前遍历，返回最前的 minDay</span><br><br></code></pre></td></tr></table></figure><p>solution 2：只从days包含的天数进行dp + 从前往后</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> valid[<span class="hljs-number">3</span>]=&#123;<span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">30</span>&#125;;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>    dp[i]=INT_MAX;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>        <span class="hljs-keyword">if</span>(days[i]-valid[j]&lt;days[<span class="hljs-number">0</span>])&#123;<br>            dp[i]=<span class="hljs-built_in">min</span>(dp[i], costs[j]); <br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">int</span> index=<span class="hljs-built_in">upper_bound</span>(days.<span class="hljs-built_in">begin</span>(), days.<span class="hljs-built_in">end</span>(), days[i]-valid[j])-days.<span class="hljs-built_in">begin</span>();<br>            <span class="hljs-comment">//找到对应的前面天数对应的下标</span><br>            <span class="hljs-comment">// cout&lt;&lt;index&lt;&lt;endl;</span><br>            dp[i]=<span class="hljs-built_in">min</span>(dp[index<span class="hljs-number">-1</span>]+costs[j], dp[i]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="数学相关问题（找规律）"><a href="#数学相关问题（找规律）" class="headerlink" title="数学相关问题（找规律）"></a>数学相关问题（找规律）</h4><ol><li><p>计算各个位数不同的数字个数 （其实就是9* 9 * 8* 7这种情况）但是要注意是n位数以内的n位数都需要计算，开始各位数有10种情况，后面在当前数插入数据的时候，最开头有9种情况，后面数据有（10-1）种情况，因为后面的数据是可以为0的（固定前面，枚举后面）</p></li><li><p>消除游戏 和约瑟夫环问题</p></li></ol><ul><li>解决方案一：使用之后的下标和之前下标的映射 来解决（删除后，末尾从1开始编号）<br>2 ~ 2k映射为k ~ 1那么还原的规律f(2k)=2*(k+1-f(k))</li><li>解决方案二：每次记录剩下链表的头结点，如果当前剩下的个数==1那么直接返回这个数</li></ul><p>约瑟夫环递推问题的公式<br>𝑓(𝑛)=(𝑓(𝑛−1)+𝑚)%𝑛</p><ol start="3"><li>第 N 位数字（一位）<br>赵到不同位数包含的数字number= base*10-base,如果n&gt;这个数那么更新n-=number * weishu,否则就在这个位数里面查找<br>如果当前的数%位数==0，那么当前的数字是cur_num=base+n/weishu-1, 否则当前的数字为cur_num=base+n/weishu，然后计算在当前数字里面对应具体哪个数字， 为(cur_num/pow(10, weishu-n%weishu))%10</li></ol><p>扩展：还有一个排序后的第n个数 （一个数）二叉树，求两个节点直接夹的数组，类似于上面这道题base*10的操作，如果小于，那么就往二叉树的下一层节点走</p><ol start="4"><li>灯泡开关<br>主要是找到规律前6个灯泡可以推导出其他灯泡的状态，更进一步是，前三个灯可以推导后面所有的状态，因此有状态16种<br>（找规律，但不是动态规划问题）</li></ol><ol start="5"><li><p>到达终点数字（左右走，步数为1， 2， 3，…） 也是属于找规律，但是不是动态规划的问题<br>找到连加中小于target的最小k,然后求delta=sum-target,如果为奇数那么k++, 直到为偶数，然后返回当前k值</p></li><li><p>子矩阵问题(lintcode)<br> 1）第一种题型，要求矩阵内部的元素全部为1，那么以i， j为右下角的最长矩阵边长为<br> if(matrix[i][j]==1){</p><pre><code> dp[i][j]=min(dp[i][j-1], dp[i-1][j], dp[i-1][j-1])+1</code></pre><p> }<br> 那么以 i， j为右下角的子矩阵的个数为dp[i][j]个<br> 2)要求矩形框最长, 那么每个点需要为何它上面最长 up，和左边最长 left， 两个数组<br> int tmp = min(left[i][j-1], up[i-1][j])+1;<br> for(int len=tmp-1;len&gt;=1;len–){ //枚举长度，使得4个边长都是在len之内，说明能围成一个框</p><pre><code> if(min(up[i][j-len], left[i-len][j])&gt;=len)&#123;     return len+1;//返回枚举得到的最长边框 &#125;</code></pre><p> }</p></li><li><p>捡苹果(lintcode) 前后缀问题(找两个区间，一个区间连续k个数，一个区间连续l个数，两个区间不相交且和最大)<br>solution: 枚举中间的划分点i,使得<br>res=max(res, presumK[i]+postsumL[i+1])<br>res=max(res, presumL[i]+postsumK[i+1])<br>思路没问题：主要是没有找打0<del>i之前连续窗口最大值与i</del>len-1 连续窗口的最大值怎么求<br>计算前缀和后缀数组，注意如果index转为1~size，那么后缀数组需要开size+2 !!!!</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=K;i&lt;=size;i++)&#123;<br>    presumK[i]=<span class="hljs-built_in">max</span>(presum[i]-presum[i-K], presumK[i<span class="hljs-number">-1</span>]);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=L;i&lt;=size;i++)&#123;<br>    presumL[i]=<span class="hljs-built_in">max</span>(presum[i]-presum[i-L], presumL[i<span class="hljs-number">-1</span>]);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=size-K+<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">1</span>;i--)&#123;<br>    postsumK[i]=<span class="hljs-built_in">max</span>(presum[i+K<span class="hljs-number">-1</span>]-presum[i<span class="hljs-number">-1</span>], postsumK[i+<span class="hljs-number">1</span>]);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=size-L+<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">1</span>;i--)&#123;<br>    postsumL[i]=<span class="hljs-built_in">max</span>(presum[i+L<span class="hljs-number">-1</span>]-presum[i<span class="hljs-number">-1</span>], postsumL[i+<span class="hljs-number">1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>钢笔和<br>题意：找到两个不相交的区间，每个区间和都为target, 使得这两个区间len之和最小，其实也可以向上一题一样，分为pre post,然后枚举划分点，使用分治算法进行计算</p></li><li><p>可被三整除的最大和<br>不要求是连续<br>使用余数的递归公式 dp[i][j]表示以i结尾的余数为j的最大和<br>那么就要根据nums[i]%3的余数分类别更新dp[i][0], dp[i][1], dp[i][2]<br>一个更简单的方法是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++">a=remainder[<span class="hljs-number">0</span>]+nums[i]; <br>b=remainder[<span class="hljs-number">1</span>]+nums[i];<br>c=remainder[<span class="hljs-number">2</span>]+nums[i];<span class="hljs-comment">//因为可以不连续</span><br>remainder[a%<span class="hljs-number">3</span>]=<span class="hljs-built_in">max</span>(remainder[a%<span class="hljs-number">3</span>], a);<span class="hljs-comment">//a对余数就是a%3,所以分在一组</span><br>remainder[b%<span class="hljs-number">3</span>]=<span class="hljs-built_in">max</span>(remainder[b%<span class="hljs-number">3</span>], b);<br>remainder[c%<span class="hljs-number">3</span>]=<span class="hljs-built_in">max</span>(remainder[c%<span class="hljs-number">3</span>], c);<br></code></pre></td></tr></table></figure></li></ol><p>类似的一个题：将字符串翻转到单调递增<br>    dp[i][0]表示前i个数以0结尾，dp[i][0]表示前i个数以1结尾<br>    易错点dp[i][1]=min(dp[i-1][0], dp[i-1][1])</p><h4 id="博弈论相关问题"><a href="#博弈论相关问题" class="headerlink" title="博弈论相关问题"></a>博弈论相关问题</h4><ol><li>石子问题</li><li>预测赢家，当前只能从石子序列的头或者尾部进行取，那么使用枚举长度的动态规划+前缀和 （区dp）</li><li>能赢吗， 因为是从1-n中随机取，而且取了之后就不能取了，所以使用带记忆的dfs, 使用位图来记录当前状态是否遍历过 dp[state]</li></ol><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ol><li><p>斐波拉切数列问题</p></li><li><p>成熟的牛不断生小牛的问题</p></li><li><p>汉罗塔问题</p></li><li><p>走地图问题（最短/最长价值/龙与地下城游戏）</p></li><li><p>扔鸡蛋问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">dp[i][j]=<span class="hljs-number">1</span>+dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+dp[i<span class="hljs-number">-1</span>][j] <span class="hljs-comment">//dp[i][j]表示用i次操作j个鸡蛋能够验证的最高高度</span><br></code></pre></td></tr></table></figure></li><li><p>画匠问题<br>动态规划或者二分算法</p></li></ol><ul><li><p>动态规划：类似于鸡蛋问题，可以使用滑动数组，将二维转为一维，但是在转的时候注意i j的顺序 dp[i-1][0<del>j]可以转 dp[0</del>i][j]不太好转</p></li><li><p>二分解法如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span> limit)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> tmpsum=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;arr.<span class="hljs-built_in">size</span>();i++)&#123;<br>        tmpsum+=arr[i];<br>        <span class="hljs-keyword">if</span>(tmpsum&gt;limit)&#123;<br>            cnt++;<br>            tmpsum=arr[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt+<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">int</span> left=INT_MIN, right=<span class="hljs-number">0</span>; <span class="hljs-comment">//表示一个画家画的时长</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;arr.<span class="hljs-built_in">size</span>();i++)&#123;<br>    left=<span class="hljs-built_in">max</span>(arr[i], left);<br>    right+=arr[i];<br>&#125;<br><br><span class="hljs-keyword">if</span>(K&gt;=arr.<span class="hljs-built_in">size</span>())&#123;<span class="hljs-comment">//如果画家数量比画多</span><br>    <span class="hljs-keyword">return</span> left;<span class="hljs-comment">//返回时长最大的画</span><br>&#125;<br><br><span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>    <span class="hljs-keyword">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">int</span> tmp=<span class="hljs-built_in">getNumber</span>(mid);<br>    <span class="hljs-keyword">if</span>(tmp==K)&#123;<br>        right=mid;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tmp&lt;K)&#123;<br>        right=mid<span class="hljs-number">-1</span>;<span class="hljs-comment">//应该也可以和tmp==K合并为right=mid</span><br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        left=mid+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> right;<span class="hljs-comment">//最小的时长</span><br></code></pre></td></tr></table></figure></li></ul><ol start="7"><li><p>邮局选址的问题： 转移状态的枚举类似于画匠问题<br>因为两个邮局的情况，不清楚那个邮局负责哪些居民区，那么就枚举，然后求最小。<br>这道题前提是要知道：建立一个邮局的时候，建在中间是最优的情况！</p><ol><li>提前求i~j这段距离建立一个邮局的最小距离</li><li>dp[i][j]表示0<del>i这段居民区，有j+1个邮局的最小距离   也可以改成j对应j个邮局，这样初始化dp[i][1],循环j从 2</del>num</li><li>初始化边界dp[i][0]=w[0][i];</li><li>建立转移方程： dp[i][j]=min(dp[k][j-1]+w[k+1][i], dp[i][j]) k从0到i，（官方题解：两端值都取!!!!!），表示建邮局的位置<br>注意j&lt;=i，当j&gt;i dp=0; 每次进入k循环的时候，在初始化dp[i][j]=INT_MAX</li><li>返回结果 dp[n-1][K-1];<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> w[size+<span class="hljs-number">1</span>][size+<span class="hljs-number">1</span>];<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i+<span class="hljs-number">1</span>;j&lt;size;j++)&#123;<br>        w[i][j]=w[i][j<span class="hljs-number">-1</span>]+a[j]-a[(i+j)/<span class="hljs-number">2</span>];<br>    &#125;<br>&#125;<br><br>dp[i][<span class="hljs-number">0</span>]=w[<span class="hljs-number">0</span>][i];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=size<span class="hljs-number">-1</span>;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=num<span class="hljs-number">-1</span>;j++)&#123;  <br>        <span class="hljs-keyword">if</span>(j&gt;=i)&#123;<span class="hljs-comment">//邮局数量&gt;=居民区数量  如果不进行判断就需要 k&lt;=i，否则就会因为进不去 k 的循环，导致dp[i][j]=INT_MAX</span><br>            dp[i][j]=<span class="hljs-number">0</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            dp[i][j]=INT_MAX;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;i;k++)&#123;<br>                dp[i][j]=<span class="hljs-built_in">min</span>(dp[k][j<span class="hljs-number">-1</span>]+ w[k+<span class="hljs-number">1</span>][i], dp[i][j]); <span class="hljs-comment">//注意k+1可能==size，因此需要w需要size+1空间</span><br>            &#125;<br>        &#125;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li><li><p>数组的最大价值 (区间dp)<br>题意，就是找任意不相交区间且每个区间首位值相等，使得这些区间加起来价值最大<br>转移方程：dp[i]=max(dp[i-1], dp[j-1]+presum[i]-presum[j-1]); （a[i]==a[j]）<br>因为需要a[j]==a[i]，如果使用二中循环会超时， 解决方案<br>（1）使用hash存储不同a[i]对应的下标<br>（2）记录另外一个hash 使得hash[a[i]]=max(hash[a[i]], dp[i-1]-presum[i-1])<br>之后再进行更新就不用循环找与i相同的下标j,可以直接更新dp[i]=max(dp[i-1], presum[i]+hash[a[i]]);<br>（注意要对hash[a[i]]是否存在进行分类讨论）</p></li><li><p>盒子放置（谷歌）<br>使用动态规划的思想；<br>dp[i][j] 表示当前第i个box，第j个position能放置的最多的box数量。<br>如果 box[i - 1] &lt;= position[j - 1]，则dp[i][j] = dp[i - 1][ j - 1] + 1 贪心，放在最后一个位置最好<br>反之，dp[i][j] = max(dp[i-1][j], dp[i][j - 1]) 其中di[i-1][j]表示不放第i个box, dp[i][j - 1] 第i个box不放在j个位置</p></li></ol><p><strong><strong>重要！！！！！</strong></strong><br>注意下标i从0<del>n-1，但是这个因为有w，所以最好和w对应，不转为1</del>n。<br>从i从0开始取的话，每次k循环，划分两个部分相加， 后半部分都不会包含第一个数，因此j要从2开始取，否则就会造成dp[0][0]//第一个0代表有地址，第二个0代表无邮局，就会返回INT_MAX,造成结果错误<br>背包问题，i下标是1~n 因为i可能从i-1推导，需要i&gt;=1</p><ol start="8"><li>“马”在棋盘上的概率<br>类似的==地图问题==，虽然当前位置可以由它四面八方的位置推出来，但是因为步数，所以对应的三维数组还是由之前的状态推导出来，因此仍然可以使用动态规划</li></ol><h4 id="字符串与动态规划"><a href="#字符串与动态规划" class="headerlink" title="字符串与动态规划"></a>字符串与动态规划</h4><p>也可以划分到Trie树问题:一般是对单词建立Trie树</p><ol><li>单词拆分问题（dp代表的是True or False）：dp+第二层循环枚举字典里面的每一个单词，看是否恰好是当前遍历序列0~i的最后几个字符<br>为了进一步减少时间，内层训练从i枚举到0，同时为true的时候直接退出<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;size;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i;j&gt;=<span class="hljs-number">0</span>;j--)&#123;<br>        string tmp=s.<span class="hljs-built_in">substr</span>(j, i-j+<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span>(wordSet.<span class="hljs-built_in">find</span>(tmp)!=wordSet.<span class="hljs-built_in">end</span>())&#123;<br>            dp[i]=dp[i]|dp[j<span class="hljs-number">-1</span>];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(dp[i])&#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>恢复空格问题(代表的无效字符的个数) 都可以转为Trie树+dp类型的题目 </li></ol><ul><li>这个不能暴力erase,因为可能出现一个单词是另外一个单词的前缀，可能导致erase顺序不同，结果不同；这个只能使用字典序；</li><li>另外一个减少暴力深搜索带来的超时问题，可以使用第二层循环每次枚举dict的每个元素，看是否与当前遍历序列的最后几个字符相同，而不是每个不同长度的单词一个一个的进行比较。</li><li>多次搜索：使用暴力的string find或者使用将small单词列表建立Trie树，然后big以每个字符为开头，查找字符串是否出现在Trie树中，在查找的路径中如果遇到isend=True说明找到了一个字符<br>然后继续找下去</li></ul><ol start="3"><li>环绕字符串中唯一的子字符串<br>计算出26个英文字母中每一个英文字母的结尾的最长的连续的环绕字符串，然后求和<br>PS：注意字符串去重，如果不考虑去重的话，可以直接使用滑动窗口记录子串个数；因为这个滑动窗口是直接出现不连续，窗口长度直接退化为1，所以可以只记录窗口长度，不记录窗口左右两端<br>题意为：找到子串字符必须是连续的，这样的子串的个数，但是这样可以会出现重复比如abcbc，所以要使用dp</li></ol><h4 id="状态压缩"><a href="#状态压缩" class="headerlink" title="状态压缩"></a>状态压缩</h4><ol><li>优美的排序</li></ol><p>没看懂+ 之后看</p><ol start="2"><li><p>划分为k个相同子集，也可以看做dfs+回溯+贪心<br>状态压缩的话就是dp[i]中i的每一个数由二进制位的状态组成，然后遍历二进制的每一个状态，当前的状态可以由当前状态中任意取消一个1的状态转移过来，或者用当前的状态更新下一个状态（将状态中为0的转为1），只有只有dp[i]=true, 而且当前状态的和%target+nums[i]&lt;=target下一个状态才为true,否则为false</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">bool</span> canPartitionKSubsets(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; nums, <span class="hljs-built_in">int</span> k) &#123;<br>        <span class="hljs-built_in">int</span> size=nums.size();<br>        <span class="hljs-built_in">int</span> total_sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>            total_sum+=nums[i];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(total_sum%k!=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> false;<br>        &#125;<br>        <span class="hljs-built_in">int</span> target=total_sum/k;<br>        sort(nums.begin(), nums.end());<br>        <span class="hljs-built_in">int</span> total_state=<span class="hljs-number">1</span>&lt;&lt;size;<br>        vector&lt;<span class="hljs-built_in">bool</span>&gt; dp(total_state, false);<br>        vector&lt;<span class="hljs-built_in">int</span>&gt; <span class="hljs-built_in">sum</span>(total_state, <span class="hljs-number">0</span>);<br>        dp[<span class="hljs-number">0</span>]=true;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;total_state;i++)&#123;<br>            <span class="hljs-keyword">if</span>(!dp[i])&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            // cout&lt;&lt;i&lt;&lt;endl;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>;j&lt;size;j++)&#123;<br>                // cout&lt;&lt;j&lt;&lt;endl;<br>                <span class="hljs-keyword">if</span>((i&amp;(<span class="hljs-number">1</span>&lt;&lt;j))==<span class="hljs-number">0</span>)&#123;   //注意：位运算一定要记得打上括号之后再判断是否相等，否则会出错！！！！！<br>                    <span class="hljs-built_in">int</span> <span class="hljs-built_in">next</span>=i|(<span class="hljs-number">1</span>&lt;&lt;j);<br>                    // cout&lt;&lt;<span class="hljs-built_in">next</span>&lt;&lt;endl;<br>                    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">sum</span>[i]%target+nums[j]&lt;=target)&#123;<br>                        <span class="hljs-built_in">sum</span>[<span class="hljs-built_in">next</span>]=<span class="hljs-built_in">sum</span>[i]+nums[j];<br>                        dp[<span class="hljs-built_in">next</span>]=true;<br>                        cout&lt;&lt;<span class="hljs-built_in">next</span>&lt;&lt;endl;<br>                    &#125;<span class="hljs-keyword">else</span>&#123;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[total_state-<span class="hljs-number">1</span>];<br><br></code></pre></td></tr></table></figure></li><li><p>优美的排列<br>也是状态压缩 或者回溯，相比第2题需要枚举当前位置放的数是哪个，所以多一层循环。上面那道题因为数的位置是固定的，所以只需要判断这个数放没放。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-class"><span class="hljs-title">public</span>:</span><br>    <span class="hljs-built_in">int</span> count(<span class="hljs-built_in">int</span> number)&#123;<br>        <span class="hljs-built_in">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(number!=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>(number&amp;<span class="hljs-number">1</span>)&#123;<br>                res++;<br>            &#125;<br>            number=number&gt;&gt;<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-built_in">int</span> countArrangement(<span class="hljs-built_in">int</span> n) &#123;<br>        <span class="hljs-built_in">int</span> state=<span class="hljs-number">1</span>&lt;&lt;n;<br><br>        <br>        vector&lt;<span class="hljs-built_in">int</span>&gt; dp(state, <span class="hljs-number">0</span>);<br>        dp[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> num=<span class="hljs-number">1</span>;num&lt;=n;num++)&#123; //类似背包的，当前放第num数， 标准答案是将状态放在外层， 然后通过<span class="hljs-number">1</span>个个数判断当前的num<br>            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;state;i++)&#123;<br>                // <span class="hljs-keyword">if</span>(!dp[i])&#123;<br>                //     <span class="hljs-keyword">continue</span>;<br>                // &#125;<br>                <span class="hljs-keyword">if</span>(count(i)!=num-<span class="hljs-number">1</span>)&#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>                    <span class="hljs-keyword">if</span>((i&amp;(<span class="hljs-number">1</span>&lt;&lt;j))==<span class="hljs-number">0</span>)&#123;<br>                        <span class="hljs-keyword">if</span>(num%(j+<span class="hljs-number">1</span>)==<span class="hljs-number">0</span>||(j+<span class="hljs-number">1</span>)%num==<span class="hljs-number">0</span>)&#123;<br>                            <span class="hljs-built_in">int</span> <span class="hljs-built_in">next</span>=i^(<span class="hljs-number">1</span>&lt;&lt;j);<br>                            dp[<span class="hljs-built_in">next</span>]+=dp[i];<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[state-<span class="hljs-number">1</span>];<br>        <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>华为的一个机试题目<br>需要在规定燃油内（规定长度内）得到的资源最大化（有点像0-1背包问题）， 但是这个不同之处在于：从不同点到相同的i，消耗的燃油是不一样的， 而且这个最后还需要回到原点，所以dist需要走过的位置mask 以及最后的位置i<br>其实就是先求每个mask的最小dist, 得到d[mask][i]:也就是以i结尾的最小燃油，然后遍历这个数组，如果d[mask][i]+fuel[i][0]&lt;=maxdist 那么更新ans<br>ans=max(ans, g[mask])</p></li></ol><p>为什么不直接求d[fuel][i]的最大化，这样也会重复vis统一节点<br><a href="https://leetcode-cn.com/circle/discuss/a4pRYY/">https://leetcode-cn.com/circle/discuss/a4pRYY/</a></p><ol start="5"><li><p>访问所有节点的最短路径<br>主要思路：先求出任意两个节点间的距离，使用floyd，同时记得出事dist[i][i]=0<br>然后使用d[mask][i]:表示最后状态为mask,并且以i结尾的最短路径<br>最后遍历d[mask][i] 求最小值<br>易错点，mask的循环一定要在节点i的循环的外面， 否则就会出错</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> mask=<span class="hljs-number">1</span>;mask&lt;(<span class="hljs-number">1</span>&lt;&lt;n);mask++)&#123;<br>          <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>              <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;n;k++)&#123;<br>                  <span class="hljs-keyword">if</span>((mask&amp;(<span class="hljs-number">1</span>&lt;&lt;k))==<span class="hljs-number">0</span>)&#123;<br>                      d[mask|(<span class="hljs-number">1</span>&lt;&lt;k)][k]=<span class="hljs-built_in">min</span>(d[mask|(<span class="hljs-number">1</span>&lt;&lt;k)][k],d[mask][i]+dist[i][k]);<br>                  &#125;<br>              &#125;<br>          &#125;<br>      &#125;<br></code></pre></td></tr></table></figure></li><li><p>基于陈述统计最多好人数<br>这个是枚举状态，与dp无关，但是和状态压缩dp有点类似</p></li><li><p>两个数组最小的异或值之和  数组的最大与和<br>这两道题都是位运算相关的状态压缩<br>第一题枚举nums2每个数应该放的位置<br>第二题需要先装为状态压缩的样子，因为每个index有两个slot,所以需要先转为2*n个slot，那么slot和index对应关系为j/2+1<br>然后枚举每个数应该放在哪个slot,同时注意这道题不是每个状态都有值，对于one_num of state i&gt;=num数量, 直接continue</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-number">1</span> &lt;&lt; (numSlots * <span class="hljs-number">2</span>))</span></span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; f.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>    <span class="hljs-keyword">int</span> c = __builtin_popcount(i); <span class="hljs-comment">//当前已经放了几个数，下一个放的数就是nums[c]</span><br>    <span class="hljs-keyword">if</span> (c &gt;= nums.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">//直接跳过</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; numSlots * <span class="hljs-number">2</span>; ++j) &#123;<br>        <span class="hljs-keyword">if</span> ((i &amp; (<span class="hljs-number">1</span> &lt;&lt; j)) == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 枚举空篮子 j</span><br>            <span class="hljs-keyword">int</span> s = i | (<span class="hljs-number">1</span> &lt;&lt; j);<br>            f[s] = <span class="hljs-built_in">max</span>(f[s], f[i] + ((j / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>) &amp; nums[c]));<br>            ans = <span class="hljs-built_in">max</span>(ans, f[s]); <span class="hljs-comment">//有效的状态求结果</span><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br></code></pre></td></tr></table></figure></li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol><li><p>图与动态规划，一定要主要vis的问题，bellman-ford以及floyd算法都是图的动态规划的例子<br>但是注意因为bellman-ford是求距离最小，所以不会出现重复vis同一个节点的情况<br>但是如果求max的情况，使用动态规划+图就可能造成一个节点vis多次，因此最好考虑记忆化dfs或者状态压缩</p></li><li><p> 状态压缩问题，将状态放在外层比较保险；如果是list数组，那么可以将num放在外面，如果是图，那么只能将状态放在外面</p></li><li><p>动态规划的关键是处理 i 取值范围 j取值范围，转移方程以及边界情况求动态规划<br>也就是找到dp[i]-&gt; dp[j] (j&lt; i) 的递推公式,这个递推可能由i，j之间回文，括号，或者异或和组成；特别的，如果是回文可以提前得到任何i，j之间是否为回文字符串，模板代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=s_len<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>     <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i+<span class="hljs-number">1</span>;j&lt;s_len;j++)&#123;<br>         p[i][j]=(s[i]==s[j]&amp;&amp;p[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>]);<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure></li></ol><p>4.区间dp问题，外围长度的字符状态，可以由内围的长度的字符推导出来 dp[i][size]</p><ol start="5"><li><p>如果进行了状态压缩：<br>0-1的最大背包问题，逆向枚举<br>多重背包问题也是，只能逆向枚举<br>完全背包（无限个）才是正向枚举！！！</p></li><li><p>有的时候动态规划不好解决，考虑使用带记忆的dfs，（比如要求所有的路径，或者所有路径中花费最小等等）</p></li><li><p>最短时间类似题，除了考虑动态规划，也可以向二分算法中思考，比如画匠问题</p></li><li><p>动态规划可以解决true/false（是否能化为k个相同区间，单词拆分问题）, 最小最大最长问题，总数问题</p></li><li><p>当动态规划的状态比较多的情况下<br>注意 res+=dp[i][m]%MOD(wrong answer)<br>res=(res+dp[m][i])%MOD(right answer);</p></li><li><p>划分性dp有两种情况：以i为结尾，和0-i之间，区分这两种情况就是判断在进行dp递推的时候，如果dp[i] 依赖于多个之前的dp[j]那么应该使用以i为结尾，如果dp[i]只依赖之前的一个dp[j]那么使用0-i之内的元素</p></li><li><p>使用状态枚举的方法，要求k&lt;32 !!!!如果n&lt;100那么久不能这么枚举</p></li><li><p>背包问题可能也会加一个额外的条件，类似于最短路径问题（Dijstra/bellman-ford/floyd）中再加一个额外条件,具体例题见“货物转移”(lintcode)模板：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span>(d[j]+<span class="hljs-number">1</span>&lt;d[i])&#123; <span class="hljs-comment">//找到更优解</span><br>    d[i]=d[j]+<span class="hljs-number">1</span>;<br>    weight[i]=weight[j]; <span class="hljs-comment">// update weight and d</span><br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(d[i]==d[j]+<span class="hljs-number">1</span>)&#123;<br>    weight[i]=max/<span class="hljs-built_in">min</span>(weight[j], weight[i]); <span class="hljs-comment">//only update weight</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-keyword">continue</span>; <span class="hljs-comment">//do not update anything</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单调栈</title>
    <link href="/2021/11/13/leetcode/%E5%8D%95%E8%B0%83%E6%A0%88%E7%9B%B8%E5%85%B3/"/>
    <url>/2021/11/13/leetcode/%E5%8D%95%E8%B0%83%E6%A0%88%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h3 id="单调栈相关题目："><a href="#单调栈相关题目：" class="headerlink" title="单调栈相关题目："></a>单调栈相关题目：</h3><ol><li><p>去除重复字母(使得去除重复字母之后，字符串的字典序最小)<br>值栈</p></li><li><p>接雨水</p></li></ol><ul><li>方法一：每个地方能接的雨水是当前下标左右两边最大值（LeftMax and RightMax）的较小一个 –&gt;值栈</li><li>方法二：使用单调递减栈，维护top and left（单调栈的top下面的值） –&gt;下标栈</li></ul><ol start="3"><li><p>直方图最大矩阵面积（求离当前直方图左右两边第一个小于该直方图的下标，使用左边单调递增+右边单调递增）注意边缘的节点，因此需要提前向栈push -1或者size<br>下标栈</p></li><li><p>以及围成矩形的最大面积 转为每行的直方图的最大面积<br>下标栈</p></li></ol><h5 id="栈相关的题目："><a href="#栈相关的题目：" class="headerlink" title="栈相关的题目："></a>栈相关的题目：</h5><ol><li><p>公式字符串求值</p><ul><li><p>可以遇到（）后进入递归，或者压入op栈中.注意（-15）这种要特别判断，if(s[i]==’-‘) &amp;&amp; if(i==0||s[i-1]==’(‘) 那么就循环获得一个负数（括号可以进入op栈中，也可以直接跳过）</p></li><li><p>在计算优先级的时候：可以不用传入两个判断，可以给每一个运算符一个分数</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">int grade( char op ) &#123;<br>    <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;(&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;+&#x27;</span> || op == <span class="hljs-string">&#x27;-&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;*&#x27;</span> || op == <span class="hljs-string">&#x27;/&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol><p>2.逆波兰表达式</p><p>3.滑动窗口的最大值，可以使用优先队列或者双向队列（单调递减）</p><p>4.频率最高的k个字符，使用大小为k的最小堆，其实也是使用优先队列实现的堆，需要自定义排序方式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 小顶堆</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">mycomparison</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">const</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&amp; lhs, <span class="hljs-keyword">const</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&amp; rhs)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> lhs.second &gt; rhs.second;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ol start="5"><li><p>有的模拟题也是用栈的，比如文件的最长路径，栈中维护递增level的长度，如果当前的level&lt;栈顶的level那么弹栈；如果遇到当前是文件，那么统计栈中元素加起来的值和result比较取最大<br>这种题一般需要对token先进行划分，然后进行统计</p></li><li><p>移掉 K 位数字, 使用单调栈，如果当前的字符小于栈顶的元素，那么循环弹出。易错点：剩下的字符包含头部0元素，以及最后如何结果为空字符串的话，应该返回“0”而不是“”</p></li><li><p>下一个更大元素||<br>题意：找到每个元素后面，第一个大于当前元素的数</p></li></ol><p>我的解法：从后往前，前面在进行判断的时候使用后面的nextid,可以跳过一些数，next[i]==-1表示没有比当前数更大的，next[i]==-2表示当前数还没有计算 nextid有值那么直接进行跳转nextid=next[nextid]</p><p>官方题解：单调栈，但是因为是训练列表，所以需要遍历n+n-1个数据</p><ol start="8"><li>子数组的最小值之和<br>这道题求每个数左边比他小的第一个数的下标，和右边第一个比他小于或等于的数的下标<br>使用单调递减栈<br>结果就是：arr[i]*(i-left[i]) * (right[i]-i)<br>注意为了处理两个数相同的情况，使用左边小于，右边小于等于！！！</li></ol><p>比如：1 2 4 8 1</p><ol start="9"><li>最小栈<br>题目：如果用时间O(1)和空间O(1)的复杂度得到栈中的最小值<br>解决：原始的数据栈用来记录数据与min的差值 （value-min），同时用一个min变量记录当前栈的最小值;注意如果数值没有限制的话，差值的计算可能会溢出。<br>getmin()：始终返回min变量的值<br>void pop(): 如果栈顶元素小于0，那么说明当前栈顶元素就是min(如果需要返回栈顶元素只，那么返回min),同时更新min为min-stack.top();否则不更新min<br>void push(value): 当栈为空，直接压入value, 令min=value, push(0); 如果不为空，计算 value-min，并压入栈中; 如果小于0, 那么修改min为value, 否则min不变。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> 设计一个有<span class="hljs-title">gitMin</span>的栈 &#123;</span><br><br>    <span class="hljs-keyword">private</span> Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> min;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (stack.<span class="hljs-built_in">isEmpty</span>()) &#123;<br>            min = x;<br>            stack.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 计算差值</span><br>            <span class="hljs-keyword">int</span> compare = x - min;<br>            stack.<span class="hljs-built_in">push</span>(compare);<br>            <span class="hljs-comment">// 如果差值小于0，显然 x 成为最小值，否则最小值不变</span><br>            min = compare &lt; <span class="hljs-number">0</span> ? x : min;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> top = stack.<span class="hljs-built_in">peek</span>();<br>        <span class="hljs-comment">// 如果top小于0，显然最小值也一并会被删除，此时更新最小值</span><br>        min = top &lt; <span class="hljs-number">0</span> ? (min - top) : min;<br>        stack.<span class="hljs-built_in">pop</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> min;<br>    &#125;<br> &#125;<br><br></code></pre></td></tr></table></figure><h4 id="括号相关的题目专题"><a href="#括号相关的题目专题" class="headerlink" title="括号相关的题目专题"></a>括号相关的题目专题</h4><p>总结: 一般来说括号相关的题使用栈解决，但是有的题目也使用动态规划解决。同时栈的方式也可以演变为更加简单的整数加减问题，不需要额外的空间。左括号出现那么+1， 右括号出现那么如果有左括号，那么左括号-1否则右括号+1</p><p>678.有效的括号字符串， 因为*既可以当左括号，又可以当右括号，又可以当空白字符</p><ul><li><p>因此需要两个栈，当左括号栈为空的时候，从星号栈弹，否则从左括号栈弹、如果最后左括号不为空，那么比较信号栈顶和左括号栈顶下标，如果星号栈顶下标大，那么同时弹出，重复上述过程</p></li><li><p>如果是动态规划的话； 就是判断dp[i][j]是否为true, 判断标准是 如果i==’(‘而却j==’)’那么dp[i][j]=dp[i+1][j-1] 否则就遍历i 到j之间的每一个元素，dp[i][j]=dp[i][k]&amp;&amp;dp[k][j]<br>类似长度的动态规划（最长回文子串）<br>len==1 s[i]==’<em>‘ dp[i][i]=true<br>len==2 (s[i]==’(‘||s[i]==’</em>‘ ) &amp;&amp; (s[j]==’)’||s[j]==’*’)</p></li></ul><ol start="22"><li>括号的生成，使用dfs， 左括号的数量应该时刻保持&gt;=右括号的数量， 因此可以使用每使用一个左括号，可使用的右括号数量+1， 左括号：n-&gt;0, 右括号：0-&gt;n</li><li>最长有效括号（动态规划中也有总结）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestValidParentheses</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> maxans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[s.<span class="hljs-built_in">length</span>()];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; s.<span class="hljs-built_in">length</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">charAt</span>(i) == <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>                <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">charAt</span>(i - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                    dp[i] = (i &gt;= <span class="hljs-number">2</span> ? dp[i - <span class="hljs-number">2</span>] : <span class="hljs-number">0</span>) + <span class="hljs-number">2</span>;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i - dp[i - <span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span> &amp;&amp; s.<span class="hljs-built_in">charAt</span>(i - dp[i - <span class="hljs-number">1</span>] - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                    dp[i] = dp[i - <span class="hljs-number">1</span>] + ((i - dp[i - <span class="hljs-number">1</span>]) &gt;= <span class="hljs-number">2</span> ? dp[i - dp[i - <span class="hljs-number">1</span>] - <span class="hljs-number">2</span>] : <span class="hljs-number">0</span>) + <span class="hljs-number">2</span>;<br>                &#125;<br>                maxans = Math.<span class="hljs-built_in">max</span>(maxans, dp[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxans;<br>    &#125;<br></code></pre></td></tr></table></figure><p>** 301. 删除无效的括号：**<br>因为是需要知道删除后所有有效的情况，所以应该dfs</p><p>solution: 先计算得到要删除的左右括号的数量，然后再dfs求所有合格的情况<br>使用dfs的两种剪枝技巧：</p><ol><li>不重复遍历相同的 if i!=cur &amp;&amp; char[i]==char[i-1] continue</li><li>记录当前左括号和右括号的数量，只有左括号的数量大于等于右括号，再遍历需要这个右括号的这种情况，否则就不遍历这种情况</li></ol><p>注意这道题在进行递归的时候，不是一个字符一个字符的判断到底加不加当前的字符，而是使用一个循环，从当前字符遍历到最后一个字符，然后将当前字符前面和后面的字符串进行拼接， 然后仍然从当前遍历的下标，进入下一个循环<br>通过这种方式可以跳过一些重复的循环， 比如（（（）， 这种方式只需要移除一个（ ， 没必要每个进行判断</p><ol start="768"><li>最多能完成排序的块 I/II<br>总结：==最大的元素标记了一个段==<br>I:无重复的元素：可以直接i==maxnum的时候res++<br>II: 有重复的元素<br>使用单调栈</li><li>如果大于等于栈顶，直接入栈</li><li>如果小于，那么将栈顶下面小于当前值的元素pop掉，然后压入原来的栈顶</li></ol><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>一定要清楚是单调递增栈还是单调递减栈；判断是单减栈还是单增栈的关键：是弹出的元素对后面的结果不会有影响。同时要注意push的是下标还是值</p><p>栈适合题目：括号相关，左右的第一个最大最小，表达式求值，模拟文件层数，树结构题目，数字数组（也可能用二分）操作。<br>括号是否匹配也可以转为整数加减问题</p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈, 单调栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode/单调栈相关</title>
    <link href="/2021/11/13/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/leetcode-%E5%8D%95%E8%B0%83%E6%A0%88%E7%9B%B8%E5%85%B3/"/>
    <url>/2021/11/13/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/leetcode-%E5%8D%95%E8%B0%83%E6%A0%88%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>scheduler_ralated</title>
    <link href="/2021/11/12/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/scheduler-ralated/"/>
    <url>/2021/11/12/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/scheduler-ralated/</url>
    
    <content type="html"><![CDATA[<p>调度需要关注的问题/或者目标：提高资源利用率，负载均衡，用户的优先级和公平性</p><p>可能是针对深度学习场景的调度，也可能是平常的请求任务</p><p>ParSync:调度器需要进行及时的同步，如果不及时进行同步那么就可能造成大量冲突；但是在同步的时候，如果一个调度器固定同步固定几个机器的话。就无法充分利用机器空闲资源；<br>所以这篇论文提出利用分片同步的策略，就是一个调度器通过轮训的方式，分时段和多个机器进行同步；同时给最后同步的机器更高的优先级，因为它的状态最新，最可信，因此发生冲突的可能性会更小</p><p>Gavel: 针对深度学习的异构感知的集群调度策略； 将调度转为一个优化问题</p><h3 id="阿里项目"><a href="#阿里项目" class="headerlink" title="阿里项目"></a>阿里项目</h3><p>资源池化的理解：<br>CPU、内存、磁盘、I/O等硬件变成可以动态管理的“资源池”，从而提高资源的利用率，简化系统管理，实现服务器整合。核心思想：能够通过区分资源优先次序并随时随地能够将服务器资源分配给最需要它们的工作负载来简化管理和提高效率，从而减少为单个工作负载峰值而存储的资源。</p><blockquote><p>池化简单来讲就是使用远程访问的形式使用GPU资源，任务使用本机的CPU和另一台机器的GPU，两者通过网络进行通信。</p></blockquote><p>ref:<a href="https://bbs.cvmart.net/articles/3696">https://bbs.cvmart.net/articles/3696</a></p><p>深度学习场景下异构池化资源管理和任务调度研究</p><p>池化和异构集群下的资源调度有什么区别？</p><p>相关研究工作：</p><p>Demand Based Hierarchical QoS Using Storage Resource Pools</p><p>化零为整:将多台服务器上的GPU集合起来提供给一个容器或者一个虚拟机使用<br>隔空取物：将虚拟机或者容器运行在一台没有物理 GPU 的服务器上，通过计算机网络，透明地使用另一台服务器上的 GPU 资源。<br>小模型场景的典型应用：从算力和显存两个角度，对GPU资源进行切分</p><p>问题：<br>这个池化是GPU还是包括CPU， 存储所有资源的池化<br>这个GPU的池化和云服务器有什么区别<br>GPU池化之后，拉远，数据传输的开销如何弥补<br>如果做到多个应用之间互不影响的，因为虽然充分应用了GPU的显存和算力资源，但是数据传输的带宽，不会因为任务量多，而相互竞争，从而影响效率吗</p><p>通过算力和显存从切分， 不在一个GPU上算力和显存如何协作起来，完成一件事情<br>与k8S的区别在哪里</p><p>为什么需要劫持调用才能实现资源的隔离</p><p>这里的调度是分配好了，就固定直到任务结束，还是像gandivia一样需要动态调整<br>主要是针对deep learning 的训练 推理还是普遍多任务背景下的任务调度，与资源池化</p><p>之后的安排：<br>看一下legoos 以及一些相关论文<br>看一下k8s的官方文档<br>看一下ppt里面的一些链接<br>讨论一下任务</p><p>相关论文总结：</p><h3 id="Multi-Job："><a href="#Multi-Job：" class="headerlink" title="Multi-Job："></a>Multi-Job：</h3><p>Gandiva: 主要是针对multi-job 超参数搜索的场景下的可预测性，在训练过程中，自适应的调整job, 最大化GPU资源的利用率</p><h3 id="训练推理混合调度："><a href="#训练推理混合调度：" class="headerlink" title="训练推理混合调度："></a>训练推理混合调度：</h3><p>AntMan : Dynamic Scaling on GPU Clusters for Deep Learning<br>PipeSwitch: Fast Pipelined Context Switching for Deep Learning Applications</p><p>将推理任务插入训练的时间片中，充分利用GPU的资源</p><h3 id="池化相关"><a href="#池化相关" class="headerlink" title="池化相关"></a>池化相关</h3><p>LegoOS: A Disseminated, Distributed OS for Hardware Resource Disaggregation<br>推翻常规的整体server模式，使process memory和storage通过网络来进行通讯，而不是总线，使用一个全局manager进行粗粒度的分配，然后使用一个local manager进行细粒度资源管理</p><p>rCUDA remote CUDA<br>rCUDA: Going Further in Remote GPU Virtualization<br>VMware-vSphere-Bitfusion<br>驱动科技的GPU拉远策略</p><h3 id="异构-集群资源调度"><a href="#异构-集群资源调度" class="headerlink" title="异构/集群资源调度"></a>异构/集群资源调度</h3><p>Scaling Large Production Clusters with Partitioned Synchronization<br>主要是多个调度器对集群支援进行调度，同时为了保证调度维持较好的实时性，减低可能发生的资源竞争，使用时间片轮训的方式，让一个调度器对多个机器组成的组进行调度</p><p>HiveD : Sharing a GPU Cluster for Deep Learning with Guarantees<br>Heterogeneity-Aware Cluster Scheduling Policies for Deep Learning Workloads<br>Topology-aware GPU scheduling for learning workloads in cloud environments<br>Tiresias: A GPU cluster manager for distributed deep learning<br>Gandiva: Introspective cluster scheduling for deep learning</p><h3 id="针对深度学习的GPU共享survey"><a href="#针对深度学习的GPU共享survey" class="headerlink" title="针对深度学习的GPU共享survey"></a>针对深度学习的GPU共享survey</h3><p><a href="https://bbs.cvmart.net/articles/3696">https://bbs.cvmart.net/articles/3696</a></p><p><a href="https://cloud.tencent.com/developer/article/1766184">https://cloud.tencent.com/developer/article/1766184</a>   Improving GPU Utilization in Kubernetes</p>]]></content>
    
    
    
    <tags>
      
      <tag>scheduler</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python相关</title>
    <link href="/2021/11/11/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/python%E7%9B%B8%E5%85%B3/"/>
    <url>/2021/11/11/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/python%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h4 id="Python语言部分"><a href="#Python语言部分" class="headerlink" title="Python语言部分"></a>Python语言部分</h4><ol><li>python 开启debug模式，使用logger.setLevel 以及在logger的时候设置不同的logger.info  logger.error  logger.warning等</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> logging<br><span class="hljs-keyword">import</span> requests<br>logging.basicConfig(level=logging.DEBUG,<br>                    <span class="hljs-built_in">format</span>=<span class="hljs-string">&#x27;%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s&#x27;</span>,<br>                    datefmt=<span class="hljs-string">&#x27;%a, %d %b %Y %H:%M:%S&#x27;</span>,<br>                    filename=<span class="hljs-string">&#x27;myapp.log&#x27;</span>,<br>                    filemode=<span class="hljs-string">&#x27;w&#x27;</span>)<br> <br>logging.debug(session.get(<span class="hljs-string">&#x27;http://www.qq.com&#x27;</span>))<br>logging.debug(session.get(<span class="hljs-string">&#x27;http://www.qq.com&#x27;</span>))<br><br></code></pre></td></tr></table></figure><p>tuple和list的区别</p><p>tuple和list都可以通过下标访问元素，但是list是可以修改列表中的元素， 但是tuple一旦初始化就不能修改，不能append和insert</p><h4 id="PyTorch-部分"><a href="#PyTorch-部分" class="headerlink" title="PyTorch 部分"></a>PyTorch 部分</h4><ol><li>在如果在模型训练的时候，一部分卷积使用的是dataparallel一部分使用的是直接cuda (比如alexnet) 这种情况在模型参数的加载的时候，需要修改keys中包含 module.的部分（dataparallel 部分）</li></ol><p>方法一:<br>修改保存或者加载时的字典</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs haxe">from collections <span class="hljs-keyword">import</span> OrderedDict<br><span class="hljs-keyword">new</span><span class="hljs-type">_state_dict</span> = OrderedDict()<br><span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> state_dict.items():<span class="hljs-type"></span><br>    namekey = k[<span class="hljs-number">7</span>:<span class="hljs-type"></span>] <span class="hljs-keyword">if</span> k.startswith(<span class="hljs-string">&#x27;module.&#x27;</span>) <span class="hljs-keyword">else</span> k<br>    <span class="hljs-keyword">new</span><span class="hljs-type">_state_dict</span>[namekey] = v<br></code></pre></td></tr></table></figure><p>方法二：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">uni_model.load_state_dict(&#123;k.replace(<span class="hljs-string">&#x27;module.&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>) :v <span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> model_queue.<span class="hljs-builtin-name">get</span>(<span class="hljs-attribute">block</span>=<span class="hljs-literal">False</span>).items() &#125;)<br></code></pre></td></tr></table></figure><ol start="2"><li>DatasetFolder类的解读<br>数据类别，是通过遍历目标文件夹，得到每个文件夹的名字，以及名字对应的下标<br>make_data返回的是 数据的路径+类别下标 序列元组 List of (sample path, class_index) tuples 得到self.samples<br>然后再在get_item函数中使用path = self.samples[index] self.loader(path) 获得图片实例</li></ol><p>那么我自定义的缓存，既可以在MyDataSet里面的DataSet_ImageNet里面修改，判断是应该从缓存中取还是从文件系统；<br>也可以修改ImageFolder, 里面加一个缓存， 在self.loader那里加上if-else判断语句</p><p>但是多进程会初始化多个dataset, 这样每个进程都会有一个cache， 我的目的应该是只有一个cache, 然后多进程从里面都可以从这个cache中取数据；而且多进程如果每一轮的dataset的实例被销毁的话会导致<br>cache也会被销毁</p><ol start="3"><li>DatasetLoader类的解读<br>问题：<br>worker_init_fn， prefetch_factor 和persistent_workers（保持被实例化的Dataset在下一轮仍然保持alive） 的作用是什么<br>warning中表示如果spwarn start method被使用， 那么worker_init_fn 不能是一个unpicklable object</li></ol><p>_MultiProcessingDataLoaderIter 可以学习一下多进程的退出<br>使用了三个队列 index_queue worker_result_queue data_queue</p><p>workers_done_event 检测一个迭代器是否shut down, 如果一个迭代器进行shutdown，那么那个进程的input_queue里面的数据只需要为None就好了， 就不用一直等待那个queue里面的数据</p><p>为什么要使用 cancel_join_thread()  index_queue.cancel_join_thread()</p><p>记录：<br>多进程每个进程都可以创建多个dataset实例, 是否在主函数中初始化一个cacheout类，然后作为dataset的参数传过去，这样多进程也是使用的一个cache<br>主要的逻辑</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self._num_workers):<br>            <span class="hljs-comment"># No certainty which module multiprocessing_context is</span><br>            index_queue = multiprocessing_context.Queue()  <span class="hljs-comment"># type: ignore</span><br>            <span class="hljs-comment"># Need to `cancel_join_thread` here!</span><br>            <span class="hljs-comment"># See sections (2) and (3b) above.</span><br>            index_queue.cancel_join_thread()<br>            w = multiprocessing_context.Process(<br>                target=_utils.worker._worker_loop,<br>                args=(self._dataset_kind, self._dataset, index_queue,<br>                      self._worker_result_queue, self._workers_done_event,<br>                      self._auto_collation, self._collate_fn, self._drop_last,<br>                      self._base_seed + i, self._worker_init_fn, i, self._num_workers,<br>                      self._persistent_workers))<br></code></pre></td></tr></table></figure><p>只有一个worker_result_queue, 以及多个result_queue; 如果pin_memory=True, 那么会将worker_result_queue里面的数据，全部放在另外一个_data_queue中</p><ol start="4"><li>代码常见标记<br>TODO：英语翻译为待办事项，备忘录。如果代码中有该标识，说明在标识处有功能代码待编写，待实现的功能在说明中会简略说明。</li></ol><p>FIXME：可以拆成短语，fix me ，意为修理我。如果代码中有该标识，说明标识处代码需要修正，甚至代码是错误的，不能工作，需要修复，如何修正会在说明中简略说明。</p><p>XXX：如果代码中有该标识，说明标识处代码虽然实现了功能，但是实现的方法有待商榷，希望将来能改进，要改进的地方会在说明中简略说明。</p><p>HACK：英语翻译为砍。如果代码中有该标识，说明标识处代码我们需要根据自己的需求去调整程序代码。</p><ol start="5"><li>pytorch安装各种版本链接：<br><a href="https://pytorch.org/get-started/previous-versions/">https://pytorch.org/get-started/previous-versions/</a></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>常见问题及解决方案</title>
    <link href="/2021/11/11/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <url>/2021/11/11/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<ol><li>vscode调试的时候找不到路径</li></ol><ul><li>解决方案:在运行的python文件中添加sys.path，同时注意vscode调试的环境可以通过vscode界面最下面一栏进行替换<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">import</span> sys<br><span class="hljs-title">sys</span>.path.append(<span class="hljs-string">&quot;/root/hushuang/IS-code&quot;</span>)<br></code></pre></td></tr></table></figure></li></ul><ol start="2"><li>程序运行的时候报错 no module named XXX</li></ol><ul><li>如果是引入了与当前包并行的其他包里面的python文件，需要对文件使用setup tools进行打包，才能看到其他module里面的python文件<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs clean">setup.py<br>    <span class="hljs-keyword">from</span> setuptools <span class="hljs-keyword">import</span> setup, find_packages<br><br>    setup(<br>        name=<span class="hljs-string">&#x27;IO-aware Importance Sampling&#x27;</span>,               # 应用名<br>        version=<span class="hljs-string">&#x27;1.0&#x27;</span>,              # 版本号<br>        packages=find_packages(),   # 包括在安装包内的Python包<br>        include_package_data=<span class="hljs-literal">True</span>,   # 启用清单文件MANIFEST.<span class="hljs-keyword">in</span><br>        # exclude_package_date=&#123;<span class="hljs-string">&#x27;&#x27;</span>:[<span class="hljs-string">&#x27;.gitignore&#x27;</span>]&#125;,<br>        # install_requires=[          # 依赖列表<br>        #     <span class="hljs-string">&#x27;Flask&gt;=0.10&#x27;</span>,<br>        #     <span class="hljs-string">&#x27;Flask-SQLAlchemy&gt;=1.5,&lt;=2.1&#x27;</span><br>        # ]<br>    )<br><br>install.sh<br>    python setup.py <br><span class="hljs-comment">//生成的XXX.egg.info文件是和install.sh一个目录内， build文件夹 是和setup.py同一个目录内</span><br></code></pre></td></tr></table></figure></li><li>在import的时候不能导入整个包名 比如IOAS/A/a.py 想要访问IOAS/B/b.py的函数时候，不能在a.py函数里面写 from IOAS.B.b import func_XXX; 正确应该是 from B.b import func_XXX; </li></ul><ol start="3"><li>vscode无法连接远程服务器，但是能够ssh</li></ol><p>解决方案：服务器/home目录满，清理之后就可以了<br>方法二：清理~/.vscode-server 删除就可以了</p><ol start="4"><li>python 出现no module find XX</li></ol><p>一般是一个python文件引用了同一个文件夹里面另外一个python文件，解决方案就是添加一个setup文件，同时一定要注意install文件和setup文件要放在整个目录的最外层 IOAS里面包含的第一层</p><p>如果出现函数参数和报错信息不一致的话，可能是因为setup安装了两个同名的文件，导致出错，使用pip unistall 自己的项目文件名称就可以了</p><ol start="5"><li>在使用RPC的时候发现如下问题<blockquote><p> uni_score_rref = rpc.rpc_async(“worker”, get_uni_sample_score_rref, args=(rank, uni_list_rref, model_param_rref, args, ))<br>File “/nfs/home/shu/.local/lib/python3.6/site-packages/torch/distributed/rpc/api.py”, line 77, in wrapper<br> return func(*args, **kwargs)<br>File “/nfs/home/shu/.local/lib/python3.6/site-packages/torch/distributed/rpc/api.py”, line 635, in rpc_async<br> return _invoke_rpc(to, func, RPCExecMode.ASYNC, args, kwargs)<br>File “/nfs/home/shu/.local/lib/python3.6/site-packages/torch/distributed/rpc/api.py”, line 481, in _invoke_rpc<br> PythonUDF(func, args, kwargs)<br>File “/nfs/home/shu/.local/lib/python3.6/site-packages/torch/distributed/rpc/internal.py”, line 86, in serialize<br> p.dump(obj)<br>TypeError: can’t pickle _thread.RLock objects</p></blockquote></li></ol><p>解决：去掉调用rpc函数里面的args参数，因为args参数里面有一个logger 会导致报错</p><ol start="6"><li>The results is different when placing rpc_aync at a different .py file</li></ol><p>I want to execute a function at the worker side and return the results to the master. However, I find that the results is different when placing rpc_async at a different .py file</p><h4 id="Method-1"><a href="#Method-1" class="headerlink" title="Method 1"></a>Method 1</h4><p>master.py:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.distributed.rpc <span class="hljs-keyword">as</span> rpc<br><span class="hljs-keyword">from</span> torch.distributed.rpc <span class="hljs-keyword">import</span> RRef<br><span class="hljs-keyword">from</span> test <span class="hljs-keyword">import</span> sub_fun<br><br>os.environ[<span class="hljs-string">&#x27;MASTER_ADDR&#x27;</span>] = <span class="hljs-string">&#x27;10.5.26.19&#x27;</span><br>os.environ[<span class="hljs-string">&#x27;MASTER_PORT&#x27;</span>] = <span class="hljs-string">&#x27;5677&#x27;</span><br><br>rpc.init_rpc(<span class="hljs-string">&quot;master&quot;</span>, rank=<span class="hljs-number">0</span>, world_size=<span class="hljs-number">2</span>)<br>rref = torch.Tensor([<span class="hljs-number">0</span>])<br>sub_fun(rref)<br>rpc.shutdown()<br></code></pre></td></tr></table></figure><p>test.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>(<span class="hljs-params">rref</span>):</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;function is executed on master&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sub_fun</span>(<span class="hljs-params">rref</span>):</span><br>x = rpc.rpc_async(<span class="hljs-string">&quot;worker&quot;</span>, f, args=(rref,))<br></code></pre></td></tr></table></figure><p>worker.py:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.distributed.rpc <span class="hljs-keyword">as</span> rpc<br><span class="hljs-keyword">from</span> torch.distributed.rpc <span class="hljs-keyword">import</span> RRef<br><br>os.environ[<span class="hljs-string">&#x27;MASTER_ADDR&#x27;</span>] = <span class="hljs-string">&#x27;10.5.26.19&#x27;</span><br>os.environ[<span class="hljs-string">&#x27;MASTER_PORT&#x27;</span>] = <span class="hljs-string">&#x27;5677&#x27;</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>(<span class="hljs-params">rref</span>):</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;function is executed on worker&quot;</span>)<br>rpc.init_rpc(<span class="hljs-string">&quot;worker&quot;</span>, rank=<span class="hljs-number">1</span>, world_size=<span class="hljs-number">2</span>)<br>rpc.shutdown()<br></code></pre></td></tr></table></figure><p>I found that the output is “function is executed on master” at the worker side.</p><h4 id="Method-2"><a href="#Method-2" class="headerlink" title="Method 2"></a>Method 2</h4><p>when I put the two functions: sub_fun and f in the master.py rather than the test.py, the result is “function is executed on worker”.</p><p>Why the two ways output the different results. and how can I get the result 2 with the method 1.</p><ol start="7"><li>args 删除里面的某个参数<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">logger_arg = args.logger<br><span class="hljs-keyword">del</span> <span class="hljs-built_in">vars</span>(args)[<span class="hljs-string">&#x27;logger&#x27;</span>]<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;--------args----------&#x27;</span>)<br><span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">list</span>(<span class="hljs-built_in">vars</span>(args).keys()):<br>    <span class="hljs-built_in">print</span>(k)<br>    <span class="hljs-comment"># print(&#x27;%s: %s&#x27; % (k, vars(args)[k]))</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;--------args----------\n&#x27;</span>)<br></code></pre></td></tr></table></figure></li></ol><ol start="8"><li>torch.distributed.rpc.rpc_aync<br>rref相关文档 <a href="https://m.w3cschool.cn/pytorch/pytorch-cdva3buf.html">https://m.w3cschool.cn/pytorch/pytorch-cdva3buf.html</a></li></ol><p><a href="https://github.com/pytorch/pytorch/issues/26759">https://github.com/pytorch/pytorch/issues/26759</a></p><ol start="9"><li>修改账户sudo权限<br>在有sudo权限的账户下执行 sudo visudo<br>并在下面添加以下权限<br>zhinengjisuan ALL=(ALL)     ALL</li></ol><ol start="10"><li>how to share a cache among multiple subprocesses when using PyTorch DDP training.</li></ol><p>I want to share a cache among multiple processes when using ddp training.<br>I found a potential solution is to use shared memory with torch.multiprocessing.<br>However, it is not convinient if I want to training on multiple nodes, thus I choose the method <code>torch.distributed.launch</code> rather than <code>mp.spwarn</code> to init DDP training.<br>The question is how can I share a cache among multiple subprocesses in the same node,  when using the method <code>torch.distributed.init_process_group</code>.<br>Supposed that there are N nodes, we should create N caches, and these subprocesses in the same node share one of the caches.</p><p>Has someone encounter the same problem before?</p><p>已解决:<br>mp.set_start_method(‘spawn’)</p><ol start="11"><li>/nfs/home/shu/.local/lib/python3.6/site-packages/PIL/TiffImagePlugin.py:788: UserWarning: Corrupt EXIF data.  Expecting to read 4 bytes but only got 0.<br>warnings.warn(str(msg))</li></ol><p>solution 1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br><br>imageFolder = /Path/To/Image/Folder<br>listImages = os.listdir(imageFolder)<br><br><span class="hljs-keyword">for</span> img <span class="hljs-keyword">in</span> listImages:<br>    imgPath = os.path.join(imageFolder,img)<br>            <br>    <span class="hljs-keyword">try</span>:<br>        img = Image.<span class="hljs-built_in">open</span>(imgPath)<br>        exif_data = img._getexif()<br>    <span class="hljs-keyword">except</span> ValueError <span class="hljs-keyword">as</span> err:<br>        <span class="hljs-built_in">print</span>(err)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Error on image: &quot;</span>, img)<br></code></pre></td></tr></table></figure><ol start="12"><li>8a100连接hec报错<br>Torch RPC Connection closed by peer<br>[W tensorpipe_agent.cpp:942] RPC agent for worker encountered error when sending outgoing request #0 to master: ECONNREFUSED: connection refused<br>[W tensorpipe_agent.cpp:942] RPC agent for worker encountered error when sending outgoing request #1 to master: ECONNREFUSED: connection refused</li></ol><p>真正的解决方案：backend=rpc.BackendType.PROCESS_GROUP，<br>不需要加其他的 os.environ[‘TF_SOCKET_IFNAME’] = ‘ens3’ 或者os.environ[‘GLOO_SOCKET_IFNAME’] = ‘ens3’</p><ol start="13"><li>git pull超时，访问缓慢的解决方案<br>参考链接：<br><a href="https://jasonkayzk.github.io/2019/10/10/%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8Git%E6%97%B6push-pull%E8%B6%85%E6%97%B6-%E4%BB%A5%E5%8F%8AGithub%E8%AE%BF%E9%97%AE%E6%85%A2%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/">https://jasonkayzk.github.io/2019/10/10/%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8Git%E6%97%B6push-pull%E8%B6%85%E6%97%B6-%E4%BB%A5%E5%8F%8AGithub%E8%AE%BF%E9%97%AE%E6%85%A2%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>vscode python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux命令</title>
    <link href="/2021/11/11/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/Linux%E5%91%BD%E4%BB%A4/"/>
    <url>/2021/11/11/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/Linux%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h4 id="rename"><a href="#rename" class="headerlink" title="rename"></a>rename</h4><p>批量修改后缀名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>rename s/\后缀1/\后缀/<span class="hljs-string">&#x27; *</span><br><span class="hljs-string"></span><br><span class="hljs-string">rename s/\后缀1/\后缀/&#x27;</span> ** //递归所有的子目录<br><br>example: rename <span class="hljs-string">&#x27;s/\.tar.gz.1/\.tar.gz/&#x27;</span> *<br></code></pre></td></tr></table></figure><h4 id="手动清理缓存"><a href="#手动清理缓存" class="headerlink" title="手动清理缓存"></a>手动清理缓存</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">释放缓存区内存的方法<br>1）清理pagecache（页面缓存）<br>[root@backup ~]<span class="hljs-comment"># echo 1 &gt; /proc/sys/vm/drop_caches     或者 # sysctl -w vm.drop_caches=1</span><br> <br>2）清理dentries（目录缓存）和inodes<br>[root@backup ~]<span class="hljs-comment"># echo 2 &gt; /proc/sys/vm/drop_caches     或者 # sysctl -w vm.drop_caches=2</span><br> <br>3）清理pagecache、dentries和inodes<br>[root@backup ~]<span class="hljs-comment"># echo 3 &gt; /proc/sys/vm/drop_caches     或者 # sysctl -w vm.drop_caches=3</span><br>　<br>上面三种方式都是临时释放缓存的方法，要想永久释放缓存，需要在/etc/sysctl.conf文件中配置：vm.drop_caches=1/2/3，然后sysctl -p生效即可！<br> <br>另外，可以使用sync命令来清理文件系统缓存，还会清理僵尸(zombie)对象和它们占用的内存<br>[root@backup ~]<span class="hljs-comment"># sync</span><br></code></pre></td></tr></table></figure><h4 id="服务器之间使用scp进行文件传输和同步"><a href="#服务器之间使用scp进行文件传输和同步" class="headerlink" title="服务器之间使用scp进行文件传输和同步"></a>服务器之间使用scp进行文件传输和同步</h4><p>rsync -r -P –rsh=ssh source_dir dest_dir(<a href="mailto:&#115;&#104;&#117;&#64;&#49;&#48;&#46;&#53;&#x2e;&#x32;&#x36;&#x2e;&#x31;&#x39;">&#115;&#104;&#117;&#64;&#49;&#48;&#46;&#53;&#x2e;&#x32;&#x36;&#x2e;&#x31;&#x39;</a>:/nfs/home/shu/hushuang-8a100)</p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux command</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>secrete</title>
    <link href="/2021/11/10/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/secrete/"/>
    <url>/2021/11/10/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/secrete/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="42bdb50f24ef810bd1fe9c3a68189192ac22e3a686b9d240c1c7f8ebad6aba86">792393e20cb95a16d338204aed962f21dfc09fc732608dcc9224b9c53e390244da9a389fb5651bdcf8a6634c53e59a5aa6711d5b381e161d71676c092e311df3</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    
    <tags>
      
      <tag>private</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>rclone</title>
    <link href="/2021/11/08/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/rclone/"/>
    <url>/2021/11/08/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/rclone/</url>
    
    <content type="html"><![CDATA[<h3 id="从google-drive中下载文件的两种方法"><a href="#从google-drive中下载文件的两种方法" class="headerlink" title="从google drive中下载文件的两种方法"></a>从google drive中下载文件的两种方法</h3><h4 id="1-让远程服务器使用rclone挂载google-drive-谷歌云端硬盘"><a href="#1-让远程服务器使用rclone挂载google-drive-谷歌云端硬盘" class="headerlink" title="1.让远程服务器使用rclone挂载google drive (谷歌云端硬盘)"></a>1.让远程服务器使用rclone挂载google drive (谷歌云端硬盘)</h4><p>简易步骤：</p><ol><li><p>下载rclone:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://www.moerats.com/usr/shell/rclone_debian.sh &amp;&amp; bash rclone_debian.sh<br></code></pre></td></tr></table></figure></li><li><p>rclone的配置</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rclone config<br></code></pre></td></tr></table></figure><p>3.使用rclone进行google drive的挂载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#新建本地文件夹，路径自己定，即下面的LocalFolder</span><br>mkdir /root/GoogleDrive<br><span class="hljs-comment">#挂载为磁盘，下面的DriveName、Folder、LocalFolder参数根据说明自行替换</span><br>rclone mount DriveName:Folder LocalFolder --copy-links --no-gzip-encoding --no-check-certificate --allow-other --allow-non-empty --<span class="hljs-built_in">umask</span> 000<br><br><span class="hljs-comment">#eg. DriveName:Folader ==&gt; GoogleDrive:/   LoacalFolder ==&gt; /data1/shu </span><br><br><span class="hljs-comment">#rclone取消挂载</span><br>fusermount -qzu &lt;本地路径&gt;<br></code></pre></td></tr></table></figure><p>参考链接： <a href="https://www.moerats.com/archives/481/">https://www.moerats.com/archives/481/</a></p><h4 id="2-从google-drive中使用wget下载单个文件"><a href="#2-从google-drive中使用wget下载单个文件" class="headerlink" title="2. 从google drive中使用wget下载单个文件"></a>2. 从google drive中使用wget下载单个文件</h4><p>1.下载小文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget --no-check-certificate <span class="hljs-string">&#x27;https://docs.google.com/uc?export=download&amp;id=FILEID&#x27;</span> -O FILENAME<br><br><span class="hljs-comment">#有的评论说针对rar文件需要加上-r</span><br>wget --no-check-certificate -r <span class="hljs-string">&#x27;https://docs.google.com/uc?export=download&amp;id=FILEID&#x27;</span> -O FILENAME<br></code></pre></td></tr></table></figure><p>2.下载大文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget --load-cookies /tmp/cookies.txt <span class="hljs-string">&quot;https://docs.google.com/uc?export=download&amp;confirm=<span class="hljs-subst">$(wget --quiet --save-cookies /tmp/cookies.txt --keep-session-cookies --no-check-certificate &#x27;https://docs.google.com/uc?export=download&amp;id=FILEID&#x27; -O- | sed -rn &#x27;s/.*confirm=([0-9A-Za-z_]+)</span>.*/\1\n/p&#x27;)&amp;id=FILEID&quot;</span> -O FILENAME &amp;&amp; rm -rf /tmp/cookies.txt<br><br></code></pre></td></tr></table></figure><p>PS:注意都是下载的文件，不是文件夹; folder目前找到的解决方案是使用循环</p><p>参考链接： <a href="https://gist.github.com/iamtekeste/3cdfd0366ebfd2c0d805">https://gist.github.com/iamtekeste/3cdfd0366ebfd2c0d805</a></p>]]></content>
    
    
    <categories>
      
      <category>工具相关</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>command-related</title>
    <link href="/2021/11/08/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/command-related/"/>
    <url>/2021/11/08/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/command-related/</url>
    
    <content type="html"><![CDATA[<h4 id="1-让远程服务器节点使用本地节点的vpn进行翻墙，-适用于远程节点"><a href="#1-让远程服务器节点使用本地节点的vpn进行翻墙，-适用于远程节点" class="headerlink" title="1.让远程服务器节点使用本地节点的vpn进行翻墙， 适用于远程节点"></a>1.让远程服务器节点使用本地节点的vpn进行翻墙， 适用于远程节点</h4><p>方法一：<br>假设，服务器上你选择使用端口18860，先在你的mac上运行命令：ssh -C  -N -g -R 18860:127.0.0.1:7890 服务器用户名@服务器ip  然后在服务器运行：export https_proxy=<a href="http://127.0.0.1:18860/">http://127.0.0.1:18860</a> 那么当服务器使用Https去下载东西的时候，就会通过端口18860把下载请求转发到你mac的7890端口，然后你的Mac作为一个代理进行下载，服务器就能获取目的网址的内容了。当你下载完的时候，记得unset https_proxy</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh -C  -N -g -R 18861:127.0.0.1:7890 zhinengjisuan@10.5.30.42 -o ProxyCommand=<span class="hljs-string">&quot;ssh shu@10.5.26.19 -W %h:%p&quot;</span><br>shu@10.5.26.19<span class="hljs-string">&#x27;s password: </span><br></code></pre></td></tr></table></figure><p>方法二: 使用terminus节点，建立一个新的连接，配置如下<br><img src="command-related/image-20211207175530810.png" alt="image-20211207175530810"><br>这个节点相当于加了方法一的命令 <code>ssh -C  -N -g -R 18860:127.0.0.1:7890 服务器用户名@服务器ip</code></p><p>然后运行一下proxy脚本,相当于方法一的第二条命令，具体的脚本内容如下:意思是bash一停（exit）, 这两条命令的效用就停止了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-built_in">export</span> http_proxy=http://127.0.0.1:18880<br><span class="hljs-built_in">export</span> https_proxy=https://127.0.0.1:18880<br>bash<br></code></pre></td></tr></table></figure><p>PS: 18860是随机选的端口， 7890的clashx的代理端口<br>只能使用curl, 不能使用ping 因为ping是在TCP协议之上的，但是curl是http协议（具体见操作系统）</p><h4 id="2-查看端口号被哪个进程占用"><a href="#2-查看端口号被哪个进程占用" class="headerlink" title="2. 查看端口号被哪个进程占用"></a>2. 查看端口号被哪个进程占用</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo lsof -i :7891<br></code></pre></td></tr></table></figure><ol start="3"><li>conda安装torch 1.8.0版本</li></ol><p><code>conda install pytorch==1.8.0 torchvision==0.9.0 torchaudio==0.8.0 cudatoolkit=10.2 -c pytorch</code></p><p>pip install torch==1.8.0+cu101 torchvision==0.9.0+cu101 torchaudio==0.8.0 -f <a href="https://download.pytorch.org/whl/torch_stable.html">https://download.pytorch.org/whl/torch_stable.html</a></p><p>//1.8.0 如果运行起来还是非常慢的话，修改为1.7 因为1.8.1稳定版本需要gpu驱动大于hec01 440.33<br>pip install torch==1.7.1+cu101 torchvision==0.8.2+cu101 torchaudio==0.7.2 -f <a href="https://download.pytorch.org/whl/torch_stable.html">https://download.pytorch.org/whl/torch_stable.html</a> -i <a href="https://pypi.douban.com/simple">https://pypi.douban.com/simple</a> some-package</p><ol start="4"><li>查看并杀死vscode 进程 macos<br><code>pgrep -f &quot;vscode&quot; | xargs kill</code> 或者 <code>pgrep -f &quot;vscode&quot;</code> 查看进程号之后使用 <code>kill -9 pid</code></li></ol>]]></content>
    
    
    <categories>
      
      <category>工具相关</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hexo 相关笔记</title>
    <link href="/2021/11/08/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/hexo-notes/"/>
    <url>/2021/11/08/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/hexo-notes/</url>
    
    <content type="html"><![CDATA[<h4 id="hexo-主题切换"><a href="#hexo-主题切换" class="headerlink" title="hexo 主题切换"></a>hexo 主题切换</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs php">git <span class="hljs-keyword">clone</span> xxx.git themes/black-blue <span class="hljs-comment">//注意在blog路径里面</span><br><br>vim _config.yml <span class="hljs-comment">//修改theme为black-blue</span><br><br>npm install --save hexo-renderer-jade hexo-<span class="hljs-built_in">generator</span>-feed hexo-<span class="hljs-built_in">generator</span>-sitemap hexo-browsersync hexo-<span class="hljs-built_in">generator</span>-archive<br><br>hexo clean<br><br>hexo g<br><br>hexo s<br><br></code></pre></td></tr></table></figure><p>hexo建立某一个目录下的blog</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new blog -p leetcode/new_name.md<br></code></pre></td></tr></table></figure><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://juejin.cn/post/6978377036645531662">https://juejin.cn/post/6978377036645531662</a></p>]]></content>
    
    
    <categories>
      
      <category>工具相关</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
