---
title: 暂时未看
catogory:
  - leetcode 题目汇总
categories:
  - leetcode
date: 2021-11-13 17:23:20
tags:
---

1. 堆排序和其他排序内容，面试前过一次

堆排序已经看，主要思路：
先对每个内部节点进行heap_build,然后每次将0交换到i位置（n-1 到0），然后对0~i-1进行heap_build；
heap_build：先对左右排序，在对root排序，如果当前root没有交换，那么退出递归程序，否则递归root=flag, heap_build


2. 字典树
前缀树也不一定要有value字段，当value的数字的时候，也可以直接用下标代表value，而不用记录value这个字段
前缀树经典例题： 
- lc648. 单词替换(前缀单词查找，注意类函数需要申明为public, 26个字符（如果申请小于26个会报错），而且最初建立的对象是指针 Trie *t=new Trie()， t->search, t->findPrefix)
- 1268. 搜索推荐系统
- 字典树变形:在字典树中加入一个set<string> bags 来存储前缀包含该路径的前3个字符串，在每将字典里面的字符串插入这棵数的时候，将经过路径的所有字符的bags都插入这个字符串， 如果大于size, 就删除最后一个元素，bags.erase(--bags.end());
vector<string> tmp(cur->bags.begin(), cur->bags.end());//set元素赋值给vec, vec反过来赋值一样的
易错点：在收缩的时候，如果发现字典树都找不到这个字符了，那么直接break, 然后s.size()-res.size()大小全部push为 空的vec<string>

其他字典树的相关题目：1032. 字符流



   例题：子数组的最大异或和：
- 方法一：可以求前缀异或和，然后遍历每个下标j前面的i XOR(i,j)=XOR(o,j)^XOR(0,j) 时间复杂度O(N^2)
- 方法二：建立XOR的前缀树，然后计算每个以j结尾的数组能够获得的最大异或值，使用，遍历当前j值的二进制位（从31-0），比如j=00111, 那么走过的路径最好为01000，也就是符号相同，其余位置相反最好，
如果之前值没有这个路径那么就取有的唯一那条路径（因为每个节点只有0 1两种情况

3. 布隆过滤器，判断一个值是否在集合中：
使用多个hash函数将输入映射到布隆过滤器 bitMap的多个位置，那么在进行判断一个输入是否存在的时候，可以根据如果计算出位置有一个位置没有被标记，说明这个数一定不在集合中，如果都被标记，那么说明可能在集合中。
何根据失误率 p 和样本数 n 来确定布隆过滤器大小 m


4. Dijstra算法，单源和多源最短路径


5. 查找无序数组的最小k个数，使用BFPRT算法，相当于快速排序，但是在寻找pivot上进行了修改，将数组按照5
个一组，找到每个组内的中位数，然后重复上述过程（也就是找中位数的中位数，直到最后只有一个数）


6. skyline问i
P446

7. 位运算相关：下一个数


8. 大数运算的相关题目，运用字符串进行加减乘除

9. 面试题 16.09. 运算 只使用加法，不使用位运算实现减法，乘法，除法
因为不使用位运算，因此只能累加，不能使用幂积法，因此需要将count对应value值存在vector之中，然后计算的时候，倒着计算，因为无法计算当前count/2是多少，不能正着加
因此只能倒着减

- 易错点：1.注意特殊情况，可以直接返回结果；2.注意数据可能有正负，因此需要都转为正数，然后最后结果判断是否需要加上符号
if(neg%2!=0){
    return -res;
} 可以用计数法判断正负号

