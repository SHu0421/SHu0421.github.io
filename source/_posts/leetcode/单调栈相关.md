---
title: 单调栈
category:
  - leetcode 题目汇总
tags: '栈, 单调栈'
categories:
  - leetcode
date: 2021-11-13 16:51:36
---


### 单调栈相关题目：

1. 去除重复字母
    - 使得去除重复字母之后，字符串的字典序最小
    - 值栈
    记录剩下字符串中是否包含这个字符，如果包含，那么就可以弹出（如果当前字符比这个字符小，就弹出）

2. 接雨水
    - 方法一：每个地方能接的雨水是当前下标左右两边最大值（LeftMax and RightMax）的较小一个 -->值栈
    - 方法二：使用单调递减栈，维护top and left（单调栈的top下面的值） -->下标栈

    接雨水II:
    - 二维接雨水
    - 上下左右四个方向分别取最大值再求短板这种想法在二维接雨水中，是不能获得正确结果的。
    - 正确的解法是，先将矩阵的外围放入优先队列中，然后取出最端的一个点，更新它四周的（需要使用vis数组，有的更新过就不能更新了），
    如果没有被vis而且当前点比他高，那么res+=h-matrix[i][j], 然后将改点压入栈中（高度为max(h, matrix[i][j])）；否则直接压入栈中


3. 直方图最大矩阵面积
    - 求离当前直方图左右两边第一个小于该直方图的下标，使用左边单调递增+右边单调递增
    - 注意边缘的节点，因此需要提前向栈push -1或者size， 作为哨兵节点
    - 下标栈


4. 围成矩形的最大面积 
    - 转为每行的直方图的最大面积 O(mn)，转为单调栈求左右第一个比当前数小的下标
    - （下标栈）
扩展： 最大正方形：使用dp
    ```C++
        for(int i=1;i<=m;i++){
            for(int j=1;j<=n;j++){
                if(matrix[i-1][j-1]=='1'){
                    dp[i][j]=min(dp[i-1][j-1],min(dp[i-1][j],dp[i][j-1]))+1;
                    result=max(dp[i][j],result);
                }
            }
        }
    ```
    最大正方形框：尾货left和up的最长，然后分别走到另外框边缘两个点进行判断是否符合，不符合的话使用循环，减小当前判断的值

5. 公式字符串求值
    - 可以遇到（）后进入递归，或者压入op栈中.注意（-15）这种要特别判断，if(s[i]=='-') && if(i==0||s[i-1]=='(') 那么就循环获得一个负数（括号可以进入op栈中，也可以直接跳过）
    - 在计算优先级的时候：可以不用传入两个判断，可以给每一个运算符一个分数
    ```
    int grade( char op ) {
        if (op == '(') return 1;
        if (op == '+' || op == '-') return 2;
        if (op == '*' || op == '/') return 3;
        return 0;
    }
    ```

6. 逆波兰表达式

7. 滑动窗口的最大值
    - 可以使用优先队列， 单调递减的双向队列
    - 一定要注意最开始压入0~k-1个字符的时候，就要压入一个结果，而不是下一个压入前面一个字符的结果，因为这样可能导致压入少一个字符
    - 前pop deque中后面小于当前元素的值，再pop deque前面超过len的值
    - 因为滑动窗口可以看成一个队列，所以这个题也可以实现找队列中最大值，而且队列没有滑动窗口一样有size的限制

8. 频率最高的k个字符
    - 使用大小为k的最小堆，其实也是使用优先队列实现的堆，需要自定义排序方式
    ```C++
        // 小顶堆
        class mycomparison {
        public:
            bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {
                return lhs.second > rhs.second;
            }
        };
    ```

9. 有的模拟题也是用栈的，
    - 比如文件的最长路径，栈中维护递增level的长度，如果当前的level<栈顶的level那么弹栈；如果遇到当前是文件，那么统计栈中元素加起来的值和result比较取最大
    - 这种题一般需要对token先进行划分，然后进行统计

10. 移掉 K 位数字
    - 使用单调栈，如果当前的字符小于栈顶的元素，那么循环弹出。易错点：剩下的字符包含头部0元素，以及最后如何结果为空字符串的话，应该返回“0”而不是“”

11. 下一个更大元素|| 

    - 题意：找到每个元素后面，第一个大于当前元素的数
    - 我的解法：从后往前，前面在进行判断的时候使用后面的nextid,可以跳过一些数，next[i]==-1表示没有比当前数更大的，next[i]==-2表示当前数还没有计算 nextid有值那么直接进行跳转nextid=next[nextid]
    - 官方题解：单调栈，但是因为是训练列表，所以需要遍历n+n-1个数据


12. 子数组的最小值之和
    - 题意：这道题求每个数左边比他小的第一个数的下标，和右边第一个比他小于或等于的数的下标
    - 解决：使用单调递减栈； 结果就是：arr[i]*(i-left[i]) * (right[i]-i)
    注意为了处理两个数相同的情况，使用左边小于，右边小于等于！！！ 
    - 比如：1 2 4 8 1

13. 最小栈
    - 题目：如何用时间O(1)和空间O(1)的复杂度得到栈中的最小值
    - 解决：原始的数据栈用来记录数据与min的差值 （value-min），同时用一个min变量记录当前栈的最小值;注意如果数值没有限制的话，差值的计算可能会溢出。
        - getmin()：始终返回min变量的值
        - void pop(): 如果栈顶元素小于0，那么说明当前栈顶元素就是min(如果需要返回栈顶元素只，那么返回min),同时更新min为min-stack.top();否则不更新min
        - void push(value): 当栈为空，直接压入value, 令min=value, push(0); 如果不为空，计算 value-min，并压入栈中; 如果小于0, 那么修改min为value, 否则min不变。
        ```C++
        public class 设计一个有gitMin的栈 {

            private Stack<Integer> stack = new Stack<Integer>();
            private int min;
            
            public void push(int x) {
                if (stack.isEmpty()) {
                    min = x;
                    stack.push(0);
                } else {
                    // 计算差值
                    int compare = x - min;
                    stack.push(compare);
                    // 如果差值小于0，显然 x 成为最小值，否则最小值不变
                    min = compare < 0 ? x : min;
                }
            }

            public void pop() {
                int top = stack.peek();
                // 如果top小于0，显然最小值也一并会被删除，此时更新最小值
                min = top < 0 ? (min - top) : min;
                stack.pop();
            }

            public int getMin() {
                return min;
            }
        }

        ```

### 括号相关的题目专题
**总结:** 一般来说括号相关的题使用栈解决，但是有的题目也使用动态规划解决。同时栈的方式也可以演变为更加简单的整数加减问题，不需要额外的空间。左括号出现那么+1， 右括号出现那么如果有左括号，那么左括号-1否则右括号+1

1. 有效的括号字符串
    - 因为*既可以当左括号，又可以当右括号，又可以当空白字符
    - 因此需要两个栈，当左括号栈为空的时候，从星号栈弹，否则从左括号栈弹、如果最后左括号不为空，那么比较信号栈顶和左括号栈顶下标，如果星号栈顶下标大，那么同时弹出，重复上述过程
    - 如果是动态规划的话； 就是判断dp[i][j]是否为true, 判断标准是 如果i=='('或者'*' 且j==')'或者 ' *'那么dp[i][j]=dp[i+1][j-1] 同时遍历i 到j之间的每一个元素，dp[i][j] |=dp[i][k]&&dp[k][j] (发现为true就break)
    类似长度的动态规划（最长回文子串）
    len==1 s[i]=='*' dp[i][i]=true
    len==2 (s[i]=='('||s[i]=='*' ) && (s[j]==')'||s[j]=='*')

2. 括号的生成，使用dfs， 左括号的数量应该时刻保持>=右括号的数量， 因此可以使用每使用一个左括号，可使用的右括号数量+1， 左括号：n->0, 右括号：0->n

3. 最长有效括号（动态规划中也有总结）

    ```C++
    public int longestValidParentheses(String s) {
            int maxans = 0;
            int[] dp = new int[s.length()];
            for (int i = 1; i < s.length(); i++) {
                if (s.charAt(i) == ')') {
                    if (s.charAt(i - 1) == '(') {
                        dp[i] = (i >= 2 ? dp[i - 2] : 0) + 2;
                    } else if (i - dp[i - 1] > 0 && s.charAt(i - dp[i - 1] - 1) == '(') {
                        dp[i] = dp[i - 1] + ((i - dp[i - 1]) >= 2 ? dp[i - dp[i - 1] - 2] : 0) + 2;
                    }
                    maxans = Math.max(maxans, dp[i]);
                }
            }
            return maxans;
        }
    ```
    另外的解决方案：使用栈，栈底需要提前push一个-1
    不需要额外的空间：需要两次遍历
    - 从左向右：如果left==right 更新答案，如果right>left 重新设置left=right=0;
    - 从右向左：如果left==right 更新答案，如果left>right 重新设置left=right=0;
<font color=red> 4. 删除无效的括号 </font>
    - 因为是需要知道删除后所有有效的情况，所以应该dfs，同时难点在于去重
    - solution: 先计算得到要删除的左右括号的数量，然后再dfs求所有合格的情况
    - 和其他dfs不一样在于，dfs遍历的是删除的括号，而不是留下的括号
    - 使用dfs的两种剪枝技巧：
        1. 不重复遍历相同的 if i!=cur && char[i]==char[i-1] continue
        2. 记录当前左括号和右括号的数量，只有左括号的数量大于等于右括号，再遍历需要这个右括号的这种情况，否则就不遍历这种情况（这道题没用）
    - 注意这道题在进行递归的时候，不是一个字符一个字符的判断到底加不加当前的字符，而是使用一个循环，从当前字符遍历到最后一个字符，然后将当前字符前面和后面的字符串进行拼接， 然后仍然从当前遍历的下标，进入下一个循环。通过这种方式可以跳过一些重复的循环， 比如（（（）， 这种方式只需要移除一个（ ， 没必要每个进行判断

    回溯+剪枝+去冗余（set/循环去）+括号匹配check, 这道题是遍历删除的字符，而不是留下的字符，因此需要用到path.substr，来进行删除后字符串的重新组合
    
    - 这道题可以扩展出另外一个题：如何判断一个字符串应该删除多少左括号，多少右括号使得剩下括号有效
    ```C++
    left=0, right=0; //需要删除的左右括号数量
    for(int i=0;i<size;i++){
        if(s[i]=='('){
            left++;
        }else{
            if(left>0){
                left--;
            }else{
                right++;
            }
        }
    }
    ```


<font color=blue>5. 最多能完成排序的块 I/II</font>
    - 总结：==最大的元素标记了一个段==
    - 题解

        1. 无重复的元素：可以直接i==maxnum的时候res++
        2. 有重复的元素
            使用单调栈
            1.如果大于等于栈顶，直接入栈， 也就是重复元素是可以单独成块的
            2.如果小于，那么将栈顶下面小于当前值的元素pop掉，然后压入原来的栈顶


<font color = red>6. 基本计算器/基本计算器||/基本计算器||| （表达式中可能有空格）</font>
第一个是只有正负符号和括号，（直接将括号展开）因此不需要转化逆波兰，只需要一个递归符号的栈+一个当前数的前面的符号就可以了；res+=s.top()* sign *num   易错点：注意在（ 要手动赋值当前的sign=1
第二个是有+-*/ ，但是全是正整数，因此只需要逆波兰，一个数字栈一个符号栈，在压栈的同时，根据优先级计算结果，同时在最后判断符号栈是否为空，如果不为空的话，需要将符号栈里面的元素逐个弹出
第三个是有+-*/ 和括号，如题2，在（压入栈中，在）依次弹出符号栈中的符号
第四个，自己的扩展，在第三个上面加上数据可以为正负； 难点在于判断-是负号还是减号
    1）将所有空格去掉 ，题目必须保证两个运算符号不会同时出现
    2）在num里面压入0，因为可能出现-(2+6)这种情况
    3）在（-变为（0-；将（+ 变为（0+
    4）题解如第三题




7. 16. lc362. design-hit-counter
这道题和单调没有什么关系，主要是队列
- 这道题让我们设计一个点击计数器（设计数据结构），能够返回五分钟内的点击数，提示了有可能同一时间内有多次点击。
- 由于操作都是按时间顺序的，下一次的时间戳都会大于等于本次的时间戳，那么最直接的方法就是用一个队列queue，每次点击时都将当前时间戳加入queue中，然后在需要获取点击数时，我们从队列开头开始看，如果开头的时间戳在5分钟以外了，就删掉，直到开头的时间戳在5分钟以内停止，然后返回queue的元素个数即为所求的点击数，
- follow up： 比较重要，因为在每个时间戳可能有多个数，所以可以用两个300大小数组，记录时间戳和点击数，节省时间和空间，每个时间戳应该放在timestamp%300的位置，因为多个timestamp映射同一个位置，所以需要先判断当前位置是不是放的当前这个数；然后read的时候，遍历300次，如果满足在5分钟内的条件，就res+=times[i]
- 解题链接：https://www.cnblogs.com/grandyang/p/5605552.html




<font color=red>8. lc456. 132 Pattern</font>
- 找到是否存在132这样的数对
- 枚举3， 然后维护遍历到3左边的最小值，那么就找到了1， 问题的关键在于如何找到2， 就是找到3右边最大小于3的数
- 方法1： 使用单调栈（找到每个数右边，第一个小于这个数的最大数，注意不是第一个小于他的数，而是小于他的最大数）进行预处理，并将结果存在一个vector中，时间复杂度为O(nlogn)
第一个小于他的数： 左到右， 单增
第一个小于这个数的最大数：二分查找（multiset） 转为找到第一个大于leftmin的数

- 方法二：使用栈记录3（左到右，递增，3越来越大）， 变量记录2，使得3 2都尽可能大; 然后枚举1，如果1小于当前变量记录值two，那么return true;
在这个过程中，two会逐渐变高，不会出现two下降的情况
```C++
int two = INT_MIN;
for (int i = size - 1; i >= 0; i--)
{
    if(nums[i]<two){
        return true;
    }
    while(!s.empty()&&nums[i]>s.top()){ //找到小于他的最大值, 逐渐增大two
        two = s.top();
        s.pop();
    }
    s.push(nums[i]);
}
```

类似的一个题: lc334. 递增的三元子序列 （类似模式123）
- 找到i, j, k使得nums[i]< nums[j] < nums[k]
- 使用一个单调递增栈，同时不断减少当前数字在栈中位置的那个数， 比如1 5，7 后来访问到 3改为 1， 3， 7（一定注意使用lower_bound） 类似最长递增子序列长度大于3
- 方法二：两次遍历，求每个数的leftMin 和rightMax, 看是否有一个数在两者之间


9. lc895. 最大频率栈
- 这个和LFU有点相像，但是实际上是不同的， LFU是删除最低频率的元素，但是这个是删除最高频率的栈中元素
- 因此不需要每次改变频率的时候都从原来的频率栈中弹出，同理，每次减低频率的时候，也不用弹出+加入新的频率
- 实际的解决方法用两个hash, 一个存储<k, freq> 一个存储<freq, vector<k>>/<freq, stack<k>>
- 一定要注意这两个hash一定要同时修改，不能只修改一个，频率包含的元素在变，元素当前的频率在变
- LFU是使用unordered_map<int, NodeList*> 存储频率到一个双向链表； 以及一个unordered_map<int, Node*> 存储key到节点的位置


<font color=red>10. lc6080. 使数组按非递减顺序排列(mid实际上有hard难度)</font>
- 找到每个数左边第一个比该数大的数的距离的变形题目
- 题意：每轮删除相邻的 nums[i - 1] > nums[i] 的 nums[i]， 问删除多少轮，使得数组变为 非递减 数组
- 解决方案：
    - 使用单调栈找到每个数左边第一个比他大的数，那么就是最大的跨度
    - 易错点：<font color=red> 因为中间的数是可以合并的 </font>，所以不能用每个数的最大跨度的最大值作为最后的结果，而只能用找到左边第一个比较大的数过程中 弹出的每个数的 合并间隔 的最大结果+1 作为当前数的合并最大间隔。
    - 比如：[14,13,2,6,13]最大间隔是4， 结果是3， 因为13， 2在第一轮删除， 6在第二轮删除， 13在第三轮删除
    - 思路类似的别人解法：https://leetcode.cn/problems/steps-to-make-array-non-decreasing/solution/dan-diao-zhan-by-haodong-du-p5hc/

11. lc1438. 绝对差不超过限制的最长连续子数组
- 两个双端队列可以用来记录一个滑动窗口的最大最小值




### 总结
ok 

1. 一定要清楚是单调递增栈还是单调递减栈；判断是单减栈还是单增栈的关键：是弹出的元素对后面的结果不会有影响。同时要注意push的是下标还是值

2. 栈适合题目：括号相关，左右的第一个最大最小，表达式求值，模拟文件层数，树结构题目，数字数组（也可能用二分）操作。

3. 括号是否匹配也可以转为整数加减问题

4.表达式求值可以直接将表达式转为逆波兰，在对逆波兰求值；或者直接用一个栈求值
第一种方法：使用一个结果栈（vector<char>），一个符号栈；如果遇到数字，直接压栈；如果遇到（，压栈；反括号，弹出符号栈中所有符号到结果栈，直到遇到（，并弹出（；运算符，如果符号栈顶符号优先级高于当前栈，那么弹出并压入结果栈，否则直接压入符号栈；最后如何符号栈有值，那么弹出所有符号到结果栈；注意是否有正负， 字母这些边界情况的处理

5. 求每个数右边第一个比当前数大的数，使用单调递增栈（栈顶到栈底），弹出的时候进行判断
//正序遍历求右边，用单调递增栈（栈顶到栈底），弹出的时候判断；逆序遍历，单调递增栈 
注意：单增还是单减，看从栈顶到栈顶，不是栈低到栈顶
（底部）1，2，3，4，5（头部）   是单调递减

6. 口诀：左右两边第一个比他大的数，用单调递增栈；比他小的数，用单调递减栈
    找较大，那么应该越远越大；找较小，应该越远越小

7. 滑动窗口可以看成队列，FIFO