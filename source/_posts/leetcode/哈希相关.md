---
title: 哈希相关+前缀和
categories:
  - leetcode
date: 2021-11-13 19:58:31
tags:
---

#### 前缀和 + hash题目汇总
一定要注意先判断hash[presum-target]是否存在并更新结果，再更新hash[presum]++， 因为可能nums[i]=0

例题：
面试题 17.05.  字母与数字，要求字母和数字个数相同，那么就是将字母转为1， 数字转为-1的时候，前缀和为0的最长序列；
另外使用这种思想是的”和等于 k 的最长子数组长度“ ”和等于k子数组“ （hash+前缀和）
```C++
//hash+前缀和的模板代码
hash[0]=-1;
int sum=0;
int res=0;
for(int i=0;i<nums.size();++i){
    sum += nums[i];
    if(hash.count(sum-k))  res= max(res,i-hash[sum-k]);
    if(!hash.count(sum)) hash[sum]=i; // 因为要的是第一次出现的值
}

```

 <font color=red>”1371. 每个元音包含偶数次的最长子字符串“</font>:
题解：为了表明每个元音出现了偶数次，可以使用二进制数，如果一个位经过一轮之后仍然为当前的值，那么说明这个位出现了偶数次或者没出现过，
通过这种方法可以类推到特定字符出现k数次，那么就使用k进制；同时注意是每个元音出现偶数次，而不是元音总个数为偶数次，如果是第二种情况
可以使用元音为奇数表示，sum%2==0表示元音个数为偶数）
    k进制的加法过程类似于大数相加


1. 连续的子数组和 注意这道题不是说连续的子数组为目标数，而是为目标数的倍数，但是仍然可以用这种方法来做，因为为目标数的倍数，意味着前缀和%该数得到的余数相同，因为可以用hash记录第一次出现该余数的下标，然后再次出现时，判断数组长度是否大于等于2， 一定要注意在开始的时候hash[0]=-1!!!

3. 连续数组 相同的0和1的个数，其实也是前缀和，只不过遇到0变为-1

4. 和相同的二元子数组
这道题是统计个数，之前是求最长为目标和的连续子数组，所有hash映射为sum的个数
注意一定要先查找hash[presum-target]，更新hash[presum]++
主要是针对0的情况，如果先更新hash就会报错
注意最开始要设置hash[0]要为1个


5. 统计「优美子数组」
将奇数转为1， 偶数转为0， 然后求和为k的子数组个数

#### 前缀和+单调栈
<font color=red>leetcode 1124表现良好的最长时间段</font>
题意就是转化为1， -1的数组，和大于0的最长连续子数组 （注意是和大于0，不是和最大）
解决方案： 整体思路：前缀和，对于每一个下标对应的当前的前缀和，应该求比他小的前缀和的下标最小的一个+这是1， -1的数组，因此前缀和应该是连续的
如果前缀和大于0，那么一定是从下标0到当前的数的长度最长
如果前缀和小于0，那么就是当前前缀和-1到当前的长度最长
先顺序遍历，如果当前数小于栈顶就push,否则continue(因为当前值不可能为最优)，然后逆序遍历，如果当前的前缀和大于栈顶，那么循环弹出，同时还需要更新最大结果，直到当前的前缀和不大于栈顶；遍历下一个数

<font color=red>类似的一个题目：962. 最大宽度坡 - 单调栈比较经典的题目</font>
- 这道题除了用正序单减栈+逆序遍历外，还可以用排序方法
- 排序方法：用结构体存储值和下标，然后按照值排序后，针对每个元素，找到它左边的元素中（都比他小），最小的下标（i - min(indexes_previously_written)） O(nlogn)


#### hash + 双指针
一定要注意返回的是元素还是元素的下标，一个可以排序使用指针，一个不能使用指针
两数之和：用双指针只能针对已经排好序的数组，没有排好序的数组，但是要求要返回下标，那么就用hash (unordered_set)
三数之和
四数之和：三重循环，因此有是三个去重的部分，不要只去重最后一层循环，忘了i j 层循环的去重

注意！！！
1. hash方法是不能去重的，要去重只能使用循环+双指针；同时返回坐标不能用双指针，返回值才能使用双指针
2. 去重放在==target的if语句之内（==循环去重==），同时可以用一些剪枝策略，但是要记得四个数相加可能出现溢出，所以如果要剪枝，记得强转为long型
```C++ 去重模板
while(i < j && nums[i] == nums[++i]);while(i < j && nums[j] == nums[--j]);

```
3. 数组不一定是排好序的，因此需要先对数组进行排序

变形：数组中的k-diff数对，这里只是换成了绝对值差，而不是目标值; 而且因为数组中存在重复的数字，因此需要先用set记录结果，然后再返回set.size
这道题也可以用排序+二分查找（找到目标的k+nums[i]），同时需要过滤掉已经找的数据

拓展：
注意前面三个题是可能包含重复的元素，但是需要返回不重复的元组对，下面这个题是找出所有的元组对，因此是包含重复的元组对的
<font color=red>题目：三数之和的多种可能</font>
解决方案：仍然是三数之和的方法的，但是在进行计算的时候， 需要判断左右指针指向的数是否相等，来计算可能组成的相同数对的个数
如果arr[left]!=arr[right]那么res+=hash[left]*hash[right] (用while循环找到hash[left]-相同数的数量，或者提前计算)
如果arr[left]==arr[right] res+=(right-left+1)*(right-left)/2

#### 代码模板（去重+找四数之和为target）
```C++
int size=nums.size();
sort(nums.begin(), nums.end());
for(int i=0;i<nums.size()-3;i++){
    while(i-1>=0&&nums[i]==nums[i-1]){
        continue; //去重
    }
    if((long) nums[i]+nums[i+1]+nums[i+2]+nums[i+3]>target){
            break;
    }
    if((long) nums[i]+nums[size-3]+nums[size-2]+nums[size-1]<target){
            continue;
    }
    for(int j=i+1;j<nums.size()-2;j++){
        if (j > i + 1 && nums[j] == nums[j - 1]) {
                    continue; //去重
        }
        if((long) nums[i]+nums[j]+nums[j+1]+nums[j+2]>target){
                break; //注意是break不是continue
        }
        if((long) nums[i]+nums[j]+nums[size-2]+nums[size-1]<target){
                continue;
        }

        int k=j+1, q=size-1;
        int find_num=target-nums[i]-nums[j];
        while(k<q){ //双指针
            if(nums[k]+nums[q]>find_num){
                q--;
            }else if (nums[k]+nums[q]<find_num){
                k++;
            }else if (nums[k]+nums[q]==find_num){
                res.push_back({nums[i], nums[j], nums[q], nums[k]});
                k++;
                q--;
                while(k<q&&nums[k]==nums[k-1]){ //去重
                    k++;
                }
                while(k<q&&nums[q]==nums[q+1]){
                q--;
                }
            }
        }

        
    }
}
```

> 参考链接：[四数之和答案](https://leetcode-cn.com/problems/4sum/solution/si-shu-zhi-he-by-leetcode-solution/)


#### HashMap的底层实现（java）
JDK1.7 的底层是数组加链表，而 JDK1.8 的底层是数组加链表加红黑树，红黑树相对于AVL树来说，牺牲了部分平衡性以换取插入/删除操作时少量的旋转操作，整体来说性能要优于AVL树。

使用hash函数（hash算法： index = HashCode（Key） & （Length - 1）），将数据放在数组中，如果数组已经将要放的位置满了，就使用链表链接在那个位置的后面；使用树是为了防止链表过长,设定阈值为8，那么大于这个阈值就将这个链表转为红黑树，小于6的时候链化， 避免查询时间过长。（8树化、6链化），而且设置为8个节点时，红黑树的性能优势也会开始展现出来，因此8是一个较合理的数字。

hashmap初始长度是16，每次扩展或者手动初始化必须是2的幂：是为了服务从key到index的hash算法：index = HashCode（Key） & （Length - 1），使得使用位运算计算的结果等同于取模（x mod 2^n = x & (2^n - 1)），也就是只取决于hashcode的二进制后面几位，只要HashCode本身分布均匀，Hash算法的结果就是均匀的，从而大大提高性能。

高并发情况下，hashmap可能会出现死锁
JDK1.7以及前是在头结点插入的，在JDK1.8之后是在尾节点插入的。，因为JDK1.7在多进程的情况下可能会出现死循环，由循环链表造成（rehash的时候，一个进程在e, next的时候挂起，另外一个进程已经将数据都扩容好，进程1又开始扩容），但是JDK1.8仍然可能会出现数据丢失（进程1要在插入时候，时间片用完，进程2插入元素在一个相同位置，进程1就会直接将进程2插入的元素覆盖），并发下扩容数据丢失


<font color=red>避免hash冲突的方法：</font>
开放定址法（再hash）
    线性探查：可能会出现大量的错误
    平方探查
    二次散列/平方探查：导致hash表空间利用率很低，出现大量重复

    优点：存储结构连续，因此查找的IO开销更小
    缺点：1）在插入的元素大于hash表的时候，需要扩容 2）hash表存储空间利用率低 3）删除操作的时间复杂度高，因为不能直接删除，因为它的后面可能有数据，因此需要设置删除标记，需要额外的空间 4）探查序列如何设计比较复杂可能会降低hash的性能

拉链法：
    可能导致数据存储的物理空间不连续导致大量I/O开销

    优点：1）对于记录总数是动态变化的情况比较好，不需要频繁扩容 2）存储空间动态分配，因此hash的空间利用率高 3）删除记录也比较方便
    缺点：1）因为使用的链表，因此在查询记录时，相比结构紧凑的数据类型（比如数组），哈希表的跳转访问会带来额外的时间开销 2)由于使用指针，记录不容易进行序列化（serialize）操作


例题：lc706. 设计哈希映射
- 使用链地址法实现，每个节点除了key val, 还需要一个next域, 然后使用vector充当数组
- 易错点：
    1. 删除的时候需要判断删除这个节点是否是头节点，和尾结点
    2. 插入的时候需要判断key是不是本身在hash中
    3. 指针在进行取值或者取下一个值（cur->key||cur->next）的时候，一定要保证这个指针(cur)不为NULL, 否则会报错

lc705. 设计哈希集合
- 这个和上面一题一样，不同的是这个不需要val字段，其余都相同


#### hash+动态规划
1. 最长定差子序列
转移方程： dp[arr[i]]=dp[arr[i]-diff]+1
因为不知道arr[i]的最大值，以及可能出现负数的下标， 所以直接使用hash，而不是数组
dp[x] 表示以 x 结尾的最长等差子序列的长度；


#### 分布式一致性hash算法
针对的问题是如何将数据均匀的分布在key-value的分布式缓存中，如果使用mod方法，均匀但是可能导致插入删除节点，所有的数据需要重新hash
1)第一种是将存储节点和数据都映射到一个首尾相连的hash环上，数据存储在hash环上顺时针的第一个节点，插入节点就只影响相邻节点的后续节点，对其他节点没有影响。但是可能造成不均衡的局面，
2）因此改进就是对一个存储节点使用虚拟节点，映射在环上的多个位置


### 前缀和和差分数组相关
一般是有关于矩阵的一维前缀和， 二维前缀和， 一维差分数组和二维差分数组
如果要计算差分数组和前缀和数组最好是将坐标转为 1-n，更好计算；不然sum i j对应的grid为i-1,j-1


一维差分数组中，如果数组中一段数据加上或者减去某一个元素，在差分数组中只有两头的元素进行了修改，中间的元素都没有修改
二维差分数组中，如果包含左上角（x1, y1）, 右下角（x2, y2）这一部分都+C, 那么对应的差分数组d[x1][y1]+c d[x2+1][y2+1]+c d[x1][y1+1]-c d[x2+1][y1]-c
(上升的对角线两端元素-c, 下降的对角线元素+c)

二维差分数组公式:
nums[i][j]-nums[i-1][j]-nums[i][j-1]+nums[i-1][j-1]=d[i][j]
从差分数组还原原来的数组
nums[i][j]=nums[i-1][j]+nums[i][j-1]-nums[i-1][j-1]+d[i][j]



例题：
1. 5931. 用邮票贴满网格图 (hard-周赛题目)

方法一: 使用二维前缀和，对原来矩阵中每个左上角为0，且邮票区域都为0的位置（二维区域前缀和为0），贴上邮票，为了减少贴这个过程的时间开销，使用二元差分数组
贴完后，对二元差分数组进行还原，如果仍然遇到为0的位置，那么返回false
注意这道题没必要求差分数组，差分数组可以全部直接初始化为0， 那么还原回来的也是填充数组
方法二: 不使用二维差分数组，使用另外一个数组，标记贴邮票的左上角，然后针对每个grid中为0的位置，计算邮票部分区域（注意是贴了邮票的矩阵，是另一个矩阵）的前缀和，如果为0，表示这个区域没有被贴上邮票，返回false

2. 航班预订统计 (middle)
一维差分数组的题目
如果原来数组的下标就是1-n的话，那么修改n-m部分的数据， 就会修改等差数列的d[n]和d[m+1]两个端点的数据


3. 拼车
这道题类似于天际线问题，使用hash, 左断点加入m个人，右端点减去m个人
然后遍历hash的每个key,如果有个时刻是大于capacity, 那么返回false

4. lc995. K 连续位的最小翻转次数（hard）
- 从左到右遍历，遇到0就进行翻转，使用差分数组进行假意翻转，通过presum累加来求得当前翻转的次数

### 前缀异或值
在求前缀异或的时候，结果数组可以从1开始取，这样的话就不用对边缘单独进行赋值操作
```C++
for (int i = 1; i <= m; ++i) {
    for (int j = 1; j <= n; ++j) {
        pre[i][j] = pre[i - 1][j] ^ pre[i][j - 1] ^ pre[i - 1][j - 1] ^ matrix[i - 1][j - 1];
        results.push_back(pre[i][j]);
    }
}
```


#### 总结
OK OK
1. 最长类似题目，可以使用dp, 前缀和，双指针，以及单栈+逆序遍历
2. 前缀和+hash可以做数组最长题目或者为目标类的连续子数组的个数，一个hash用来记录之前前缀和的下标，一个用来记录前缀和为sum的个数
（个数和长度问题）
