---
title: 滑动窗口
catogory:
  - leetcode 题目汇总
categories:
  - leetcode
date: 2021-11-13 17:22:03
tags:
---

#### 例题
1. 最小覆盖子串（两个字符串）
2. 不同字符的最小子序列（一个字符串）
  需要有一个hash来记录一个字符的剩余出现次数
  如果栈中没找到，从栈中弹出剩余出现次数大于0，而且大于当前字符的字符，然后压入当前字符
  否则直接将num[当前字符]--
3. 窗口内的最大值，使用的是单调栈
4. 未排序数组中，累加和为给定值的最长子数组
- 方法一： 滑动窗口 （使用了条件，数据全部为正数，如果没有这个条件就不能使用滑动窗口）
- 方法二： 使用hash记录一个sum出现的最早index,同时要记得压入hash[0]=-1 
  (PS: 累加和为给定值的子数组个数->hash)

- 补充问题1，正数和负数个数相等的最长子数组
    将正数转为1，负数转为0，求累加和为0最长子数组
- 补充问题2： 元素只有0和1的情况下，求0 和 1个数相等的最长子数组
    将0转为-1，1不变，求累加和为0的最长子数组

5. 未排序数组中，累加和小于等于给定值的最长子数组

6. 和小于等于K的最长子数组  以及 和不小于k的最短子数组leetcode 862
<font color=red>862. 和至少为 K 的最短子数组(hard)</font>
因为带有负数，所以收缩窗口不一定sum变小，和还有可能变大,所以滑动窗口不行
解决方案：使用前缀和+双端队列
  - 题目说明K一定是大于0的数
  - 如果当前的值比队尾小，那么循环弹出队尾部的值；
  - 如果队尾的值减去队首前缀和大于等于target，那么循环弹出首部的值（下标）,同时更新minlen (先pop前面再pop后面，或者先pop后面再pop前面都是可以的)
  - 易错点：一定要注意先push_back(0), 因为要处理只有一个元素的情况  [1] k=1

<font color=blue> 这道题可以和连续和大于0的最长序列（lc-1124:表现良好的最长时间段）一起看：
  - 求最长大于k使用前缀和+单调栈，求最短大于等于k使用前缀和+双端队列； 
  - 如果是求最长小于k（和小于k的最长序列），那么使用先遍历一次前缀和数组（小压栈，否则continue），得到底部到顶单增的栈，然后逆序遍历，求小于k的最长序列
  - 如果是求最长大于k（和大于0的最长序列），那么使用先遍历一次前缀和数组（小压栈，否则continue），得到底部到顶单减的栈，然后逆序遍历，求小于k的最长序列
  - 如果是求最短小于k（一般无这种问法）
</font>


<font color=red>7. 至少有 K 个重复字符的最长子串</font>
题意：子串中每个字符都需要重复k次
解决方案： 
- 滑动窗口，枚举窗口内包含的字符的总数，如果字符总数大于（1-26个字符26种情况下，每个字符至少k个）的最大长度，当当前窗口包含的字符数大于遍历的这种情况的话，收缩窗口， 末尾如果typecnt=k_num那么就更新答案

- 分治算法，先统计当前字符串，每个字符的频率，然后以小于k 的字符的任意一个作为划分点（感觉也可以放在一个集合，判断字符是否在集合内），将当前字符分为多个段，然后递归求解


8. 等差数列的划分，求个数问题 每个窗口包含的等差数列的个数=左右指针差-1（滑动窗口内包含子数组的个数计算）

9. 找到字符串的所有异位词，注意这个是两个指针之间只能包含这个词

  - 解法1：类似于needle数组，只有count==0判断right-left+1是否等于p.size() 然后收缩窗口，每次收缩的时候都需要重新判断 len是否相等
  - 解法2：维护一个和p 一样长度的窗口，如果当前字符频率数组==p的字符频率数组（vec1==vecb），那么说明找到一个异位词
  - 解法3：也可以使用一个count vector，表示两个字符串各个字符的差值，和一个diff变量，如果diff变量==0说明两个字符串相等。减左边1之后，如果count[i]==0，那么diff--,如果count[i]==-1, diff++；同理加右边1之后

PS:类似的题 最小覆盖子串（可以包含其他字符）， 至少有k个无重复字符的最长子串, lc 面试题 17.18. 最短超串(big字符串里面包含small字符串里面每个字符的最短串)
  - <font color=red>易错点：注意一定是needle[big[left]]++/--不是needle[left] or needle[right]</font>

模板 needle+count来判断
```C++
总结：count == 0的时候，先收缩不必要的字符再进行判断！！！！
int left=0, right=0;
        //right最好是包含这个字符
while(right<len1){

    if(needle[s[right]]>0){
        count--; 
    }
    needle[s[right]]--; //先减再判断
    if(count==0){
        //收缩字符
        while(needle[s[left]]<0){
            needle[s[left]]++;
            left++;
        }
        if(right-left+1<min_len){
            min_len = right - left+1;
            start = left;
        }
            needle[s[left]]++;
            count++;
            left++;
        }
        
        right++;
  }
```

<font color=red>10. 最少交换次数来组合所有的 1 II</font>
  先计算出有多少个1，假设为k个
  然后用一个固定大小为k的窗口，遍历数组，记录窗口内0的最小个数即为答案
  II和I的区别在于II是环形数组，因此需要遍历每一个start(包括==size, 此时end通过求余得到),但是I只需要遍历end<size

11. 水果成篮
题意是包含两种数据类型的最长子数组;使用typecnt， hash_cnt 和left right指针；当typecnt<=2对窗口进行扩， 否则进行收缩
用滑动窗口
注意是hash[fruit[left]]++/--不是hash[left]++/--


12. 最大连续1的个数III
滑动窗口，当当前的0的个数比k大，就收缩窗口，否则扩展窗口


13. 爱生气的书店老板
先将满意时的数据加起来，然后这些位置的值置为0，剩下的就是求滑动窗口的最大值

14. 尽可能使字符串相等
这道题转化的题意是，使得子数组（连续的数,开销都为正数）的和小于maxCost的最长子数组的长度
使用滑动窗口
```C++
 while(right<size){
      sum+=dist[right];
      while(sum>maxCost&&left<=right){
          sum-=dist[left];
          left++;
      }
      res=max(res, right-left+1);
      right++;
  }
```

另外一种方法是前缀和+二分，对于每个index, 二分找到前缀和大于等于presum[index]-maxCost的最小下标（lower_bound）


13. 可获得的最大点数
题意：只能从两端取数据，取得k个数据的最大值
solution: 滑动窗口size-k内元素之和的最小值, 其实也可以用区间dp解决，但是因为为造成三维dp[left][right][k]，因此会超出内存

<font color=red>14. 最高频元素的频数</font>
- 将整个数组进行排序，使用滑动窗口，枚举将窗口内所有的数转为右边界这个数的最长长度， l只会递增不会减少， r就是当前遍历的下标，因为之前的元素都已经转为num[r-1]，因此还需要消耗的数据只有(nums[r]-nums[r-1])*(r-l), 如果比给定的k大，那么收缩窗口
- 具有滑动窗口单增特性，r向右滑动，需要的数越来越大，l向右滑动需要的越来越小

15. 查找给定哈希值的子串
这个就是 字符串hash的一个例子，但是和常规的字符串hash不一样的是，字符串hash计算方式为
hash(s, p, m) = (val(s[0]) * p0 + val(s[1]) * p1 + ... + val(s[k-1]) * pk-1) mod m.

但是因为除法不满足取余的恒等性质，如果正序的话就会导致需要减去第一个数然后/power+最后一个数的值，会发生错误
因此需要倒序，减去当前的值，乘以power再加上新元素的值。（乘法满足取余恒等）
solution: 从右到左，滑动窗口计算k字符串里面的hashvalue （求后缀和，中间的那段的hash/滑动窗口从右到左，和从左到右的计算方式不同

另一种解法，适用于任何长度的字符串，仍然需要反向计算
与标准的不同之处：sum[i] 从sum[i-1]变为从sum[i+1], 计算hash由hash[right]-hash[left]变为hash[left]-hash[right]
https://leetcode-cn.com/problems/find-substring-with-given-hash-value/solution/zi-fu-chuan-ha-xi-zi-fu-chuan-chu-li-cha-v809/

PS:取模和乘法同一优先级：乘法都要在后面加一个%运算符， 减了一个元素，需要在取模前加上这个modulo；这道题也不能直接套用以前封装的的字符串哈希类，因为POWER 与 MOD 要互质(存在逆元) 才能调RK算法

16. lc713. 乘积小于K的子数组
- 求乘积小于K的连续子数组的个数
- 滑动窗口：具有增大窗口，值递增，减少窗口值减少，求所有满足条件子集的个数；如果增大窗口，值并不出现单调趋势，就不能使用滑窗


17. lc632. 最小区间
- 每个区间的数至少包含一个，其实就是1 3 2都要包含的最短区间问题，使用滑动窗口
- 使用最小覆盖子串解决


18. lc295. 数据流的中位数
- 使用两个优先队列/multiset来维护一个大顶堆和小顶堆
- 为了保证大顶堆和小顶堆数据量的平衡，可以使用偶数插入大顶堆， 并移除最大元素到小顶堆， 以及奇数插入小顶堆， 并移除最大元素到大顶堆的方法
```C++
set1.insert(num);
int tmp=*set1.begin();
set1.erase(set1.begin());
set2.insert(tmp);
```

19. lc480. 滑动窗口中位数

- 方法一：需要使用一个map来记录需要删除的数，进行延迟删除 mp[l]++; 这种方法，为了保证左右两边数据的平衡，可以用一个变量balance来记录，（small加一个数，balance++， 减一个数balance--） 使得balance维持0就行了
- 方法二：可以使用multiset来删除特定的数
- 因为large（小顶堆）应该始终比 small(大顶堆)的size 大于等于1, 因此可以通过这个来判断之后的数应该是插入大顶堆还是小顶堆

20.  lc424: 替换后的最长重复字符-这道题和和其他滑动窗口都不一样；主要是由于窗口内最多的字符是未知的，因为窗口即使收缩，长度也不会变小，不能以右边指针的字符代表整个窗口最后选定的字符！！！！！
```C++
       while(right<size){
            nums[s[right]-'A']++;
            maxn=max(maxn, nums[s[right]-'A']);//这个可以求到曾经滑动窗口中出现最多的字符数目，但是具体是哪个字符不知道
            if(right-left+1>maxn+k){
                nums[s[left]-'A']--;
                left++;
            }
            right++;
        }
        return right-left;
```


21. lc1438. 绝对差不超过限制的最长连续子数组
- 如何维护滑动窗口的最大值和最小值？
- 方法1：使用multiset的方法，使用*s.rbegin()- *s.begin()来找到最小和最大的差值，使用s.erase(s.find(nums[left]))来删除最左边的元素
- 方法2: 使用两个双端队列，分别维护滑动窗口的最大值和最小值，其中最大值q，存储元素类似一个单调递减的栈（当一个更大的值出现后，前面更小的元素都不可能成为窗口的最大值了，因此弹出，成为单调减队列；最前面最大值弹出后，后面下的一个数可能为窗口最大值）; 最小值q,存储元素的时候类似一个单调递增的栈；然后判断两个队列的差值是否在limit之内，如果不在就判断q_min和q_max的front是否是当前的nums[left], 如果是就弹出，否则就说明有可能之前就已经被弹出了。


#### 总结
ok 
1. 涉及连续子数组的两种方法：
  a.滑动窗口 
  b.前缀和+hash+二分
    - 如果是小于等于K的最长，那么使用二分查找，查找大于等于sums[i]-target的第一个下标index（向前查找）i-index+1  lower_bound 最后返回时候判断一下是否>=target
    - 如果是大于等于K的最短，那么使用二分查找，查找大于等于sums[i]+target的第一个下标index（向后查找）index-i+1
  (hash适用于==target, 滑动窗口适用于至多至少target，最长连续，最短连续这种情况)

3. 滑动串口count==0 先收缩再判断

4. 求子数组的个数，以及最长子数组， 可能使用滑动窗口(右边固定，左边每个都可以，子数组的所有个数)，可能使用hash+前缀和（和为k， 右边固定，左边部分可，部分不行），也可能两种都可以，注意区别。
如果固定了left到right之间的间距，一般用滑动窗口
而且区分子序列（不连续）， 子数组（连续）

5. 滑动窗口适合字符串/数组是连续场景，滑动窗口里面的字符是可能都需要，也能只需要子序列满足条件就可以

6. 如果字符串连续+长度固定，使用滑动窗口 （lc1423. 可获得的最大点数, 拿的点数是固定的，所以没必要使用动态规划， 使用动态规划三维数组，反而会导致错误）

7. 求滑动窗口的适合没有负数的场景，对于负数这种情况，不满足扩充窗口和变大，减小窗口和变小的规律（不满足单调性质），因此不使用于滑动窗口这种场景
对于包含负数的这种情况：求最短大于使用前缀和+双端队列，求最长大于或者小于k使用前缀和+单调栈，见例题6详细说明

8.滑动窗口使用与某一段连续只包含k中字符，只允许翻转k个数类似的题目， 同时也可以转为前缀和+二分来进行查找

9. 两端k个元素和最大的问题可以转为中间size-k个元素和最小的问题


10. 一种是right每次往右走，只要不满足条件，left就一直收敛。 另一种是，right每次往右走，如果不满足条件，left最多收敛一次（进阶）lc424:替换后的最长重复字符

11.如果遇到环形数组，那么将数组拉直解决，就是并列两个相同的数组aa






