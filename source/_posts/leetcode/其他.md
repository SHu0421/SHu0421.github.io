---
title: 其他问题
catogory:
  - leetcode 题目汇总
tags: 其他
categories:
  - leetcode
date: 2021-11-13 17:22:38
---

#### 数组相关问题
要将数字放在对应的位置上，使用原地交换的方式
1. 旋转矩阵  这个好像不行，需要记录交换过来的值的同时，记录交换过来的下标
2. 自然数数组的排序
3. 奇数下标是奇数，偶数下标是偶数

- 第一种方法，使用一个环来进行数据的交换
- 第二种方法，每个数据与当前的数据进行交换，然后判断当前交换过来的数据应该放到的位置，重复这样的过程，知道当前交换过来的数是应该放置的数

举个例子：
//如果下标i应该放的数据是 i+1 index和value之间存在映射
```C++
tmp=a[i];
while(a[i]!=i+1){
    int next=a[tmp-1];
    a[tmp-1]=tmp;
    tmp=next;
}

while(a[i]!=i+1){
    swap(a[i], a[a[i]-1]);
}
```

4. 最大子矩阵的和转为最大子数组的和，枚举每一行开始  i从0 ~ n-1,每次换开始的时候重新初始化数组s; j从i ~ n-1
二维转为一维
```C++
for(int i=0;i<matrix.size();i++){ //枚举row1
    int s[matrix[0].size()];
    for(int j=i;j<matrix.size();j++){ //枚举row2
        int cur=0;//从头开始
        for(int k=0;k<matrix[0].size();k++){ //转为最大子数组和
            s[k]+=matrix[j][k];
            cur+=s[k]; //利用之前加的值，加上现在的值
            res=max(res, cur);
            if(cur<0){
                cur=0;
            }
        }
    }
}
```

5. 边界都是1的最大正方形：
这种问题先想个暴力算法，然后考虑如何用空间换时间，加速判断的过程
- 1.先循环，找到每个点的right down数组，注意边界要单独赋值，从右往左，从下网上计算
- 2.遍历size（最开始初始化为m.size()和m[0].size()的最小值）, 每个size下遍历每个点，看左右边长以及右上角和左下角的right down是否都大于size,
如果是返回true,否则返回false


6. 数组partition的调整
使用双指针，一个指针指向排序好的末尾，一个指针指向待排序序列的头结点
```C++
int left=0;
int right=1;
while(right<length){
    if(arr[left]!=arr[right]){
        left++;
        swap(arr[left], arr[right]);
        right++;
        
    }
}
```

此类型的拓展问题，红蓝白球的排序，以及 0 1 2的排序
解决方案：记录一个左节点（初始化-1）右节点（length）中间节点：
```C++
int left=-1;
int right=length;//排好序的头
int index=0;
while(index<right){
    if(arr[index]==0){
        swap(arr[++left], arr[index]);
        index++;
    }else if(arr[index]==2){
        swap(arr[--right], arr[index]);//注意这种情况index还要继续判断，因此不能index++
    }else{
        index++;
    }
}

```

7. 网格中的最短路径和最短通路问题：
- 1.一定要分清楚是用dp还是bfs
- 2.如果是只能从左上往右下走，那么是dp,否则应该用bfs,同时因为是路径，因此需要一个额外的二维数组判断到当前节点需要的步数，或者另外申明一个node,
这个node里面记录到这个节点的步数


<font color=red>8. 缺失的第一个正数： /引申缺失的最大负数（原位hash或者置换）</font>
- 方法一：如何在原数组上进行hash,但是保留那个位置的数不变使用- 符号；(负数 0全部变为size)
  同时如果原来有符号，那么为了避免混淆，将原来为符号的数变为我们不关心的正数
- 方法二：使用置换的方式，这种方式一定要注意进入死循环的方式因此在交换的时候判断。nums[nums[i]-1]!=nums[i]



##### random类似题目总结：

rand5 to rand7
rand01p to rand6
rand1toM to rand1toN

```C++
1）  二维的方式，使得两个调用rand5在二维矩阵上是大于rand7，然后就可以选取7的倍数的一段距离对rand7取模
    do{
        row=rand5()-1;
        col=rand5()-1;
        num=row*5+col //0-24之间
    }while(num>=21)

    return num%7+1;

```
2)
首先等概率产生0-1  01 10是等概率残生的
```C++
int rand01(){
    do{
        num=rand01p();
    }while(num==rand01p());
    return num;
}

那么rand03=rand01()*2+rand01();
rand0-15=rand03()*4+rand03(); //倍数+插空  用进制的方法可以产生rand07()=rand03()+rand01()*4
那么rand6可由如下产生:
do{
    num=rand0-15;
}while(num>=12)
return num%6+1;
```

3）k维的方式
rand1toM()转为rand1toN()其实就是调用k次（用N的M进制可以求得）的rand1toM, 使得这a* M^(k-1)+b* M^(k-2)+……  +c 比n要小， 然后返回就可以了
其实就是用M进制的数来表示N-1，如果随机生成的数是大于N，那么从头进行生成（注意是从头，而不是从当前数重新生成），否则返回这个数
步骤：
   1、将n-1转换成m进制数，假设结果转换成数组为 k = [a,b,c,d,e]
　　2、使用rand1ToM(m)函数产生结果数组 res = [A,B,C,D,E]，如果res所表示的数值大于k所表示的数值，将res丢掉重新随机，直到产生的结果小于或等于k，这时产生的res的范围就在0～n-1之间，但是此时res所表示的数还是m进制的。 //随机生成M进制的每一位数
　　3、将res数组转换成10进制整数。
　　4、将步骤3的结果加1就是最终的结果。


##### 数学相关问题
1. 求num阶层中最后的包含0的个数，因为包含因子2的个数一定比5多，因此可以直接求包含因子5的个数
每5个数有一个5，每25个数中有一个数包含两个5
同样下面的模板可以用于求任何因子的个数
```C++
int func(int num){
    int res=0;
    while(num){
        res+=num/5;
        num=num/5;
    }
    return res;
}
```
<font color=blue>2. 判断一个点是否在矩形中：叉乘+点乘</font>
对角向量叉积的点积>=0,（对角向量的叉积方向相同），使用叉积的原因是：一个点在线外还是在线内，叉积的正负不同
使用叉积可以判断方向，A = <a1, a2>，B = <b1, b2>
AXB=a1* b2-a2 *b1, 叉积向量的方向为法线的方向，上下为第一个向量指向第二个向量，大手指的方向
叉乘加内积

(p1 p2 X p1 p ) * (p3 p4 X p3 p1)  >= 0  （四个边分成两组，每两个对边一组， 看两边的叉积是否同方向）

<font color=blue>3. 相同的题型：判断点是否在三角形中 叉乘</font>
1）先判断三个点的顺序是否是逆时针方向:逆时针方向叉积小于0；顺时针方向叉积大于等于（注意顺序可能导致结果不同！！！）；如果是顺时针正方向，那么调整点位置
2）然后判断这个点x是否都是在三角形每条边的左边，判断过程：三角形每个顶点和边的叉积小于0

（逆时针，点左侧；判断逆时针，仍然使用点左侧）

求三个三角形不推荐，因为double类型可能出现误差


<font color=red>4. 路径数组转为统计数组的题目：原地hash, 注意以负数作为标记的话，全部的数都需要转为正数</font>
要求额外的空间复杂度为O(1)
如果要实现空间复杂度为O(1),那么需要在原来的数据上进行运算，那么每个位置存储跳过来的位置（最开始节点存储为-1），直到当前的数为一个负数（表示已经求过距离），然后跳回去的时候就知道来的位置，同时更新当前的距离，
为了区分已经判断过的值和未判断过的值，使用负数；求到距离矩阵之后再计算每个距离出现的次数，仍然是使用跳的方式，开始节点记得赋值为0，表示已经访问计算过

这种方式也出现在”第一个未出现的正数“这道题解决方案中（值与下标相互映射）


5. 正数数组的最小不可组成和：
dp[0][0]=1
使用动态规划
for j=0; j=arr.size(); j++:
    for i = sum to min: //注意反着,因为一个数只能取一次0-1背包
        if(i>=arr[j]):
            dp[i]=dp[i-arr[j]]?True:dp[i]//注意是dp[i]而不是false,也不是dp[i]=dp[i-arr[i]]//因为可能一个数一种方式可以组成，但是另一种不行

PS:没有思路就想暴力算法，然后递归考虑是否能转为动态规划，类似背包问题
```C++
dp[i][j]=dp[i-1][j-arr[i]]||dp[i-1][j];

for i in min to sum:
    if dp[n][i] == false:
        return i
```

6. 累加出整个范围最少还需要的数:
使用当前可以累加得到的范围，如果范围超过了当前遍历到的arr的第一个数，那么下一个可以累加得到的范围是当前的范围+arr[i];否则下一个差的数应该是touch+1,可以累加得到的数是touch+1+touch

可以累加得到的数是touch,下一个差的数是touch+1
```C++
touch=0;
cnt=0;
for(int i=0;i<arr.size();i++){
    if(touch+1<arr[i]){
        while(touch<arr[i]+1){//注意这是循环
            touch+=touch+1;
            cnt++;
            if(touch>=range){
                return cnt;
            }
        }
    }else{
        touch+=arr[i];
        if(touch>=range){
            return cnt;
        }
    }
}
while(touch<range){
        touch+=touch+1;
        cnt++;    
}

    return cnt;
```

7. 一种字符串和数字对应的关系 （lc168. Excel表列名称）
A -> 1
B -> 2
C -> 3
...
Z -> 26
AA -> 27
AB -> 28 
从 1开始的的 2626 进制转换题。（每一位至少都有1）
- 方法1：
```C++
string res="";
while(columnNumber>0){
    columnNumber--;
    res+=(columnNumber%26+'A');
    columnNumber/=26;
}
reverse(res.begin(), res.end());
return res;
```

- 方法2：注意是K伪进制数，也就是每一个伪至少为1不能为0，因此需要先从右往左计算位数（同时每一位分得1, 因为这个规则每一位至少都有1），然后从左往右分剩下的数字 

```C++
//先从右往左，减掉一轮，再从左往右看补在哪为 进制如果为3：base=1 3 9
void int2str(){
    cur=1;//代表进制的基数
    k=0//代表位数
    base=3//代表进制数，多少个字符就是多少进制
    while(n>=cur){
        k++;
        n-=cur;
        cur*=base;
    }

    int index=0;
    while(k){
        cur/=base;
        res[index++]=getchar(n/cur);  //当前base的数量应该为n/cur+1,对应的下标就是n/cur
        n=n%cur; //剩下的数可以分多少到下一个进制位中
        k--;
    }
}
```


str2int类似于K进制

从N个数中等概率打印M个数,空间复杂度为O(1)：将每次打印的数每次交换到整个数组的末尾，然后下次在生成随机数的时候，减少生成范围（1，n-count）




8. 数字的中文表达和英文表达：
- 1.中文表达：对于零特殊处理
- 2.英文表达：每三个一组进行处理；使用递归或者迭代。递归方式就是分别求出billion million和thousand三个部分的数字，然后加起来，
在求每个部分的时候，先判断百位，如果百位有数字的话，那么加上”hundred“,否则分为数字<=10 <20; <=20 <100 and <10 三种情况进行处理


9. 实现sqrt函数
- 方法一：使用二分算法（一个数的平方根不会大于 n/2+1），标准二分，返回right

- 方法二：牛顿迭代算法： y=f(x0)+k(x-x0)
令y=0, 得到 x_i+1=(x_i+ C/x_i)  其中C为要求的目标
```C++
class Solution {
public:
    int mySqrt(int x) {
        if (x == 0) {
            return 0;
        }

        double C = x, x0 = x;
        while (true) {
            double xi = 0.5 * (x0 + C / x0);
            if (fabs(x0 - xi) < 1e-7) {
                break;
            }
            x0 = xi;
        }
        return int(x0);
    }
};
```

10. 小数的十进制转为二进制是*2 取整数部分，如果整数>=1, 那么num-=1,否则当前位为0， 直到num=0; 也可以1连除2，num如果num>base,那么减去base
十进制整数转换为二进制整数采用"除2取余，逆序排列"法
十进制小数转换成二进制小数采用"乘2取整，顺序排列"法


11. 全排列问题，使用交换或者vis+回溯，一定要注意是否有重复的字符，如果有重复的字符，那么下一个交换或者选择的数，一定是当前没有选择的 （可以和当前自己位置进行交换）


<font color=red>12. 树状数组例题：数字流的秩 线段树（平衡树+二叉搜索树，需要初始化4*n区间） 使用频繁更新数组的某一位（后面的位数也需要相应修改），以及求前缀和</font>
线段树和树状数组的基本功能都是在某一满足结合律的操作(比如加法，乘法，最大值，最小值)下，O(logn)的时间复杂度内修改单个元素并且维护区间信息。不同的是，树状数组只能维护前缀“操作和”(前缀和，前缀积，前缀最大最小)，而线段树可以维护区间操作和。线段数组是真正的数，而树状数组只是一个数组

树状数组主要是用于求前缀和，（改变原始然后求前缀和；差分数组适用于，某一段的元素被整体加上或者减去一个元素）
- 区间查询：求index的前缀和其实就是不断将index的二进制数的最后一个一个1逐渐变为0 的数据对应的值相加；（x-(x&-x)）//不断地去掉二进制数最右边的一个1 （从x到=n）
- 单点修改：更新一个index需要更新的其他下标的值相当于 不断加上最后一个1所代表的数字下标对应的值（x+(x&-x)）//从右边起一系列连续的1变为0，再把这一系列1的前一位0变为1,相当与最后一个1+1，导致连续进位
其中存储值的下标从1开始，0下标主要是判断循环的终点，不被用来存储值 （从x到0）

而且树状数组的下标从1开始，常用语频繁更新和频繁求前缀和
```C++
建立树状数组：
int n;
int a[1005],c[1005]; //对应原数组和树状数组
//范围是[1,n]
int lowbit(int x){
    return x&(-x);
}

void updata(int i,int k){    //在i位置加上k
    while(i <= n){
        c[i] += k;
        i += lowbit(i);
    }
}

int getsum(int i){        //求A[1 - i]的和
    int res = 0;
    while(i > 0){
        res += c[i];
        i -= lowbit(i);
    }
    return res;
}
```
树状数组如果输入有0， 那么所有的输入都应该向右边偏移以为（输入x，实际上对应x+1）

例题：lc5999. 统计数组中好三元组数目
这道题是求在一个数的左边，同时小于这个数的数量（数量题）
lc307. 区域和检索 - 数组可修改
- 这道题是，频繁的修改某个下标的元素值+同时求某个范围元素之间的元素和（值题目）
- 数组的大小为arr的范围n， 下标对于树状数组的二进制下标
- 需要先将num的值插入树状数组中， 然后更新的时候使用newvalue-ori[index]来更新当前节点后面的值，同时一定要记得更新ori[index]=newvalue !!!!
- 一定要记得树状数组的下标是从1开始，但是num的下标从0开始；而且区间范围是两边闭合，所以求区间差的时候，left_index应该减1

<font color=red>lc315. 计算右侧小于当前元素的个数（hard）</font>
- 注意这道题数据可能为负数，因此需要对数据+10000+1 使数据shift到[1, +无穷]
- 使用归并排序，每个i, j 那么num[i]+=j-i-1 (就是在i后面而且比nums[i]小的数的数量)
归并排序易错点：需要使用索引数组,同时在进行归并的时候会修改索引数组，一定要记得复制一个新的数组出来，不能使用原来的数组；其次就是注意数组的范围，左右都闭合；归并排序还长用于计算逆序对

lc493. 翻转对(hard)
- 归并排序
- 范围映射的树状数组（具体代码可见模板代码）


13. 最佳直线，使用暴力枚举的方式， 三重循环
    枚举直线两个起始端点(i, j)，后面遍历k是否在直线(i, j)上，在的话计算过得点个数进行更新， 最后判断这条直线上最多有多少个同点
    时间复杂度：O(n^3)
    空间复杂度：O(1)O(1)


14. 枚举题：模式匹配问题，暂时未做，主要是通过a和b的数量来枚举a匹配的字符的长度和b字符的长度，主要是注意边界情况应该先于长度的枚举进行判断
    example： pattern = "abba", value = "dogcatcatdog"
    注意：pattern只包含字母"a"和"b"两种字符， 而且a或者b可以为空串， 而且a 与b映射的字符串不应该相等
    lena lenb都为0; lena为0; lenb为0;lena lenb都不为0时， 他们映射的字符串不应该相等


15. 大数相乘的题目
- 使用第二个数的每一位数和第一个数相乘<< i 位，然后将求得的结果相加
- 使用第一个数的每一位和第二个数相乘，更新结果的 arr[i+k]位

16. 矩形覆盖面积： 公式为area1+area2-inter_area
inter_area = max((最小 右上横坐标 - 最大左下横坐标), 0)* max(（最小右上纵坐标 -  最大左下纵坐标, 0)

注意一定要和0进行比较


16. 找众数II:
- 使用hash算法
- 使用摩尔投票算法

找到超过 (n/3) 向下取整的数：数学证明这样的数最多2个，选两个数，如果当前的数都不等于前两个数，那么两个投票数都--
这种投票算法同样适用于找到超过 n/2

```C++
class Solution {
public:
    vector<int> majorityElement(vector<int>& nums) {
        vector<int> ans;
        int element1 = 0;
        int element2 = 0;
        int vote1 = 0;
        int vote2 = 0;

        for (auto & num : nums) {
            if (vote1 > 0 && num == element1) { //如果该元素为第一个元素，则计数加1
                vote1++;
            } else if (vote2 > 0 && num == element2) { //如果该元素为第二个元素，则计数加1
                vote2++;
            } else if (vote1 == 0) { // 选择第一个元素
                element1 = num;
                vote1++;
            } else if (vote2 == 0) { // 选择第二个元素
                element2 = num;
                vote2++;
            } else { //如果三个元素均不相同，则相互抵消1次
                vote1--;
                vote2--;
            }
        }

        int cnt1 = 0;
        int cnt2 = 0;
        for (auto & num : nums) {
            if (vote1 > 0 && num == element1) {
                cnt1++;
            }
            if (vote2 > 0 && num == element2) {
                cnt2++;
            }
        }
        // 检测元素出现的次数是否满足要求
        if (vote1 > 0 && cnt1 > nums.size() / 3) {
            ans.push_back(element1);
        }
        if (vote2 > 0 && cnt2 > nums.size() / 3) {
            ans.push_back(element2);
        }

        return ans;
    }
};

```


17. 为运算表达式计算优先级
使用分治算法, 遍历表达式，找到运算符，将结果分成两个部分， 递归查找。类似二叉树的组成方式查找
如果求具体的结果，那么需要使用vector将结果进行push_back,否则可以直接使用动态规划，计算总数


18. 摆动序列 如果是需要相邻两个数不能等于的话，只能两个字符串都进行翻转，如果可以相邻等于的话，可以后面的字符串进行翻转就行了 


19. 中文变为阿拉伯数字和阿拉伯数字变为中文
    1.中文变为阿拉伯数字
    使用栈，将文字划分为数字和量纲，遇到量纲，那么从栈中弹出与当前量纲小的数字与当前量纲相乘，然后不断累加，知道栈为空或者栈顶量纲比当前量纲大，然后将当前累加到的数压入栈中；最后的结果就是栈中的数求和

    2.阿拉伯数字变为中文
    注意：亿，万节之后如果只有0那么不需要输出0，如果千位为0的话那么需要输出0
    10500，一万零五百， 15000一万五千
    
    将数组划分为节，然后每节使用一个函数判断
    如果不是第一节，而且当前的数是大于0，而且小于1000的话那么需要加零


20. 面试题 16.14. 最佳直线/149. 直线上最多的点数
- 暴力方法：使用三重循环，前两个点固定一条直线，后一个点判断是否在直线上，是cnt++,最后找最大的cnt
- hash方法，使用二重循环，遍历两个点，两个点得到一个斜率，然后hash_map中存储该斜率的cnt, 最后取最大值的时候res=max(res, cnt+1)//一定记得+1
    因为gcd(5, 0)=5=cd(0, 5) 所以不存在除0情况
```C++
int a = x1 - x2, b = y1 - y2;
int k = gcd(a, b);
String key = (a / k) + "_" + (b / k); //斜率用string存储

int gcd(int a, int b) {
    return b == 0 ? a : gcd(b, a % b);
}
```

21. 阶层之后的零
-  方法1， 直接计算，n是5的倍数的个数+25倍数个数+...
```C++
int pow=5;
while(n>=pow){
    cnt+=n/pow;
    pow=pow*5;
}
return cnt;
```
- 方法2， 对1-n中的每一个数计算，能够拆分为多少个5的因子
```C++
for(int i=1;i<=n;i++){
int tmp=i;
while(tmp%5==0){
    tmp=tmp/5;
    cnt++;
}
```

22. lc277. find-the-celebrity
- 所有的人都认识名人，名人谁都不认识，找出名人
- 假设法，O(n), 假设0是名人，如果遇到knows(0, i)==true, 说明0不是名人，同时说明[0~i-1]都不是名人，因为他们都不被0知道
- 之后再判断一次，如果出现know(ans, i)==true||know(i, ans)==false, 返回-1




 #####  19.交换数据的位置
（1）打标记方法： 这种方式理解起来更轻松, 注意这种方式，如果元数据中包含0或者小于0，但是目标数据中是大于0的([1, size])， 那可以将0，负数转为size+1; 否则如果元数据有0， 目标数据也有0的话，打标记是无法解决的

1. 缺失的第一个正数 （用负号在原地打标记代替hash方法，或者用置换方法，一定要将负数和>size都转为size+1；同时对于target_index和当前index数据相同时，退出循环）
2. 丢失的数字
3. 数组中重复的数据

将当前的数在对应的下标中打上标记，同时为了找到被覆盖数据的元数据，可以使用+n（这种可以找到重复3次， 4次都可以）,或者变为负数的这种做法
但是变负数的这种方式，不能适用于含有0的这种情况，因为-0和0是一样的，无法判断是否出现过这个数字

找到的条件是 nums[i]>=0 退出
``` C++
   int firstMissingPositive(vector<int>& nums) {
        int n = nums.size();
        for (int& num: nums) {
            if (num <= 0) {
                num = n + 1;
            }
        }
        for (int i = 0; i < n; ++i) {
            int num = abs(nums[i]);
            if (num <= n) {
                nums[num - 1] = -abs(nums[num - 1]);
            }
        }
        for (int i = 0; i < n; ++i) {
            if (nums[i] > 0) {
                return i + 1;
            }
        }
        return n + 1;
    }

```

（2）置换
1. 缺失的第一个正数 把数据放在对应的位置

将当前的数放在当前数据对应的下标中

找到的条件是 nums[i]！=i+1 退出
```C++
    int firstMissingPositive(vector<int>& nums) {
        int n = nums.size();
        for (int i = 0; i < n; ++i) {
            while (nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i]) {
                swap(nums[nums[i] - 1], nums[i]); //要和它交换的数不能等于它本身
            }
        }
        for (int i = 0; i < n; ++i) {
            if (nums[i] != i + 1) {
                return i + 1;
            }
        }
        return n + 1;
    }
```
（3） 二分算法，查找小于mid的数据量，如果是大于mid的话说明重复的数小于等于mid,因此r=mid-1 and ans=mid(或者r=mid), 否则l=mid+1
 (4) 数组版快慢指针，index->nums[index] 那么有一个数会被指向两次，那么存在环
 - 映射找环法， 找冗余的数据，其实就是找环路的起点
 - https://segmentfault.com/a/1190000003817671
 ```C++
 class Solution {
    public:
        int findDuplicate(vector<int>& nums) {
            int slow = 0, fast = 0;
            do {
                slow = nums[slow];
                fast = nums[nums[fast]];
            } while (slow != fast);
            slow = 0;
            while (slow != fast) {
                slow = nums[slow];
                fast = nums[fast];
            }
            return slow;
        }
    };
 ```

4. lc 440和lc386 按照字典序排序，和按照字典序排序的第k个数字
我们输入两个值n和k，n表示我们有从1到n个整数，然后将这些整数都字符串化之后按字典排序，找出其中第K大的。例如:n=15,k=5.那么1-15字符串化之后排序如下:1,10,11,12,13,14,15,2,3,4,5,6,7,8,9。其中第5大的就为13。
实际上多叉树从到右进行计数

每次求解二叉树相邻两个节点之间(base 和base+1)包含的数据，如果k>num那么直接更新k 然后当前数+1(base=base+1), 否则递归求里面的数据(base=base*10)


<font color=red>20. 字符串相乘</font>
- 模板代码：
    ```C++ 关键代码
    vector<int> res(size1+size2+1, 0);
    reverse(num1.begin(), num1.end());
    reverse(num2.begin(), num2.end());
    for(int i=0;i<size1;i++){
        for(int j=0;j<size2;j++){
            res[i+j]=res[i+j]+(num1[i]-'0')*(num2[j]-'0');

        }
    }
    ```
- 知识点：字符ASCII码和数字的相互转换
    char a='0'+81;
    char b=a-81;
    int c=a-'0';
    cout<<a<< " "<<b<<" "<<c<<endl;
    注意c最终打印的结果为-175, 而不是81！！！！ 所以在初始化字符串相乘的数组只能用int类型不能用string类型
    char m='A'+1;//打印输出'B'

- 初始化一个m+n的数组（注意一定要为int类型，不能为string类型），然后循环计算每一位应该的值，最后从低位到高位进行进位更新
- 易错点：str1和str2需要翻转，之后的结果需要去前缀零以及翻转回来
如果不翻转，那么nums1[i]和nums2[j]对应nums[i+j+1]的数组


21. 分数到小数，模拟除法

使用hash记录余数到下标的隐射，如果出现重复余数，说明出现了重复的小数循环体
注意易错点：
- 1.可能存在负数，但是不能直接对负数取反（因为可能为INT_MIN），需要转为long型
    判断结果为负数使用异或
    if (numeratorLong < 0 ^ denominatorLong < 0) {//异号为负数
        sb.append('-');
    }


22. lc670. 最大交换
- 一个数字交换一次，如何使得交换后的数最大 输入: 2736 输出: 7236
- 先遍历字符串求得每个数最靠后的下标（因为小于当前的数，应该换到越靠后面越好）
- 然后从左遍历每个数的时候，遍历 '9'到s[i]-'0'看是否有比当前数大的数，而且在这个数后面，如果有，那么交换，然后退出
- 因为第二重循环只是从9到s[i]-'0'， 因此总的时间复杂度还是O(N)



#### 分而治之专题

1. 超级次方， 也类似观察规律的题目，就是在定义一种新的运算的时候，将它化简为熟知的运算。同时运用规律“对乘法的结果求模，等价于先对每个因子都求模，然后对因子相乘的结果再求模”
不能直接使用系统自带的pow,只能自己实现pow因为，在求乘方过程随时会出现溢出，所以要为每一个中间结果取模

2. 第K个语法符号
找第n个的数的第k个字符是什么，转为找第n-1个数的对应f(k)位上面的数据（左半边不取反，右半边取反）
易错点在：一个数的时候会add两次如何解决, 那么就在返回的时候，只有一个数的时候，说明出现了[[num, []]]的这种情况，那么直接return result.getInterger, 否则直接返回result

#### 递归相关，表达式相关专题

1. 迷你语法分析器： 
注意在进行递归的时候， 递归进去直接初始化一个NestInterger res, 来加入[]里面的数字， 遇到循环递归调用，然后返回时直接res.add
另外一个易错点是，注意负数的处理


#### 蓄水池抽样算法

模板
```C++
class Solution {
public:
    Solution(ListNode* head) {
        this->head=head;
    }
    
    int getRandom() {
        ListNode*cur=this->head;
        int pool=-1;
        int i=1;
        while(cur){
            if(rand()%i==0)pool=cur->val; //只选取一个数的情况
            i++;
            cur=cur->next;
        }
        return pool;
    }

private:
    ListNode*head;
};

```

例题：
1. 链表随机节点
2. 随机索引数 ，找到target数的随机一个index



#### 并查集专题
相关例题：

除法求值：并查集的变形，除了要判断各个数字是否连通，还需添加一个数组记录节点之间的权重 weight(当前节点到其父节点的权重); 而且注意如何a/b那么应该是a的父亲节点是b, a指向b的权重为a/b, 反过来的话不对 **一定要注意这个权重的更新，应该为当前的权重 * 他原来父亲的现在的权重**

易错点：
- 在进行节点merge的时候一定要注意权重的更新，weight代表的是两个节点之间的权重，而不是一个节点到根节点的权重
- find的时候返回的是father[a]而不是a !!!!!!
- fa!=fb的时候应该是father[fa]=fb, 与两个孩子节点a b无关
- 递归寻找father的时候，应该使用father[index]作为函数的参数而不是index(会陷入无限死循环中)
- 在并查集的时候，可以直接使用string作为头节点，不一定要转为int类型  unordered_map<string, string> father; unordered_map<string, int>num
例题：面试题 17.07. 婴儿名字
- 可以使用string的find函数来对字符串进行分割（带括号或者，形式的分割）

并查集模板：具体可见vscode里面的代码，两个模板 带size和不带size的情况


例题2：lc947. 移除最多的同行或同列石头
- 这个是二维坐标的，横坐标或者纵坐标相同都在一个并查集，因此需要将横纵坐标放在两个范围中，防止重叠；因为x, y在[0,1000]之间，一次你可以将横坐标放在+10001, 使得x y范围错开






#### 图相关

竞赛第四题 hard lc2097. 合法重新排列数对 //暂时没有看
```C++
class Solution {
    map<int, vector<int>> mp;
    map<int, int> deg;
    vector<vector<int>> ans;

    void dfs(int sn) {
        vector<int> &e = mp[sn]; // 注意这个是引用
        while (!e.empty()) {
            int fn = e.back();
            e.pop_back();
            dfs(fn);
            ans.push_back(vector<int>{sn, fn});
        }
    }
    //为什么要先dfs再push_back没看明白

public:
    vector<vector<int>> validArrangement(vector<vector<int>>& pairs) {
        for (auto &pair : pairs) {
            mp[pair[0]].push_back(pair[1]);
            deg[pair[0]]--; deg[pair[1]]++;
        }
        for (auto it = deg.begin(); it != deg.end(); it++) if (it->second == -1) dfs(it->first);
        if (ans.empty()) dfs(deg.begin()->first);
        reverse(ans.begin(), ans.end());
        return ans;
    }
};

```


##### 有关于有向图和无向图的最短路径，以及有负边和无负边的最短路径

1. Dijstra算法，适用于单源，有向或者无向的最短路径，不能适用于有负边（注意不是负环，负环情况下，无最短路径）的情况：例子：-1， -5， 2
时间复杂度O(n^2))
```C++
#define INF 0x3f3f3f3f

int e[Max][Max];//e[i][j]代表从i->j的距离，不通设为无穷大
int dis[Max];//dis[i]代表从起点到i的最短距离
bool book[Max];//book[i]代表点i是否在S中
int n;//n个顶点
int s;//起点

void Dijkstra()
{
    for(int i=1;i<=n;i++)//初始化dis数组
        dis[i]=e[s][i];

    for(int i=1;i<=n;i++)//初始化book数组
        book[i]=0;
    dis[s]=0;
    book[s]=1;

    for(int i=1;i<=n-1;i++)//Dijkstra算法核心语句  注意也是n-1次
    {
        int minDis=INF;
        int k;//找到与s最近的顶点k
        for(int j=1;j<=n;j++)
        {
            if(book[j]==0 && dis[j]<minDis)
            {
                minDis=dis[j];
                k=j;
            }
        }
        book[k]=1;

        for(int j=1;j<=n;j++)//“松弛”过程
        {
            if(e[k][j]<INF)
            {
                if(dis[j]>dis[k]+e[k][j])
                    dis[j]=dis[k]+e[k][j];
            }
        }
    }
}
```

2. Bellman-ford算法：适用于单源，可有负权，有向或者无向的最短路径 记住只松弛n-1次
能够检测出有负环情况
dp[i][dst]=min(dp[i][dst], dp[i-1][src]+dist[src][dst]) i==1的时候表示经过的中转站为0

时间复杂度O(n*m)/O(VE)

```C++
#define INF 0x3f3f3f3f

struct Edge{
    int u;//起
    int v;//终
    int weight;//长度
};

Edge edge[maxm];//用来存储所有的边
int dis[maxn];//dis[i]表示源点到i的最短距离
int n,m;//n个点，m条边
int s;//源点

bool Bellmen_ford()
{
    for(int i=1;i<=n;i++)//初始化
        dis[i]=INF;

    dis[s]=0;//源节点到自己的距离为0

    for(int i=1;i<n;i++)//松弛过程，计算最短路径 
    {
        for(int j=1;j<=m;j++) //m条边
        {
            if(dis[edge[j].v]>dis[edge[j].u]+edge[j].weight)//比较s->v与s->u->v大小
                dis[edge[j].v]=dis[edge[j].u]+edge[j].weight;
        }
    }

    for(int j=1;j<=m;j++)//判断是否有负边权的边
    {
        if(dis[edge[j].v]>dis[edge[j].u]+edge[j].weight)
            return false;
    }

    return true;
}
```


3. SPFA算法：是Bellman-ford算法的队列优化，适用于单源，可有负权，有向或者无向的最短路径 （自身其实无法处理负权）  
设立一个队列用来保存待优化的点，优化时每次取出队首结点u，并且用u点当前的最短路径估计值对u点所指向的结点v进行松弛操作，如果v点的最短路径估计值有所调整，且v点不在当前的队列中，就将v点放入队尾。这样不断从队列中取出结点来进行松弛操作，直至队列空为止。

注意，一旦从队列中弹出来，vis就设置为false，感觉负权的情况就会一直循环下去，不会跳出；遍历点，与边无关
```C++
#define INF 0x3f3f3f3f

int dis[MAX];//dis[i]表示起点到i的最短距离
bool vis[MAX];//是否访问过点i
int e[MAX][MAX];//矩阵

int n,m;//点和边的数量
int s;//源点

void SPFA()
{
    for(int i=1;i<=n;i++)//初始化
    {
        dis[i]=INF;
        vis[i]=false;
    }
    queue<int> q;
    q.push(s);
    dis[s]=0;
    vis[s]=true;

    while(!q.empty())
    {
        int cur=q.front();
        q.pop();
        vis[cur]=false;
        for(int i=1;i<=n;i++) //遍历每一个节点
        {
            if(e[cur][i]!=INF&&dis[i]>=dis[cur]+e[cur][i])
            {
                dis[i]=dis[cur]+e[cur][i];
                if(!vis[i])
                {
                    vis[i]=true;
                    q.push(i);  ///之后将start缩小的边才拿出来
                }
            }
        }
    }
}
```

4. Floyd算法： Floyd算法是一种利用动态规划思想的计算加权图中多源点之间最短路径的算法。可以正确处理有向图或负权的最短路径问题。

时间复杂度：O(N^3）

空间复杂度：O(N^2）

处理问题：多源、可有负权、有向图、无向图最短路径 
```C++
int e[Max][Max];//e[i][j]代表从i->j的距离，不通设为无穷大
int n;//n个顶点
//Floyd算法
void Floyd()
{
    for(int k=1;k<=n;k++)//遍历所有的中间点
    {
        for(int i=1;i<=n;i++)//遍历所有的起点
        {
            for(int j=1;j<=n;j++)//遍历所有的终点
            {
                if (e[i][j]>e[i][k]+e[k][j])//如果当前i->j的距离大于i->k->j的距离之和
                    e[i][j]=e[i][k]+e[k][j];//更新从i->j的最短路径
            }
        }
    }
}
```

最短路衍生拓展的一类题目：
1. 最长路径问题：
图不为非负权图：当存在正环时无解。
如果不存在正环，边权取负后使用Bellman-Ford算法求最短路。
2. 最长路径，但是路径的计算是权重之间的乘积，而且权重都是0-1之间的值，使用Dijstra算法 （e.g概率最大的路径）
Solution: 
    单独使用Dijstra会导致超时，因此需要结合Dijstra+优先队列
    1.现将src点push 到堆进行
    2.然后遍历堆中的每个节点，如果当前节点能够松弛它的邻接节点，那么就放入堆中，否则不放入类似于SPFA,但是不同的是，
    - 这个使用的优先队列，而SPFA是用的是一般的堆
    - 这个不仅仅push了节点，也push了当前节点的最大概率，因此没有vis数组来标记当前节点是否在堆中，因为即使在堆中， 概率也可能是不一样的。
    总的来说这道题使用bellman-ford算法更简单，只要当前没有任何松弛的边，那么直接退出循环

颜色交替的最短路径：使用bellman-ford算法（本质是动态规划）， 只是在距离的转换是需要讨论两种情况
dstEndWithRed[end]=min(dstEndWithRed[end], dstEndWithBlue[start]+1);
dstEndWithBlue[end]=min(dstEndWithBlue[end], dstEndWithRed[start]+1);
```C++
for(int i=0;i<n-1;i++){
    for(auto edge: redEdges){
        int start=edge[0];
        int end=edge[1];
        dstEndWithRed[end]=min(dstEndWithRed[end], dstEndWithBlue[start]+1);
    }
    for(auto edge: blueEdges){
        int start=edge[0];
        int end=edge[1];
        dstEndWithBlue[end]=min(dstEndWithBlue[end], dstEndWithRed[start]+1);
    }
}
```
3. 成语接龙的最长，使用bfs，同时对连接好的成语，再来一次bfs (微软三面)

<font color=red>4. lc787. K 站中转内最便宜的航班</font>
- 只能最多经过k个中转站的最短路径
- 使用bellman-ford算法，k个中转站就是松弛每条边 k+1次(1~k+1)，然后使用dp[i][dst]记录 中转i次的最短路径
最后的结果就是在dp[1][dst] 到dp[k+1][dst]中取最小的一个


### 前缀和和差分数组相关
一般是有关于矩阵的一维前缀和， 二维前缀和， 一维差分数组和二维差分数组
如果要计算差分数组和前缀和数组最好是将坐标转为 1-n，更好计算；不然sum i j对应的grid为i-1,j-1


一维差分数组中，如果数组中一段数据加上或者减去某一个元素，在差分数组中只有两头的元素进行了修改，中间的元素都没有修改
二维差分数组中，如果包含左上角（x1, y1）, 右下角（x2, y2）这一部分都+C, 那么对应的差分数组d[x1][y1]+c d[x2+1][y2+1]+c d[x1][y1+1]-c d[x2+1][y1]-c
(上升的对角线两端元素-c, 下降的对角线元素+c)

二维差分数组公式:
nums[i][j]-nums[i-1][j]-nums[i][j-1]+nums[i-1][j-1]=d[i][j]
从差分数组还原原来的数组
nums[i][j]=nums[i-1][j]+nums[i][j-1]-nums[i-1][j-1]+d[i][j]



例题：
1. 5931. 用邮票贴满网格图 (hard-周赛题目)

方法一: 使用二维前缀和，对原来矩阵中每个左上角为0，且邮票区域都为0的位置（二维区域前缀和为0），贴上邮票，为了减少贴这个过程的时间开销，使用二元差分数组
贴完后，对二元差分数组进行还原，如果仍然遇到为0的位置，那么返回false
注意这道题没必要求差分数组，差分数组可以全部直接初始化为0， 那么还原回来的也是填充数组
方法二: 不使用二维差分数组，使用另外一个数组，标记贴邮票的左上角，然后针对每个grid中为0的位置，计算邮票部分区域（注意是贴了邮票的矩阵，是另一个矩阵）的前缀和，如果为0，表示这个区域没有被贴上邮票，返回false

2. 航班预订统计 (middle)
一维差分数组的题目
如果原来数组的下标就是1-n的话，那么修改n-m部分的数据， 就会修改等差数列的d[n]和d[m+1]两个端点的数据


3. 拼车
这道题类似于天际线问题，使用hash, 左断点加入m个人，右端点减去m个人
然后遍历hash的每个key,如果有个时刻是大于capacity, 那么返回false

4. lc995. K 连续位的最小翻转次数（hard）
- 从左到右遍历，遇到0就进行翻转，使用差分数组进行假意翻转，通过presum累加来求得当前翻转的次数

### 前缀异或值
在求前缀异或的时候，结果数组可以从1开始取，这样的话就不用对边缘单独进行赋值操作
```C++
for (int i = 1; i <= m; ++i) {
    for (int j = 1; j <= n; ++j) {
        pre[i][j] = pre[i - 1][j] ^ pre[i][j - 1] ^ pre[i - 1][j - 1] ^ matrix[i - 1][j - 1];
        results.push_back(pre[i][j]);
    }
}
```


### 分类讨论题
1.  K 次串联后最大子数组之和
分类分析
k=1;
k=2;
k>2 如果array之和小于0，那么结果就是k=2情况，否则k=2+(k-2)*sum(one array)


#### 摩尔投票算法
1.求众数
```C++
int k=0;
int target_num=0;
for(int i=0;i<size;i++){
    if(k==0){
        target_num=nums[i];
        k=1;
    }else{
        if(nums[i]==target_num){
            k++;
        }else{
            k--;
        }
    }
}

//判断target_num的数是否大于n/2;
int cnt=0;
for(int i=0;i<size;i++){
    if(nums[i]==target_num){
        cnt++;
    }
}
if(cnt>n/2){
    return target_num;
}
```

2.求大于n/3 的数
这样的数最多只有两个
```C++
int k1=0;//投票的数量
int k2=0;
int target_num1;//具体的数
int target_num2;
for(int i=0;i<size;i++){
    if(k1>0&&target_num1==nums[i]){
        k1++;
    }else if(k2>0&&target_num2==nums[i]){
        k2++;
    }else if(k1==0){
        target_num1=nums[i];
        k1=1;
    }else if(k2==0){
        target_num2=nums[i];
        k2=1;
    }else{
        k1--;
        k2--;
    }
}

int cnt1=0;
int cnt2=0;
for(int i=0;i<size;i++){
    if(k1>0&&nums[i]==target_num1){
        cnt1++;
    }else if(k2>0&&nums[i]==target_num2){
        cnt2++;
    }
}
if(cnt1>n/3){
    res.push_back(target_num1);
}
if(cnt2>n/3){
    res.push_back(target_num2);
}

```




### 分治算法专题
1.IP地址验证合理性
1. 对于 IPv4 地址，通过界定符 . 将地址分为四块->a；对于 IPv6 地址，通过界定符 : 将地址分为八块->b。（count(.)==4/count(:)==6/neither）
    a. 对于 IPv4 地址的每一块，检查它们是否在 0 - 255 内，且没有前置零。
    b. 对于 IPv6 地址的每一块，检查其长度是否为 1 - 4 位的十六进制数。

2. 删除注释
    分情况判断+用一个状态表明现在是否在注释内，主要是用于/* */情况
    （1）题目中没有考虑/* 不属于注释的这种情况，因此每次遇到/* &&block= False 表示开始块注释，每次遇到*/&&block=True,表示结束块注释
    （2）遇到//直接结束，因为//后面都是注释，而且不改变状态


#### corner case的例子
lc1363: 形成3的最大倍数
思路： 判断sum之和
1. %3==0， 那么返回res
2. %3==1, 如果数组中有%3==1的数字那么直接删除； 否则删除两个%3==2的数字
3. %3==2, 如果数组中有%3==2的数字那么直接删除； 否则删除两个%3==1的数字
4. 易错点：结果可能包含前缀0，因此需要将前缀0去掉（000001/000000）；结果也可能只是“”， 那么直接返回“”， 而不是0


lc旋转链表
1.求size
2. k=k%size; k=k-size,表示第k个节点是现在的头结点（k-1是新链表尾节点）
3. 将头节点前面一个节点（k-1）的next置为null, 同时将当前链表的最后一个节点next指向头节点（利用在第二步变成环，可以减少找尾结点这一步）
<font color=red>链表类似题一定要判断head是否为null, size是否为0或者1这种情况 </font>
快慢指针删除链表的重复元素的时候，一定要记得将慢指针的next设置为null

lc,加1
在vector数组上+1
- 一定要注意最后carry不为0的情况，需要在最开头插入一个数 digits.insert(digits.begin(),carry);
- 应该使用tmp记录当前位的和。int tmp=digits[i]+carry;

lc68. 文本左右对齐
字符串相关的模拟题，主要是分情况讨论
一个单词/最后一行/其他情况（spacecount, extraspace）

其他corner case: 
- 1. 乘法可能会超出范围，可能需要使用long long型 （数据范围一定要注意是用long long还是int）
- 2. 在进行寻找mid的时候left+(right-left)/2
- 3. 一定要注意< <=，以及边界情况的例子，在微软（矩阵旋转）和字节（和滑动窗口的最大值）最开始取[0,k-1]以及压入一个元素 已经跌过两次坑了
- lc220. 存在重复元素 III，一定要注意nums[i]-t可能超出整数的范围，因此需要使用long 或者longlong对nums进行强制转换


#### 模拟题目
1. 矩阵旋转90
2. 螺旋矩阵 （使用分成4段（后面两段需要判断 left< right&& upper< down才可以），或者坐标移动+vis数组）
3. 倒酒杯


#### 总结
ok 

1. 二维差分数组常用在对数组中的某一个块的区域进行操作， 比如这道题的贴邮票， 对整块数组+1; 比如对0-k这段距离的数据都进行翻转

2. 一个数比较大，但是它取模之后的结果不一定大,两种解决方案
    1) 保存long long的结果
    2) sum为定值的时候，一个数越接近sum的一半，乘积之后的结果越大

    ```C++
    if (abs(cur*2 - sum) < abs(best*2 - sum)) {
        best = cur;
    }
    ```
3. 负数和正数的向上向下取整不同
Math.floor(2.6);    //2.0   floor地板 水平数轴向右取整
Math.floor(-2.6);   //-3.0   floor地板 水平数轴向右取整


