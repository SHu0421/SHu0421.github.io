---
title: 字符串相关问题
catogory:
  - leetcode 题目汇总
categories:
  - leetcode
date: 2021-11-13 17:23:32
tags:
---

#### 常见字符串解决套路
1. [用动态规划求解](./动态规划题型.md)
2.[用滑动窗口求解](./滑动窗口.md)
3. [用双指针求解](./双指针.md)
4. [使用DFS/BFS求一个字符串转为另外一个字符串的路径问题](./回溯_DFS_BFS.md)


#### 扩展：字符串hash
abcde
转为为多项式
f(5)= a* p^5 + b*p^4 +c *p^3 +d *p^2 +e *p^1
f(3)= a* p^3 + b*p^2 +c *p^1
f(4, 5)=f(5)-f(3)*p^(5-4+1)

c++用unsigned long long 自然溢出，可以不用取模，如果使用取模方式可能会导致溢出
```C++
p[0]=1;
h[0]=0;
for(int i=1;i<size;i++){
  h[i]=h[i-1]*p+s[i-1]; //0到i-1之间的hash值
  p[i]=p[i-1]*p;  //不同长度字符串的p值
}

hash_val_m_n=h[m]-h[n-1]*p[m-n+1];
```

最长重复子串（hard）
使用字符串hash+二分寻找长度，如果hash的key是字符串的话，时间复杂度为O(n*len))， 只有key为整数类型，时间复杂度才为 O(n))

#### 例题

1. 最大数：注意使用str.substr以及位移操作时候一定要记得赋值，否则结果是不会改变的 res=res.substr(start, len), 以及注意最后的结果包含首0的情况，一定要记得去除首零

2. 最大单词长度乘积
使用掩码判断字符串是否有相似的字符，然后掩码&

3. 打开转盘锁
使用bfs
值得学习的地方：
1. 使用unordered_set代替vector
主要在判断一个字符之前是否在一个集合中, 使用unordered_set比vector更快 if(!set.count())  表示集合中没有这个元素
2. 在查找当前字符变形后的字符，一定要及得保留当前的字符再做修改！！

3. 匹配子序列的单词数
查看多个字符串中，有几个是字符串s的子序列
使用二分查找，先通过hash，将不同字符对应的下标值进行存储，然后遍历需要查询的每个字符串，分别从hash里面多个vector进行查找，同时下次查找的下标，应该比当前下标至少+1


<font color=red>4. 反转每对括号间的子串 (华为机试)</font>
**字符串+栈**
注意这道题我最开始还没想出来
- 解决方案：
  str为最后的结果
  遇到（ 那么将str的元素压入栈中，然后str转为“”
  遇到）那么将str元素翻转，**如果栈不为空, 将栈顶元素弹出**, str=s.top()+str; s.pop()
  其余的字符直接追加在str后面
  最后返回str
- 也就是拼接好的字符串直接放在str中，不需要再压入栈中, 多了一个 "每次遇到]将当前字符串reverse 并加在栈顶元素的后面" 的步骤

PS：类似的一道题: 字符串解码 (2021年4399后端开发笔试原题)
- 仍然使用栈, 思路和4相似，只不过多了一个数字 （左括号不会被压入栈中）
- 另一种解法：数字存放在数字栈，字符串存放在字符串栈，遇到右括号时候弹出一个数字栈，字母栈弹到左括号为止。（左括号会压入栈中）


<font color=red>5. lc2157字符串分组(hard)</font>
- (lc49字符串异位词分组) 用string或者vector<int> 作为hash的key
- 并查集对字符串进行分组和记录组数（带size的并查集，同时要考虑可能存在相同字符串的情况， size[x]>1 group--，同时合并的时候， group也会--），状态压缩+位运算实现字符串关联判断和查找
- 如果直接枚举任意两个字符串并判断是否关联，并以此得到图上所有的边，时间复杂度至少为 O(n^2), 会超出时间限制。因此对每个字符串进行变换



```C++
int x = 0;
for (char ch: word) {
    x |= 1 << (ch - 'a'); // 计算 word 的二进制表示
}

for x := range fa { // 枚举所有字符串（二进制表示）
		for i := 0; i < 26; i++ {
			merge(x, x^1<<i) // 添加或删除字符 i  0变为1， 1变为0
			if x>>i&1 == 1 { //找到一个1， 0对 翻转
				for j := 0; j < 26; j++ {
					if x>>j&1 == 0 {
						merge(x, x^1<<i|1<<j) // 替换字符 i 为 j
					}
				}
			}
		}
	}

```

6. 最长的美好子字符串
- 枚举，i， j, 表示字符串左右，两重循环
- 然后使用两个二进制代替两个数组，判断是否大小写都有，如果有数量就不能使用两个数来代替，只有这种有或没有可以
也是使用二进制对字符串进行压缩
枚举/分治/枚举typenum(至少有K个重复字符的最长子串, 不建议用这种方法，因为比较难)

7. 不同字符的最小子序列
去除重复的字符串，使得子序列包含所有的字符，每个字符一次，同时字典序有最少
solution: 
需要有一个hash来记录一个字符的剩余出现次数
如果栈中没找到，从栈中弹出剩余出现次数大于0，而且大于当前字符的字符，然后压入当前字符
如果栈中找到，直接将num[当前字符]--, 不push进入栈中


<font color=red>8.序列自动机</font>
字符串dp
在进行判断一个字符串a是否是另外一个字符串b的子序列的时候，可以使用双指针，判断a的指针是否能走到末尾
也可以使用dp
dp[i][j]=i  s[i]==j （表示s从i开始第一个等于字符j的下标）
dp[i][j]=dp[i+1][j]  s[i]!=j
从后往前更新
```java
 Arrays.fill(f[m], m);
for (int i = m - 1; i >= 0; --i) {
	for (int j = 0; j < 26; ++j) {//只包含小写字符
		if (s.charAt(i) == (char) ('a' + j)) {
			f[i][j] = i;
		} else {
			f[i][j] = f[i + 1][j];
		}
	}
}
String res = "";
for (String t : dictionary) {
	boolean match = true;
	int j = 0;
	for (int i = 0; i < t.length(); ++i) {
		if (f[j][t.charAt(i) - 'a'] == m) {
			match = false;
			break;
		}
		j = f[j][t.charAt(i) - 'a'] + 1;
	}
	if (match) {
		
	}
}
```

9. KMP算法的模板，主要是求next的数组，以及在循环退出之后判断字符是否相等，进行k的判断或者next数组的赋值
```C++
 void findnext(string pattern, vector<int>& next){
        int size = pattern.size();
        int k = -1;
        next[0] = -1;//代表已经匹配的下标
        for (int i = 1; i < size; i++)
        {
            while(k!=-1&&pattern[i]!=pattern[k+1]){
                    k = next[k];
            }//因为跳出循环后还需要判断相等，因此将判断相等放在while的后面而不是前面
            if(pattern[i]==pattern[k+1]){
                k++;
            }

            next[i] = k;
        }
    }
    int strStr(string haystack, string needle) {
    // int KMP(string target, string pattern){
        string target=haystack;
        string pattern=needle;
        int size = target.size();
        int k = -1;
        if(pattern==""){
            return 0;
        }
        vector<int> next(pattern.size());
        findnext(pattern, next);
        for (int i = 0; i < size; i++)
        {
            while(k!=-1&&target[i]!=pattern[k+1]){
                    k = next[k];
            }
            if(target[i]==pattern[k+1]){
                k++;
                if(k==pattern.size()-1){
                    return i - k ; //返回匹配字符串的头位置
                }
            }

        }
        return -1;
    }
```

10. 字符串翻转
“leetcode i" --> "i leetcode"
思路：1. 使用栈
2. 先整个字符串翻转，去空格+原位翻转（双指针）+删除后面多余的字符 //空间复杂度O(1)

11. 实现 atoi() 字符串转数字：注意这几个测试用例
  a. 包含非法字符，返回 error 或者 0
  b. 要考虑正负号
  c. 要考虑溢出的情况。直接按照字典序，比较输入字符串和 TMin、TMax 的字符串就可以了，不需要在转换过程中判断是否溢出

12. lc115. 不同的子序列(字符串匹配问题)
-  这道题主要是求一个字符串s中可以找到多少个字符串t(只变了一个字符也是一种新的情况) (见8.序列自动机)
-  使用dp[i][j]表示字符串s前i个，和字符串t前j个进行匹配的个数，那么状态转移方程为 （下面展示的是从前往后，从后往前也是可以的）
```C++
        for(int i=0;i<s1;i++){  //注意这里的初始化非常重要
            dp[i][0]=1;
        }
        for(int i=1;i<s1;i++){
            for(int j=1;j<s2;j++){
                if(s[i]==t[j]){
                    dp[i][j]=dp[i-1][j-1]+dp[i-1][j];   //相同可以与当前t匹配，也可以不匹配
                }else{
                    dp[i][j]=dp[i-1][j];
                }
                dp[i][j]=min(dp[i][j],1LL*1000000000000000); //这里是为了防止long long型超出范围
            }
        }
```
-  其他注意的地方：自左向右和从右到左都会爆 long long超出范围，使用记忆化搜索不会。同时一定要记得初始化，没有与模式字符串匹配的时候，都需要赋值为1 dp[i][0]=1



13. Trie树的实现
具体实现见系统设计中的Trie树专题

14. 单词搜索
- Trie树+回溯
先将要字典中的单词建立一颗Trie树，然后枚举矩阵中的每个点，进行dfs, 在进行dfs的时候，只对Trie树中有的边进行dfs, 如果当前走到isEnd=True的情况，那么就直接压入结果，同时这个时候不能直接退出，还可以继续dfs,因为字典中的单词可能是存在相互包含的关系的（dfs剪枝）

<font color=red>15. 最长回文前缀</font>
lc214. 最短回文串
求s的最长回文前缀，其实就是求str = s+"#"+rev_s的最长公共前后缀，使用KMP算法求next数组，然后返回next[str.size()-1]，就是最长的回文前缀

一个字符串的最长前后缀为，这个字符串求next数组，返回next[size-1]

马拉车算法：https://www.acwing.com/file_system/file/content/whole/index/content/446985/

<font color=red>16. lc321. 拼接最大数 (hard)</font>
- 题意：从两个数组中共选择k个数，是的数最大
- 第一步是枚举每个数组中取数据的个数
- 第二步分别从两个数组中得到指定长度的最大子序列
- 第三步是将两个最大子序列合并。（一定要注意合并！！！！ 可能会遇到相同的情况，不是随便选一个，而是要找到他们后面第一个不相等的进行比较）
```C++
  bool flag=true; //第一个数组++
  while(index1<m&&index2<n){
      if(arr1[index1]>arr2[index2]){
          flag==true;
          break;
      }else if(arr1[index1]<arr2[index2]){
          flag=false;
          break;
      }
      index1++;
      index2++;
  }
  if(index1==m){
      flag=false;
  }
```


17. lc792. 匹配子序列的单词数
- 判断字典里面的每个字符串是否是s的子序列，使用双指针会超时
- 方法一：使用字符串dp, dp[i][j]表示s从index下标开始，找到的第一个字母j的下标
- 方法二：使用map<int, vector<int>> 记录下每个字母在字符串中下标的位置，然后使用二分查找


#### 总结
ok ok
1. 在对字符串进行操作通常可以朝栈，递归， bfs等方向思考
    尤其是左右括号对应的这种情况-> 栈和递归
2. 状态压缩：如果字符串的每一个字符串都至多包含每个字母一次，并且字母的顺序无关紧要，因此我们可以使用一个 262的二进制数 mask 表示一个字符串。
  同时如何两两判断两个字符串是否有关联的时间复杂度太高O(n^2^len(str)), 那么可以转为「枚举一个节点」+「枚举可能的相邻节点」+「使用哈希表判断相邻节点是否真正存在」的方法得到所有关联的边，（也就是猜测字符串的每个数的时间复杂度可能小于两层循环遍历+判断）

3. 注意在进行字符串比较的时候是比较多次，但是在进行数字比较的时候是比较一次,所以hash的key存int比存string更高效

4. char a可以使用a++，变为另外一个字符 'A'->'B'
  但是string s类型，即使只有一个字符，也必须使用s[0]++, 不能使用s++

5. 如果出现反复将一个字符串的子串和字典中的每个字符比对的题目，可以使用Trie树，或者使用动态规划（True/False类型），提前判断某一个子字符串是否在字典中 （PS: 动态规划中也有这句话的总结）

6. Trie树，通常是将字典里面的字符串构建一个trie数，然后在进行查询的时候，就相当于直接在字典中（多个字符串同时）查找，而不是和字典中的每个字符串进行对比
例题：lc: 面试题 17.17. 多次搜索(KMP/ Trie数)

7. 字符串匹配问题:求个数，求是否匹配，求删除字符的最小数量，都是使用的动态规划，定义的dp[i][j]都是让s前i个字符和t前j个字符匹配的xxxx， 一般都是将s[i]和t[j]是否相等分成两种情况，并分别求对应的状态转移

8. 有时候有字典的这种情况会考虑到建立前缀树，也可以考虑使用逆向思维，将字典树加密的所有字符串提前求出来，然后使用打表方法
lc5302. 加密解密字符串（周赛hard）





