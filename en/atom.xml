<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hello World</title>
  
  
  <link href="http://shu0421.github.io/en/atom.xml" rel="self"/>
  
  <link href="http://shu0421.github.io/en/"/>
  <updated>2023-07-12T10:34:16.050Z</updated>
  <id>http://shu0421.github.io/en/</id>
  
  <author>
    <name>Shu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>常见模板代码</title>
    <link href="http://shu0421.github.io/en/2022/08/21/autumn_recruit/%E7%BE%8E%E5%9B%A2/important/"/>
    <id>http://shu0421.github.io/en/2022/08/21/autumn_recruit/%E7%BE%8E%E5%9B%A2/important/</id>
    <published>2022-08-21T13:05:07.000Z</published>
    <updated>2023-07-12T10:34:16.050Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;hello world&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>处理字符串的输入输出</p>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;</summary>
      
    
    
    
    <category term="autumn_recruit" scheme="http://shu0421.github.io/en/categories/autumn-recruit/"/>
    
    <category term="美团" scheme="http://shu0421.github.io/en/categories/autumn-recruit/%E7%BE%8E%E5%9B%A2/"/>
    
    
  </entry>
  
  <entry>
    <title>Hard题目集合</title>
    <link href="http://shu0421.github.io/en/2022/04/10/leetcode/hard%E9%A2%98%E7%9B%AE%E5%90%88%E9%9B%86/"/>
    <id>http://shu0421.github.io/en/2022/04/10/leetcode/hard%E9%A2%98%E7%9B%AE%E5%90%88%E9%9B%86/</id>
    <published>2022-04-10T08:41:22.000Z</published>
    <updated>2023-07-10T10:36:19.531Z</updated>
    
    <content type="html"><![CDATA[<h3 id="枚举-二分"><a href="#枚举-二分" class="headerlink" title="枚举+二分"></a>枚举+二分</h3><p>lc6040. 花园的最大总美丽值</p><ul><li>主要是在求partial的最小超时, 还有就是一个long long数据类型注意！！</li><li>法一: 从右到左，先枚举完善花园数目，再计算不完善花园数据可以获得的最大<br>解决方案：使用二分+前缀和来求增加后的最小值，而不是一个一个遍历(空间复杂度O(n))</li></ul><p>-法二: 如果是从左到右计算，可以将空间开销降到O(1)，先计算要让所有的花园变为完善花园还剩下的花的数量（可能为负数），然后遍历的时候一个一个加回去，同时不完善花园数目最小值是逐渐增大，所以可以在之前的结果上累加，不用重头计算</p><ul><li>同样类型的题目，+k使最小的数能够达到的最大值，lc6039. K 次增加后的最大乘积（这道题也可以最小堆+1，一个一个加）</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;枚举-二分&quot;&gt;&lt;a href=&quot;#枚举-二分&quot; class=&quot;headerlink&quot; title=&quot;枚举+二分&quot;&gt;&lt;/a&gt;枚举+二分&lt;/h3&gt;&lt;p&gt;lc6040. 花园的最大总美丽值&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主要是在求partial的最小超时, 还有就是一个lo</summary>
      
    
    
    
    <category term="leetcode" scheme="http://shu0421.github.io/en/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>DP问题专栏</title>
    <link href="http://shu0421.github.io/en/2022/04/04/dp%E9%97%AE%E9%A2%98%E4%B8%93%E6%A0%8F/DAG+%E6%A0%91%E7%8A%B6+%E5%85%B6%E4%BB%96dp/"/>
    <id>http://shu0421.github.io/en/2022/04/04/dp%E9%97%AE%E9%A2%98%E4%B8%93%E6%A0%8F/DAG+%E6%A0%91%E7%8A%B6+%E5%85%B6%E4%BB%96dp/</id>
    <published>2022-04-04T03:54:12.633Z</published>
    <updated>2023-07-12T10:34:45.675Z</updated>
    
    <content type="html"><![CDATA[<p>DAG上的dp</p><p>UVa 437 巴比伦塔 The Tower of Babylon</p><p>这道题求最高的塔，其实就是一个记忆化dfs的过程<br>一些需要注意的点：</p><ol><li>因为不可能出现一个立方体同时叠两次，因此不需要vis</li><li>因为有三种叠法，所以需要3个方向</li><li>因为最开始让谁做底部是不清楚的，所以使用循环遍历方法</li><li>因为一个底确定之后的最高是确定的，因此使用记忆化搜索，避免重复计算</li><li>对于这种题情况多，再加上dfs的题，先分析一两个小的情况（if-else, 三个方向分情况讨论）， 再暴力（dfs）， 再优化（记忆化数组）</li><li>类似最长路问题</li></ol><p>树状dp: dfs+dp<br>主要是针对图有层级结构（没有上司的舞会），或者选择课程这样的dp, 主要是背包和树状dp结合<br>使用dfs+dp</p><ul><li><p>一般解题步骤：</p></li><li><p>先使用dfs记录子节点的状态：dp[i][0]/ dp[i][1]/ dp[i][k]</p></li><li><p>然后计算当前节点的状态转移 (u是父节点， i是子节点)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">dp[u][a+b] = <span class="hljs-built_in">max</span>(dp[u][a+b], dp[u][a]+dp[i][b]) <span class="hljs-comment">//课程的转移方程</span><br>或者<br>dp[u][<span class="hljs-number">0</span>] += <span class="hljs-built_in">max</span>(dp[i][<span class="hljs-number">0</span>], dp[i][<span class="hljs-number">1</span>]); <span class="hljs-comment">//上司的转移方程</span><br>dp[u][<span class="hljs-number">1</span>] += dp[i][<span class="hljs-number">0</span>];<br></code></pre></td></tr></table></figure></li><li><p>例题<br>洛谷 P2014 CTSC1997 选课 （挺难的）</p></li><li><p>加入一门课程，森林转为树，求解dp[0][m+1]</p></li><li><p>我们枚举 u点的每个子结点 ，同时枚举以 i 为根的子树选了几门课程，将子树的结果合并到 u 上。注意这个使用a的取值范围随着访问的子树的数量逐渐增加</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> p = <span class="hljs-number">1</span>;<br>  f[u][<span class="hljs-number">1</span>] = s[u];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : e[u]) &#123;<br>    <span class="hljs-keyword">int</span> siz = <span class="hljs-built_in">dfs</span>(v);<br>    <span class="hljs-comment">// 注意下面两重循环的上界和下界</span><br>    <span class="hljs-comment">// 只考虑已经合并过的子树，以及选的课程数超过 m+1 的状态没有意义</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-built_in">min</span>(p, m + <span class="hljs-number">1</span>); i; i--)<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= siz &amp;&amp; i + j &lt;= m + <span class="hljs-number">1</span>; j++)<br>        f[u][i + j] = <span class="hljs-built_in">max</span>(f[u][i + j], f[u][i] + f[v][j]);  <span class="hljs-comment">// 转移方程</span><br>    p += siz; <span class="hljs-comment">//p逐渐增加</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><p>换根dp: 两次dfs， 找到换根前后dp的转移公式</p><ul><li>树和图dfs不一样，不需要使用vis,只需要记录一下当前index，和当前index的father就能避免访问同一节点</li></ul><p>数位dp感觉比较难</p><p>不要62<br><a href="https://blog.csdn.net/Enjoying_Science/article/details/44082929">https://blog.csdn.net/Enjoying_Science/article/details/44082929</a> 动态规划<br><a href="https://www.cnblogs.com/wenruo/p/4725005.html">https://www.cnblogs.com/wenruo/p/4725005.html</a> 动态规划，解释有点问题<br><a href="http://www.calvinneo.com/2017/09/23/HDU2089%E4%B8%8D%E8%A6%8162/">http://www.calvinneo.com/2017/09/23/HDU2089%E4%B8%8D%E8%A6%8162/</a> dfs<br><a href="https://www.programminghunter.com/article/8939658418/">https://www.programminghunter.com/article/8939658418/</a> dfs</p><ol start="600"><li>不含连续1的非负整数</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;DAG上的dp&lt;/p&gt;
&lt;p&gt;UVa 437 巴比伦塔 The Tower of Babylon&lt;/p&gt;
&lt;p&gt;这道题求最高的塔，其实就是一个记忆化dfs的过程&lt;br&gt;一些需要注意的点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;因为不可能出现一个立方体同时叠两次，因此不需要vis&lt;/li</summary>
      
    
    
    
    <category term="dp问题专栏" scheme="http://shu0421.github.io/en/categories/dp%E9%97%AE%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>vscode 配置</title>
    <link href="http://shu0421.github.io/en/2022/02/25/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/vscode/"/>
    <id>http://shu0421.github.io/en/2022/02/25/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/vscode/</id>
    <published>2022-02-25T01:45:56.000Z</published>
    <updated>2023-07-10T10:36:19.583Z</updated>
    
    <content type="html"><![CDATA[<ol><li>有关于在macos big sur上配置c/c++程序运行和调试详细步骤：<br>注意需要安装codellb<br><a href="https://blog.csdn.net/weixin_44881648/article/details/111046381">https://blog.csdn.net/weixin_44881648/article/details/111046381</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;有关于在macos big sur上配置c/c++程序运行和调试详细步骤：&lt;br&gt;注意需要安装codellb&lt;br&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_44881648/article/details/111046381&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>多线程</title>
    <link href="http://shu0421.github.io/en/2022/01/26/leetcode/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"/>
    <id>http://shu0421.github.io/en/2022/01/26/leetcode/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/</id>
    <published>2022-01-26T04:19:28.000Z</published>
    <updated>2022-03-02T03:53:22.049Z</updated>
    
    <content type="html"><![CDATA[<h3 id="semaphore-信号量"><a href="#semaphore-信号量" class="headerlink" title="semaphore 信号量"></a>semaphore 信号量</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">#<span class="hljs-keyword">include</span> &lt;semaphore.h&gt;<br>sem_t sem1;<span class="hljs-comment">//进行变量申明</span><br><br>sem<span class="hljs-constructor">_init(&amp;<span class="hljs-params">sem1</span>, 1, 0)</span>; <br>第一个参数：指向的信号对象<br>第二个参数：控制信号量的类型，如果其值为<span class="hljs-number">0</span>，就表示信号量是当前进程的局部信号量，否则信号量就可以在多个进程间共享<br>第三个参数：信号量sem的初始值<br><br>sem<span class="hljs-constructor">_post(&amp;<span class="hljs-params">sem1</span>)</span> 信号量值加<span class="hljs-number">1</span><br><br>sem<span class="hljs-constructor">_wait(&amp;<span class="hljs-params">sem1</span>)</span> 信号量值减<span class="hljs-number">1</span><br><br>sem<span class="hljs-constructor">_destroy(&amp;<span class="hljs-params">sem1</span>)</span> 信号量销毁<br></code></pre></td></tr></table></figure><h3 id="互斥锁和条件变量（可以实现一个进程打印5次，另外一个进程打印1次的场景）"><a href="#互斥锁和条件变量（可以实现一个进程打印5次，另外一个进程打印1次的场景）" class="headerlink" title="互斥锁和条件变量（可以实现一个进程打印5次，另外一个进程打印1次的场景）"></a>互斥锁和条件变量（可以实现一个进程打印5次，另外一个进程打印1次的场景）</h3><p>C++： condition_variable C: pthread_cond_t<br>条件变量的一个例子，讲得很详细：<a href="https://blog.csdn.net/jinking01/article/details/110362483">https://blog.csdn.net/jinking01/article/details/110362483</a></p><p>讲述conditon_variable的一个例子：<a href="https://segmentfault.com/a/1190000006679917">https://segmentfault.com/a/1190000006679917</a> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++">伪代码<br>condition_variable cond;<br>mutex p_lock;<br><span class="hljs-keyword">int</span> count=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">process1</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *args)</span></span>&#123;<br>  <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>    p_lock.<span class="hljs-built_in">lock</span>();<br>    count++;<br>    <span class="hljs-keyword">if</span>(count%<span class="hljs-number">5</span>==<span class="hljs-number">0</span>)&#123;<br>      cond.<span class="hljs-built_in">cond_signal</span>(&amp;cond);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>      <span class="hljs-built_in">printFunction</span>(<span class="hljs-string">&quot;this is process 1&quot;</span>);<br>    &#125;<br>    p_lock.<span class="hljs-built_in">unlock</span>();<br><br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">process2</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *args)</span></span>&#123;<br>  <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        p_lock.<span class="hljs-built_in">lock</span>();<br>        <span class="hljs-built_in">cond_wait</span>(&amp;cond);<span class="hljs-comment">//锁内部</span><br>        <span class="hljs-built_in">printFunction</span>(<span class="hljs-string">&quot;this is process 2&quot;</span>);<br>        p_lock.<span class="hljs-built_in">unlock</span>();t<br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>生产者-消费者问题<br>读者-写者问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">sem_t</span> full;<br><span class="hljs-keyword">sem_t</span> empty;<br><span class="hljs-keyword">sem_t</span> mutex;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Producer</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>      <span class="hljs-built_in">down</span>(&amp;empty);<br>      <span class="hljs-built_in">down</span>(&amp;mutex);<br>      <span class="hljs-built_in">produce_item</span>();<br>      <span class="hljs-built_in">up</span>(&amp;mutex);<br>      <span class="hljs-built_in">up</span>(&amp;full);<br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Consumer</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>      <span class="hljs-built_in">down</span>(&amp;full);<br>      <span class="hljs-built_in">down</span>(&amp;mutex);<br>      <span class="hljs-built_in">produce_item</span>();<br>      <span class="hljs-built_in">up</span>(&amp;mutex);<br>      <span class="hljs-built_in">up</span>(&amp;empty);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>读者-写者问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">sem_t</span> data_mutex;<br><span class="hljs-keyword">sem_t</span> count_mutex;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Reader</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>      <span class="hljs-built_in">down</span>(&amp;count_mutex);<br>      count++;<br>      <span class="hljs-keyword">if</span>(count==<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-built_in">down</span>(&amp;data_mutex);<br>      &#125;<br>      <span class="hljs-built_in">up</span>(&amp;count_mutex);<br><br>      <span class="hljs-built_in">read</span>();<span class="hljs-comment">//没有单独加数据锁</span><br><br>      <span class="hljs-built_in">down</span>(&amp;count_mutex);<br>      count--;<br>      <span class="hljs-keyword">if</span>(count==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">up</span>(&amp;data_mutex);<br>      &#125;<br>      <span class="hljs-built_in">up</span>(&amp;count_mutex);<br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">riter</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>      <span class="hljs-built_in">down</span>(&amp;data_mutex);<br>      <span class="hljs-built_in">produce_item</span>();<br>      <span class="hljs-built_in">up</span>(&amp;data_mutex);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>1.<br>引入条件变量一个就是为了避免为了查看条件是否成立而不断轮询的情况<br>总结：互斥锁实现的是线程之间的互斥，条件变量实现的是线程之间的同步。<br>初始化条件变量<br>pthread_cond_t cond = PTHREAD_COND_INITIALIZER;</p><p>该函数用来在一个ConditionVariable上阻塞等待，做以下三步操作：①释放Mutex；②阻塞等待；③当被唤醒时，重新获得Mutex并返回。<br>int pthread_cond_wait(pthread_cond_t &amp;cond_name, pthread_mutex_t &amp;mutex_name);</p><p>唤醒等待线程<br>pthread_cond_signal()：用于唤醒在该条件变量下等待的一个线程，至于哪个被唤醒，取决于线程的优先级和调度策略。<br>pthread_cond_broadcast()：用于唤醒在某个ConditionVariable 上等待的所有线程。使用这种方法时，瞬间唤醒的线程数过多，资源请求过大，容易导致系统不稳定。<br>int pthread_cond_signal(pthread_cond_t &amp;cond_name);<br>int pthread_cond_broadcast(pthread_cond_t &amp;cond_name);</p><ol start="2"><li>和信号量的区别：<br>条件变量的提出是为了解决互斥锁中的循环等待问题，其希望引入一种挂起、唤醒的机制来实现cpu的高效利用<br>（1）使用条件变量可以一次唤醒所有等待者，而这个信号量没有的功能，感觉是最大区别。<br>（2）信号量是有一个值（状态的），而条件变量是没有的，没有地方记录唤醒（发送信号）过多少次，也没有地方记录唤醒线程（wait返回）过多少次。</li></ol><ol start="3"><li>注意！！！！<br>条件变量被通知后，挂起的线程就被唤醒，但是唤醒也有可能是假唤醒，或者是因为超时等异常情况，所以被唤醒的线程仍要检查条件是否满足，所以 wait 是放在条件循环里面。cv.wait(lock, [] { return ready; }); 相当于：while (!ready) { cv.wait(lock); }。</li></ol><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><ol><li>为了实现两个函数的交替打印，可以使用信号量，也可以使用交替锁</li><li>交替打印 FooBar</li></ol><p>solution 1:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++">func1:<br><span class="hljs-built_in">sem_wait</span>(&amp;sem_foo);<br><span class="hljs-built_in">printFoo</span>();<br><span class="hljs-built_in">sem_post</span>(&amp;sem_bar);<br><br><span class="hljs-function">func2</span><br><span class="hljs-function"><span class="hljs-title">sem_wait</span><span class="hljs-params">(&amp;sem_bar)</span></span>;<br><span class="hljs-built_in">printBar</span>();<br><span class="hljs-built_in">sem_post</span>(&amp;sem_foo);<br></code></pre></td></tr></table></figure><p>solution 2 互斥锁（不建议用这种解法，在不同线程加锁解锁确实会出问题）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++">func1:<br>mutex lock1, lock2; <span class="hljs-comment">//这里锁类似条件变量</span><br><br>lock1.<span class="hljs-built_in">lock</span>();<br><span class="hljs-built_in">printFoo</span>();<br>lock2.<span class="hljs-built_in">unlock</span>();<br><br>func2<br>lock2.<span class="hljs-built_in">lock</span>();<br><span class="hljs-built_in">printBar</span>();<br>lock1.<span class="hljs-built_in">unlock</span>();<br></code></pre></td></tr></table></figure><ol start="2"><li>实现一个线程安全的队列<br>在多个线程进行push的时候需要加锁，在push的时候通知pop的线程可以pop<br>使用trypop，如果加锁，判断队列为空，那么直接返回，否则调用pop //不用try pop那么可能出现阻塞<br>pop函数使用使用条件锁 m_cond, 在pop的时候也需要加锁 //在多进程需要使用条件变量，虽然判断了是否为empty再进入的pop，因为可能时间片被其他线程占用导致当前没有元素pop<br>empty(), 加锁判断队列里面是否有元素</li></ol><p>使用条件变量判断队列里面是否有元素，才能pop</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>ok<br>生成者-消费者需要两个信号量用于同步，一个用于给数据加锁<br>条件变量主要是用于达到了某个条件通知另外的进程可以做某件事（5对1，或者队列pop push）<br>读者-写者，写者加数据锁（信号量），读者只需要加count锁，因为多个读者可以同时读<br>队列这种，pop先判断是否为空，为空直接返回；不为空还需要等待条件变量，放置pop的时候被其他pop抢占，或者多个同时判断不为空，但是只有一个元素情况</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;semaphore-信号量&quot;&gt;&lt;a href=&quot;#semaphore-信号量&quot; class=&quot;headerlink&quot; title=&quot;semaphore 信号量&quot;&gt;&lt;/a&gt;semaphore 信号量&lt;/h3&gt;&lt;figure class=&quot;highlight reas</summary>
      
    
    
    
    <category term="leetcode" scheme="http://shu0421.github.io/en/categories/leetcode/"/>
    
    
    <category term="多线程并发， 信号量， 互斥锁" scheme="http://shu0421.github.io/en/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%EF%BC%8C-%E4%BF%A1%E5%8F%B7%E9%87%8F%EF%BC%8C-%E4%BA%92%E6%96%A5%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>分布式训练</title>
    <link href="http://shu0421.github.io/en/2022/01/26/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%AD%E7%BB%83/"/>
    <id>http://shu0421.github.io/en/2022/01/26/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%AD%E7%BB%83/</id>
    <published>2022-01-26T02:50:50.000Z</published>
    <updated>2022-02-14T10:03:35.528Z</updated>
    
    <content type="html"><![CDATA[<h3 id="资料："><a href="#资料：" class="headerlink" title="资料："></a>资料：</h3><p>一个pytorch 分布式 单机多卡/多机多卡的例子<br><a href="https://github.com/lesliejackson/PyTorch-Distributed-Training">https://github.com/lesliejackson/PyTorch-Distributed-Training</a></p><p>常见分布式训练讲解，但是主要命令是启动单机多卡，而不是多机多卡 包括slum, apex, horovod<br><a href="https://github.com/tczhangzhi/pytorch-distributed">https://github.com/tczhangzhi/pytorch-distributed</a> </p><p>pytorch DDP介绍<br><a href="https://zhuanlan.zhihu.com/p/76638962">https://zhuanlan.zhihu.com/p/76638962</a></p><p><a href="https://github.com/richardkxu/distributed-pytorch">https://github.com/richardkxu/distributed-pytorch</a> （也有多机多卡的命令）</p><p>可能会用到：<br>两个机器之间相互免密登录：<a href="https://blog.csdn.net/u010391029/article/details/51126210">https://blog.csdn.net/u010391029/article/details/51126210</a></p><p>DDP time breakdown<br><a href="https://discuss.pytorch.org/t/how-to-measure-ddp-time-breakdown/78925">https://discuss.pytorch.org/t/how-to-measure-ddp-time-breakdown/78925</a><br><a href="https://discuss.pytorch.org/t/how-to-measure-ddp-time-breakdown/78925">https://discuss.pytorch.org/t/how-to-measure-ddp-time-breakdown/78925</a><br><a href="https://discuss.pytorch.org/t/calculating-flops-of-a-given-pytorch-model/3711/4">https://discuss.pytorch.org/t/calculating-flops-of-a-given-pytorch-model/3711/4</a> FLOPS计算</p><p>多进程logging和mkdir设置，分布式inferenc/ 分布式训练的一些小技巧</p><p><a href="https://zhuanlan.zhihu.com/p/250471767">https://zhuanlan.zhihu.com/p/250471767</a> </p><blockquote><p>包括的内容1. 在DDP中引入SyncBN<br>2. DDP下的Gradient Accumulation的进一步加速<br>3. 多机多卡环境下的inference加速<br>4. 保证DDP性能：确保数据的一致性<br>5. 和DDP有关的小技巧<br>6. 1. 控制不同进程的执行顺序<br>   2. 避免DDP带来的冗余输出</p></blockquote><p>Ray分布式执行框架  PyTorch + Ray Tune 调参<br><a href="https://blog.csdn.net/tszupup/article/details/112059788">https://blog.csdn.net/tszupup/article/details/112059788</a></p><p>分布式相关论文源码<br><a href="https://github.com/msr-fiddle/pipedream">https://github.com/msr-fiddle/pipedream</a>  pipedream源码 mini-bath parallism<br><a href="https://github.com/kakaobrain/torchgpipe">https://github.com/kakaobrain/torchgpipe</a></p><p>pytorch分布式训练的时候保存一定要用model.module<br><a href="https://blog.csdn.net/comway_Li/article/details/107531165">https://blog.csdn.net/comway_Li/article/details/107531165</a> 一些需要注意的地方</p><p>horovod多机多卡<br><a href="http://chaopeng.name/2020/01/03/horovod%E5%A4%9A%E6%9C%BA%E5%A4%9A%E5%8D%A1%E5%90%AF%E5%8A%A8%E6%8C%87%E5%8D%97/">http://chaopeng.name/2020/01/03/horovod%E5%A4%9A%E6%9C%BA%E5%A4%9A%E5%8D%A1%E5%90%AF%E5%8A%A8%E6%8C%87%E5%8D%97/</a></p><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ol><li>DP和DDP区别<br>DP是单进程多线程数据并行，将模型copy到每个设备，scatter数据到每个设备进行计算后，将多个GPU输出传到master device(一般为设备0)进行损失计算，（可以优化一下：将loss作为forward 一部分，这样的话每个GPU上自行计算loss，而不用进行模型输出的传输）将损失结果（分发的是各个GPU分别对应的loss）传给每个设备进行反向传播，每个设备将反向传播后的梯度到主设备进行汇聚求平均，然后replicate一份模型的参数到每个设备中，重复上诉的训练过程。</li></ol><ol start="2"><li><p>DDP中all reduce与PS<br> DDP （all reduce）同步的是梯度，不是参数<br> PS，传给master的是梯度，返回的是参数</p><p> 思考：对不重要的梯度进行累积后同步/直接不同步（会不会造成模型的不一致）</p></li><li><p>同步代码<br>分布式训练源代码解读：<a href="https://zhuanlan.zhihu.com/p/343951042">https://zhuanlan.zhihu.com/p/343951042</a></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">手动同步梯度<br><span class="hljs-keyword">for</span> param <span class="hljs-keyword">in</span> ddp_model.parameters<span class="hljs-literal">()</span>: <br>dist.all<span class="hljs-constructor">_reduce(<span class="hljs-params">param</span>.<span class="hljs-params">grad</span>.<span class="hljs-params">data</span>, <span class="hljs-params">op</span>=<span class="hljs-params">dist</span>.<span class="hljs-params">reduce_op</span>.SUM)</span><br>    param.grad.data /= world_size <br><br>手动同步参数：<br>在不重要的样本反向传播后但是不同步参数后，同步梯度<br><span class="hljs-keyword">for</span> param <span class="hljs-keyword">in</span> ddp_model.parameters<span class="hljs-literal">()</span>: <br>dist.all<span class="hljs-constructor">_reduce(<span class="hljs-params">param</span>.<span class="hljs-params">data</span>, <span class="hljs-params">op</span>=<span class="hljs-params">dist</span>.<span class="hljs-params">reduce_op</span>.SUM)</span><br>    param.data /= world_size <br></code></pre></td></tr></table></figure></li></ol><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><h4 id="solution-1-atom版本"><a href="#solution-1-atom版本" class="headerlink" title="solution 1 - atom版本"></a>solution 1 - atom版本</h4><p>裸机 多节点 atom平台</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /workspace/mnt/storage/anchao/ac_file/traffic_iteration/SupreVision &amp;&amp; \<br>./install.sh &amp;&amp; \<br>python -m torch.distributed.launch \<br>        --nnode=4 \<br>        --node_rank=0 \<br>        --nproc_per_node=8 \<br>        --master_addr=<span class="hljs-string">&quot;10.244.55.30&quot;</span> \<br>        --master_port=23467 \<br>        tools/train.py \<br>        --config_file configs/YOLOv3/opencv_pelee_reorg.yml \<br>        SOLVER.IMS_PER_BATCH <span class="hljs-string">&quot;16&quot;</span> \<br>        MODEL.DEVICE_ID <span class="hljs-string">&quot;(&#x27;0,1,2,3,4,5,6,7&#x27;)&quot;</span> \<br>        &gt; detection0.log 2&gt;&amp;1<br></code></pre></td></tr></table></figure><p>单机多卡</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /workspace/mnt/storage/anchao/ac_file/traffic_iteration/SupreVision &amp;&amp; \<br>./install.sh &amp;&amp; \<br>CUDA_VISIBLE_DEVICES=3,4,5,6 python -m torch.distributed.launch \<br>                --nproc_per_node=2 \<br>                --master_port=$((RANDOM + <span class="hljs-number">20000</span>)) \<br>                ./imagenet_final_train_master.py \<br>                --config_file configs/YOLOv3/opencv_pelee_reorg.yml \<br>                &gt; detection0.log 2&gt;&amp;1<br></code></pre></td></tr></table></figure><h4 id="solution-2-简洁版"><a href="#solution-2-简洁版" class="headerlink" title="solution 2 - 简洁版"></a>solution 2 - 简洁版</h4><p>多机多卡<br>suppose we have two machines and one machine have 4 gpus<br>In multi machine multi gpu situation, you have to choose a machine to be master node.<br>we named the machines A and B, and set A to be master node</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">script run at A<br><br>python -m torch.distributed.launch --nproc_per_node=4 --nnode=2 --node_rank=0 --master_addr=A_ip_address master_port=29500 main.py ... <br><br>script run at B<br><br>python -m torch.distributed.launch --nproc_per_node=4 --nnode=2 --node_rank=1 --master_addr=A_ip_address master_port=29500 main.py ... <br></code></pre></td></tr></table></figure><p>单机多卡</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python -m torch.distributed.launch --nproc_per_node=ngpus --master_port=29500 main.py ... <br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;资料：&quot;&gt;&lt;a href=&quot;#资料：&quot; class=&quot;headerlink&quot; title=&quot;资料：&quot;&gt;&lt;/a&gt;资料：&lt;/h3&gt;&lt;p&gt;一个pytorch 分布式 单机多卡/多机多卡的例子&lt;br&gt;&lt;a href=&quot;https://github.com/leslieja</summary>
      
    
    
    
    <category term="工具相关" scheme="http://shu0421.github.io/en/categories/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/"/>
    
    
  </entry>
  
  <entry>
    <title>md语法相关</title>
    <link href="http://shu0421.github.io/en/2022/01/20/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/md%E8%AF%AD%E6%B3%95%E7%9B%B8%E5%85%B3/"/>
    <id>http://shu0421.github.io/en/2022/01/20/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/md%E8%AF%AD%E6%B3%95%E7%9B%B8%E5%85%B3/</id>
    <published>2022-01-20T04:11:13.000Z</published>
    <updated>2022-02-14T10:03:35.528Z</updated>
    
    <content type="html"><![CDATA[<p>对代码块进行折叠</p><details>  <summary>点击时的区域标题</summary><pre><p>内容</p></pre></details>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;对代码块进行折叠&lt;/p&gt;
&lt;details&gt;
  &lt;summary&gt;点击时的区域标题&lt;/summary&gt;
&lt;pre&gt;

&lt;p&gt;内容&lt;/p&gt;

&lt;/pre&gt;&lt;/details&gt;


</summary>
      
    
    
    
    <category term="工具相关" scheme="http://shu0421.github.io/en/categories/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="typora, md" scheme="http://shu0421.github.io/en/tags/typora-md/"/>
    
  </entry>
  
  <entry>
    <title>系统设计相关题目</title>
    <link href="http://shu0421.github.io/en/2022/01/19/leetcode/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    <id>http://shu0421.github.io/en/2022/01/19/leetcode/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</id>
    <published>2022-01-19T06:09:24.000Z</published>
    <updated>2022-04-12T12:52:07.484Z</updated>
    
    <content type="html"><![CDATA[<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p><a href="https://github.com/donnemartin/system-design-primer">https://github.com/donnemartin/system-design-primer</a></p><h4 id="题型"><a href="#题型" class="headerlink" title="题型"></a>题型</h4><h5 id="1-标准布隆过滤器hash函数的设置"><a href="#1-标准布隆过滤器hash函数的设置" class="headerlink" title="1.标准布隆过滤器hash函数的设置"></a>1.标准布隆过滤器hash函数的设置</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashFunction</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> cap, seed;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">HashFunction</span>(<span class="hljs-keyword">int</span> cap, <span class="hljs-keyword">int</span> seed) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;cap = cap;<br>        <span class="hljs-keyword">this</span>-&gt;seed = seed;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(string&amp; value)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> n = value.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            ret += seed * ret + value[i];<br>            ret %= cap;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StandardBloomFilter</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> k;<br>    vector&lt;HashFunction*&gt; hashFunc;<br>    bitset&lt;200000&gt; bits;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">StandardBloomFilter</span>(<span class="hljs-keyword">int</span> k) &#123;<br>        <span class="hljs-comment">// initialize your data structure here</span><br>        <span class="hljs-keyword">this</span>-&gt;k = k;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i)<br>            hashFunc.<span class="hljs-built_in">push_back</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">HashFunction</span>(<span class="hljs-number">100000</span> + i, <span class="hljs-number">2</span> * i + <span class="hljs-number">3</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>每个字符串通过这个hash函数可以得到一个值（position），然后将bit[200000]中该位置为1，多个函数，那么就会有多个位置为1;判断某一个字符串是否存在，就是判断多个函数计算出来值是否都在bit中位1，如果有一个不为1，说明该字符串不在</p><h5 id="2-序列化Trie树-Lintcode"><a href="#2-序列化Trie树-Lintcode" class="headerlink" title="2. 序列化Trie树(Lintcode)"></a>2. 序列化Trie树(Lintcode)</h5><p> 这个模板一定要记住，不要用自己的方法，用模板<br> 同类型题目：二叉树的序列化和反序列化， n叉数的序列化和反序列化<br>注意这道题</p><ul><li>在进行序列化：使用dfs, 在遍历完所有的chidren后，加上‘/‘表示退出当前循环</li><li>在进行反序列化时： 使用全局index, index在进入下一层循环和退出循环(注意这里和二叉树不同，有两处)之前都需要+1， 其余情况index保持不变</li><li>注意:<br>(1)在退出训练时候不是返回null, 而是返回一个Trie对象的指针！！！<br>(2)因为一个节点有多个节点，而不是只有二叉树的left和right节点，因此需要使用while判断，如果data[index]==’/‘的时候退出while循环<br>(3)<figure class="highlight c++"><figcaption><span>right</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">TrieNode* tmp=<span class="hljs-keyword">new</span> <span class="hljs-built_in">TrieNode</span>(); <span class="hljs-comment">//注意区分类和结构体</span><br>map&lt;<span class="hljs-keyword">char</span>, TrieNode*&gt; &amp;childs=tmp-&gt;children;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><figcaption><span>wrong</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">TrieNode* tmp; <span class="hljs-comment">//注意区分类和类指针，这里直接申明一个空指针是不对的, 即使是结构体也应该是student s;</span><br>map&lt;<span class="hljs-keyword">char</span>, TrieNode*&gt; childs;<br>tmp-&gt;children=childs;<br></code></pre></td></tr></table></figure></li></ul><p>官方题解使用的<data> 进行序列化+栈的方式进行反序列化：&lt;将当前current入栈 &gt;将栈顶出栈 其余：新建一个Trie对象(current)，将当前data[index]指向这个对象</data></p><p>//下面模板代码可以用作n叉树的遍历或者trie树遍历，下面的这种方式会将空字符串用&lt;&gt;，如果想要空字符串没有，可以使用dfs2</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition of TrieNode:</span><br><span class="hljs-comment"> * class TrieNode &#123;</span><br><span class="hljs-comment"> * public:</span><br><span class="hljs-comment"> *     TrieNode() &#123;&#125;</span><br><span class="hljs-comment"> *     map&lt;char, TrieNode*&gt; children;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-comment">//适用于n叉数的遍历， 但是这种方式在进行反序列化的时候，每次从栈中弹出一个元素前，需要将栈顶赋值给cur</span><br> <span class="hljs-comment">//&lt;1&lt;3&lt;5&gt;&lt;6&gt;&gt;&lt;2&gt;&lt;4&gt;&gt; null节点无&lt;&gt;</span><br><span class="hljs-comment">//  lc428 每个节点都被&lt;&gt;分开，即使是同一层</span><br><span class="hljs-function">string <span class="hljs-title">dfs</span><span class="hljs-params">(Node* root)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br>    string data;<br>    <span class="hljs-keyword">int</span> size=root-&gt;children.<span class="hljs-built_in">size</span>();<br>    data+=<span class="hljs-built_in">to_string</span>(root-&gt;val);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>        data+=<span class="hljs-built_in">dfs</span>(root-&gt;children[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;&quot;</span>+data+<span class="hljs-string">&quot;&gt;&quot;</span>;<br>&#125;<br><br><span class="hljs-comment">//&lt;a&lt;b&lt;e&lt;&gt;&gt;c&lt;&gt;d&lt;f&lt;&gt;&gt;&gt;&gt; 节点之间可能没有&lt;&gt;分开</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * This method will be invoked first, you should design your own algorithm </span><br><span class="hljs-comment">     * to serialize a trie which denote by a root node to a string which</span><br><span class="hljs-comment">     * can be easily deserialized by your own &quot;deserialize&quot; method later.</span><br><span class="hljs-comment">     */</span><br>     <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(TrieNode* root)</span></span>&#123;<br>        <span class="hljs-function">string <span class="hljs-title">dfs</span><span class="hljs-params">(Node* root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        string data;<br>        <span class="hljs-keyword">int</span> size=root-&gt;children.<span class="hljs-built_in">size</span>();<br>        data+=<span class="hljs-built_in">to_string</span>(root-&gt;val);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>            data+=<span class="hljs-built_in">dfs</span>(root-&gt;children[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;&quot;</span>+data+<span class="hljs-string">&quot;&gt;&quot;</span>;<br>    &#125;<br>    <br>    <span class="hljs-function">string <span class="hljs-title">serialize</span><span class="hljs-params">(TrieNode* root)</span> </span>&#123;<br>        <span class="hljs-comment">// Write your code here</span><br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        string data;<br>        <span class="hljs-keyword">for</span> (map&lt;<span class="hljs-keyword">char</span>, TrieNode*&gt;::iterator it = root-&gt;children.<span class="hljs-built_in">begin</span>();<br>             it != root-&gt;children.<span class="hljs-built_in">end</span>(); ++it) &#123;<br>            data += it-&gt;first;<br>            data += <span class="hljs-built_in">serialize</span>(it-&gt;second);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;&quot;</span> + data + <span class="hljs-string">&quot;&gt;&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * This method will be invoked second, the argument data is what exactly</span><br><span class="hljs-comment">     * you serialized at method &quot;serialize&quot;, that means the data is not given by</span><br><span class="hljs-comment">     * system, it&#x27;s given by your own serialize method. So the format of data is</span><br><span class="hljs-comment">     * designed by yourself, and deserialize it here as you serialize it in </span><br><span class="hljs-comment">     * &quot;serialize&quot; method.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">TrieNode* <span class="hljs-title">deserialize</span><span class="hljs-params">(string data)</span> </span>&#123;<br>        <span class="hljs-comment">// Write your code here</span><br>        <span class="hljs-keyword">if</span> (data.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>        TrieNode* head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TrieNode</span>();<br>        TrieNode* current = head;<br>        stack&lt;TrieNode*&gt; path;<br>        <span class="hljs-keyword">int</span> len = data.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;<br>            <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (data[i]) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>:<br>                    path.<span class="hljs-built_in">push</span>(current);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>:<br>                    <span class="hljs-comment">//如果是null节点无&lt;&gt;情况，那么需要在这里赋值cur=path.top()</span><br>                    path.<span class="hljs-built_in">pop</span>();<br>                    <br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">default</span>:<br>                    current = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TrieNode</span>();<br>                    path.<span class="hljs-built_in">top</span>()-&gt;children[data[i]] = current;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ol start="3"><li>Trie树专题<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">class <span class="hljs-title">Trie</span><span class="hljs-params">()</span></span>&#123;<br>    vector&lt;Trie*&gt; children;<br>    <span class="hljs-keyword">bool</span> isEnd;<br>    <span class="hljs-built_in">Trie</span>()&#123;<br>        <span class="hljs-keyword">this</span>-&gt;child = vector&lt;Trie*&gt;(<span class="hljs-number">26</span>,<span class="hljs-literal">nullptr</span>); <span class="hljs-comment">//一定要记得初始化26个节点，而且都为null</span><br>        <span class="hljs-keyword">this</span>-&gt;isEnd = <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-built_in">search</span>(string s)&#123;<br>        Trie* root=<span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(root-&gt;children[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>]==<span class="hljs-literal">NULL</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            root= root-&gt;children[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> root-&gt;isEnd;<br>    &#125;<br>    <span class="hljs-built_in">insert</span>(string s)&#123;<br>        Trie* root=<span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();i++)&#123;<br>            <span class="hljs-keyword">if</span>(root-&gt;children[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>]==<span class="hljs-literal">NULL</span>)&#123;<br>                root-&gt;children[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>]=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Trie</span>();<br>            &#125;<br>            root= root-&gt;children[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        root-&gt;isEnd=<span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ol><p>二叉树的序列化和反序列可以使用前序遍历实现</p><ol start="4"><li>lc355. 设计推特</li></ol><ul><li>需要实现4个功能: 关注， 取消关注， 发表博客， 列出userid和userid最近发表的10条博客</li><li>实现关注和取消关注使用unordered_map&lt;int, unordered_set<int>&gt; hash</int></li><li>发表博客使用unordered_map&lt;int, node*&gt; , 其中node记录<br>node{<br>  tuiteid, //充当时间戳<br>  userid, //发表用户<br>  node* next; //指向下一个node, 类似于LRU，方便使用头插入方法<br>}</li><li> 列出userid和userid最近发表的10条博客， 使用K个链表的合并，找出前M个数</li><li>为什么使用链表，这样的话扩展非常方便，如果不使用，那么在删除博客的时候就比较麻烦</li></ul><ol start="5"><li>单词自动补全系统</li></ol><ul><li>题意：1. 初始化系统，包括一些句子和句子最初始的频率，一个句子之间可能小写字符或者空格 2. 每次input一个字符应该接着上一个字符，同时输出‘#’表示输出的末尾，这时候需要初始化data=””, cur=root（全局变量）, 更新句子的频率</li><li>解决方案：</li><li><ol><li>使用前缀树+hash(存储句子+频率) 前缀树的每个节点，应该存储一个vector<string> 表示走到这个节点的下面所有字符</string></li></ol></li><li><ol start="2"><li>注意字符串在进行查找如果cur==null, 那么直接返回空，否则一直在cur的基础上走一步 cur=cur-&gt;children[c]//unordered_map&lt;char, TrieNode*&gt; children;</li></ol></li><li><ol start="3"><li>如果走到‘#’，表示走到了末尾，这时候需要初始化data=””, cur=root, 同时更新句子的频率 +1（句子频率会更新）</li></ol></li><li>参考答案: <a href="https://aaronice.gitbook.io/lintcode/data_structure/design-search-autocomplete-system">https://aaronice.gitbook.io/lintcode/data_structure/design-search-autocomplete-system</a><br><a href="https://zhuanlan.zhihu.com/p/99499171">https://zhuanlan.zhihu.com/p/99499171</a> (有点问题，不应该在每个节点里面记录节点的频率，因为这个随时更新，之后就不准确，应该用一个单独的hashmap来记录)</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>一般是有关于系统， 多个函数的整体设计题目<br>比如：GeoHash, GFS, 布隆过滤器， 心跳设计， 缓存系统， LRU cache设计，二叉树的序列化和反序列化等<br>还有新定义一种数据结构，嵌套返回list leetcode-扁平化嵌套列表迭代器 使用递归方式分解</p><p>为了在vector里面删除元素更快，可以再配合使用一个dict (map)映射特定值对应的index;注意在进行删除元素的时候，除了交换vector中最后一个元素和当前元素，还需要修改hash最后一个元素映射的下标为当前index+从hash中删除key</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;链接&quot;&gt;&lt;a href=&quot;#链接&quot; class=&quot;headerlink&quot; title=&quot;链接&quot;&gt;&lt;/a&gt;链接&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/donnemartin/system-design-primer&quot;&gt;https://</summary>
      
    
    
    
    <category term="leetcode" scheme="http://shu0421.github.io/en/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>Zplot画图相关知识点</title>
    <link href="http://shu0421.github.io/en/2022/01/04/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/zplot/"/>
    <id>http://shu0421.github.io/en/2022/01/04/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/zplot/</id>
    <published>2022-01-04T08:04:52.000Z</published>
    <updated>2022-07-31T09:11:32.488Z</updated>
    
    <content type="html"><![CDATA[<p>Zplot-folder<br>|–breakdown<br>    |–Makefile<br>    |–breakdown1.py<br>    |–breakdown1.data<br>    |–breakdown2.py<br>    |–breakdown2.data<br>|–eval_lineplot<br>    |–Makefile<br>|–…<br>|–makefig.sh</p><ol><li>每次运行的时候只需要运行makefig文件就可以了，如果要修改所有生成的pdf在的目录，直接修改makefig.sh</li></ol><p>2。 Makefile里面的文件主要是运行当前py文件生成eps文件，然后使用ps2pdf转为pdf并使用pdf2crop对生成的pdf文件进行裁剪<br>PS：一定要注意python文件的名字一定要和data文件名字相同，否则会报错</p><p>prequisuite</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install zplot <br><span class="hljs-comment">#注意可能会出现list错误，可能是由于python2 和python3的不兼容原因，只需要将zplot.py里面的ListType改为list就可以了</span><br><br>sudo apt-get install texlive-extra-utils  <br></code></pre></td></tr></table></figure><p>Makefile文件分析</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash">PY=python<br>EPS2PDF=ps2pdf<br>CROP=pdfcrop<br><br>SRC := $(wildcard *.py) <span class="hljs-comment">#列出所有文件对应的py文件</span><br>SRC := $(filter-out zplot.py, $(SRC))<br>EPS = $(patsubst %.py,%.eps,$(SRC))<br>PDF = $(patsubst %.py,%.pdf,$(SRC)) <span class="hljs-comment">#列出所有文件对应的eps和pdf文件</span><br><br>all: $(EPS) $(PDF)<br><br>%.eps: %.py  <span class="hljs-comment"># 目标文件： 源文件</span><br>$(PY) $&lt; eps  <span class="hljs-comment">#$&lt; 表示源文件  $@表示目标文件//官方解释： $&lt; 表示第一个依赖文件， $@ 表示目标集</span><br><br>%.pdf: %.eps<br>$(EPS2PDF) $&lt;<br>$(CROP) <span class="hljs-variable">$@</span> <span class="hljs-variable">$@</span><br>rm -rf $&lt;<br><br>fig:<br><span class="hljs-comment"># mv -f *.pdf ../../../fig/ #将所有的文件都转移到zplot对应的root目录下面</span><br>mv -f *.pdf ../../<br>rm -rf *.eps *.pdf<br></code></pre></td></tr></table></figure><p>makefile语法的参考链接： <a href="https://seisman.github.io/how-to-write-makefile/rules.html">https://seisman.github.io/how-to-write-makefile/rules.html</a> </p><p>makefig.sh文件分析</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>rm -rf *.pdf <span class="hljs-comment">#这是我自己家的，在执行生成之前，现将之前生成的pdf文件删除，应该是也不用</span><br><br><span class="hljs-keyword">for</span>  dir  <span class="hljs-keyword">in</span>  `find .  -name Makefile`  <span class="hljs-comment">#找到包含Makefile文件的dir</span><br><span class="hljs-keyword">do</span><br>path=`dirname <span class="hljs-variable">$dir</span>` <span class="hljs-comment">#找到dir对应的路径path</span><br>    <span class="hljs-comment"># echo $path</span><br>    <span class="hljs-comment"># echo $dir</span><br><span class="hljs-keyword">if</span>  [ <span class="hljs-variable">$path</span>  !=  . ]<br><span class="hljs-keyword">then</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$path</span> <span class="hljs-comment">#打印出path的路径</span><br><span class="hljs-built_in">cd</span> <span class="hljs-variable">$path</span>  <br>make    <span class="hljs-comment">#执行make和makefig命令</span><br>make fig<br><span class="hljs-built_in">cd</span>  -<br><span class="hljs-keyword">fi</span><br><span class="hljs-keyword">done</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Zplot-folder&lt;br&gt;|–breakdown&lt;br&gt;    |–Makefile&lt;br&gt;    |–breakdown1.py&lt;br&gt;    |–breakdown1.data&lt;br&gt;    |–breakdown2.py&lt;br&gt;    |–breakdown2.</summary>
      
    
    
    
    <category term="工具相关" scheme="http://shu0421.github.io/en/categories/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="zplot" scheme="http://shu0421.github.io/en/tags/zplot/"/>
    
  </entry>
  
  <entry>
    <title>Anaconda环境搭建</title>
    <link href="http://shu0421.github.io/en/2021/12/15/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/anaconda%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%BB%8E%E9%9B%B6%E5%88%B0%E4%B8%80/"/>
    <id>http://shu0421.github.io/en/2021/12/15/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/anaconda%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%BB%8E%E9%9B%B6%E5%88%B0%E4%B8%80/</id>
    <published>2021-12-15T06:48:24.000Z</published>
    <updated>2022-02-14T10:03:35.528Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>一个服务器上已经搭建好的环境，但是需要换另一台机器，或者另外的用户需要访问这个环境， 如果另一台服务器上没有anaconda环境就需要从0开始进行搭建，然后再进行环境的迁移</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol><li>安装anaconda3<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">wget</span> https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda<span class="hljs-number">3</span>-<span class="hljs-number">5</span>.<span class="hljs-number">3</span>.<span class="hljs-number">1</span>-Linux-x<span class="hljs-number">86</span>_<span class="hljs-number">64</span>.sh<br><span class="hljs-attribute">bash</span> Anaconda<span class="hljs-number">3</span>-<span class="hljs-number">5</span>.<span class="hljs-number">3</span>.<span class="hljs-number">1</span>-Linux-x<span class="hljs-number">86</span>_<span class="hljs-number">64</span>.sh<br></code></pre></td></tr></table></figure></li></ol><p>一般情况下安装是默认设置，在安装vscode的时候可以根据需要选择no或者yes<br>注意在安装installer的时候需要选择yes, 如果选择了no<br>那么可以自行添加环境:<br><a href="https://zhuanlan.zhihu.com/p/64930395%EF%BC%88%E4%B9%9F%E5%B0%B1%E6%98%AF%E6%BF%80%E6%B4%BB%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%89">https://zhuanlan.zhihu.com/p/64930395（也就是激活环境中的方法二）</a></p><ol start="2"><li>激活环境<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 方法一失效</span><br>输入命令打开配置文件：vim ~/.bashrc<br>在最后添加语句：export PATH=<span class="hljs-regexp">/root/</span>xxx<span class="hljs-regexp">/anaconda3/</span>bin:<span class="hljs-variable">$PATH</span> （<span class="hljs-regexp">/root/</span>xxx 为安装路径）<br>最后输入如下命令，更新配置文件即可：source ~/.bashrc<br><br><span class="hljs-comment">#方法二有效：</span><br>如果conda的初始化时选择了no，则需要自行配置环境变量。<br><br>打开profile文件：<br><br>vi <span class="hljs-regexp">/etc/</span>profile<br>在文件最后加入如下语句（路径需要根据自己的安装位置更改）：<br><br>PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-regexp">/opt/</span>anaconda3/bin<br>export PATH<br>保存文件并退出。最后使用如下命令刷新环境变量即可：<br><br>source <span class="hljs-regexp">/etc/</span>profile<br>echo <span class="hljs-variable">$PATH</span><br></code></pre></td></tr></table></figure></li></ol><p>PS: 如果conda名称弹出问题，使用<code>sudo vi ~/.bashrc</code>查看conda路径是否正确</p><ol start="3"><li>conda相关命令<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs applescript">conda <span class="hljs-built_in">list</span> 查看安装包<br>conda info <span class="hljs-comment">--envs 查看环境</span><br>conda <span class="hljs-built_in">activate</span> XXX 激活环境 （XXX 为环境名称）<br>python -V 检查Python版本<br><br>如果需要卸载anaconda的话，只需要删除anaconda目录即可:<br>rm -rf /root/xxx/anaconda3<br></code></pre></td></tr></table></figure></li><li>使用conda-pack迁移环境</li></ol><p>在源机器：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">conda pack -n env-<span class="hljs-built_in">name</span> <span class="hljs-comment">--ignore-editable-packages（如果没有后面这个会报错）</span><br>得到一个env_name.tar.gz压缩文件<br></code></pre></td></tr></table></figure><p>在目标机器：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">cd ~<span class="hljs-regexp">/anaconda3/</span>envs;<br>mkdir env_name<br>tar -xzvf env_name.tar.gz -C <span class="hljs-regexp">/home/</span>root_name<span class="hljs-regexp">/anaconda3/</span>envs/env_name<br></code></pre></td></tr></table></figure><ol start="5"><li>使用环境<br><code>source activate attnGAN</code></li></ol><p>注意使用conda activate会报错<br>目前找到一个解决方案：<br><a href="https://blog.csdn.net/qq_43828332/article/details/114235922">https://blog.csdn.net/qq_43828332/article/details/114235922</a></p><p>总共耗时 1个半小时左右~</p><h4 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h4><ol><li><a href="https://blog.csdn.net/lwgkzl/article/details/89329383">https://blog.csdn.net/lwgkzl/article/details/89329383</a></li><li><a href="https://www.jianshu.com/p/1fddd11bcd25">https://www.jianshu.com/p/1fddd11bcd25</a></li><li><a href="https://blog.csdn.net/ds1302__/article/details/120027173">https://blog.csdn.net/ds1302__/article/details/120027173</a></li></ol><p>注意之江实验室hec anaconda3的安装路径是：/nfs/home </p><h4 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h4><p>在终端输入conda info –envs检验anaconda是否安装成功，发现报错：conda: command not found</p><p>原因是因为~/.bashrc文件没有配置好</p><p>解决方案：<br>sudo vim ~/.bashrc<br>在最后一行加上<br>export PATH=$PATH:/home/vincent/anaconda3/bin</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h3&gt;&lt;p&gt;一个服务器上已经搭建好的环境，但是需要换另一台机器，或者另外的用户需要访问这个环境， 如果另一台服务器上没有anaconda</summary>
      
    
    
    
    <category term="工具相关" scheme="http://shu0421.github.io/en/categories/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="conda environment" scheme="http://shu0421.github.io/en/tags/conda-environment/"/>
    
  </entry>
  
  <entry>
    <title>RPC related</title>
    <link href="http://shu0421.github.io/en/2021/12/03/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/rpc/"/>
    <id>http://shu0421.github.io/en/2021/12/03/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/rpc/</id>
    <published>2021-12-03T02:01:07.000Z</published>
    <updated>2023-07-10T10:36:19.582Z</updated>
    
    <content type="html"><![CDATA[<p>gRPC 可以保证不同语言之间的通讯<br>编写.proto文件，生成指定语言源代码。<br>编写服务端代码<br>编写客户端代码<br><a href="https://www.liwenzhou.com/posts/Go/gRPC/">https://www.liwenzhou.com/posts/Go/gRPC/</a>  一个python客户端和go服务端的例子</p><p>pytorch的官网框架<br>rpc常见方法<br>rpc_sync同步远程调用、rpc_async异步远程调用、remote异步远程调用。</p><p>rpc.init_rpc 初始化rpc，需要在master和worker都进行初始化，方便之后的通讯<br>rpc.rpc_sync  worker端调用在master上进行执行的方法<br>rpc.rpc_async<br>rpc.remote</p><p>dist_autograd.get_gradient(cid) 目前猜测在rpc场景进行前向传播，的梯度反向传播需要使用dist_grad</p><p>TrainNet是worker调用的假的网络，实际的网络是在Net里面调用，每次worker里面数据的前向传播，实际上都是在master里面的调用net进行前向传播</p><h3 id="分析rpc-parameter-server代码"><a href="#分析rpc-parameter-server代码" class="headerlink" title="分析rpc_parameter_server代码"></a>分析rpc_parameter_server代码</h3><p>master和worker都需要init_rpc</p><p>worker里面主要执行TrainNet：初始化的时候得到远程parameterServer的引用，然后包含二个函数 get_global_param_rref 以及forward函数(均要调用remote_method)<br>master里面执行parameterServer类，：初始的时候，得到真实训练的model, 同时实现三个函数, 对模型参数加上的引用rpc.RRef，使用dist_autograd得到模型参数，以及对输入数据进行前向传播</p><p>在master中加上</p><p>uni_sample_score_rref</p><h3 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h3><p>route_guide_client文件主要是通过stub 和传入的参数调用server的函数</p><p>route_guide_server里面主要是编写得到输入服务器处理函数逻辑</p><p>route_guide_pb2_grpc，类似于头文件，定义Stub类和Servicer类，每个类只是定义函数，但不进行具体的实现； 以及一个add_RouteGuideServicer_to_server的函数</p><h4 id="使用go语言"><a href="#使用go语言" class="headerlink" title="使用go语言"></a>使用go语言</h4><ul><li>前置安装要求<br>安装go，和protocol buffer编译器<br><a href="https://grpc.io/docs/languages/go/quickstart/#prerequisites">https://grpc.io/docs/languages/go/quickstart/#prerequisites</a></li></ul><p>go command not found<br>使用export， 重启一个控制台窗口就找不到这个命令了<br>需要使用vim <del>/.bashrc写入文件 将这个命令写进去，然后使用source ~/.bashrc<br>(</del>/.bashrc:是用户相关的终端（shell）的环境设置，通常打开一个新终端时，默认会load里面的设置，在这里的设置不影响其它人。<br>/etc/profile会影响所有的用户)</p><p>go download超时解决：<br>export GOPROXY=<a href="https://goproxy.cn/">https://goproxy.cn</a></p><h4 id="使用python"><a href="#使用python" class="headerlink" title="使用python"></a>使用python</h4><p>一个python小例子：<a href="https://grpc.io/docs/languages/python/quickstart/">https://grpc.io/docs/languages/python/quickstart/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;gRPC 可以保证不同语言之间的通讯&lt;br&gt;编写.proto文件，生成指定语言源代码。&lt;br&gt;编写服务端代码&lt;br&gt;编写客户端代码&lt;br&gt;&lt;a href=&quot;https://www.liwenzhou.com/posts/Go/gRPC/&quot;&gt;https://www.liwen</summary>
      
    
    
    
    <category term="工具相关" scheme="http://shu0421.github.io/en/categories/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/"/>
    
    
  </entry>
  
  <entry>
    <title>orangefs</title>
    <link href="http://shu0421.github.io/en/2021/12/01/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/orangefs/"/>
    <id>http://shu0421.github.io/en/2021/12/01/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/orangefs/</id>
    <published>2021-12-01T07:54:01.000Z</published>
    <updated>2022-02-14T10:03:35.528Z</updated>
    
    <content type="html"><![CDATA[<h3 id="orangefs"><a href="#orangefs" class="headerlink" title="orangefs"></a>orangefs</h3><ol><li><p>genconfig是一个go语言文件，它有一个可选参数oranges-server.conf</p></li><li><p>init_start_all.sh相比start_all.sh 多了一个/local500G/orange_store/ 以及多了一条有-f命令的语句 应该是在服务器节点启动pvfs-server<br>orangefs默认的服务器的文件系统挂载的目录是在oranges-server.conf里面进行配置（/nfs/home/yfwang/orangefs/install/etc/oranges-server.conf）</p></li></ol><p>加上f的原因： 第一次启动PVFS2服务要首先分配空间，添加参数-f：<br>root@ubuntu:~# pvfs2-server /etc/pvfs2-fs.conf -f<br>其后启动服务则不需加参数，或使用-d使得服务运行于前台（占用当前终端窗口，终端窗口关闭后服务终止）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> host <span class="hljs-keyword">in</span> `cat /nfs/home/yfwang/orangefs/install/nodelist`<br><span class="hljs-keyword">do</span><br><span class="hljs-comment">#       ssh -t -t -o StrictHostKeyChecking=no -o PasswordAuthentication=no $USER@$host sudo rm -rf /local500G/orange_store/*</span><br>        ssh -t -t -o StrictHostKeyChecking=no -o PasswordAuthentication=no <span class="hljs-variable">$USER</span>@<span class="hljs-variable">$host</span> sudo /nfs/home/yfwang/orangefs/install/sbin/pvfs2-server -f /nfs/home/yfwang/orangefs/install/etc/oranges-server.conf<br>        ssh -t -t -o StrictHostKeyChecking=no -o PasswordAuthentication=no <span class="hljs-variable">$USER</span>@<span class="hljs-variable">$host</span> sudo /nfs/home/yfwang/orangefs/install/sbin/pvfs2-server /nfs/home/yfwang/orangefs/install/etc/oranges-server.conf<br><span class="hljs-keyword">done</span> <br></code></pre></td></tr></table></figure><ol start="4"><li><p>stop_all.sh 停止所有的pvfs-server</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> host <span class="hljs-keyword">in</span> `cat /nfs/home/yfwang/orangefs/install/nodelist`<br><span class="hljs-keyword">do</span><br>        ssh -t -t -o StrictHostKeyChecking=no -o PasswordAuthentication=no <span class="hljs-variable">$USER</span>@<span class="hljs-variable">$host</span> sudo killall pvfs2-server<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure></li><li><p>start_client.sh 启动客户端orangefs-client， 同时将服务器任意一个节点的位置暴露为客户端，例子是hec09</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo /nfs/home/yfwang/orangefs/install/sbin/pvfs2-client -f -p /nfs/home/yfwang/orangefs/install/sbin/pvfs2-client-core<br>sudo mount -t pvfs2 tcp://hec09:3334/orangefs /mnt/orangefs<br></code></pre></td></tr></table></figure><p>nodelist<br>里面直接写hec10 hec11</p><p><a href="https://github.com/waltligon/orangefs/wiki/Distributions-and-Layouts">https://github.com/waltligon/orangefs/wiki/Distributions-and-Layouts</a> 设置数据不同的放置策略,一个文件放在一个节点使用basic方式 distribution</p><p><a href="https://github.com/waltligon/orangefs/wiki/Programming-Guide">https://github.com/waltligon/orangefs/wiki/Programming-Guide</a></p><p>setfattr -n “user.pvfs2.dist_name” -v “basic_dist” /mnt/pvfs2/directory<br>./bin/pvfs2-xattr -s -k “user.pvfs2.dist_name” -v “basic-dist” /mnt/shu-orangefs/dataset</p><p>orangefs里面有一个PINT_dist函数<br><a href="https://www.mcs.anl.gov/~robl/pvfs2/pvfs2-dox/html/pint-distribution_8c.html#a2">https://www.mcs.anl.gov/~robl/pvfs2/pvfs2-dox/html/pint-distribution_8c.html#a2</a></p><h5 id="现在找到将文件保存在一个服务器的方案："><a href="#现在找到将文件保存在一个服务器的方案：" class="headerlink" title="现在找到将文件保存在一个服务器的方案："></a>现在找到将文件保存在一个服务器的方案：</h5><p><a href="https://stackoverflow.com/questions/64923445/how-to-configure-orangefs-save-the-file-into-the-same-server-not-split-it">https://stackoverflow.com/questions/64923445/how-to-configure-orangefs-save-the-file-into-the-same-server-not-split-it</a><br>使用命令：setfattr -n “user.pvfs2.num_dfiles” -v “1” /mnt/orangefs<br>如果按照这种方式设置会报错：setfattr -n “user.pvfs2.dist_name” -v “basic_dist” /mnt/pvfs2/directory 传输数据会报错</p><h3 id="配置教程"><a href="#配置教程" class="headerlink" title="配置教程"></a>配置教程</h3><p>安装server<br>拷贝已经编译好的程序<br>cp -r /nfs/home/yfwang/orangefs/install /nfs/home/weijian/orangefs_install/<br>配置server<br>./bin/pvfs2-genconfig /nfs/home/weijian/orangefs_install/install/orangefs-server.conf<br>具体的配置项，自己可以先记录下来<br>tcp<br>3336<br>/local500G/wj-fast/storage/data<br>/local500G/wj-fast/storage/meta<br>/var/log/orangefs-server.log<br>hec08,hec09<br>配置完成时可以cat /nfs/home/weijian/orangefs_install/install/orangefs-server.conf查看配置项是否符合需求<br>到各个server上，各自初始化存储目录<br>sudo ./sbin/pvfs2-server -f orangefs-server.conf -a <server alias><br>到各个server上，启动服务<br>sudo ./sbin/pvfs2-server  orangefs-server.conf</server></p><p>安装client<br>拷贝已经编译好的程序（如果已经可以访问就不需要拷贝了）<br>scp -r weijian@hec08:/nfs/home/yfwang/orangefs/install/ /nfs/home/weijian/orangefs_install/<br>向内核加载orangefs模块<br>sudo modprobe orangefs<br>创建挂载点<br>sudo mkdir /mnt/wj-fast-orangefs<br>写配置文件<br>sudo sh -c “echo ‘tcp://hec08:3336/orangefs /mnt/wj-fast-orangefs pvfs2’ &gt;&gt; /etc/pvfs2tab”<br>测试与server是否连通<br>./bin/pvfs2-ping -m /mnt/wj-fast-orangefs<br>启动client客户端<br>sudo ./sbin/pvfs2-client -p ./sbin/pvfs2-client-core<br>挂载<br>sudo mount -t pvfs2 tcp://hec08:3336/orangefs /mnt/wj-fast-orangefs</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;orangefs&quot;&gt;&lt;a href=&quot;#orangefs&quot; class=&quot;headerlink&quot; title=&quot;orangefs&quot;&gt;&lt;/a&gt;orangefs&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;genconfig是一个go语言文件，它有一个可选参数oranges-se</summary>
      
    
    
    
    <category term="工具相关" scheme="http://shu0421.github.io/en/categories/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/"/>
    
    
  </entry>
  
  <entry>
    <title>二叉树</title>
    <link href="http://shu0421.github.io/en/2021/11/23/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://shu0421.github.io/en/2021/11/23/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2021-11-23T02:27:56.000Z</published>
    <updated>2023-07-10T10:36:19.532Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>验证二叉树的前序序列化<br> 观察规律题或者建树题<br> 我的思路是直接建立一颗二叉树，但是建立树代码可以不写；最后树是正确的就是中间不会访问到cur==size的情况，同时最后循环完之后不会再出现#或者数字<br> 官方题解是：通过槽位计数，如果遍历到最后槽位为0说明正确，如果中间槽位为0，说明出错<br> 因为加上一个#槽位数会–，如果加上一个数字那么槽位数会++（-1+2）<br> 注意这道题的易错点是: 字符串中包含’,’而且可能数字包含两个字符 98,7,#</p></li><li><p>二叉树的宽度： 宽度应该包含一层的节点之间夹杂的空字符，所以为了得到一层的宽度，应该在栈中压入每个节点的下标(左边：2 * pos, 右边：2 * pos+1)，而不是具体的二叉树ListNode</p></li><li><p>两个子节点的最近公共父节点</p></li></ol><p>如果一个节点为target_one或者target_two那么直接返回当前节点，否则进行dfs, dfs返回的左右节点都是非NULL那么就返回当前节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">ListNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(ListNode* root, ListNode* node1, ListNode* node2)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>||root==p||root==q) <span class="hljs-keyword">return</span> root;<br>    <span class="hljs-keyword">if</span>(root==node1||root==node2)&#123;<br>        <span class="hljs-keyword">return</span> cur;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        ListNode *left=<span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left, node1, node2);<br>        ListNode *right=<span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right, node1, node2);<br>        <span class="hljs-keyword">if</span>(left&amp;&amp;right)&#123;<br>            <span class="hljs-keyword">return</span> cur;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left)&#123;<br>            <span class="hljs-keyword">return</span> left;<br>        &#125;<br>        <span class="hljs-keyword">return</span> right;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol start="4"><li>从二叉树一个节点到另一个节点每一步的方向</li></ol><p>方法，通过dfs找到到达startValue和dstValue的具体路径，然后删除路径前面相同的部分，然后到达startValue剩余的size都加上U， 到达dstValue剩余的都加上dst剩余的路径</p><ol start="5"><li><p>寻找重复的树，<br> 解决方案：序列化+hash判断子树是否唯一，序列化只能使用# ，以及前序和后序遍历</p><ul><li>注意这道题需要记录空节点，同时，只能使用前序或者后序遍历 唯一判定两棵子树是否相同，而不能使用中序遍历。而且数据与数据应该用，隔开，因为222可以理解为2+2+2也可以理解为2+22 </li><li> ==加上#的这种情况，只有后序遍历和前序遍历能够唯一确定一课子树。中序遍历不行==  </li><li>同样这道题使用二叉树的序列化和反序列化, 因为前序和后序都可以知道根节点，但是中序不行</li></ul></li><li><p>最长同值路径</p><ul><li>和二叉树的直径类似，不过这里需要判断值是否相等，多了一个条件</li><li>为了区分left+right+1 left+1 right+1三种情况，可以使用一个left_mark 如果左边和root相等那么==left_val+1否则为0。那么最后的结果都是left_mark+right_mark+1， 解决了三种情况 返回max(left_mark, right_mark)+1</li></ul></li><li><p>二叉树中所有距离为 K 的结点<br>先通过dfs找到每个节点的父节点，然后再对target节点进行dfs 左右和父节点 (或者bfs+vis)</p></li><li><p>二叉树寻路，使用数学方法<br> 1.先求每个数正常的父亲，然后再对不同的层进行修改<br> 2.在进行修改的时候抓住对称的点的和是相同的<br> 3.如果层数是偶数，那么只需要修改奇数层的值；如果层数是奇数，那么需要修改偶数层的数据</p></li><li><p>二叉树中两个节点间的距离<br>先求两个节点的最近公共祖先，然后从最近公共祖先出发，求祖先节点分别到两个节点的距离(使用dfs两次，target==p||q)，距离之和就是两个节点的最短路径<br>代码：<a href="https://www.jianshu.com/p/cec33f514f69">https://www.jianshu.com/p/cec33f514f69</a></p></li></ol><ol start="10"><li>树的直径问题<br>任意选择一个节点为根，然后找到离他最远的节点a，然后找到离a最远的节点b，那么a-&gt;b就是最远的路径（数的直径）<br>如果是二叉树有指针的情况可以使用递归<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> result=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxDistance</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> leftLength=<span class="hljs-built_in">maxDistance</span>(root-&gt;left);<br>    <span class="hljs-keyword">int</span> rightLenght=<span class="hljs-built_in">maxDistance</span>(root-&gt;right);<br>    result=<span class="hljs-built_in">max</span>(leftLength+rightLenght+<span class="hljs-number">1</span>, result);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(leftLength, rightLenght)+<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">diameterOfBinaryTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-built_in">maxDistance</span>(root);<br>    <span class="hljs-keyword">return</span> result<span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>如果是无向图：<br>算法思想<br>①从任意一点P出发，通过DFS寻找离它最远的点Q。<br>②再次从点Q出发，通过DFS寻找离它最远的W。<br>③直径即为WQ。<br>证明：<a href="https://zhuanlan.zhihu.com/p/115966044">https://zhuanlan.zhihu.com/p/115966044</a></li></ol><p>两次dfs</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> st)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;edge[st].<span class="hljs-built_in">size</span>();i++)<br>    &#123;<br>        <span class="hljs-keyword">int</span> to=edge[st][i];<br>        <span class="hljs-keyword">if</span>(!vis[to])<br>        &#123;<br>            vis[to]=<span class="hljs-number">1</span>;<br>            dis[to]=dis[st]+<span class="hljs-number">1</span>;<span class="hljs-comment">//注意，本代码计算的是无权树的直径，所以边权为1</span><br>            <span class="hljs-comment">//如果是有权树，则这里的1要改为边权</span><br>            <span class="hljs-built_in">dfs</span>(to);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>求最长就是求最大的dis，两次dfs中间需要重新初始化dis=0</p><ol start="11"><li>具有所有最深节点的最小子树</li></ol><p>在深度优先搜索的时候同时返回结果和计算深度，返回的是一个结构体 node{root, dist}.<br>1)获取当前节点的左右子树的最大深度<br>2)如果两边最大深度相同，则这个节点就是结果<br>3)不相等，那返回深度大的子树的root信息</p><ol start="12"><li><ol start="205"><li>同构字符串/890. 查找和替换模式<br>查找和对应模式一致的字符串，abb模式。<br>使用双hash,也就是两边都没有映射，才建立映射，或者两边都有映射且未对方，那么continue,否则说明出处<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span>(s2t.<span class="hljs-built_in">find</span>(s[i])==s2t.<span class="hljs-built_in">end</span>()&amp;&amp;t2s.<span class="hljs-built_in">find</span>(t[i])==t2s.<span class="hljs-built_in">end</span>())&#123;<br>    s2t[s[i]]=t[i];<br>    t2s[t[i]]=s[i];<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s2t[s[i]]=t[i]&amp;&amp;t2s[t[i]]==s[i])&#123;<br>    <span class="hljs-keyword">continue</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol><ol start="12"><li>前后序遍历中空间复杂度为O(1)的Morris Traval方法（主要是利用叶子节点的空指针进行映射到下一个节点）<br><a href="https://www.cnblogs.com/AnnieKim/archive/2013/06/15/MorrisTraversal.html">https://www.cnblogs.com/AnnieKim/archive/2013/06/15/MorrisTraversal.html</a></li></ol><ul><li><strong>前序遍历</strong><br>  根左右<ol><li>如果当前节点的左孩子为空，那么输出当前节点，并将当前节点设置为当前节点的右孩子</li><li>一个节点的左孩子不为空，那么在当前节点的左子树找到这个节点的前驱节点<br> 如果这个前驱节点的右孩子为空，那么设置右孩子为当前节点，==输出当前节点==（于中序的唯一不同），并当前节点更新为当前节点左孩子<br> 如果这个前驱节点的右孩子为当前节点，那么将右孩子重新设置为空。并更新当前节点为当前节点的右孩子。</li></ol></li></ul><ul><li><strong>中序遍历</strong><br>  左根右<ol><li>如果当前节点的左孩子为空，那么输出当前节点，并将当前节点设置为当前节点的右孩子</li><li>一个节点的左孩子不为空，那么在当前节点的左子树找到这个节点的前驱节点<br> 如果这个前驱节点的右孩子为空，那么设置右孩子为当前节点，并当前节点更新为当前节点左孩子<br> 如果这个前驱节点的右孩子为当前节点，那么将右孩子重新设置为空。<strong>输出当前节点</strong>， 并更新当前节点为当前节点的右孩子<br> 与前序遍历相比一个是回来之后再输出(else)，一个是建立前驱到根节点关系后输出（if）</li></ol></li></ul><ul><li><strong>后序遍历</strong><br>  <strong>需要建立一个临时节点dump</strong>，使该节点的左子树等于root<ol><li>如果当前节点的左孩子为空，那么则将其右孩子作为当前节点</li><li>一个节点的左孩子不为空，那么在当前节点的左子树找到这个节点的前驱节点<br>如果这个前驱节点的右孩子为空，那么设置右孩子为当前节点, 并当前节点更新为当前节点左孩子<br>如果这个前驱节点的右孩子为当前节点，那么还原前驱右孩子为null, ==同时逆序输出从当前节点左孩子到前驱节点的路==，并更新当前节点为右孩子</li></ol></li></ul><p>总结：建立关系后，到左孩子；为空或者一圈回来后到右孩子<br>    一圈回来后，还原关系</p><ol start="13"><li> 将子数组重新排序得到同一个二叉查找树的方案数<br>题意，交换插入序列，但是得到的二叉搜索树最后的结果相同的序列共有多少个<br>解决：抓住，先插左还是右的顺序是可以变的，但是在插入单边的时候，根节点的插入顺序是不可以变的</li></ol><ul><li>排列组合+dfs</li><li>求排列组合的时候，其实用动态规划的思想 C(n,k)=C(n-1, k-1)+C(n-1,k)</li><li>node-&gt;ans = (long long)c[lsize + rsize][lsize] % mod * lans % mod * rans % mod;</li><li>在使用dfs的时候，使用一个全局的res变量，每次乘以（all, less)的组合结果；划分less, greater的时候，可以用一个新的vector来记录左右子树的节点</li><li>也可以先建立一棵树，使用递归左右指针的方式，树的信息需要包含size ,ans等一些信息<br>另一种出题的方式：<br>  一个数组入栈顺序定了，有多少种出栈的顺序<br>  f(n)=f(1)* f(n-1) + f(2) * f(n-2)+…..f(n-1) f(1);<br>  递推公式的解为：h(n)=c(2n,n)-c(2n,n+1)(n=1,2,3,…)</li></ul><ol start="14"><li>二叉搜索树删除一个节点<br>递归删除<br>易错点：<ol><li>可以根据二叉搜索树的性质，选择向左右递归 </li><li>找到该节点，如果是叶节点直接删除，如果只有左右子树，也可以直接返回左右子树，否则找到左边最小，然后赋值到当前值，然后递归删除</li><li>注意递归删除的的时候，一定要注意返回值，一定要赋值给当前节点的左指针或者右指针; 否则会造成树在中间断裂</li></ol></li></ol><ol start="15"><li>lc987. 二叉树的垂序遍历</li></ol><ul><li>dfs 遍历nodes 记录下每个节点的行号row，列号 col 以及值 value。<br>在遍历完成后，我们按照 col 为第一关键字升序，row 为第二关键字升序，value 为第三关键字升序，对所有的节点进行排序即可。 遍历时将同一col的放到同一vector中</li><li>也可以使用map&lt;int, vector<node>&gt; 这样的话就不用手动分每一个col</node></li></ul><p><font color="red">16. lc979. 在二叉树中分配硬币</font></p><ul><li>第一种方法：可以考虑后序遍历理解；需要从父节点得到或者获取 root-&gt;val-1个节点，<br>ans+=abs(root-&gt;val-1); return root-&gt;val-1//返回可能是负数</li><li>第二种方法：转为在子树中分配硬币<br>dfs(root)表示root这棵子树冗余的节点数<br>root-&gt;val+dfs(root-&gt;left)+dfs(root-&gt;right)-1;<br>ans+=abs(dfs(root-&gt;left))+abs(dfs(root-&gt;right));</li></ul><ol start="16"><li> lc99. 恢复二叉搜索树</li></ol><ul><li>二叉树出现位置交换会出现两种情况<br>两次逆序：记录前面x和后面y， 第二次更新y<br>一次逆序：记录前面x和后面y</li><li>时间O(n),空间O(1)</li></ul><ol start="17"><li> Find Leaves of Binary Tree 找二叉树的叶节点</li></ol><ul><li>题意：类似剥洋葱一样，将二叉树从最外到最内</li><li>重新定义二叉树的深度为最优深度最大值加一，然后res[depth].push_back(root-&gt;val)<br>if (depth &gt;= res.size()) res.resize(depth + 1);//因为最开始不知道最大的深度，因此不知道如何初始化，所以在最深一层初始化大小</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>ok ok</p><ol><li>主要考察前中后序遍历， 子树（序列化+hash）, 直径(自底向上判断，左右返回最大一个，同时更新结果为根)， 宽度（BFS）， 二叉树的左右节点（index*2, index *2）, 二叉搜索树相关（删除节点）， 自顶向下和自底向上递归</li><li>主要关联的数据结构有栈，队列（BFS/DFS）， hash, 字符串等</li><li>求总数的时候可能会涉及排列组合的知识， </li><li>判断当前子树是否为BST, 不能仅仅靠当前节点的值大于左边最大和右边最小就可以，还需要左右两边都是BST（lc333-最大BST子树）</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;p&gt;验证二叉树的前序序列化&lt;br&gt; 观察规律题或者建树题&lt;br&gt; 我的思路是直接建立一颗二叉树，但是建立树代码可以不写；最后树是正确的就是中间不会访问到cur==size的情况，同时最后循环完之后不会再出现#或者数字&lt;br&gt; 官方题解是：通过槽位计数，如果遍历</summary>
      
    
    
    
    <category term="leetcode" scheme="http://shu0421.github.io/en/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>链表</title>
    <link href="http://shu0421.github.io/en/2021/11/16/leetcode/%E9%93%BE%E8%A1%A8/"/>
    <id>http://shu0421.github.io/en/2021/11/16/leetcode/%E9%93%BE%E8%A1%A8/</id>
    <published>2021-11-16T10:29:23.000Z</published>
    <updated>2023-07-10T10:36:19.576Z</updated>
    
    <content type="html"><![CDATA[<p>有序链表的合并，一定要注意判断两个链表是否相交，或者链表是否有环的情况，如果遇到这两种情况要特殊处理</p><h5 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h5><ol><li><p>扁平化多级双向链表</p></li><li><p>有序数组或者链表转为二叉搜索树lc109</p></li></ol><ul><li>常规解法：找到中间节点为当前根节点，分别建立左右子树</li><li>链表找中位数，需要使用快慢指针和断开链表</li><li>为了解决链表找中位数耗时比较大，同时不使用额外空间（不转为数组方法）的方法就是使用中序遍历建树方法：</li><li>我们没有必要“先”找到中间节点：我们可以先构建了左子树，建立结束后，指针自然指向中间结点。那么如何构建左子树呢？其实我们只需要确定子树的大小就可以。所以先用O(n)的时间计算链表长度，之后用中序遍历。当然，指针需要是“引用”。</li><li>为什么要使用指针：因为使用了递归，如果不使用指针，那么递归返回，head就不会被修改，而实际上我们是像达到一个全局变量向前走的效果，因此需要使用指针引用 ListNode* &amp;head</li></ul><ol start="3"><li>二叉树的最小深度（简单）</li></ol><ul><li>注意是叶节点返回1，root==null 返回0， 但是在更新内部节点要判断左右是否为空，若任意一边为空，那么那一边不能加入计算中</li></ul><ol start="4"><li><p>二叉树展开为链表<br>先展开左右两边，然后如果展开的左边不为空，那么将左边展开后返回的头结点插入root-&gt;right, 同时设置root-&gt;left=null, 然后循环找到之前左边（现在右边）中最下面那个点，连接展开的右边返回的头节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">TreeNode* <span class="hljs-title">flattenFunc2</span><span class="hljs-params">(TreeNode *root)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    TreeNode* f_left = <span class="hljs-built_in">flattenFunc2</span>(root-&gt;left);<br>    TreeNode* f_right = <span class="hljs-built_in">flattenFunc2</span>(root-&gt;right);<br>    root-&gt;left=<span class="hljs-literal">nullptr</span>;<br>    TreeNode* res=root; <span class="hljs-comment">//一定要记得记录最开始的头结点</span><br>    <span class="hljs-keyword">if</span>(f_left!=<span class="hljs-literal">nullptr</span>)&#123; <span class="hljs-comment">//1. 左边不为空插入根和右边之间</span><br>        root-&gt;right=f_left;<br>        <span class="hljs-keyword">while</span>(root-&gt;right!=<span class="hljs-literal">nullptr</span>)&#123;<br>            root=root-&gt;right; <span class="hljs-comment">//改变了头结点</span><br>        &#125;<br>        root-&gt;right=f_right;<br>    &#125;<span class="hljs-keyword">else</span>&#123;  <span class="hljs-comment">//2. 否则直接连接根和右边</span><br>        root-&gt;right=f_right;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>    <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>lc1019. 链表中的下一个更大节点</p></li></ol><ul><li>题意：求链表中每个元素下一个更大的值</li><li>方法1.单独一个vector来记录，单调递减栈下标（从左到右，需要知道前面元素的下标）</li><li>方法2.进行链表的翻转，得到list的len， 同时使用单调递减值栈 (从右到左， 不需要知道下标，只需要存储值)</li></ul><ol start="6"><li>lc143. 重排链表</li></ol><ul><li>找到链表终点，后面的链表翻转，链表merge</li><li>这道题既考了快慢指针查找链表中点，还考了链表翻转以及链表merge 字节+阿里面试题</li></ul><h5 id="易错点"><a href="#易错点" class="headerlink" title="易错点"></a>易错点</h5><ol><li>判断head是否为null</li><li>在使用tmp-&gt;next 或者tmp-&gt;prev 一定要注意判断当前节点不能为null<br>也就是if(tmp){</li></ol><p>}</p><p>3.双向链表在进行删除某个节点的时候，先固定前面和后面的关系都可以；但是在插入一个节点的时候一定要先固定后面的</p><p>4.LRU cache易错点：再删除需要指针+hash都需要消除，cache.erase(lastNode-&gt;key); delete lastNode;<br>可以用hash.size()定位cache元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"> LRU cache（一个双向链表，一个hash）<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LinkNode</span>&#123;</span><br>    <span class="hljs-keyword">int</span> key,val;<br>    LinkNode* next;<br>    LinkNode* pre;<br>    <span class="hljs-built_in">LinkNode</span>()&#123;<br>        next=<span class="hljs-literal">nullptr</span>;<br>        pre=<span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>LRU： 使用一个双向链表+unordered_map(数组/(key-&gt;*node))<br>unordered_map&lt;int,Node*&gt; cache;<br>LFU, 需要使用双向链表List(key-&gt;*node/ freq_list: (freq-&gt; 链表list头节点，也就是nodelist双向链表))+unordered_map<br>map&lt;int, Node*&gt; key2node;<br>map&lt;int, NodeList*&gt; freq2List;</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>ok ok</p><ol><li>注意root=null 特殊情况</li><li>在调整树结构的时候一定要注意，返回节点，否则就可能链表断掉</li><li>充分利用二叉搜索树这些信息</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;有序链表的合并，一定要注意判断两个链表是否相交，或者链表是否有环的情况，如果遇到这两种情况要特殊处理&lt;/p&gt;
&lt;h5 id=&quot;例题&quot;&gt;&lt;a href=&quot;#例题&quot; class=&quot;headerlink&quot; title=&quot;例题&quot;&gt;&lt;/a&gt;例题&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;扁平化</summary>
      
    
    
    
    <category term="leetcode" scheme="http://shu0421.github.io/en/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>资源汇总</title>
    <link href="http://shu0421.github.io/en/2021/11/16/%E5%85%B6%E4%BB%96/%E5%90%84%E7%B1%BB%E8%B5%84%E6%BA%90/"/>
    <id>http://shu0421.github.io/en/2021/11/16/%E5%85%B6%E4%BB%96/%E5%90%84%E7%B1%BB%E8%B5%84%E6%BA%90/</id>
    <published>2021-11-16T07:32:21.000Z</published>
    <updated>2023-07-10T10:36:19.579Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.payititi.com/">人工智能相关各种任务数据集下载网站</a></p><p>阿里巴巴各部门:<a href="https://blog.csdn.net/alitech2017/article/details/105096822">https://blog.csdn.net/alitech2017/article/details/105096822</a></p><p>基础设施部门面经</p><p>8a100tianshu账号登录方式：<br>登录地址(需之江内网orVPN)：<a href="https://access.zhejianglab.com/">https://access.zhejianglab.com</a>  maokuang 密码请咨询毛旷，登录后：运维–主机运维—“登陆”栏目下的地球图<br>密码zjlab!@#</p><p><a href="https://github.com/SharingSource/LogicStack-LeetCode/wiki">https://github.com/SharingSource/LogicStack-LeetCode/wiki</a> 宫水三叶的刷题笔记</p><p>画图工具：<br><a href="https://draveness.me/sketch-and-sketch/">https://draveness.me/sketch-and-sketch/</a></p><p>hugo为后端的博客</p><p>做笔记的工具：notion 截图的工具：snipaste</p><p>可以将进程放在后台执行的软件 screen或者tmux</p><p>浙江大学正版化软件：<a href="http://ms-zju-edu-cn.webvpn.zju.edu.cn:8001/help/install">http://ms-zju-edu-cn.webvpn.zju.edu.cn:8001/help/install</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.payititi.com/&quot;&gt;人工智能相关各种任务数据集下载网站&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;阿里巴巴各部门:&lt;a href=&quot;https://blog.csdn.net/alitech2017/article/details/10509</summary>
      
    
    
    
    <category term="其他" scheme="http://shu0421.github.io/en/categories/%E5%85%B6%E4%BB%96/"/>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://shu0421.github.io/en/2021/11/13/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/hello-world/"/>
    <id>http://shu0421.github.io/en/2021/11/13/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/hello-world/</id>
    <published>2021-11-13T12:26:46.510Z</published>
    <updated>2021-11-13T12:27:48.242Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    <category term="工具相关" scheme="http://shu0421.github.io/en/categories/%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/"/>
    
    
  </entry>
  
  <entry>
    <title>基本神经网络相关问题</title>
    <link href="http://shu0421.github.io/en/2021/11/13/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E5%9F%BA%E6%9C%AC%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/"/>
    <id>http://shu0421.github.io/en/2021/11/13/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E5%9F%BA%E6%9C%AC%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/</id>
    <published>2021-11-13T12:11:27.000Z</published>
    <updated>2023-07-10T10:36:19.588Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>滤波和传统的图像算法 e.g. SIFT</p></li><li><p>CNN感受野定义以及计算方式<br>感受野指的是一个特定的 CNN 特征（特征图上的某个点）在输入空间所受影响的区域。<br>感受野的计算是输出图像的反向过程<br>out_put=(iput_size-kernel_size)/stride+1<br>input_size=(out_put-1)*stride+kernel_size</p></li></ol><ol start="3"><li><p>CNN矩阵乘法原理<br>参考链接：<a href="https://shuokay.com/2016/06/08/convolution/">卷积计算</a><br>img2col将卷积运算转为矩阵乘法<br>其中输入的矩阵：行方向对应特征图不同channel同一视野（位置）的向量展开；列方向代表不同的位置；<br>kernel的矩阵：行方向代表代表不同的卷积核，列方向代表一个滤波器每个channel的矩阵-&gt;向量，<br>输出矩阵</p></li><li><p>BatchNormalization与正则化的区别：<br> BatchNormalization主要是用于将神经网络中间输入特征图的均值和方差进行规范化，使输入分布拉到容易激活后面激活层中，解决梯度消失和梯度爆炸问题问题<br> 正则化，通常用于机器学习，在损失函数中加上参数的一阶或者二阶和，防止过拟合</p></li></ol><ol start="5"><li>产生梯度消失或爆炸的原因：<br>网络层数太深而引发的梯度反向传播中的连乘效应<br>解决梯度消失或者梯度爆炸问题的解决方案：<ul><li>batch BatchNormalization</li><li>梯度裁剪</li><li>修改激活函数，比如leaky relu</li><li>残差结构</li><li>每层预训练后微调</li></ul></li></ol><ol start="6"><li>机器学习：多分类如何转为多个二分类问题：需要训练N个分类器<br><a href="https://yuanxiaosc.github.io/2018/07/01/%E4%BA%8C%E5%88%86%E7%B1%BB%E3%80%81%E5%A4%9A%E5%88%86%E7%B1%BB%E4%B8%8E%E5%A4%9A%E6%A0%87%E7%AD%BE%E9%97%AE%E9%A2%98%E7%9A%84%E5%8C%BA%E5%88%AB%E2%80%94%E2%80%94%E5%AF%B9%E5%BA%94%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E7%9A%84%E9%80%89%E6%8B%A9/">参考链接</a><br>将每一次的一个类作为正例，其余作为反例，总共训练N个分类器。测试的时候若仅有一个分类器预测为正的类别则对应的类别标记作为最终分类结果，若有多个分类器预测为正类，则选择置信度最大的类别作为最终分类结果。<br>PS:目标检测的多标签二分类损失函数是使用每个标签的概率的求二分损失函数（逻辑损失）然后求平均值得到整体的损失<br>其他方案：<br>一对一，建立N(N-1)/2个分类器，然后进行投票<br>直接用softmax进行多分类任务训练</li></ol><ol start="7"><li><p>网络退化以及resnet为什么可以解决梯度消失和网络退化问题：<br>首先介绍什么是网络退化问题<br>举个例子，假设已经有了一个最优化的网络结构，是18层。当我们设计网络结构的时候，我们并不知道具体多少层次的网络时最优化的网络结构，假设设计了34层网络结构。那么多出来的16层其实是冗余的，我们希望训练网络的过程中，模型能够自己将这16层冗余层训练为恒等映射，也就是经过这层时的输入与输出完全一样。<br>但是往往模型很难将这16层恒等映射的参数学习正确，那么就不如最优化的18层网络结构的性能，这就是随着网络深度增加，模型会产生退化现象。它不是由过拟合产生的，而是由冗余的网络层学习了不是恒等映射的参数造成的。<br>也就是说神经网络学习恒等映射 F(x)=x 的效果不好，但是加上了skip connection 神经网络就用于学习F(x)=0</p></li><li><p>链式法则：<br>原本y对x求偏导，但是由于过程较为复杂，我们引入了一个中间层z，先利用y对z求偏导，在乘上z对x求偏导，这样会使整个计算更为简单。<br>当前error对当前层参数的导数，是error对当前输出（输出特征图）的倒数*当前节点的输入（输入特征图）</p></li></ol><ol start="9"><li>矩阵的反向传播算法/CNN的反向梯度传播算法</li></ol><ol start="10"><li>激活函数sigmoid，tanh，relu. 各自的优点和适用场景<br>[参考链接]（<a href="https://zhuanlan.zhihu.com/p/71882757%EF%BC%89">https://zhuanlan.zhihu.com/p/71882757）</a><br>激活函数的作用：主要是向神经网络中引入非线性的特征</li></ol><ul><li>sigmoid函数：主要运用在逻辑二分类中，缺点：计算复杂，不是0均值，同时容易出现梯度饱和，当输入是非常大的正值或者负值的时候，反向传播梯度为0；</li><li>tanh函数：是0均值，但是计算复杂，同时也容易出现梯度饱和问题</li><li>relu函数：计算简单，在输入大于0的时候不会出现梯度饱和，但是在输入小于0的时候会出现梯度为0，造成死的神经元，因此参数一直得不到更新</li></ul><ol start="11"><li><p>常见神经网络的结构特点和结构优势</p></li><li><p>牛顿法和SGD的各自原理，优势，区别</p></li><li><p>LR的梯度反向传播推导<br><a href="https://blog.csdn.net/ft_sunshine/article/details/105370528">https://blog.csdn.net/ft_sunshine/article/details/105370528</a></p></li></ol><p>方程：y=theta<em>x<br>激活函数 h(x)-1/(1+e^(-theta x))<br>损失函数 loss=1/m</em>求和(y^ilog(h(x)) - (1-y^i)log(1-h(x))))</p>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;p&gt;滤波和传统的图像算法 e.g. SIFT&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;CNN感受野定义以及计算方式&lt;br&gt;感受野指的是一个特定的 CNN 特征（特征图上的某个点）在输入空间所受影响的区域。&lt;br&gt;感受野的计算是输出图像的反向过程&lt;br&gt;out_put</summary>
      
    
    
    
    <category term="项目相关" scheme="http://shu0421.github.io/en/categories/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/"/>
    
    
  </entry>
  
  <entry>
    <title>机器学习</title>
    <link href="http://shu0421.github.io/en/2021/11/13/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    <id>http://shu0421.github.io/en/2021/11/13/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-11-13T12:11:16.000Z</published>
    <updated>2021-11-13T12:27:48.243Z</updated>
    
    <content type="html"><![CDATA[<ol><li>xgboost与GDBT的区别</li></ol><p>xgboost属于GDBT的工程实现，但是相比于GDBT有更多的优化</p><ul><li>1.两者都是属于boosting方法，就是迭代串行求多个模型，每个模型不同权重，训练过程中样本也具有不同的权重</li><li>2.GDBT是使用多个决策树组成的，xgboost可以使用线性模型</li><li>3.xgboost使用了代价函数的一阶和二阶信息，同时可以用户自定义代价函数，同时xgboost在代价函数中加入了正则项，用于控制模型的复杂度</li><li>4.xgboost能够自动对缺失值进行处理</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;xgboost与GDBT的区别&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;xgboost属于GDBT的工程实现，但是相比于GDBT有更多的优化&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.两者都是属于boosting方法，就是迭代串行求多个模型，每个模型不同权重，训练过程中样本也具有不同的</summary>
      
    
    
    
    <category term="项目相关" scheme="http://shu0421.github.io/en/categories/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="machine learning" scheme="http://shu0421.github.io/en/tags/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title>编程语言</title>
    <link href="http://shu0421.github.io/en/2021/11/13/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    <id>http://shu0421.github.io/en/2021/11/13/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/</id>
    <published>2021-11-13T12:11:07.000Z</published>
    <updated>2023-07-10T10:36:19.589Z</updated>
    
    <content type="html"><![CDATA[<h4 id="python"><a href="#python" class="headerlink" title="python"></a>python</h4><ol><li><p>python GIL介绍</p></li><li><p>list tuple set的区别</p></li></ol><ol start="3"><li><p>python迭代器和生成器的区别是什么<br>生成器本质上还是一个迭代器，也是用在迭代操作中，因此它有和迭代器一样的特性，唯一的区别在于实现方式上不一样，后者更加简洁；<br>生成器只是在需要这个值再生成</p></li><li><p>迭代器<br>迭代器对象要求支持迭代器协议的对象。在Python中，支持迭代器协议就是实现对象的__iter__()和next()方法。<br>其中__iter__()方法返回迭代器对象本身；next()方法返回容器的下一个元素，在结尾时引发StopIteration异常。<br>iter是可迭代对象，可迭代对象才能调用next函数</p></li></ol><ol start="5"><li>生成器<br>生成器(generator)就是一个函数，它提供了一种实现迭代器协议的便捷方式。<br>生成器与普通函数的区别在于它包含 yield 表达式，并且不需要定义 <strong>iter</strong>()和__next__()。</li></ol><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><h5 id="1-vector"><a href="#1-vector" class="headerlink" title="1.vector"></a>1.vector</h5><p>find(vector.begin(), vector.end(), target_val)!=vector.end() find函数返回的是一个迭代器</p><p>vector.push_back(i)<br>vector.pop_back()</p><p>vec1.swap(vec2)//进行vector1和vector2的交换<br>vec2(vec1.begin(), vec1.begin()+4)表示截取vector的一部分，并赋值给vec2,注意后面的值表示vec不需要 也就是左闭右开模式</p><p>vector最后一个元素，vector.back()</p><p>vector.insert(vec.begin()+pos, target); // 将target元素插入到pos位置</p><p>auto pos=lower_bound(nums.begin(), nums.end(), target)<br>index = pos-nums.begin() //<br><font color="red">lower_bound返回的是大于等于目标函数的数， upper_bound返回的是大于目标函数的数</font></p><p>注意和set的lower_bound不一样的<br>set.lower_bound(targets) 返回一个迭代器</p><p>mp的lower_bound也是不一样的<br>auto iter = mp.lower_bound(val)</p><p>set和map中的元素都是排好序的</p><h5 id="2-unordered-set-my-set"><a href="#2-unordered-set-my-set" class="headerlink" title="2.unordered_set my_set"></a>2.unordered_set my_set</h5><p>my_set.find(target_value)!=my_set.end() or my_set.count(target_value)!=0<br>my_set.insert(value)<br>my_set.erase(value)A</p><p>unordered_set查找元素的两种方式：（1）umap.find(target)!=-1  (2) umap[target]<br>unordered_set在进行查找的时候可以直接使用unordered_set[target]即使是target不存在也不会报错，<br>但是在vector中查找某一个元素就需要vec.find(target)!=vec.end() </p><h5 id="3-priority-queue-queue"><a href="#3-priority-queue-queue" class="headerlink" title="3. priority_queue / queue"></a>3. priority_queue / queue</h5><p>q.push()<br>q.pop()</p><h5 id="4-set-insert-value-erase-value-push-pop"><a href="#4-set-insert-value-erase-value-push-pop" class="headerlink" title="4. set insert(value) erase(value) push pop"></a>4. set insert(value) erase(value) push pop</h5><p>遍历 for(auto iter=set.begin(); iter!=set.end(); iter++)</p><p>用vector里面的元素初始化set unordered_set<int> nums_set(nums1.begin(), nums1.end());//其中nums1是vector</int></p><h5 id="5-map"><a href="#5-map" class="headerlink" title="5.map"></a>5.map</h5><p>插入元素：map[key]=value; 或者map.insert(make_pair(key, value))<br>删除元素：map.erase(key)//注意不是remove</p><p>查找元素：map.find(key)</p><p>复制：hash.insert(hash1.begin(), hash1.end())<br>PS： vector的复制是 vec.assign(vec1.begin(), vec1.end())</p><h5 id="6-其他语法"><a href="#6-其他语法" class="headerlink" title="6.其他语法"></a>6.其他语法</h5><p>判断字符是字母：isalpha()</p><p>判断字符是数字：isdigit()</p><p>判断字符是字母或数字：isalnum()</p><p>同时注意c++中，字符用单引号表示，字符串用双引号表示</p><p>注意c++中只有数组能够使用memset，在vector中不能使用</p><h5 id="7-string"><a href="#7-string" class="headerlink" title="7.string"></a>7.string</h5><p>find函数 pos=s.find(target)  pos=s.find(target,0)<br>如果没有找到返回s.npos 或者string::npos</p><p>原地移除数组上的元素，我们说到了数组上的元素，不能真正的删除，只能覆盖。array.erase(i)的时间复杂度是O(n)</p><h5 id="8-set-数组-map的选择"><a href="#8-set-数组-map的选择" class="headerlink" title="8.set 数组 map的选择"></a>8.set 数组 map的选择</h5><p>主要是看数据的范围，如果数据返回不确定那么尽量选择map or set，如果确定是小写字母的话，也就是26个字母，可以使用数组<br>set包含 unordered_set（无序， 哈希表，不能重复， 查询和增删效率O(1)）, multiset（有序，红黑树，可以重复 O(nlogn)）, set(有序， 红黑树，不能重复， O(nlong))； map类似<br>三种都是只能erase和insert不能修改数值， map不能修改key但是可以修改value</p><h5 id="9-stack"><a href="#9-stack" class="headerlink" title="9. stack"></a>9. stack</h5><p>栈的底层实现可以是vector, dequeue, list<br>栈只能获取最后一个元素，无法直接获取第一个元素<br>top()    返回栈顶元素的引用，类型为 T&amp;，如果栈为空，返回值未定义<br>pop()    栈顶元素出栈<br>size()    返回栈中元素的个数<br>empty()    栈中没有元素时返回 true<br>emplace()    使用传入的参数调用构造函数，在栈顶生成对象<br>push(const T&amp; obj)    将对象副本压入栈顶，通过调用底层容器的 push_back() 函数实现<br>push(T&amp;&amp; obj)    以移动对象的方式将对象压入栈，通过调用底层容器的有右值引用参数的 push_back() 函数实现<br>swap(stack<T> &amp; other_stack)    将当前栈中的元素和参数中的元素交换，参数所包含元素的类型必须和当前栈的相同，对于 stack 对象有一个特例化的全局函数 swap() 可以使用</T></p><p>可以出一道面试题：栈里面的元素在内存中是连续分布的么？</p><p>这个问题有两个陷阱：<br>陷阱1：栈是容器适配器，底层容器使用不同的容器，导致栈内数据在内存中是不是连续分布。<br>陷阱2：缺省情况下，默认底层容器是deque，那么deque的在内存中的数据分布是什么样的呢？答案是：不连续的，下文也会提到deque。</p><h5 id="10-queue-队列"><a href="#10-queue-队列" class="headerlink" title="10.queue 队列"></a>10.queue 队列</h5><p>可以访问队列最后一个元素，但是无法pop最后一个元素<br>queue入队，如例：q.push(x); 将x 接到队列的末端。</p><p>queue出队，如例：q.pop(); 弹出队列的第一个元素，注意，并不会返回被弹出元素的值。</p><p>访问queue队首元素，如例：q.front()，即最早被压入队列的元素。</p><p>访问queue队尾元素，如例：q.back()，即最后被压入队列的元素。</p><p>判断queue队列空，如例：q.empty()，当队列空时，返回true。</p><h5 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h5><p>pair&lt;int, int&gt; 访问元素不是用下标而是用first second; 创建一个pair用pair&lt;int, int&gt; res = make_pair&lt;a, b&gt;<br>或者用括号 pair&lt;int, int&gt; b(1, 2);</p><h5 id="multiset-set"><a href="#multiset-set" class="headerlink" title="multiset/set"></a>multiset/set</h5><p>两者都是存储的重复的数据，不一样的是前者可以存储冗余的数据<br>删除一个数<br>c1.erase(c1.find(x))//删除一个x<br>c1.erase(x)//删除所有x元素</p><h5 id="新建一个未知长度的数组"><a href="#新建一个未知长度的数组" class="headerlink" title="新建一个未知长度的数组"></a>新建一个未知长度的数组</h5><p>int *queue;<br>queue=new int[k+1] 主要是用于类构建动态数组的这种情况</p><h4 id="向上取整"><a href="#向上取整" class="headerlink" title="向上取整"></a>向上取整</h4><p>(x+(b-1))/b*b</p><h4 id="malloc和new的区别"><a href="#malloc和new的区别" class="headerlink" title="malloc和new的区别"></a>malloc和new的区别</h4><p><img src="/en/.io//image-20220122202312622.png" alt="image-20220122202312622"></p><h4 id="hashMap原理"><a href="#hashMap原理" class="headerlink" title="hashMap原理"></a>hashMap原理</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;python&quot;&gt;&lt;a href=&quot;#python&quot; class=&quot;headerlink&quot; title=&quot;python&quot;&gt;&lt;/a&gt;python&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;python GIL介绍&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;list tuple set的</summary>
      
    
    
    
    <category term="项目相关" scheme="http://shu0421.github.io/en/categories/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="python, C++" scheme="http://shu0421.github.io/en/tags/python-C/"/>
    
  </entry>
  
  <entry>
    <title>笔试</title>
    <link href="http://shu0421.github.io/en/2021/11/13/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E7%AC%94%E8%AF%95/"/>
    <id>http://shu0421.github.io/en/2021/11/13/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E7%AC%94%E8%AF%95/</id>
    <published>2021-11-13T12:10:47.000Z</published>
    <updated>2023-07-10T10:36:19.589Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/lcylmhlcy/Awesome-algorithm-interview/blob/master/README.md#1-interview-1">Awesome algorithm interview</a></p><h4 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h4><p>TCP连接为什么要三次握手，TCP关闭为什么要4次挥手？<br>三次握手是为了防止服务器资源的浪费，因为如何是两次的话，如果客户端发送请求连接，但是不发送请求数据，就可能造成服务器端口占用，资源被浪费；四次回收是因为客户端和服务器可以各自关闭，比如客户端告诉服务器FIN，表示自己不发送数据，但是仍然可以接收数据，因此服务器可以继续发送，服务器将数据发送完了之后，再发出关闭信号，因此四次挥手允许客户端和服务器各自分别关闭</p><h4 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h4><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><p>搜索github 上面的面试八股文</p><p><a href="https://github.com/cosen1024/Java-Interview">https://github.com/cosen1024/Java-Interview</a> java面试小抄书</p><p>JVM内存结构，什么是hash 冲突，如何解决</p><p>语言/数据结构/操作系统/网络/分布式/系统设计</p><p>考研408</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/lcylmhlcy/Awesome-algorithm-interview/blob/master/README.md#1-interview-1&quot;&gt;Awesome algorithm interview&lt;/a&gt;&lt;/p</summary>
      
    
    
    
    <category term="项目相关" scheme="http://shu0421.github.io/en/categories/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="八股文" scheme="http://shu0421.github.io/en/tags/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
  </entry>
  
</feed>
