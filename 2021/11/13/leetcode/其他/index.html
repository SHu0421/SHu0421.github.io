

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@500;600;700&display=swap" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
   <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="这是我的第一篇博客">
  <meta name="author" content="huhu">
  <meta name="keywords" content="">
  <meta name="description" content="数组相关问题要将数字放在对应的位置上，使用原地交换的方式  旋转矩阵  这个好像不行，需要记录交换过来的值的同时，记录交换过来的下标 自然数数组的排序 奇数下标是奇数，偶数下标是偶数   第一种方法，使用一个环来进行数据的交换 第二种方法，每个数据与当前的数据进行交换，然后判断当前交换过来的数据应该放到的位置，重复这样的过程，知道当前交换过来的数是应该放置的数  举个例子：&#x2F;&#x2F;如果下标i应该放的数">
<meta property="og:type" content="article">
<meta property="og:title" content="其他问题">
<meta property="og:url" content="http://example.com/2021/11/13/leetcode/%E5%85%B6%E4%BB%96/index.html">
<meta property="og:site_name" content="Hello World">
<meta property="og:description" content="数组相关问题要将数字放在对应的位置上，使用原地交换的方式  旋转矩阵  这个好像不行，需要记录交换过来的值的同时，记录交换过来的下标 自然数数组的排序 奇数下标是奇数，偶数下标是偶数   第一种方法，使用一个环来进行数据的交换 第二种方法，每个数据与当前的数据进行交换，然后判断当前交换过来的数据应该放到的位置，重复这样的过程，知道当前交换过来的数是应该放置的数  举个例子：&#x2F;&#x2F;如果下标i应该放的数">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-11-13T09:22:38.000Z">
<meta property="article:modified_time" content="2022-02-11T08:10:57.168Z">
<meta property="article:author" content="huhu">
<meta property="article:tag" content="其他">
<meta name="twitter:card" content="summary_large_image">
  
  <title>其他问题 - Hello World</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.12","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Hello World" type="application/atom+xml">
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>HU&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="其他问题">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-11-13 17:22" pubdate>
        2021年11月13日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      16k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      52 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">其他问题</h1>
            
            <div class="markdown-body">
              <h4 id="数组相关问题"><a href="#数组相关问题" class="headerlink" title="数组相关问题"></a>数组相关问题</h4><p>要将数字放在对应的位置上，使用原地交换的方式</p>
<ol>
<li>旋转矩阵  这个好像不行，需要记录交换过来的值的同时，记录交换过来的下标</li>
<li>自然数数组的排序</li>
<li>奇数下标是奇数，偶数下标是偶数</li>
</ol>
<ul>
<li>第一种方法，使用一个环来进行数据的交换</li>
<li>第二种方法，每个数据与当前的数据进行交换，然后判断当前交换过来的数据应该放到的位置，重复这样的过程，知道当前交换过来的数是应该放置的数</li>
</ul>
<p>举个例子：<br>//如果下标i应该放的数据是 i+1 index和value之间存在映射</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++">tmp=a[i];<br><span class="hljs-keyword">while</span>(a[i]!=i+<span class="hljs-number">1</span>)&#123;<br>    <span class="hljs-keyword">int</span> next=a[tmp<span class="hljs-number">-1</span>];<br>    a[tmp<span class="hljs-number">-1</span>]=tmp;<br>    tmp=next;<br>&#125;<br><br><span class="hljs-keyword">while</span>(a[i]!=i+<span class="hljs-number">1</span>)&#123;<br>    <span class="hljs-built_in">swap</span>(a[i], a[a[i]<span class="hljs-number">-1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="4">
<li><p>最大子矩阵的和转为最大子数组的和，枚举每一行开始  i从0 ~ n-1,每次换开始的时候重新初始化数组s; j从i ~ n-1</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;matrix.<span class="hljs-built_in">size</span>();i++)&#123;<br>    <span class="hljs-keyword">int</span> s[matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i;j&lt;matrix.<span class="hljs-built_in">size</span>();j++)&#123;<br>        <span class="hljs-keyword">int</span> cur=<span class="hljs-number">0</span>;<span class="hljs-comment">//从头开始</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();k++)&#123;<br>            cur+=matrix[j][k]; <span class="hljs-comment">//利用之前加的值，加上现在的值</span><br>            res=<span class="hljs-built_in">max</span>(res, cur);<br>            <span class="hljs-keyword">if</span>(cur&lt;<span class="hljs-number">0</span>)&#123;<br>                cur=<span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>边界都是1的最大正方形：<br>这种问题先想个暴力算法，然后考虑如何用空间换时间，加速判断的过程</p>
</li>
</ol>
<ul>
<li>1.先循环，找到每个点的right down数组，注意边界要单独赋值，从右往左，从下网上计算</li>
<li>2.遍历size（最开始初始化为m.size()和m[0].size()的最小值）, 每个size下遍历每个点，看左右边长以及右上角和左下角的right down是否都大于size,<br>如果是返回true,否则返回false</li>
</ul>
<ol start="6">
<li>数组partition的调整<br>使用双指针，一个指针指向排序好的末尾，一个指针指向待排序序列的头结点<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> left=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> right=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(right&lt;length)&#123;<br>    <span class="hljs-keyword">if</span>(arr[left]!=arr[right])&#123;<br>        left++;<br>        <span class="hljs-built_in">swap</span>(arr[left], arr[right]);<br>        right++;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<p>此类型的拓展问题，红蓝白球的排序，以及 0 1 2的排序<br>解决方案：记录一个左节点（初始化-1）右节点（length）中间节点：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> left=<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">int</span> right=length;<span class="hljs-comment">//排好序的头</span><br><span class="hljs-keyword">int</span> index=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(index&lt;right)&#123;<br>    <span class="hljs-keyword">if</span>(arr[index]==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">swap</span>(arr[++left], arr[index]);<br>        index++;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr[index]==<span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-built_in">swap</span>(arr[--right], arr[index]);<span class="hljs-comment">//注意这种情况index还要继续判断，因此不能index++</span><br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        index++;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<ol start="7">
<li>网格中的最短路径和最短通路问题：</li>
</ol>
<ul>
<li>1.一定要分清楚是用dp还是bfs</li>
<li>2.如果是只能从左上往右下走，那么是dp,否则应该用bfs,同时因为是路径，因此需要一个额外的二维数组判断到当前节点需要的步数，或者另外申明一个node,<br>这个node里面记录到这个节点的步数</li>
</ul>
<ol start="8">
<li>缺失的第一个正数：</li>
</ol>
<ul>
<li>方法一：如何在原数组上进行hash,但是保留那个位置的数不变使用- 符号；<br>同时如果原来有符号，那么为了避免混淆，将原来为符号的数变为我们不关心的正数</li>
<li>方法二：使用置换的方式，这种方式一定要注意进入死循环的方式因此在交换的时候判断。nums[nums[i]-1]!=nums[i]</li>
</ul>
<h5 id="random类似题目总结："><a href="#random类似题目总结：" class="headerlink" title="random类似题目总结："></a>random类似题目总结：</h5><p>rand5 to rand7<br>rand01p to rand6<br>rand1toM to rand1toN</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-number">1</span>）<br>    <span class="hljs-keyword">do</span>&#123;<br>        row=<span class="hljs-built_in">rand5</span>()<span class="hljs-number">-1</span>;<br>        col=<span class="hljs-built_in">rand5</span>()<span class="hljs-number">-1</span>;<br>        num=row*<span class="hljs-number">5</span>+col <span class="hljs-comment">//0-24之间</span><br>    &#125;<span class="hljs-keyword">while</span>(num&gt;=<span class="hljs-number">21</span>)<br><br>    <span class="hljs-keyword">return</span> num%<span class="hljs-number">7</span>+<span class="hljs-number">1</span>;<br><br></code></pre></td></tr></table></figure>
<p>2)<br>首先等概率产生0-1  01 10是等概率残生的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rand01</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">do</span>&#123;<br>        num=<span class="hljs-built_in">rand01p</span>();<br>    &#125;<span class="hljs-keyword">while</span>(num==<span class="hljs-built_in">rand01p</span>());<br>    <span class="hljs-keyword">return</span> num;<br>&#125;<br><br>那么rand03=<span class="hljs-built_in">rand01</span>()*<span class="hljs-number">2</span>+<span class="hljs-built_in">rand01</span>();<br>rand0<span class="hljs-number">-15</span>=<span class="hljs-built_in">rand03</span>()*<span class="hljs-number">4</span>+<span class="hljs-built_in">rand03</span>(); <span class="hljs-comment">//倍数+插空  用进制的方法可以产生rand07()=rand03()+rand01()*4</span><br>那么rand6可由如下产生:<br><span class="hljs-keyword">do</span>&#123;<br>    num=rand0<span class="hljs-number">-15</span>;<br>&#125;<span class="hljs-keyword">while</span>(num&gt;=<span class="hljs-number">12</span>)<br><span class="hljs-keyword">return</span> num%<span class="hljs-number">6</span>+<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>

<p>3）其实就是用M进制的数来表示N-1，如果随机生成的数是大于N，那么从头进行生成（注意是从头，而不是从当前数重新生成），否则返回这个数<br>步骤：<br>   1、将n-1转换成m进制数，假设结果转换成数组为 k = [a,b,c,d,e]<br>　　2、使用rand1ToM(m)函数产生结果数组 res = [A,B,C,D,E]，如果res所表示的数值大于k所表示的数值，将res丢掉重新随机，直到产生的结果小于或等于k，这时产生的res的范围就在0～n-1之间，但是此时res所表示的数还是m进制的。<br>　　3、将res数组转换成10进制整数。<br>　　4、将步骤3的结果加1就是最终的结果。</p>
<h5 id="数学相关问题"><a href="#数学相关问题" class="headerlink" title="数学相关问题"></a>数学相关问题</h5><ol>
<li><p>求num阶层中最后的包含0的个数，因为包含因子2的个数一定比5多，因此可以直接求包含因子5的个数<br>每5个数有一个5，每25个数中有一个数包含两个5<br>同样下面的模板可以用于求任何因子的个数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(num)&#123;<br>        res+=num/<span class="hljs-number">5</span>;<br>        num=num/<span class="hljs-number">5</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>判断一个点是否在矩形中：对角向量叉积的点积&gt;=0,（对角向量的叉积方向相同），使用叉积的原因是：一个点在线外还是在线内，叉积的正负不同<br>使用叉积可以判断方向，A = &lt;a1, a2&gt;，B = &lt;b1, b2&gt;<br>AXB=a1<em>b2-a2</em>b1, 叉积向量的方向为法线的方向，上下为第一个向量指向第二个向量，大手指的方向<br>叉乘加内积</p>
</li>
<li><p>相同的题型：判断点是否在三角形中<br>1）先判断三个点的顺序是否是逆时针方向:逆时针方向叉积小于0；顺时针方向叉积大于等于（注意顺序可能导致结果不同！！！）；如果是顺时针正方向，那么调整点位置<br>2）然后判断这个点x是否都是在三角形每条边的左边，判断过程：三角形每个顶点和边的叉积小于0</p>
</li>
</ol>
<p>求三个三角形不推荐，因为double类型可能出现误差</p>
<ol start="4">
<li>路径数组转为统计数组的题目：<br>要求额外的空间复杂度为O(1)<br>如果要实现空间复杂度为O(1),那么需要在原来的数据上进行运算，那么每个位置存储跳过来的位置（最开始节点存储为-1），直到当前的数为一个负数（表示已经求过距离），然后跳回去的时候就知道来的位置，同时更新当前的距离，<br>为了区分已经判断过的值和未判断过的值，使用负数；求到距离矩阵之后再计算每个距离出现的次数，仍然是使用跳的方式，开始节点记得赋值为0，表示已经访问计算过</li>
</ol>
<p>这种方式也出现在”第一个未出现的正数“这道题解决方案中（值与下标相互映射）</p>
<ol start="5">
<li>正数数组的最小不可组成和：<br>dp[0][0]=1<br>使用动态规划<br>for i = sum to min: //注意反着<br> for j=0; j=arr.size(); j++:<pre><code> if(i&gt;=arr[i]):
     dp[i]=dp[i-arr[j]]?True:dp[i]//注意是dp[i]而不是false,也不是dp[i]=dp[i-arr[i]]//因为可能一个数一种方式可以组成，但是另一种不行
</code></pre>
</li>
</ol>
<p>PS:没有思路就想暴力算法，然后递归考虑是否能转为动态规划，类似背包问题</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++">dp[i][j]=dp[i<span class="hljs-number">-1</span>][j-arr[i]]||dp[i<span class="hljs-number">-1</span>][j];<br><br><span class="hljs-keyword">for</span> i in min to sum:<br>    <span class="hljs-keyword">if</span> dp[n][i] == <span class="hljs-literal">false</span>:<br>        <span class="hljs-keyword">return</span> i<br></code></pre></td></tr></table></figure>

<ol start="6">
<li>累加出整个范围最少还需要的数:<br>使用当前可以累加得到的范围，如果范围超过了当前遍历到的arr的第一个数，那么下一个可以累加得到的范围是当前的范围+arr[i];否则下一个差的数应该是touch+1,可以累加得到的数是touch+1+touch</li>
</ol>
<p>可以累加得到的数是touch,下一个差的数是touch+1</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++">touch=<span class="hljs-number">0</span>;<br>cnt=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;arr.<span class="hljs-built_in">size</span>();i++)&#123;<br>    <span class="hljs-keyword">if</span>(touch+<span class="hljs-number">1</span>&lt;arr[i])&#123;<br>        <span class="hljs-keyword">while</span>(touch&lt;arr[i])&#123;<br>            touch+=touch+<span class="hljs-number">1</span>;<br>            cnt++;<br>            <span class="hljs-keyword">if</span>(touch&gt;=range)&#123;<br>                <span class="hljs-keyword">return</span> cnt;<br>            &#125;<br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        touch+=arr[i];<br>        <span class="hljs-keyword">if</span>(touch&gt;=range)&#123;<br>            <span class="hljs-keyword">return</span> cnt;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">while</span>(touch&lt;range)&#123;<br>        touch+=touch+<span class="hljs-number">1</span>;<br>        cnt++;    <br>&#125;<br><br>    <span class="hljs-keyword">return</span> cnt;<br></code></pre></td></tr></table></figure>

<ol start="7">
<li>一种字符串和数字对应的关系<br>注意是K伪进制数，也就是每一个伪至少为1不能为0，因此需要先从右往左计算位数，然后从左往右分剩下的数字<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">int2str</span><span class="hljs-params">()</span></span>&#123;<br>    cur=<span class="hljs-number">1</span>;<span class="hljs-comment">//代表进制的基数</span><br>    k=<span class="hljs-number">0</span><span class="hljs-comment">//代表位数</span><br>    base=<span class="hljs-number">3</span><span class="hljs-comment">//代表进制数，多少个字符就是多少进制</span><br>    <span class="hljs-keyword">while</span>(n&gt;=cur)&#123;<br>        k++;<br>        n-=cur;<br>        cur*=base;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> index=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(k)&#123;<br>        cur/=base;<br>        res[index++]=<span class="hljs-built_in">getchar</span>(n/cur);  <span class="hljs-comment">//当前base的数量应该为n/cur+1,对应的下标就是n/cur</span><br>        n=n%cur; <span class="hljs-comment">//剩下的数可以分多少到下一个进制位中</span><br>        k--;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
str2int类似于K进制</li>
</ol>
<p>从N个数中等概率打印M个数,空间复杂度为O(1)：将每次打印的数每次交换到整个数组的末尾，然后下次在生成随机数的时候，减少生成范围（1，n-count）</p>
<ol start="8">
<li>数字的中文表达和英文表达：</li>
</ol>
<ul>
<li>1.中文表达：对于零特殊处理</li>
<li>2.英文表达：每三个一组进行处理；使用递归或者迭代。递归方式就是分别求出billion million和thousand三个部分的数字，然后加起来，<br>在求每个部分的时候，先判断百位，如果百位有数字的话，那么加上”hundred“,否则分为数字&lt;=10 &lt;20; &lt;=20 &lt;100 and &lt;10 三种情况进行处理</li>
</ul>
<ol start="9">
<li>实现sqrt函数</li>
</ol>
<ul>
<li><p>方法一：使用二分算法（一个数的平方根不会大于 n/2+1），标准二分，返回right</p>
</li>
<li><p>方法二：牛顿迭代算法： y=f(x0)+k(x-x0)<br>令y=0, 得到 x_i+1=(x_i+ C/x_i)  其中C为要求的目标</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">double</span> C = x, x0 = x;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">double</span> xi = <span class="hljs-number">0.5</span> * (x0 + C / x0);<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(x0 - xi) &lt; <span class="hljs-number">1e-7</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            x0 = xi;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(x0);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
<ol start="10">
<li>小数的十进制转为二进制是*2 取整数部分，如果整数&gt;=1, 那么num-=1,否则当前位为0， 直到num=0; 也可以1连除2，num如果num&gt;base,那么减去base<br>十进制整数转换为二进制整数采用”除2取余，逆序排列”法<br>十进制小数转换成二进制小数采用”乘2取整，顺序排列”法</li>
</ol>
<ol start="11">
<li>全排列问题，使用交换或者vis+回溯，一定要注意是否有重复的字符，如果有重复的字符，那么下一个交换或者选择的数，一定是当前没有选择的</li>
</ol>
<ol start="12">
<li><p>树状数组例题：数字流的秩 线段树<br>树状数组主要是用于求前缀和，求index的前缀和其实就是不断将index的二进制数的最后一个一个1逐渐变为0 的数据对应的值相加；（x-(x&amp;-x)）<br>更新一个index需要更新的其他下标的值相当于 不断加上最后一个1所代表的数字下标对应的值 （x+(x&amp;-x)）<br>其中存储值的下标从1开始，0下标主要是判断循环的终点，不被用来存储值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++">建立树状数组：<br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">int</span> a[<span class="hljs-number">1005</span>],c[<span class="hljs-number">1005</span>]; <span class="hljs-comment">//对应原数组和树状数组</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> x&amp;(-x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">updata</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> k)</span></span>&#123;    <span class="hljs-comment">//在i位置加上k</span><br>    <span class="hljs-keyword">while</span>(i &lt;= n)&#123;<br>        c[i] += k;<br>        i += <span class="hljs-built_in">lowbit</span>(i);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getsum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;        <span class="hljs-comment">//求A[1 - i]的和</span><br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i &gt; <span class="hljs-number">0</span>)&#123;<br>        res += c[i];<br>        i -= <span class="hljs-built_in">lowbit</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>最佳直线，使用暴力枚举的方式，使用map存储斜率，同时在求斜率的时候注意：1）斜率不存在情况的处理 2）斜率有负数，以及斜率是倍数情况的处理</p>
</li>
</ol>
<ol start="14">
<li>枚举题：模式匹配问题，暂时未做，主要是通过a和b的数量来枚举a匹配的字符的长度和b字符的长度，主要是注意边界情况应该先于长度的枚举进行判断</li>
</ol>
<ol start="15">
<li>大数相乘的题目</li>
</ol>
<ul>
<li>使用第二个数的每一位数和第一个数相乘&lt;&lt; i 位，然后将求得的结果相加</li>
<li>使用第一个数的每一位和第二个数相乘，更新结果的 arr[i+k]位</li>
</ul>
<ol start="16">
<li>矩形面积： 公式为area1+area2-inter_area<br>inter_area = max((最小 右上横坐标 - 最大左下横坐标), 0)* max(（最小右上纵坐标 -  最大左下纵坐标, 0)</li>
</ol>
<p>注意一定要和0进行比较</p>
<ol start="16">
<li>找众数II:</li>
</ol>
<ul>
<li>使用hash算法</li>
<li>使用摩尔投票算法</li>
</ul>
<p>找到超过 (n/3) 向下取整的数：数学证明这样的数最多2个，选两个数，如果当前的数都不等于前两个数，那么两个投票数都–<br>这种投票算法同样适用于找到超过 n/2</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">majorityElement</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; ans;<br>        <span class="hljs-keyword">int</span> element1 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> element2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> vote1 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> vote2 = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp; num : nums) &#123;<br>            <span class="hljs-keyword">if</span> (vote1 &gt; <span class="hljs-number">0</span> &amp;&amp; num == element1) &#123; <span class="hljs-comment">//如果该元素为第一个元素，则计数加1</span><br>                vote1++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (vote2 &gt; <span class="hljs-number">0</span> &amp;&amp; num == element2) &#123; <span class="hljs-comment">//如果该元素为第二个元素，则计数加1</span><br>                vote2++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (vote1 == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 选择第一个元素</span><br>                element1 = num;<br>                vote1++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (vote2 == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 选择第二个元素</span><br>                element2 = num;<br>                vote2++;<br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//如果三个元素均不相同，则相互抵消1次</span><br>                vote1--;<br>                vote2--;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> cnt1 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> cnt2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp; num : nums) &#123;<br>            <span class="hljs-keyword">if</span> (vote1 &gt; <span class="hljs-number">0</span> &amp;&amp; num == element1) &#123;<br>                cnt1++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (vote2 &gt; <span class="hljs-number">0</span> &amp;&amp; num == element2) &#123;<br>                cnt2++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 检测元素出现的次数是否满足要求</span><br>        <span class="hljs-keyword">if</span> (vote1 &gt; <span class="hljs-number">0</span> &amp;&amp; cnt1 &gt; nums.<span class="hljs-built_in">size</span>() / <span class="hljs-number">3</span>) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(element1);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (vote2 &gt; <span class="hljs-number">0</span> &amp;&amp; cnt2 &gt; nums.<span class="hljs-built_in">size</span>() / <span class="hljs-number">3</span>) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(element2);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>


<ol start="17">
<li>为运算表达式计算优先级<br>使用分治算法, 遍历表达式，找到运算符，将结果分成两个部分， 递归查找。类似二叉树的组成方式查找<br>如果求具体的结果，那么需要使用vector将结果进行push_back,否则可以直接使用动态规划，计算总数</li>
</ol>
<ol start="18">
<li>摆动序列 如果是需要相邻两个数不能等于的话，只能两个字符串都进行翻转，如果可以相邻等于的话，可以后面的字符串进行翻转就行了 </li>
</ol>
<h5 id="19-交换数据的位置"><a href="#19-交换数据的位置" class="headerlink" title="19.交换数据的位置"></a>19.交换数据的位置</h5><p>（1）打标记方法： 这种方式理解起来更轻松, 注意这种方式，如果元数据中包含0或者小于0，但是目标数据中是大于0的([1, size])， 那可以将0，负数转为size+1; 否则如果元数据有0， 目标数据也有0的话，打标记是无法解决的</p>
<ol>
<li>缺失的第一个正数 （用负号在原地打标记代替hash方法，或者用置换方法，一定要将负数和&gt;size都转为size+1；同时对于target_index和当前index数据相同时，退出循环）</li>
<li>丢失的数字</li>
<li>数组中重复的数据</li>
</ol>
<p>将当前的数在对应的下标中打上标记，同时为了找到被覆盖数据的元数据，可以使用+n（这种可以找到重复3次， 4次都可以）,或者变为负数的这种做法<br>但是变负数的这种方式，不能适用于含有0的这种情况，因为-0和0是一样的，无法判断是否出现过这个数字</p>
<p>找到的条件是 nums[i]&gt;=0 退出</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">firstMissingPositive</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>     <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>&amp; num: nums) &#123;<br>         <span class="hljs-keyword">if</span> (num &lt;= <span class="hljs-number">0</span>) &#123;<br>             num = n + <span class="hljs-number">1</span>;<br>         &#125;<br>     &#125;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>         <span class="hljs-keyword">int</span> num = <span class="hljs-built_in">abs</span>(nums[i]);<br>         <span class="hljs-keyword">if</span> (num &lt;= n) &#123;<br>             nums[num - <span class="hljs-number">1</span>] = -<span class="hljs-built_in">abs</span>(nums[num - <span class="hljs-number">1</span>]);<br>         &#125;<br>     &#125;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>         <span class="hljs-keyword">if</span> (nums[i] &gt; <span class="hljs-number">0</span>) &#123;<br>             <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>         &#125;<br>     &#125;<br>     <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;<br> &#125;<br><br></code></pre></td></tr></table></figure>

<p>（2）置换</p>
<ol>
<li>缺失的第一个正数 把数据放在对应的位置</li>
</ol>
<p>将当前的数放在当前数据对应的下标中</p>
<p>找到的条件是 nums[i]！=i+1 退出</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">firstMissingPositive</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">while</span> (nums[i] &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[nums[i] - <span class="hljs-number">1</span>] != nums[i]) &#123;<br>            <span class="hljs-built_in">swap</span>(nums[nums[i] - <span class="hljs-number">1</span>], nums[i]); <span class="hljs-comment">//要和它交换的数不能等于它本身</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] != i + <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>（3）按照字典序排列数字：<br>我们输入两个值n和k，n表示我们有从1到n个整数，然后将这些整数都字符串化之后按字典排序，找出其中第K大的。例如:n=15,k=5.那么1-15字符串化之后排序如下:1,10,11,12,13,14,15,2,3,4,5,6,7,8,9。其中第5大的就为13。<br>实际上多叉树从到右进行计数</p>
<p>每次求解二叉树相邻两个节点之间包含的数据，如果k&gt;num那么直接更新k 然后当前数+1, 否则递归求里面的数据</p>
<h5 id="20-字符串相乘："><a href="#20-字符串相乘：" class="headerlink" title="20. 字符串相乘："></a>20. 字符串相乘：</h5><p>知识点：字符ASCII码和数字的相互转换<br>char a=’0’+81;<br>char b=a-81;<br>int c=a-‘0’;<br>cout&lt;&lt;a&lt;&lt; “ “&lt;&lt;b&lt;&lt;” “&lt;&lt;c&lt;&lt;endl;<br>注意c最终打印的结果为-175, 而不是81！！！！ 所以在初始化字符串相乘的数组只能用int类型不能用string类型</p>
<p>初始化一个m+n的数组（注意一定要为int类型，不能为string类型），然后循环计算每一位应该的值，最后从低位到高位进行进位更新<br>易错点：str1和str2需要翻转，之后的结果需要去前缀零以及翻转回来<br>如果不翻转，那么nums1[i]和nums2[j]对应nums[i+j+1]的数组</p>
<ol start="21">
<li>分数到小数，模拟除法<br>使用hash记录遇到到下标的隐射，如果出现重复余数，说明出现了重复的小数循环体<br>注意易错点：1.可能存在负数，但是不能直接对负数取反（因为可能为INT_MIN），需要转为long型<br>判断结果为负数使用异或<br>if (numeratorLong &lt; 0 ^ denominatorLong &lt; 0) {<br>sb.append(‘-‘);<br>}</li>
</ol>
<h4 id="分而治之专题"><a href="#分而治之专题" class="headerlink" title="分而治之专题"></a>分而治之专题</h4><ol>
<li><p>超级次方， 也类似观察规律的题目，就是在定义一种新的运算的时候，将它化简为熟知的运算。同时运用规律“对乘法的结果求模，等价于先对每个因子都求模，然后对因子相乘的结果再求模”<br>不能直接使用系统自带的pow,只能自己实现pow因为，在求乘方过程随时会出现溢出，所以要为每一个中间结果取模</p>
</li>
<li><p>第K个语法符号<br>找第n个的数的第k个字符是什么，转为找第n-1个数的对应f(k)位上面的数据</p>
</li>
</ol>
<h4 id="递归相关，表达式相关专题"><a href="#递归相关，表达式相关专题" class="headerlink" title="递归相关，表达式相关专题"></a>递归相关，表达式相关专题</h4><ol>
<li>迷你语法分析器： 注意在进行递归的时候一定要在主函数判断时候有[,如果有[再进入递归，否则直接返回结果，不用进入递归程序，另外一个易错点是，注意负数的处理</li>
</ol>
<h4 id="蓄水池抽样算法"><a href="#蓄水池抽样算法" class="headerlink" title="蓄水池抽样算法"></a>蓄水池抽样算法</h4><p>模板</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><br>class Solution &#123;<br>public:<br>    Solution(ListNode* head) &#123;<br>        this-&gt;<span class="hljs-attribute">head</span>=head;<br>    &#125;<br>    <br>    int getRandom() &#123;<br>        ListNode<span class="hljs-number">*c</span><span class="hljs-attribute">ur</span>=this-&gt;head;<br>        int <span class="hljs-attribute">pool</span>=-1;<br>        int <span class="hljs-attribute">i</span>=1;<br>        <span class="hljs-keyword">while</span>(cur)&#123;<br>            <span class="hljs-keyword">if</span>(rand()%<span class="hljs-attribute">i</span>==0)pool=cur-&gt;val;<br>            i++;<br>            <span class="hljs-attribute">cur</span>=cur-&gt;next;<br>        &#125;<br>        return<span class="hljs-built_in"> pool;</span><br><span class="hljs-built_in"></span>    &#125;<br><br>private:<br>    ListNode*head;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<p>例题：</p>
<ol>
<li>链表随机节点</li>
<li>随机索引数 ，找到target数的随机一个index</li>
</ol>
<h4 id="并查集专题"><a href="#并查集专题" class="headerlink" title="并查集专题"></a>并查集专题</h4><p>相关例题：</p>
<p>除法求值：并查集的变形，除了要判断各个数字是否连通，还需添加一个数组记录节点之间的权重 weight(当前节点到其父节点的权重); 而且注意如何a/b那么应该是a的父亲节点是b, a指向b的权重为a/b, 反过来的话不对 <strong>一定要注意这个权重的更新，应该为当前的权重 * 他原来父亲的现在的权重</strong></p>
<p>易错点：</p>
<ul>
<li>在进行节点merge的时候一定要注意权重的更新，weight代表的是两个节点之间的权重，而不是一个节点到根节点的权重</li>
<li>find的时候返回的是father[a]而不是a !!!!!!</li>
</ul>
<p>并查集模板：具体可见vscode里面的代码，两个模板 带size和不带size的情况</p>
<h4 id="图相关"><a href="#图相关" class="headerlink" title="图相关"></a>图相关</h4><p>竞赛第四题</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    map&lt;<span class="hljs-keyword">int</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; mp;<br>    map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; deg;<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; ans;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sn)</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;e = mp[sn]; <span class="hljs-comment">// 注意这个是引用</span><br>        <span class="hljs-keyword">while</span> (!e.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">int</span> fn = e.<span class="hljs-built_in">back</span>();<br>            e.<span class="hljs-built_in">pop_back</span>();<br>            <span class="hljs-built_in">dfs</span>(fn);<br>            ans.<span class="hljs-built_in">push_back</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;&#123;sn, fn&#125;);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//为什么要先dfs再push_back没看明白</span><br><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">validArrangement</span>(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; pairs) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;pair : pairs) &#123;<br>            mp[pair[<span class="hljs-number">0</span>]].<span class="hljs-built_in">push_back</span>(pair[<span class="hljs-number">1</span>]);<br>            deg[pair[<span class="hljs-number">0</span>]]--; deg[pair[<span class="hljs-number">1</span>]]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = deg.<span class="hljs-built_in">begin</span>(); it != deg.<span class="hljs-built_in">end</span>(); it++) <span class="hljs-keyword">if</span> (it-&gt;second == <span class="hljs-number">-1</span>) <span class="hljs-built_in">dfs</span>(it-&gt;first);<br>        <span class="hljs-keyword">if</span> (ans.<span class="hljs-built_in">empty</span>()) <span class="hljs-built_in">dfs</span>(deg.<span class="hljs-built_in">begin</span>()-&gt;first);<br>        <span class="hljs-built_in">reverse</span>(ans.<span class="hljs-built_in">begin</span>(), ans.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>


<h5 id="有关于有向图和无向图的最短路径，以及有负边和无负边的最短路径"><a href="#有关于有向图和无向图的最短路径，以及有负边和无负边的最短路径" class="headerlink" title="有关于有向图和无向图的最短路径，以及有负边和无负边的最短路径"></a>有关于有向图和无向图的最短路径，以及有负边和无负边的最短路径</h5><ol>
<li><p>Dijstra算法，适用于单源，有向或者无向的最短路径，不能适用于有负边（注意不是负环，负环情况下，无最短路径）的情况：例子：-1， -5， 2<br>时间复杂度O(n^2))</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><br><br><span class="hljs-keyword">int</span> e[Max][Max];<span class="hljs-comment">//e[i][j]代表从i-&gt;j的距离，不通设为无穷大</span><br><span class="hljs-keyword">int</span> dis[Max];<span class="hljs-comment">//dis[i]代表从起点到i的最短距离</span><br><span class="hljs-keyword">bool</span> book[Max];<span class="hljs-comment">//book[i]代表点i是否在S中</span><br><span class="hljs-keyword">int</span> n;<span class="hljs-comment">//n个顶点</span><br><span class="hljs-keyword">int</span> s;<span class="hljs-comment">//起点</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-comment">//初始化dis数组</span><br>        dis[i]=e[s][i];<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-comment">//初始化book数组</span><br>        book[i]=<span class="hljs-number">0</span>;<br>    dis[s]=<span class="hljs-number">0</span>;<br>    book[s]=<span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n<span class="hljs-number">-1</span>;i++)<span class="hljs-comment">//Dijkstra算法核心语句  注意也是n-1次</span><br>    &#123;<br>        <span class="hljs-keyword">int</span> minDis=INF;<br>        <span class="hljs-keyword">int</span> k;<span class="hljs-comment">//找到与s最近的顶点k</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(book[j]==<span class="hljs-number">0</span> &amp;&amp; dis[j]&lt;minDis)<br>            &#123;<br>                minDis=dis[j];<br>                k=j;<br>            &#125;<br>        &#125;<br>        book[k]=<span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<span class="hljs-comment">//“松弛”过程</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(e[k][j]&lt;INF)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(dis[j]&gt;dis[k]+e[k][j])<br>                    dis[j]=dis[k]+e[k][j];<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>Bellman-ford算法：适用于单源，可有负权，有向或者无向的最短路径 记住只松弛n-1次<br>能够检测出有负环情况<br>dp[i][dst]=min(dp[i][dst], dp[i-1][src]+dist[src][dst]) i==1的时候表示经过的中转站为0</p>
</li>
</ol>
<p>时间复杂度O(n*m)/O(VE)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span>&#123;</span><br>    <span class="hljs-keyword">int</span> u;<span class="hljs-comment">//起</span><br>    <span class="hljs-keyword">int</span> v;<span class="hljs-comment">//终</span><br>    <span class="hljs-keyword">int</span> weight;<span class="hljs-comment">//长度</span><br>&#125;;<br><br>Edge edge[maxm];<span class="hljs-comment">//用来存储所有的边</span><br><span class="hljs-keyword">int</span> dis[maxn];<span class="hljs-comment">//dis[i]表示源点到i的最短距离</span><br><span class="hljs-keyword">int</span> n,m;<span class="hljs-comment">//n个点，m条边</span><br><span class="hljs-keyword">int</span> s;<span class="hljs-comment">//源点</span><br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Bellmen_ford</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-comment">//初始化</span><br>        dis[i]=INF;<br><br>    dis[s]=<span class="hljs-number">0</span>;<span class="hljs-comment">//源节点到自己的距离为0</span><br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)<span class="hljs-comment">//松弛过程，计算最短路径 </span><br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(dis[edge[j].v]&gt;dis[edge[j].u]+edge[j].weight)<span class="hljs-comment">//比较s-&gt;v与s-&gt;u-&gt;v大小</span><br>                dis[edge[j].v]=dis[edge[j].u]+edge[j].weight;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)<span class="hljs-comment">//判断是否有负边权的边</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(dis[edge[j].v]&gt;dis[edge[j].u]+edge[j].weight)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="3">
<li>SPFA算法：是Bellman-ford算法的队列优化，适用于单源，可有负权，有向或者无向的最短路径 （自身其实无法处理负权）<br>设立一个队列用来保存待优化的点，优化时每次取出队首结点u，并且用u点当前的最短路径估计值对u点所指向的结点v进行松弛操作，如果v点的最短路径估计值有所调整，且v点不在当前的队列中，就将v点放入队尾。这样不断从队列中取出结点来进行松弛操作，直至队列空为止。</li>
</ol>
<p>注意，一旦从队列中弹出来，vis就设置为false，感觉负权的情况就会一直循环下去，不会跳出；遍历点，与边无关</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF 0x3f3f3f3f</span><br><br><span class="hljs-keyword">int</span> dis[MAX];<span class="hljs-comment">//dis[i]表示起点到i的最短距离</span><br><span class="hljs-keyword">bool</span> vis[MAX];<span class="hljs-comment">//是否访问过点i</span><br><span class="hljs-keyword">int</span> e[MAX][MAX];<span class="hljs-comment">//矩阵</span><br><br><span class="hljs-keyword">int</span> n,m;<span class="hljs-comment">//点和边的数量</span><br><span class="hljs-keyword">int</span> s;<span class="hljs-comment">//源点</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SPFA</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-comment">//初始化</span><br>    &#123;<br>        dis[i]=INF;<br>        vis[i]=<span class="hljs-literal">false</span>;<br>    &#125;<br>    queue&lt;<span class="hljs-keyword">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(s);<br>    dis[s]=<span class="hljs-number">0</span>;<br>    vis[s]=<span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        <span class="hljs-keyword">int</span> cur=q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        vis[cur]=<span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-comment">//遍历每一个节点</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(e[cur][i]!=INF&amp;&amp;dis[i]&gt;=dis[cur]+e[cur][i])<br>            &#123;<br>                dis[i]=dis[cur]+e[cur][i];<br>                <span class="hljs-keyword">if</span>(!vis[i])<br>                &#123;<br>                    vis[i]=<span class="hljs-literal">true</span>;<br>                    q.<span class="hljs-built_in">push</span>(i);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="4">
<li>Floyd算法： Floyd算法是一种利用动态规划思想的计算加权图中多源点之间最短路径的算法。可以正确处理有向图或负权的最短路径问题。</li>
</ol>
<p>时间复杂度：O(N^3）</p>
<p>空间复杂度：O(N^2）</p>
<p>处理问题：多源、可有负权、有向图、无向图最短路径 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> e[Max][Max];<span class="hljs-comment">//e[i][j]代表从i-&gt;j的距离，不通设为无穷大</span><br><span class="hljs-keyword">int</span> n;<span class="hljs-comment">//n个顶点</span><br><span class="hljs-comment">//Floyd算法</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Floyd</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;k++)<span class="hljs-comment">//遍历所有的中间点</span><br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-comment">//遍历所有的起点</span><br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<span class="hljs-comment">//遍历所有的终点</span><br>            &#123;<br>                <span class="hljs-keyword">if</span> (e[i][j]&gt;e[i][k]+e[k][j])<span class="hljs-comment">//如果当前i-&gt;j的距离大于i-&gt;k-&gt;j的距离之和</span><br>                    e[i][j]=e[i][k]+e[k][j];<span class="hljs-comment">//更新从i-&gt;j的最短路径</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>最短路衍生拓展的一类题目：</p>
<ol>
<li>最长路径问题：<br>图不为非负权图：当存在正环时无解。<br>如果不存在正环，边权取负后使用Bellman-Ford算法求最短路。</li>
<li>最长路径，但是路径的计算是权重之间的乘积，而且权重都是0-1之间的值，使用Dijstra算法 （e.g概率最大的路径）<br>Solution:<br> 单独使用Dijstra会导致超时，因此需要结合Dijstra+优先队列<br> 1.现将src点push 到堆进行<br> 2.然后遍历堆中的每个节点，如果当前节点能够松弛它的邻接节点，那么就放入堆中，否则不放入类似于SPFA,但是不同的是，<ul>
<li>这个使用的优先队列，而SPFA是用的是一般的堆</li>
<li>这个不仅仅push了节点，也push了当前节点的最大概率，因此没有vis数组来标记当前节点是否在堆中，因为即使在堆中， 概率也可能是不一样的。<br>总的来说这道题使用bellman-ford算法更简单，只要当前没有任何松弛的边，那么直接退出循环</li>
</ul>
</li>
</ol>
<p>颜色交替的最短路径：使用bellman-ford算法（本质是动态规划）， 只是在距离的转换是需要讨论两种情况<br>dstEndWithRed[end]=min(dstEndWithRed[end], dstEndWithBlue[start]+1);<br>dstEndWithBlue[end]=min(dstEndWithBlue[end], dstEndWithRed[start]+1);</p>
<h3 id="前缀和和差分数组相关"><a href="#前缀和和差分数组相关" class="headerlink" title="前缀和和差分数组相关"></a>前缀和和差分数组相关</h3><p>一般是有关于矩阵的一维前缀和， 二维前缀和， 一维差分数组和二维差分数组<br>如果要计算差分数组和前缀和数组最好是将坐标转为 1-n，更好计算；不然sum i j对应的grid为i-1,j-1</p>
<p>一维差分数组中，如果数组中一段数据加上或者减去某一个元素，在差分数组中只有两头的元素进行了修改，中间的元素都没有修改<br>二维差分数组中，如果包含左上角（x1, y1）, 右下角（x2, y2）这一部分都+C, 那么对应的差分数组d[x1][y1]+c d[x2+1][y2+1]+c d[x1][y1+1]-c d[x2]+1[y1]-c<br>(上升的对角线两端元素-c, 下降的对角线元素+c)</p>
<p>二维差分数组公式:<br>nums[i][j]-nums[i-1][j]-nums[i][j-1]+nums[i-1][j-1]=d[i][j]<br>从差分数组还原原来的数组<br>nums[i][j]=nums[i-1][j]+nums[i][j-1]-nums[i-1][j-1]+d[i][j]</p>
<p>例题：</p>
<ol>
<li><ol start="5931">
<li>用邮票贴满网格图 (hard)</li>
</ol>
</li>
</ol>
<p>方法一: 使用二维前缀和，对原来矩阵中每个左上角为0，且邮票区域都为0的位置，贴上邮票，为了减少贴这个过程的时间开销，使用二元差分数组<br>贴完后，对二元差分数组进行还原，如果仍然遇到为0的位置，那么返回false<br>注意这道题没必要求差分数组，差分数组可以全部直接初始化为0， 那么还原回来的也是填充数组<br>方法二: 不使用二维差分数组，使用另外一个数组，标记贴邮票的左上角，然后针对每个grid中为0的位置，计算邮票部分区域的前缀和，如果为0，表示这个区域没有被贴上邮票，返回false</p>
<ol start="2">
<li>航班预订统计 (middle)<br>一维差分数组的题目<br>如果原来数组的下标就是1-n的话，那么修改n-m部分的数据， 就会修改等差数列的d[n]和d[m+1]两个端点的数据</li>
</ol>
<ol start="3">
<li>拼车<br>这道题类似于天际线问题，使用hash, 左断点加入m个人，右端点减去m个人<br>然后遍历hash的每个key,如果有个时刻是大于capacity, 那么返回false</li>
</ol>
<h3 id="前缀异或值"><a href="#前缀异或值" class="headerlink" title="前缀异或值"></a>前缀异或值</h3><p>在求前缀异或的时候，结果数组可以从1开始取，这样的话就不用对边缘单独进行赋值操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++j) &#123;<br>        pre[i][j] = pre[i - <span class="hljs-number">1</span>][j] ^ pre[i][j - <span class="hljs-number">1</span>] ^ pre[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] ^ matrix[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>        results.<span class="hljs-built_in">push_back</span>(pre[i][j]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h3 id="分类讨论题"><a href="#分类讨论题" class="headerlink" title="分类讨论题"></a>分类讨论题</h3><ol>
<li> K 次串联后最大子数组之和<br>分类分析<br>k=1;<br>k=2;<br>k&gt;2 如果array之和小于0，那么结果就是k=2情况，否则k=2+(k-2)*sum(one array)</li>
</ol>
<h4 id="摩尔投票算法"><a href="#摩尔投票算法" class="headerlink" title="摩尔投票算法"></a>摩尔投票算法</h4><p>1.求众数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> target_num=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>    <span class="hljs-keyword">if</span>(k==<span class="hljs-number">0</span>)&#123;<br>        target_num=nums[i];<br>        k=<span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">if</span>(nums[i]==target_num)&#123;<br>            k++;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            k--;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//判断target_num的数是否大于n/2;</span><br><span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>    <span class="hljs-keyword">if</span>(nums[i]==target_num)&#123;<br>        cnt++;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">if</span>(cnt&gt;n/<span class="hljs-number">2</span>)&#123;<br>    <span class="hljs-keyword">return</span> target_num;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>2.求大于n/3 的数<br>这样的数最多只有两个</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> k1=<span class="hljs-number">0</span>;<span class="hljs-comment">//投票的数量</span><br><span class="hljs-keyword">int</span> k2=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> target_num1;<span class="hljs-comment">//具体的数</span><br><span class="hljs-keyword">int</span> target_num2;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>    <span class="hljs-keyword">if</span>(k1&gt;<span class="hljs-number">0</span>&amp;&amp;target_num1==nums[i])&#123;<br>        k1++;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(k2&gt;<span class="hljs-number">0</span>&amp;&amp;target_num2==nums[i])&#123;<br>        k2++;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(k1==<span class="hljs-number">0</span>)&#123;<br>        target_num1=nums[i];<br>        k1=<span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(k2==<span class="hljs-number">0</span>)&#123;<br>        target_num2=nums[i];<br>        k2=<span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        k1--;<br>        k2--;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">int</span> cnt1=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> cnt2=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>    <span class="hljs-keyword">if</span>(k1&gt;<span class="hljs-number">0</span>&amp;&amp;nums[i]==target_num1)&#123;<br>        cnt1++;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(k2&gt;<span class="hljs-number">0</span>&amp;&amp;nums[i]==target_num2)&#123;<br>        cnt2++;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">if</span>(cnt1&gt;n/<span class="hljs-number">3</span>)&#123;<br>    res.<span class="hljs-built_in">push_back</span>(target_num1);<br>&#125;<br><span class="hljs-keyword">if</span>(cnt2&gt;n/<span class="hljs-number">3</span>)&#123;<br>    res.<span class="hljs-built_in">push_back</span>(target_num2);<br>&#125;<br><br></code></pre></td></tr></table></figure>







<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>二维差分数组常用在对数组中的某一个块的区域进行操作， 比如这道题的贴邮票， 对整块数组+1</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/leetcode/">leetcode</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E5%85%B6%E4%BB%96/">其他</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/11/13/leetcode/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">贪心算法</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/11/13/leetcode/%E5%8F%8C%E6%8C%87%E9%92%88/">
                        <span class="hidden-mobile">双指针</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
