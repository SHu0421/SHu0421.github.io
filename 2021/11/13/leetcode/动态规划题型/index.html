

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/self.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Shu">
  <meta name="keywords" content="">
  
    <meta name="description" content="求总数问题1. 回文字符串的个数2. 表达式为期望结果的总数 也是区间dp, dp[i][j][0]或者dp[i][j][1]) 因为不是表达式的个数，而是达到期望值的个数，因此要记录一个表达式的值，用三维数组  3. 能够组成的二叉树的个数4. 打气球的最大分数(区间dp) 虽然不是求个数，而是求最大，但是也是与当前状态的左右边界有关。因为最终结果和左右两边有关，因此都是枚举的长度+右边界，计算">
<meta property="og:type" content="article">
<meta property="og:title" content="动态规划">
<meta property="og:url" content="http://shu0421.github.io/2021/11/13/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%A2%98%E5%9E%8B/index.html">
<meta property="og:site_name" content="Hello World">
<meta property="og:description" content="求总数问题1. 回文字符串的个数2. 表达式为期望结果的总数 也是区间dp, dp[i][j][0]或者dp[i][j][1]) 因为不是表达式的个数，而是达到期望值的个数，因此要记录一个表达式的值，用三维数组  3. 能够组成的二叉树的个数4. 打气球的最大分数(区间dp) 虽然不是求个数，而是求最大，但是也是与当前状态的左右边界有关。因为最终结果和左右两边有关，因此都是枚举的长度+右边界，计算">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-11-13T09:00:51.000Z">
<meta property="article:modified_time" content="2023-11-29T02:21:21.322Z">
<meta property="article:author" content="Shu">
<meta property="article:tag" content="dp">
<meta name="twitter:card" content="summary_large_image">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>动态规划 - Hello World</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />

  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="//at.alicdn.com/t/c/font_4176555_qx6ctrgomb9.css">
<link rel="stylesheet" href="/css/mac.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"shu0421.github.io","root":"/","version":"1.9.5","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":"UA-294899992-1","tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"gtag":"G-MVXHSJJR3Q"},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  
    <!-- Google tag (gtag.js) -->
    <script async>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=", function() {
          window.dataLayer = window.dataLayer || [];
          function gtag() {
            dataLayer.push(arguments);
          }
          gtag('js', new Date());
          gtag('config', '');
        });
      }
    </script>
  

  

  

  

  



  
<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Hello World" type="application/atom+xml">
</head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 60vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>HU&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button"
                 data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                <i class="iconfont icon-books"></i>
                <span>爱好</span>
              </a>
              <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                
                  
                  
                  
                  <a class="dropdown-item" href="/favorite/">
                    
                    <span>概述</span>
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/favorite-reading">
                    
                    <span>阅读</span>
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/favorite-language/">
                    
                    <span>语言</span>
                  </a>
                
              </div>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="http://shu0421.github.io/en/">
                <i class="iconfont icon-qiehuanyuyan"></i>
                <span>English</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/bg-wenzhang-2.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="动态规划"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2021-11-13 17:00" pubdate>
          2021年11月13日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          <!-- compatible with older versions-->
          29k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          <!-- compatible with older versions-->
          93 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">动态规划</h1>
            
              <p class="note note-info">
                
                  
                    <!-- compatible with older versions-->
                    本文最后更新于：2023年11月29日 上午
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <h2 id="求总数问题"><a href="#求总数问题" class="headerlink" title="求总数问题"></a>求总数问题</h2><h3 id="1-回文字符串的个数"><a href="#1-回文字符串的个数" class="headerlink" title="1. 回文字符串的个数"></a>1. 回文字符串的个数</h3><h3 id="2-表达式为期望结果的总数"><a href="#2-表达式为期望结果的总数" class="headerlink" title="2. 表达式为期望结果的总数"></a>2. 表达式为期望结果的总数</h3><ul>
<li>也是区间dp, dp[i][j][0]或者dp[i][j][1])</li>
<li>因为不是表达式的个数，而是达到期望值的个数，因此要记录一个表达式的值，用三维数组</li>
</ul>
<h3 id="3-能够组成的二叉树的个数"><a href="#3-能够组成的二叉树的个数" class="headerlink" title="3. 能够组成的二叉树的个数"></a>3. 能够组成的二叉树的个数</h3><h3 id="4-打气球的最大分数-区间dp"><a href="#4-打气球的最大分数-区间dp" class="headerlink" title="4. 打气球的最大分数(区间dp)"></a>4. 打气球的最大分数(区间dp)</h3><ul>
<li>虽然不是求个数，而是求最大，但是也是与当前状态的左右边界有关。因为最终结果和左右两边有关，因此都是枚举的长度+右边界，计算左边界，进行动态规划<br>转移方程：考虑这个区间上最后一个气球的打破方式，即最后一个气球的打破位置。在左边右边和中间<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">f[i][j] = <span class="hljs-built_in">max</span>( f[i][j], f[i][k - <span class="hljs-number">1</span>] + f[k + <span class="hljs-number">1</span>][j] + a[k] * a[i - <span class="hljs-number">1</span>] * a[j + <span class="hljs-number">1</span>]); <span class="hljs-comment">//闭区间的更新方式</span><br></code></pre></td></tr></table></figure></li>
</ul>
<p>在leetcode上面的一道原题，只是描述改变了<br>lc312. 戳气球</p>
<ul>
<li>这道题如果将dp[i][j]定义为开区间或得的最大值就更容易理解<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">状态转移： dp[i][j]=<span class="hljs-built_in">max</span>(dp[i][j], dp[i][k]+dp[k][j]+val[i]*val[k]*val[j]);<span class="hljs-comment">//开区间的更新方式</span><br></code></pre></td></tr></table></figure></li>
<li>注意为了减少情况的分类讨论，需要在左右两边都加上1，这样的话枚举一个区间留下的最后一个数，也是可以求得值的</li>
</ul>
<h3 id="5-旋变字符串问题-区间dp-lc87-扰乱字符串"><a href="#5-旋变字符串问题-区间dp-lc87-扰乱字符串" class="headerlink" title="5. 旋变字符串问题 (区间dp) lc87. 扰乱字符串"></a>5. 旋变字符串问题 (区间dp) lc87. 扰乱字符串</h3><ul>
<li>四重循环，三维dp（两个字符串两个端点+一个长度）</li>
<li>这道题不是求个数，而是求是否，但是仍然是需要枚举长度的问题，因为是两个字符串，所以应该有4个边，但是运用长度相等的信息，将思维坐标转为左边坐标+size, 成为三维问题<br>dp[start1][start2][len] 而且这道题有两个长度：一个是总字符串长度，一个是总字符串化为为两个旋变字符串的长度  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> size = <span class="hljs-number">2</span>; size &lt;= n; size++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> l1 = <span class="hljs-number">0</span>; l1 &lt;= n - size; l1++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> l2 = <span class="hljs-number">0</span>; l2 &lt;= n - size; l2++)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> leftPart = <span class="hljs-number">1</span>; leftPart &lt; size; leftPart++)&#123;<br>                    <span class="hljs-keyword">if</span>((dp[l1][l2][leftPart] &amp;&amp; dp[l1 + leftPart][l2 + leftPart][size - leftPart]) || <br>                        (dp[l1][l2 + size - leftPart][leftPart] &amp;&amp; dp[l1 + leftPart][l2][size - leftPart]))&#123;<br>                        dp[l1][l2][size] = <span class="hljs-literal">true</span>;      <span class="hljs-comment">// 只要有一个leftPart满足旋变串条件就可以break出去</span><br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="6-数字字符串转为字母组合的总数"><a href="#6-数字字符串转为字母组合的总数" class="headerlink" title="6. 数字字符串转为字母组合的总数"></a>6. 数字字符串转为字母组合的总数</h3><ul>
<li>因为只是与之前的结果或者后面的结果有关，因此只需要从左到右枚举下标就可以了<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++">递推式<br><span class="hljs-comment">// 第 i 个字符只能单独转换为一个 字母</span><br><span class="hljs-comment">// dp[i-1] ：第 i 个字符单独转换的方案数</span><br>dp[i]=dp[i<span class="hljs-number">-1</span>];<br><span class="hljs-comment">// 第 i 个字符 可以和 第 i-1 个字符 共同转换为一个 字母</span><br><span class="hljs-comment">// dp[i-1] ：第 i 个字符单独转换的方案数</span><br><span class="hljs-comment">// dp[i-2] ：第 i 个字符，结合第 i-1 个字符组合转换为一个字母的方案数</span><br>dp[i]=dp[i<span class="hljs-number">-1</span>]+dp[i<span class="hljs-number">-2</span>];<br><span class="hljs-comment">//如果第i个字符不能单独存在那么</span><br>dp[i]=<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="7-组合总数IV"><a href="#7-组合总数IV" class="headerlink" title="7. 组合总数IV"></a>7. 组合总数IV</h3><ul>
<li>可以用作骰子问题的解决方案， 600个点数扔出400点总共有多少种方案</li>
<li>总结：如果排序不同算不同的排列组合的话那么 target循环在外侧， nums总数循环在内侧  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=target;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;size;j++)&#123; <span class="hljs-comment">//最后这个数1-size都可以选择</span><br>            <span class="hljs-keyword">if</span>(i&gt;=nums[j]&amp;&amp;dp[i - nums[j]] &lt; INT_MAX - dp[i])&#123;<br>                dp[i]+=dp[i-nums[j]]; <span class="hljs-comment">//只需要一维就好</span><br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></li>
<li>如果排序不同算相同的排列祝贺的话那么， target循环在内侧，nums总数循环在外侧, 完全背包问题  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=size;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=target;j++)&#123;<br>        dp[i][j]+=dp[i<span class="hljs-number">-1</span>][j];<br>        <span class="hljs-keyword">if</span>(j&gt;=nums[i<span class="hljs-number">-1</span>])&#123;<br>            dp[i][j]+=dp[i][j-nums[i<span class="hljs-number">-1</span>]]; <span class="hljs-comment">//完全背包</span><br>        &#125;<br>    &#125;<br>&#125;<br>- 如果是&#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>&#125;可以重复选择每个数组成target的话，使用完全背包<br>dp[i][j]=dp[i][j-nums[i]]+dp[i<span class="hljs-number">-1</span>][j]<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="8-删除回文子数组"><a href="#8-删除回文子数组" class="headerlink" title="8. 删除回文子数组"></a>8. 删除回文子数组</h3><ul>
<li>区间dp/枚举长度的dp</li>
<li>数组，每次可以删除一个数字，或者删除掉一个回文串，求删除需要的最少次数<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">dp<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-attr">[j]</span>=min(dp<span class="hljs-selector-attr">[i+1]</span><span class="hljs-selector-attr">[j-1]</span>, dp<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-attr">[j]</span>) <span class="hljs-keyword">if</span> <span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[i]</span>==<span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[j]</span><br>dp<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-attr">[j]</span>=min(dp<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-attr">[k]</span>+dp<span class="hljs-selector-attr">[k+1]</span><span class="hljs-selector-attr">[j]</span>, dp<span class="hljs-selector-attr">[i]</span><span class="hljs-selector-attr">[j]</span>)<br>dp长度从<span class="hljs-number">3</span>开始，dp长度为<span class="hljs-number">1</span>， <span class="hljs-number">2</span>的时候使用初始化<br></code></pre></td></tr></table></figure></li>
<li>答案见：<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1659691">LeetCode 1246. 删除回文子数组（区间DP）-腾讯云开发者社区-腾讯云</a> 可以作为区间dp模板，但是枚举长度和转移方程那里可以修改一下</li>
</ul>
<h3 id="9-lc115-不同的子序列-具体分析见字符串匹配问题"><a href="#9-lc115-不同的子序列-具体分析见字符串匹配问题" class="headerlink" title="9. lc115. 不同的子序列 (具体分析见字符串匹配问题)"></a>9. lc115. 不同的子序列 (具体分析见字符串匹配问题)</h3><h3 id="10-lc446-等差数列划分-II-子序列（hard）"><a href="#10-lc446-等差数列划分-II-子序列（hard）" class="headerlink" title="10. lc446. 等差数列划分 II - 子序列（hard）"></a>10. lc446. 等差数列划分 II - 子序列（hard）</h3><ul>
<li>题意：等差子序列个数，可不连续，每个序列至少包含3个数</li>
<li>我的困难地方在于，这个序列长度要等于3，那么将序列==2的如何处理，如果出现重复如何处理 比如2  1 2 3</li>
<li>官方解题方案是，计算弱等差子序列的个数（序列==2），然后再计算结果的时候遍历三个数，同时因为差为负数，所以使用hash_map数组vector&lt;unordered_map&lt;long long, int&gt;&gt; d(size)</li>
<li>将记录以某一下标结尾的序列中包含的数个数，转为差为d的对数（个数-&gt;对数）</li>
</ul>
<h3 id="11-lc1000-合并石头的最低成本-hard"><a href="#11-lc1000-合并石头的最低成本-hard" class="headerlink" title="11. lc1000. 合并石头的最低成本(hard)"></a>11. lc1000. 合并石头的最低成本(hard)</h3><ul>
<li>区间dp的经典题目，四重区间dp</li>
<li>将i，j之间的num堆转为 区间划分前面1堆后面num-1堆，然后因为连续k堆可以转为一堆，所以单独对于dp[i][j][k]单独进行转换为dp[i][j][1]<br>dp[i][j][num]=min(dp[i][j][num], dp[i][q][1]+dp[q+1][j][num-1]); //num表示num堆， 注意没有必要枚举dp[i][q][2]+dp[q+1][j][num-2]//这种情况，因为下标划分已经达到枚举的作用</li>
</ul>
<h3 id="12-lc1130-叶值的最小代价生成树"><a href="#12-lc1130-叶值的最小代价生成树" class="headerlink" title="12. lc1130. 叶值的最小代价生成树"></a>12. lc1130. 叶值的最小代价生成树</h3><ul>
<li><p>注意题意：中序遍历要对应！！！（相邻顺序不变的题，一般使用区间dp）</p>
</li>
<li><p>解决方法：区间dp或者贪心算法<br>状态转移方程<br>f[i][j]=min(f[i][j],f[i][k]+f[k+1][j]+g[i][k]∗g[k+1][j]</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-cost-tree-from-leaf-values/solution/qu-jian-dp-dong-tai-gui-hua-die-dai-xie-g4jac/">参考链接</a></p>
</li>
</ul>
<h3 id="13-lc1039-多边形三角剖分的最低得分"><a href="#13-lc1039-多边形三角剖分的最低得分" class="headerlink" title="13. lc1039. 多边形三角剖分的最低得分"></a>13. lc1039. 多边形三角剖分的最低得分</h3><ul>
<li>区间dp问题</li>
<li>主要找到中间那个三角形+左右两边子问题， 直接划分为两个子问题做不出来</li>
<li>不要想象为环形</li>
</ul>
<h3 id="14-和为偶数的子数组的个数，-子序列的个数"><a href="#14-和为偶数的子数组的个数，-子序列的个数" class="headerlink" title="14. 和为偶数的子数组的个数， 子序列的个数"></a>14. 和为偶数的子数组的个数， 子序列的个数</h3><p>扩展：长度为n， 使用二维状态转移方程<br>思路：转为0 1， 然后和为奇数和偶数分开计算</p>
<ul>
<li><p>子数组的个数：（连续）</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus">当前值为<span class="hljs-number">0</span>：<br>even<span class="hljs-selector-attr">[i]</span>=even<span class="hljs-selector-attr">[i-1]</span>+<span class="hljs-number">1</span><span class="hljs-comment">//以i结尾的偶数子数组的个数</span><br>odd<span class="hljs-selector-attr">[i]</span>=odd<span class="hljs-selector-attr">[i-1]</span> <span class="hljs-comment">// 以i结尾的奇数子数组的个数</span><br>当前值为<span class="hljs-number">1</span>: <br>odd<span class="hljs-selector-attr">[i]</span>=even<span class="hljs-selector-attr">[i-1]</span>+<span class="hljs-number">1</span><span class="hljs-comment">//以i结尾的偶数子数组的个数</span><br>even<span class="hljs-selector-attr">[i]</span>=odd<span class="hljs-selector-attr">[i-1]</span> <span class="hljs-comment">// 以i结尾的偶数子数组的个数</span><br>最后结果是even<span class="hljs-selector-attr">[0~n-1]</span><br></code></pre></td></tr></table></figure></li>
<li><p>子序列的个数：（连续）</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus">当前值为<span class="hljs-number">0</span>：<br>even<span class="hljs-selector-attr">[i]</span>=<span class="hljs-number">2</span>*even<span class="hljs-selector-attr">[i-1]</span>+<span class="hljs-number">1</span><span class="hljs-comment">//以i结尾的偶数子数组的个数</span><br>odd<span class="hljs-selector-attr">[i]</span>=<span class="hljs-number">2</span>*odd<span class="hljs-selector-attr">[i-1]</span> <span class="hljs-comment">// 以i结尾的奇数子数组的个数</span><br>当前值为<span class="hljs-number">1</span>: <br>even<span class="hljs-selector-attr">[i]</span>=even<span class="hljs-selector-attr">[i-1]</span>+odd<span class="hljs-selector-attr">[i-1]</span><span class="hljs-comment">//以i结尾的偶数子数组的个数</span><br>odd<span class="hljs-selector-attr">[i]</span>=odd<span class="hljs-selector-attr">[i-1]</span>+even<span class="hljs-selector-attr">[i-1]</span>+<span class="hljs-number">1</span> <span class="hljs-comment">// 以i结尾的偶数子数组的个数</span><br>最后返回even<span class="hljs-selector-attr">[size-1]</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="求最大最小问题"><a href="#求最大最小问题" class="headerlink" title="求最大最小问题"></a>求最大最小问题</h2><p>PS: 子串都是要求连续的，而子序列是不要求连续的</p>
<h3 id="1-扔鸡蛋-lc887"><a href="#1-扔鸡蛋-lc887" class="headerlink" title="1. 扔鸡蛋 lc887"></a>1. 扔鸡蛋 lc887</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/92288604">https://zhuanlan.zhihu.com/p/92288604</a></p>
<ul>
<li>两种状态转移：<br>  a. dp[k][n], k个鸡蛋n层楼， 需要最少扔多少次  <figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">dp<span class="hljs-comment">[1]</span><span class="hljs-comment">[N]</span> = N<br>dp<span class="hljs-comment">[..]</span><span class="hljs-comment">[0]</span> = 0<br>for i=1到n:<br>    dp<span class="hljs-comment">[k]</span><span class="hljs-comment">[n]</span>=min(dp<span class="hljs-comment">[k]</span><span class="hljs-comment">[n]</span>, max(dp<span class="hljs-comment">[k]</span><span class="hljs-comment">[i-1]</span>+dp<span class="hljs-comment">[k-1]</span><span class="hljs-comment">[n-i]</span>)+1);//不需要在第i层再扔，因此删除i<br></code></pre></td></tr></table></figure>
  b. dp[k][m], k个鸡蛋扔m次，可以验证的最大楼层数  <figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs inform7">dp<span class="hljs-comment">[0]</span><span class="hljs-comment">[..]</span> = 0<br>dp<span class="hljs-comment">[..]</span><span class="hljs-comment">[0]</span> = 0<br>whle(dp<span class="hljs-comment">[K]</span><span class="hljs-comment">[m]</span>&lt;N)&#123;<br>    m++;<br>    for (int k = 1; k &lt;= K; k++)&#123;<br>        dp<span class="hljs-comment">[k]</span><span class="hljs-comment">[m]</span> = dp<span class="hljs-comment">[k]</span><span class="hljs-comment">[m - 1]</span> + dp<span class="hljs-comment">[k - 1]</span><span class="hljs-comment">[m - 1]</span> + 1;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>整体解法<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> ans=<span class="hljs-number">-1</span>;<br>vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n+<span class="hljs-number">1</span>,vector&lt;<span class="hljs-keyword">int</span>&gt;(k+<span class="hljs-number">1</span>));<br><span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>&amp;k&gt;=<span class="hljs-number">1</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++)&#123;<br>    dp[i][<span class="hljs-number">1</span>]=i; <span class="hljs-comment">//一个鸡蛋</span><br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=k;j++)&#123;<br>    dp[<span class="hljs-number">1</span>][j]=<span class="hljs-number">1</span>; <span class="hljs-comment">//一次操作</span><br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123; <span class="hljs-comment">//n次操作</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=k;j++)&#123; <span class="hljs-comment">//k个鸡蛋</span><br>        dp[i][j]=dp[i<span class="hljs-number">-1</span>][j]+dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(dp[i][k]&gt;=n)&#123;<br>            ans=i;<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-最长递增子串"><a href="#2-最长递增子串" class="headerlink" title="2. 最长递增子串"></a>2. 最长递增子串</h3><h3 id="3-最长递增子序列"><a href="#3-最长递增子序列" class="headerlink" title="3. 最长递增子序列"></a>3. 最长递增子序列</h3><p>两种方法：</p>
<ul>
<li>两重循环</li>
<li>单调栈+二分查找<br>扩展 最长递增子序列的个数，时间复杂度仍然是O(n^2)，只是多了一个cnt, 每次出现最大就更新，否则进行cnt的累加</li>
</ul>
<p>另外类似的题目: 1027. 最长等差数列<br>dp[i][j]表示以i结尾而且差为j的最长数列</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;i;j++)&#123;<br>        <span class="hljs-keyword">int</span> tmp=nums[i]-nums[j];<span class="hljs-comment">//因为差可能是负数</span><br>        dp[i][tmp+<span class="hljs-number">1000</span>]=dp[j][tmp+<span class="hljs-number">1000</span>]+<span class="hljs-number">1</span>;<br>        res=<span class="hljs-built_in">max</span>(res, dp[i][tmp+<span class="hljs-number">1000</span>]);   <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>lc1218. 最长定差子序列： 这道题diff是定了，因此只需要一维hash就可以了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>    hash[arr[i]]=<span class="hljs-built_in">max</span>(hash[arr[i]-difference]+<span class="hljs-number">1</span>, hash[arr[i]]);<br>    res=<span class="hljs-built_in">max</span>(res, hash[arr[i]]);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="4-最长公共子串（要求连续）"><a href="#4-最长公共子串（要求连续）" class="headerlink" title="4. 最长公共子串（要求连续）"></a>4. 最长公共子串（要求连续）</h3><pre><code class="hljs">- 注意和子序列的区别：动态规划转移方程是 dp[i][j]=dp[i-1][j-1]+1 or dp[i][j]=0表示以i或者j结尾的子串， 最后遍历二维数组求最大值
</code></pre>
<p>求具体的最长公共子串，只需要动态规划的时候，记录最长的公共子串的下标，然后<code>s.substr(start_pos = index-maxlen+1, len = maxlen)</code>就可以了</p>
<h3 id="5-最长公共子序列-（最长长度-最长具体序列-最短包含序列）"><a href="#5-最长公共子序列-（最长长度-最长具体序列-最短包含序列）" class="headerlink" title="5. 最长公共子序列 （最长长度/最长具体序列/最短包含序列）"></a>5. 最长公共子序列 （最长长度/最长具体序列/最短包含序列）</h3><ul>
<li>题意改变，但是代码不变的题目–不相交的线</li>
<li>相似的题目：</li>
</ul>
<ol>
<li>编辑距离</li>
<li>两个字符串的删除操作， 可以直接动态规划求最少的删除字符数量，也可以用最长公共子序列，然后用m+n-2*lcs</li>
</ol>
<ul>
<li>如果要求具体删除的是哪些字符串，两种方法应该都是可以的</li>
<li>动态规划转移方程是 <figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>=dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>+1 or dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>=max(dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j-1]</span>, dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[j]</span>)<br></code></pre></td></tr></table></figure>
dp[i-1][j] 表示以i或者j结尾的子串中包括的最长公共子序列（不一定是以i j结尾）， 所以最后只用直接返回dp[m][n]</li>
<li>在求最长的公共子序列的时候，需要使用dp转换等式 i–,j– 或者j–, 或者i–来进行查找最长的公共子序列， 同时也可以求最短的删除的字符具体是哪些<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> i = m<span class="hljs-number">-1</span>, j = n<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">if</span>(s1.<span class="hljs-built_in">charAt</span>(i) == s2.<span class="hljs-built_in">charAt</span>(j))&#123;<br>        res.<span class="hljs-built_in">append</span>(s1.<span class="hljs-built_in">charAt</span>(i));<br>        i--;<br>        j--;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span> &amp;&amp; j&gt;<span class="hljs-number">0</span> &amp;&amp; s1.<span class="hljs-built_in">charAt</span>(i) != s2.<span class="hljs-built_in">charAt</span>(j))&#123;<br>        <span class="hljs-keyword">if</span>(dp[i<span class="hljs-number">-1</span>][j] &gt; dp[i][j<span class="hljs-number">-1</span>])<br>            i--;<br>        <span class="hljs-keyword">else</span><br>            j--;<br>        <span class="hljs-comment">//dp[i-1][j] &lt; dp[i][j-1]时,j--;</span><br>        <span class="hljs-comment">//dp[i-1][j] = dp[i][j-1]时,i--或j--,这里统一为j--;</span><br>    &#125;<br>    <br>    <span class="hljs-comment">//行或列到达边界</span><br>    <span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>)j--;<br>    <span class="hljs-keyword">if</span>(j==<span class="hljs-number">0</span>)i--;<br>&#125;<br></code></pre></td></tr></table></figure>
PS: lc1092. 最短公共超序列</li>
<li>求包含两个字符的最短序列， 其实就是m+n-k(k为公共序列的长度)<br>相比于公共序列， 会在i–, j– 都push_back字符; 求具体的公共序列的时候，只有相等的时候才push相等的字符<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> i=size1<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">int</span> j=size2<span class="hljs-number">-1</span>;<br>string res;<br><span class="hljs-keyword">while</span>(i&gt;<span class="hljs-number">0</span>&amp;&amp;j&gt;<span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">if</span>(str1[i]==str2[j])&#123;<br>        res.<span class="hljs-built_in">push_back</span>(str1[i]);<br>        i--;j--;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">if</span>(dp[i<span class="hljs-number">-1</span>][j]&gt;dp[i][j<span class="hljs-number">-1</span>])&#123;<br>            res.<span class="hljs-built_in">push_back</span>(str1[i]);<br>            i--;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            res.<span class="hljs-built_in">push_back</span>(str2[j]);<br>            j--;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">while</span>(i&gt;<span class="hljs-number">0</span>)&#123;<br>    res.<span class="hljs-built_in">push_back</span>(str1[i--]);<br>&#125;<br>    <span class="hljs-keyword">while</span>(j&gt;<span class="hljs-number">0</span>)&#123;<br>    res.<span class="hljs-built_in">push_back</span>(str2[j--]);<br>&#125;<br><span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>());<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="6-最长回文子序列"><a href="#6-最长回文子序列" class="headerlink" title="6. 最长回文子序列"></a>6. 最长回文子序列</h3><ul>
<li>不要求连续，枚举长度</li>
<li>初始化长度为1和2的情况，然后<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> len=<span class="hljs-number">3</span>;len&lt;=s_len;len++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> left=<span class="hljs-number">0</span>;left&lt;s_len;left++)&#123;<br>        <span class="hljs-keyword">int</span> right=left+len<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">if</span>(right&lt;s_len)&#123;<br>            dp[left][right]=<span class="hljs-built_in">max</span>(dp[left+<span class="hljs-number">1</span>][right], dp[left][right<span class="hljs-number">-1</span>]);<br>            <span class="hljs-keyword">if</span>(s[left]==s[right])&#123;<br>                dp[left][right]=<span class="hljs-built_in">max</span>(dp[left][right],dp[left+<span class="hljs-number">1</span>][right<span class="hljs-number">-1</span>]+<span class="hljs-number">2</span>);<br>            &#125; <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="7-最长回文子串的问题-（判断true-false的dp系列）"><a href="#7-最长回文子串的问题-（判断true-false的dp系列）" class="headerlink" title="7. 最长回文子串的问题 （判断true/false的dp系列）"></a>7. 最长回文子串的问题 （判断true/false的dp系列）</h3><ul>
<li>可以用动态规划也可以用从中间向两边扩展的方法<br>动态规划dp[left][right]不是表示长度，而是表示是否为回文子串，在求长度使用一个公共变量max_len,每求出dp 如果dp为1那么更新max_len</li>
</ul>
<h3 id="8-最长有效括号子串"><a href="#8-最长有效括号子串" class="headerlink" title="8. 最长有效括号子串"></a>8. 最长有效括号子串</h3><ul>
<li>方法一：动态规划</li>
<li>转移方程 dp[i]:以i结尾的最长有效括号子串 转移方程如下<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;s_len;i++)&#123;<br>    <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;)&#x27;</span>)&#123;<br>        <span class="hljs-keyword">int</span> j=i-dp[i<span class="hljs-number">-1</span>]<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">if</span>(j&gt;=<span class="hljs-number">0</span>&amp;&amp;s[j]==<span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>            dp[i]=dp[i<span class="hljs-number">-1</span>]+<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(j<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>)&#123;<br>                dp[i]+=dp[j<span class="hljs-number">-1</span>];<br>            &#125;<br>        &#125;<br>        result=<span class="hljs-built_in">max</span>(result, dp[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>方法二：下标栈，栈低维护的是最后一个没有被匹配的右括号下标，如果<code>s[i]==&#39;(&#39;</code>入栈下标; 如果<code>s[i]==&#39;)&#39;</code>, 栈中弹出一个元素，如果栈为空，直接<code>push(i) continue</code>，否则更新<code>ans=max(ans, i-s.peek())</code></li>
</ul>
<h3 id="9-分割回文串系列题目"><a href="#9-分割回文串系列题目" class="headerlink" title="9. 分割回文串系列题目"></a>9. 分割回文串系列题目</h3><ol>
<li>分割回文串1</li>
</ol>
<ul>
<li>动态规划+回溯dfs，求所有i， j之间的子字符串p[i][j]是否是回文（类似最长回文子串的题目）</li>
</ul>
<ol start="2">
<li>分割回文串2</li>
</ol>
<ul>
<li>求最少分割次数<ul>
<li>这道题不能使用枚举长度和左边界+枚举分割点的方式，时间复杂度太高（O(N^3)）</li>
<li>正确的解决方案是，求dp[i] 从0到i需要分割的最少次数，同时事先需要使用动态规划求出任意i j之间是否是回文串；如果0-i是回文串，直接结果为0，否则依次遍历i之后的字符串，找到回文串j+1-i，同时更新dp[i]=min(dp[i], dp[j]+1)</li>
<li>这道题可以和“子数组异或值为0的最多划分”进行类比（动态规划+map映射上一个位置）；不同之处这道题通过回文串映射到上一个位置，异或和是通过异或值为和当前值相同隐射到上一个位置<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;s_len;i++)&#123;<br>    dp[i]=INT_MAX;<br>&#125;<br>dp[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;s_len;i++)&#123;<br>    <span class="hljs-keyword">if</span>(p[<span class="hljs-number">0</span>][i])&#123;<br>        dp[i]=<span class="hljs-number">0</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;i;j++)&#123; <span class="hljs-comment">//类似最长递增序列 需要预处理，i, j之间是否为回文， 预处理代码i为逆序，j为顺序</span><br>            <span class="hljs-keyword">if</span>(p[j+<span class="hljs-number">1</span>][i])&#123;<br>                dp[i]=<span class="hljs-built_in">min</span>(dp[i], dp[j]+<span class="hljs-number">1</span>);<span class="hljs-comment">//每一个被分割的子字符串都必须要为回文</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>&#125;<br><span class="hljs-keyword">return</span> dp[s_len<span class="hljs-number">-1</span>];<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="10-背包问题"><a href="#10-背包问题" class="headerlink" title="10. 背包问题"></a>10. 背包问题</h3><ul>
<li><p>比较难的例题：货物转移（lintcode-困难） 反向dp（求背包数最少）+滚动数组+额外条件</p>
<ul>
<li>相当于转为两个题：</li>
</ul>
<ol>
<li>从n个背包里面选择最少的背包使得背包容量大于等于sum（与选最大价值使得，重量小于sum相反）</li>
<li>假设1求出来的结果为m, 从n个背包里面选择m个背包使得转移最少–&gt;选出的n个背包里面包含货物最多（weight最大）<br>相当于在状态转移方程再加上了一个weight数组的更新，具体代码如下：<br>dp[i]表示使得容量达到i（大于等于i），选择的最少的背包；<br>weight[i]表示使得背包容量达到i（大于等于i），在选择的背包最少的前提下，背包里原本包含的货物最多。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=sum;j&gt;=<span class="hljs-number">1</span>;j--)&#123; <span class="hljs-comment">//0-1背包问题</span><br>            <span class="hljs-keyword">int</span> tmp=<span class="hljs-built_in">max</span>(j-b[i], <span class="hljs-number">0</span>);<br>            <span class="hljs-comment">// dp[j]=min(dp[tmp]+1, dp[j]); 实际上的状态转移</span><br>            <span class="hljs-keyword">if</span>(dp[j]&lt;dp[tmp]+<span class="hljs-number">1</span>)&#123;  <span class="hljs-comment">//拆分后的状态转移</span><br>                <span class="hljs-comment">// weight[j]=weight[tmp];</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dp[j]==dp[tmp]+<span class="hljs-number">1</span>)&#123;<br>                weight[j]=<span class="hljs-built_in">max</span>(weight[j], weight[tmp]+a[i]); <span class="hljs-comment">//背包数量一样，选择权重加起来更大的背包</span><br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dp[j]&gt;dp[tmp]+<span class="hljs-number">1</span>)&#123;<br>                dp[j]=dp[tmp]+<span class="hljs-number">1</span>;<br>                weight[j]=weight[tmp]+a[i];<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>扩展的有关于 分组背包的问题（），每个组k的数量还不一样<br>分组背包：每组物品有若干个，同一组内的物品最多只能选一个。（每组中物品不同，个数和体积都可能不一样）<br>多重背包: 有N种物品和一个容量为V 的背包。第i种物品最多有Mi件可用，每件耗费的空间是Ci ，价值是Wi (每组物品相同，且个数相等)</p>
<figure class="highlight c++"><figcaption><span>分组背包伪代码 和多重背包有点类似也是三重循环</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//注意这里是三层循环</span><br>    <span class="hljs-keyword">for</span> 所有的组k<br>        <span class="hljs-keyword">for</span> v=V to <span class="hljs-number">0</span><br>            <span class="hljs-keyword">for</span> 所有属于组k的i <br>            f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;<br>            end<br>        end<br>    end<br></code></pre></td></tr></table></figure>
<p>例题：lc2218. 从栈中取出 K 个硬币的最大面值和（hard）</p>
</li>
<li><p>使用前缀和+动态规划</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123; <span class="hljs-comment">//注意1-n, 之后piles在进行下标访问的时候需要i-1</span><br>    <span class="hljs-keyword">int</span> size=piles[i<span class="hljs-number">-1</span>].<span class="hljs-built_in">size</span>();<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">presum</span><span class="hljs-params">(piles[i<span class="hljs-number">-1</span>].size(), <span class="hljs-number">0</span>)</span></span>;<br>    presum[<span class="hljs-number">0</span>]=piles[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>];<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">1</span>;k&lt;size;k++)&#123;<br>        presum[k]=presum[k<span class="hljs-number">-1</span>]+piles[i<span class="hljs-number">-1</span>][k]; <span class="hljs-comment">//用前缀和表示选择前面z个</span><br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=k;j++)&#123;<br>        dp[i][j]=dp[i<span class="hljs-number">-1</span>][j];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> z=<span class="hljs-number">1</span>;z&lt;=size;z++)&#123; <span class="hljs-comment">//每组的size可能都不相同</span><br>            <span class="hljs-keyword">if</span>(j&gt;=z)&#123;<br>                dp[i][j]=<span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][j-z]+presum[z<span class="hljs-number">-1</span>], dp[i][j]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">return</span> dp[n][k];<br></code></pre></td></tr></table></figure></li>
<li><p>背包问题求具体的转移方案：我们可以用g_{i,v}表示第 i件物品占用空间为 v的时候是否选择了此物品。</p>
<figure class="highlight c++"><figcaption><span>(感觉应该是0-1背包的)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> v = V;  <span class="hljs-comment">// 记录当前的存储空间</span><br><span class="hljs-comment">// 因为最后一件物品存储的是最终状态，所以从最后一件物品进行循环</span><br><span class="hljs-keyword">for</span> (从最后一件循环至第一件) &#123;<br><span class="hljs-keyword">if</span> (g[i][v]) &#123;<br>    选了第 i 项物品;<br>    v -= 第 i 项物品的价值;<br>&#125; <span class="hljs-keyword">else</span><br>    未选第 i 项物品;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="11-换钱问题"><a href="#11-换钱问题" class="headerlink" title="11. 换钱问题"></a>11. 换钱问题</h3><p>零钱兑换II：一定要注意虽然每个硬币都有无数个，但是不能出现重复，也就是 121  112这种情况，所以硬币的循环一定要放在最外层</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;coins.<span class="hljs-built_in">size</span>();i++)&#123;<span class="hljs-comment">//硬币放在最内层会发生错误</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;=amount;j++)&#123;<br>        <span class="hljs-keyword">if</span>(j&gt;=coins[i])&#123;<br>                dp[j]=dp[j]+dp[j-coins[i]];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="12-通配符匹配问题（hard）-类似最短单词距离的动态转移"><a href="#12-通配符匹配问题（hard）-类似最短单词距离的动态转移" class="headerlink" title="12. 通配符匹配问题（hard） 类似最短单词距离的动态转移"></a>12. 通配符匹配问题（hard） 类似最短单词距离的动态转移</h3><ul>
<li>一定要注意动态规划的状态转移方程式是i j 从 i-k j-k转移过来，不能出现i+k j+k(如果出现，一定是枚举的长度，例如回文串和打气球问题)</li>
<li>易错点：<br>字符串的匹配问题，通常会在字符前面加上” “ dp[0][0]=1<br>同时如果i j从1开始取的话，需要初始化赋值dp[0][i] 和dp[i][0]</li>
</ul>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">corner case:<br>    <span class="hljs-attr">s</span> = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-attr">p</span> = <span class="hljs-string">&quot;******&quot;</span> <br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++">dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span><br><span class="hljs-comment">//下面这个循环是非常重要的</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;p_len;i++)&#123;<br>    <span class="hljs-keyword">if</span>(p[i]==<span class="hljs-string">&#x27;*&#x27;</span>)&#123;<br>        dp[<span class="hljs-number">0</span>][i]=dp[<span class="hljs-number">0</span>][i<span class="hljs-number">-1</span>]; <span class="hljs-comment">// or dp[0][i]=dp[0][i-1];</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;s_len;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;p_len;j++)&#123;<br>        <span class="hljs-keyword">if</span>(p[j]==<span class="hljs-string">&#x27;*&#x27;</span>)&#123;<br>            dp[i][j]=dp[i<span class="hljs-number">-1</span>][j]||dp[i][j<span class="hljs-number">-1</span>];<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(s[i]==p[j]||p[j]==<span class="hljs-string">&#x27;?&#x27;</span>)&#123;<br>                dp[i][j]=dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]; <br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                dp[i][j]=<span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>如果不好赋值dp[i][0] or dp[0][i] 可以让i j 从0开始取，但是在状态转移的时候注意进行j 或者i的判断 if j&gt;=1  dp[j-1]<ol>
<li>问题1：*可以匹配任意字符 </li>
<li>问题2：*只能匹配前面字符的0个1个或多个(正则表达式匹配) 需要判断s[i] p[j-1]是否相等</li>
</ol>
</li>
</ul>
<h3 id="13-打家劫舍"><a href="#13-打家劫舍" class="headerlink" title="13. 打家劫舍"></a>13. 打家劫舍</h3><ul>
<li>求能够得到金额的最大值。</li>
<li>环形可以转为dp[0][size-2]和dp[1][size-1]两者之中求最大值</li>
<li>类似的一道题：删除并获得点数（题意：选了nums[i]， 就不能选择nums[i-1] 和nums[i+1]， 打家劫舍这里的i, i+1是下标的， 这道题是实际数字上的。两个问题都是使用dp </li>
</ul>
<h3 id="14-整数拆分"><a href="#14-整数拆分" class="headerlink" title="14. 整数拆分"></a>14. 整数拆分</h3><ul>
<li>可以使用动态规划 二层循环 dp[i]= max(j*(i-j), j* dp[i-j])， 因为存在i-j &gt; dp[i-j]的情况</li>
<li>或者使用数据规划，将余数为2（2<em>） 1（4</em>） 0(3*)情况区别对待</li>
</ul>
<h3 id="15-最大整除子集"><a href="#15-最大整除子集" class="headerlink" title="15. 最大整除子集"></a>15. 最大整除子集</h3><ul>
<li>和最长递增序列有相似之处）</li>
<li>注意：在进行倒推序列的时候，需要记录当前的maxval 以及target_dpval, 这两者都需要在压入每个元素的时候更新</li>
<li>相邻两个数的商不一定相等</li>
</ul>
<h3 id="16-摆动序列-（序列最长问题）"><a href="#16-摆动序列-（序列最长问题）" class="headerlink" title="16.  摆动序列 （序列最长问题）"></a>16.  摆动序列 （序列最长问题）</h3><h3 id="17-无重叠区间"><a href="#17-无重叠区间" class="headerlink" title="17. 无重叠区间"></a>17. 无重叠区间</h3><ul>
<li>可以使用动态规划，找到以每个区间结尾的最长子序列（O(N^2)） 或者贪心，对区间右边进行排序然后选择 O(nlogn)</li>
</ul>
<h3 id="18-最后一块石头的重量-II"><a href="#18-最后一块石头的重量-II" class="headerlink" title="18. 最后一块石头的重量 II"></a>18. 最后一块石头的重量 II</h3><ul>
<li><p>需要理解题意之后转为背包问题，也就是最大最小问题</p>
</li>
<li><p>求两个子集相差的最小值 -&gt; 转为背包问题，背包容量是sum/2，求能够放入背包的最大数</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[j]</span>=max(dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[j]</span>, dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[j-stone<span class="hljs-comment">[i]</span>]</span>+stone<span class="hljs-comment">[i]</span>)<br></code></pre></td></tr></table></figure></li>
<li><p>0-1的最大背包问题，逆向枚举</p>
</li>
<li><p>多重背包问题也是，只能逆向枚举</p>
</li>
<li><p>完全背包（无限个）才是正向枚举！！！</p>
</li>
</ul>
<h3 id="19-乘积为正数的最长子数组长度-最长子数组系列题目"><a href="#19-乘积为正数的最长子数组长度-最长子数组系列题目" class="headerlink" title="19. 乘积为正数的最长子数组长度 (最长子数组系列题目)"></a>19. 乘积为正数的最长子数组长度 (最长子数组系列题目)</h3><ul>
<li>注意这道题是求最长的长度，不是最大的乘积，但是这两个问题都可以使用动态规划完成</li>
</ul>
<ol>
<li>最长的长度，positive[i]表示以i结尾的为正数的子数组，negtive[i] i结尾的为负数的子数组，<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span> (nums[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">0</span>) &#123;<br>    positive[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[<span class="hljs-number">0</span>] &lt; <span class="hljs-number">0</span>) &#123;<br>    negative[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">int</span> maxLength = positive[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; length; i++) &#123;<br>    <span class="hljs-keyword">if</span> (nums[i] &gt; <span class="hljs-number">0</span>) &#123;<br>        positive[i] = positive[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>        negative[i] = negative[i - <span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span> ? negative[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span> : <span class="hljs-number">0</span>; <span class="hljs-comment">//注意一定要和0判断</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] &lt; <span class="hljs-number">0</span>) &#123;<br>        positive[i] = negative[i - <span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span> ? negative[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        negative[i] = positive[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        positive[i] = <span class="hljs-number">0</span>;<br>        negative[i] = <span class="hljs-number">0</span>;<br>    &#125;<br>    maxLength = Math.<span class="hljs-built_in">max</span>(maxLength, positive[i]);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>我的思路：转为前缀和+hash<br>  题意转为：负数为1，正数为0， 0单独处理，相加和为偶数的最长子数组<br>  如果&lt;0, 那么sum+=1；<br>  如果&gt;0, 那么sum不变；<br>  如果=0, 那么sum=0，  hash.clear(), hash[0]=i；<br>  如果sum为偶数：<br>  res=max(res, i-hash[0])<br>  如果sum为奇数：<br>  如果hash[1]存在<br>  res=max(res, i-hash[1])<br>  否则hash[1]=i;</li>
</ul>
<ol start="2">
<li>最大乘积（可能为负数），dp1[i]表示以i结尾乘积最大子数组，dp2[i]的乘积最小(注意不一定为负数)的子数组<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=size;i++)&#123;<br>    <span class="hljs-keyword">if</span>(nums[i<span class="hljs-number">-1</span>]&gt;<span class="hljs-number">0</span>)&#123;<br>        dp1[i]=<span class="hljs-built_in">max</span>(dp1[i<span class="hljs-number">-1</span>]*nums[i<span class="hljs-number">-1</span>], nums[i<span class="hljs-number">-1</span>]);<br>        dp2[i]=<span class="hljs-built_in">min</span>(dp2[i<span class="hljs-number">-1</span>]*nums[i<span class="hljs-number">-1</span>], nums[i<span class="hljs-number">-1</span>]);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[i<span class="hljs-number">-1</span>]&lt;<span class="hljs-number">0</span>)&#123;<br>        dp1[i]=<span class="hljs-built_in">max</span>(dp2[i<span class="hljs-number">-1</span>]*nums[i<span class="hljs-number">-1</span>], nums[i<span class="hljs-number">-1</span>]);<br>        dp2[i]=<span class="hljs-built_in">min</span>(dp1[i<span class="hljs-number">-1</span>]*nums[i<span class="hljs-number">-1</span>], nums[i<span class="hljs-number">-1</span>]);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        dp1[i]=<span class="hljs-number">0</span>;<br>        dp2[i]=<span class="hljs-number">0</span>;<br>    &#125;<br>    res=<span class="hljs-built_in">max</span>(res, dp1[i]);<br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="20-最低票价"><a href="#20-最低票价" class="headerlink" title="20. 最低票价"></a>20. 最低票价</h3><ul>
<li><p>找到能够让days天都观光的最低票价，类似完全背包问题， 最少兑换钞票</p>
</li>
<li><p>dp[i]定义为至少让index==i天观光所需要的最低票价， 分别遍历决策1，决策2， 决策3需要的最低票价</p>
</li>
<li><p>solution 1：每天进行dp + 从后往前</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> len = days.length, maxDay = days[len - <span class="hljs-number">1</span>], minDay = days[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[maxDay + <span class="hljs-number">31</span>]; <span class="hljs-comment">// 多扩几天，省得判断 365 的限制</span><br><span class="hljs-comment">// 只需看 maxDay -&gt; minDay，此区间外都不需要出门，不会增加费用</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> d = maxDay, i = len - <span class="hljs-number">1</span>; d &gt;= minDay; d--) &#123;<br>    <span class="hljs-comment">// i 表示 days 的索引</span><br>    <span class="hljs-comment">// 也可提前将所有 days 放入 Set，再通过 set.contains() 判断</span><br>    <span class="hljs-keyword">if</span> (d == days[i]) &#123;<br>        dp[d] = Math.<span class="hljs-built_in">min</span>(dp[d + <span class="hljs-number">1</span>] + costs[<span class="hljs-number">0</span>], dp[d + <span class="hljs-number">7</span>] + costs[<span class="hljs-number">1</span>]); <span class="hljs-comment">//三种情况</span><br>        dp[d] = Math.<span class="hljs-built_in">min</span>(dp[d], dp[d + <span class="hljs-number">30</span>] + costs[<span class="hljs-number">2</span>]);<br>        i--; <span class="hljs-comment">// 别忘了递减一天</span><br>    &#125; <span class="hljs-keyword">else</span> dp[d] = dp[d + <span class="hljs-number">1</span>]; <span class="hljs-comment">// 不需要出门</span><br>&#125;<br><span class="hljs-keyword">return</span> dp[minDay]; <span class="hljs-comment">// 从后向前遍历，返回最前的 minDay</span><br></code></pre></td></tr></table></figure></li>
<li><p>solution 2：只从days包含的天数进行dp + 从前往后</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> valid[<span class="hljs-number">3</span>]=&#123;<span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">30</span>&#125;;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>    dp[i]=INT_MAX;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>        <span class="hljs-keyword">if</span>(days[i]-valid[j]&lt;days[<span class="hljs-number">0</span>])&#123;<br>            dp[i]=<span class="hljs-built_in">min</span>(dp[i], costs[j]); <br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">int</span> index=<span class="hljs-built_in">upper_bound</span>(days.<span class="hljs-built_in">begin</span>(), days.<span class="hljs-built_in">end</span>(), days[i]-valid[j])-days.<span class="hljs-built_in">begin</span>();<br>            <span class="hljs-comment">//找到对应的前面天数对应的下标</span><br>            <span class="hljs-comment">// cout&lt;&lt;index&lt;&lt;endl;</span><br>            dp[i]=<span class="hljs-built_in">min</span>(dp[index<span class="hljs-number">-1</span>]+costs[j], dp[i]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="21-lc1186-删除一次得到子数组最大和"><a href="#21-lc1186-删除一次得到子数组最大和" class="headerlink" title="21. lc1186. 删除一次得到子数组最大和"></a>21. lc1186. 删除一次得到子数组最大和</h3><ul>
<li>最大连续和的变形题目：得到最大的连续和之后，可以选择删除序列的一个数，或者选择不删除</li>
<li>使用动态规划：记录到index i的两种状态：1. 执行了删除操作的最大值 2. 没有执行删除操作的最大值<br>所以得到的状态转移方程就是:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> a=arr[<span class="hljs-number">0</span>]; <span class="hljs-comment">//未执行删除得到的最大值</span><br><span class="hljs-keyword">int</span> b=<span class="hljs-number">0</span>;<span class="hljs-comment">//已经执行删除得到的最大值</span><br><span class="hljs-keyword">int</span> res=arr[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span> 到 size<br>b=<span class="hljs-built_in">max</span>(b+arr[i], a);<br>a=<span class="hljs-built_in">max</span>(a+arr[i], arr[i]);<br>res=<span class="hljs-built_in">max</span>(res, a);<br>res=<span class="hljs-built_in">max</span>(res, b);<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="数学相关问题（找规律）"><a href="#数学相关问题（找规律）" class="headerlink" title="数学相关问题（找规律）"></a>数学相关问题（找规律）</h2><h3 id="1-计算各个位数不同的数字个数"><a href="#1-计算各个位数不同的数字个数" class="headerlink" title="1. 计算各个位数不同的数字个数"></a>1. 计算各个位数不同的数字个数</h3><ul>
<li>其实就是9* 9 * 8* 7这种情况）但是要注意是n位数以内的n位数都需要计算，开始各位数有10种情况，后面在当前数插入数据的时候，最开头有9种情况，后面数据有（10-1）种情况，因为后面的数据是可以为0的（固定前面，枚举后面）</li>
</ul>
<h3 id="2-消除游戏-和约瑟夫环问题"><a href="#2-消除游戏-和约瑟夫环问题" class="headerlink" title="2. 消除游戏 和约瑟夫环问题"></a>2. 消除游戏 和约瑟夫环问题</h3><ul>
<li><p>解决方案一：使用之后的下标和之前下标的映射 来解决（删除后，末尾从1开始编号）<br>2 ~ 2k映射为k ~ 1那么还原的规律f(2k)=2*(k+1-f(k))</p>
</li>
<li><p>解决方案二：每次记录剩下链表的头结点，如果当前剩下的个数==1那么直接返回这个数</p>
</li>
<li><p>约瑟夫环递推问题的公式</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">𝑓(𝑛)=(𝑓(𝑛−<span class="hljs-number">1</span>)+𝑚)%𝑛  （一共n个人，数到m的人被杀）<br>def last<span class="hljs-constructor">Remaining(<span class="hljs-params">n</span>, <span class="hljs-params">m</span>)</span>:<br>    <span class="hljs-keyword">if</span> n<span class="hljs-operator"> == </span><span class="hljs-number">1</span>: return <span class="hljs-number">0</span><br>    return (last<span class="hljs-constructor">Remaining(<span class="hljs-params">n</span>-1, <span class="hljs-params">m</span>)</span> + m) % n<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-第-N-位数字（一位）"><a href="#3-第-N-位数字（一位）" class="headerlink" title="3. 第 N 位数字（一位）"></a>3. 第 N 位数字（一位）</h3><ul>
<li><p>题意： 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,顺序排列后的第n位数字</p>
</li>
<li><p>找到不同位数包含的数字number= base*10-base,如果n&gt;这个数那么更新n-=number * weishu,否则就在这个位数里面查找</p>
</li>
<li><p>如果当前的数%位数==0，那么当前的数字是cur_num=base+n/weishu-1, 否则当前的数字为cur_num=base+n/weishu，然后计算在当前数字里面对应具体哪个数字， 为(cur_num/pow(10, weishu-n%weishu))%10</p>
</li>
<li><p>扩展：还有一个排序后的数 （一个数）二叉树，求两个节点直接夹的数组，类似于上面这道题base* 10的操作，如果小于，那么就往二叉树的下一层节点走（a=a<em>10, b=b</em>10, 知道a大于n, 退出向下搜索的循环）</p>
</li>
</ul>
<h3 id="4-灯泡开关-灯泡开关II"><a href="#4-灯泡开关-灯泡开关II" class="headerlink" title="4. 灯泡开关/灯泡开关II"></a>4. 灯泡开关/灯泡开关II</h3><ul>
<li>主要是找到规律前6个灯泡可以推导出其他灯泡的状态，更进一步是，前三个灯可以推导后面所有的状态，因此有状态16种</li>
<li>只需要枚举每个灯泡的每种状态(为0或者为1)就可以了因此是16种情况，用4位表示； 1的数量num num&lt; m， 而且num%2 == m%2</li>
<li>同时要注意可能灯泡小于6， 因此需要shift=max(6-n, 0)</li>
<li>然后再将每个状态异或起来就可以了<br>（找规律，但不是动态规划问题）</li>
</ul>
<h3 id="5-到达终点数字"><a href="#5-到达终点数字" class="headerlink" title="5. 到达终点数字"></a>5. 到达终点数字</h3><ul>
<li>左右走，步数为1， 2， 3，…。也是属于找规律，但是不是动态规划的问题 </li>
<li>找到连加中大于target的最小sum(cur=k),然后求delta=sum-target,如果为奇数那么k++, 直到为delta偶数 (那么就可以减去delta/2)，然后返回当前k值</li>
</ul>
<h3 id="6-子矩阵问题-lintcode"><a href="#6-子矩阵问题-lintcode" class="headerlink" title="6. 子矩阵问题(lintcode)"></a>6. 子矩阵问题(lintcode)</h3><ol>
<li><p>第一种题型，要求矩阵内部的元素全部为1，那么以i， j为右下角的最长矩阵边长为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span>(matrix[i][j]==<span class="hljs-number">1</span>)&#123;<br>    dp[i][j]=<span class="hljs-built_in">min</span>(dp[i][j<span class="hljs-number">-1</span>], dp[i<span class="hljs-number">-1</span>][j], dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>])+<span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>那么以 i， j为右下角的子矩阵的个数为dp[i][j]个</p>
</li>
<li><p>要求矩形框最长, 那么每个点需要为何它上面最长 up，和左边最长 left， 两个数组</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> tmp = <span class="hljs-built_in">min</span>(left[i][j<span class="hljs-number">-1</span>], up[i<span class="hljs-number">-1</span>][j])+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> len=tmp<span class="hljs-number">-1</span>;len&gt;=<span class="hljs-number">1</span>;len--)&#123; <span class="hljs-comment">//枚举长度，使得4个边长都是在len之内，说明能围成一个框</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">min</span>(up[i][j-len], left[i-len][j])&gt;=len)&#123;<br>        <span class="hljs-keyword">return</span> len+<span class="hljs-number">1</span>;<span class="hljs-comment">//返回枚举得到的最长边框</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="7-捡苹果-lintcode"><a href="#7-捡苹果-lintcode" class="headerlink" title="7. 捡苹果(lintcode) "></a><font color="red">7. 捡苹果(lintcode) </font></h3><ul>
<li>前后缀问题(找两个区间，一个区间连续k个数，一个区间连续l个数，两个区间不相交且和最大)</li>
<li>solution: 枚举中间的划分点i,使得<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">res=<span class="hljs-built_in">max</span>(res, presumK[i]+postsumL[i+<span class="hljs-number">1</span>])<br>res=<span class="hljs-built_in">max</span>(res, presumL[i]+postsumK[i+<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure></li>
<li>思路没问题：主要是没有找打0<del>i之前连续窗口最大值与i</del>len-1 连续窗口的最大值怎么求</li>
<li>计算前缀和后缀数组，注意如果index转为1~size，那么后缀数组需要开size+2 !!!!<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=K;i&lt;=size;i++)&#123;<br>    presumK[i]=<span class="hljs-built_in">max</span>(presum[i]-presum[i-K], presumK[i<span class="hljs-number">-1</span>]);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=L;i&lt;=size;i++)&#123;<br>    presumL[i]=<span class="hljs-built_in">max</span>(presum[i]-presum[i-L], presumL[i<span class="hljs-number">-1</span>]);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=size-K+<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">1</span>;i--)&#123;<br>    postsumK[i]=<span class="hljs-built_in">max</span>(presum[i+K<span class="hljs-number">-1</span>]-presum[i<span class="hljs-number">-1</span>], postsumK[i+<span class="hljs-number">1</span>]);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=size-L+<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">1</span>;i--)&#123;<br>    postsumL[i]=<span class="hljs-built_in">max</span>(presum[i+L<span class="hljs-number">-1</span>]-presum[i<span class="hljs-number">-1</span>], postsumL[i+<span class="hljs-number">1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="8-钢笔和"><a href="#8-钢笔和" class="headerlink" title="8. 钢笔和"></a>8. 钢笔和</h3><ul>
<li>题意：找到两个不相交的区间，每个区间和都为target, 使得这两个区间len之和最小，其实也可以向上一题一样，分为pre post,然后枚举划分点，使用分治算法进行计算</li>
</ul>
<h3 id="9-可被三整除的最大和-这道题和lc1363-形成3的最大倍数是一样的思路"><a href="#9-可被三整除的最大和-这道题和lc1363-形成3的最大倍数是一样的思路" class="headerlink" title="9. 可被三整除的最大和 这道题和lc1363 形成3的最大倍数是一样的思路"></a>9. 可被三整除的最大和 这道题和lc1363 形成3的最大倍数是一样的思路</h3><ul>
<li><p>不要求是连续</p>
</li>
<li><p>使用余数的递归公式 dp[i][j]表示以i结尾的余数为j的最大和</p>
</li>
<li><p>那么就要根据nums[i]%3的余数分类别更新dp[i][0], dp[i][1], dp[i][2]</p>
</li>
<li><p>一个更简单的方法是 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++">a=remainder[<span class="hljs-number">0</span>]+nums[i]; <br>b=remainder[<span class="hljs-number">1</span>]+nums[i];<br>c=remainder[<span class="hljs-number">2</span>]+nums[i];<span class="hljs-comment">//因为可以不连续</span><br>remainder[a%<span class="hljs-number">3</span>]=<span class="hljs-built_in">max</span>(remainder[a%<span class="hljs-number">3</span>], a);<span class="hljs-comment">//a对余数就是a%3,所以分在一组</span><br>remainder[b%<span class="hljs-number">3</span>]=<span class="hljs-built_in">max</span>(remainder[b%<span class="hljs-number">3</span>], b);<br>remainder[c%<span class="hljs-number">3</span>]=<span class="hljs-built_in">max</span>(remainder[c%<span class="hljs-number">3</span>], c);<br></code></pre></td></tr></table></figure></li>
<li><p>PS: 类似的一个题：将字符串翻转到单调递增<br>dp[i][0]表示前i个数以0结尾，dp[i][0]表示前i个数以1结尾<br>易错点：dp[i][1]=min(dp[i-1][0], dp[i-1][1]) //以1结尾的时候，前面以0结尾是不需要+1的</p>
</li>
</ul>
<h3 id="10-lc1594-矩阵的最大非负积"><a href="#10-lc1594-矩阵的最大非负积" class="headerlink" title="10. lc1594. 矩阵的最大非负积"></a>10. lc1594. 矩阵的最大非负积</h3><ul>
<li>有负数的最后最大题型+结果需要取余</li>
<li>因为有负数，所以需要记录每个位置的最大和最小值，而不只是最大值</li>
<li>负数取余会变正，所以一定要注意 在最后取余，同时为了防止中间数溢出，需要使用long long类型的数据</li>
</ul>
<h3 id="11-lc1621-大小为-K-的不重叠线段的数目"><a href="#11-lc1621-大小为-K-的不重叠线段的数目" class="headerlink" title="11. lc1621. 大小为 K 的不重叠线段的数目"></a>11. lc1621. 大小为 K 的不重叠线段的数目</h3><ul>
<li> 通过状态转移方程多加入一维，就可以减少三重循环为两重循环的例子</li>
<li>dp[i][j][0] 表示第 j 条线段的右端点不是 i，也就是说我们没有办法继续延长第 j 条线段；<br>  dp[i][j][1] 表示第 j条线段的右端点就是 i，也就是说我们可以选择是否继续延长第 j条线段。<br>  dp[i][j][1]= dp[i-1][j][1] 就表示当前线和之前线连在一起，</li>
</ul>
<p>也就是延长之前的线，那么就不用第三重训练来遍历起点</p>
<h2 id="博弈论相关问题"><a href="#博弈论相关问题" class="headerlink" title="博弈论相关问题"></a>博弈论相关问题</h2><h3 id="1-石子问题"><a href="#1-石子问题" class="headerlink" title="1. 石子问题"></a>1. 石子问题</h3><h3 id="2-预测家"><a href="#2-预测家" class="headerlink" title="2. 预测家"></a>2. 预测家</h3><ul>
<li>当前只能从石子序列的头或者尾部进行取，那么使用枚举长度的动态规划+前缀和 （区dp） 注意这道题和lc1423. 可获得的最大点数 不一样因为这个是一定要拿完，而且有两个人拿，而lc1423是一个人拿，所以使用滑动窗口解决 n-k的窗口内数据最小就行</li>
</ul>
<h3 id="3-能赢吗"><a href="#3-能赢吗" class="headerlink" title="3. 能赢吗"></a>3. 能赢吗</h3><ul>
<li>因为是从1-n中随机取，而且取了之后就不能取了，所以使用带记忆的dfs, 使用位图来记录当前状态是否遍历过 dp[state]</li>
</ul>
<h2 id="字符串与动态规划"><a href="#字符串与动态规划" class="headerlink" title="字符串与动态规划"></a>字符串与动态规划</h2><p>也可以划分到Trie树问题:一般是对单词建立Trie树</p>
<h3 id="1-单词拆分问题"><a href="#1-单词拆分问题" class="headerlink" title="1. 单词拆分问题"></a>1. 单词拆分问题</h3><ul>
<li>dp代表的是True or False</li>
<li>dp+第二层循环枚举字典里面的每一个单词，看是否恰好是当前遍历序列0~i的最后几个字符<br>为了进一步减少时间，内层训练从i枚举到0，同时为true的时候直接退出<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;size;i++)&#123; <span class="hljs-comment">//遍历字符串的每一个字符</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i;j&gt;=<span class="hljs-number">0</span>;j--)&#123;<br>        string tmp=s.<span class="hljs-built_in">substr</span>(j, i-j+<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span>(wordSet.<span class="hljs-built_in">find</span>(tmp)!=wordSet.<span class="hljs-built_in">end</span>())&#123;<br>            dp[i]=dp[i]|dp[j<span class="hljs-number">-1</span>];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(dp[i])&#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br>方法二：<br>以当前判断后面的字符串<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=s.<span class="hljs-built_in">size</span>();i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;wordDict.<span class="hljs-built_in">size</span>();j++)&#123;<br>        <span class="hljs-keyword">if</span>(!dp[i])&#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        string tmp=s.<span class="hljs-built_in">substr</span>(i,wordDict[j].<span class="hljs-built_in">size</span>());<br>        <span class="hljs-keyword">if</span>(tmp==wordDict[j])&#123;<br>            dp[i+wordDict[j].<span class="hljs-built_in">size</span>()]=<span class="hljs-literal">true</span>;<br>        <br>            path[i].<span class="hljs-built_in">push_back</span>(i+wordDict[j].<span class="hljs-built_in">size</span>());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<font color="red">单词拆分II需要求出所有可行的解</font><br>为了避免重复的计算和对比，字符串的前缀是否包含单词表里面的单词，需要使用单词拆分1的方法将i后面对应的true的下标放在hash&lt;int, vector&gt;里面记录起来，这样之后再进行遍历的时候就不需要重复判断；<br>另外一个去处回溯的重复方案是， 将一个下标后面的字符串对应的可以拆分方案提前记录起来（hash&lt;int, vector&lt;vector<int>&gt;），这样的话，就不用对同一下标进行多次重复求值（类似于二叉树的组成类似的）</int></li>
</ul>
<h3 id="2-恢复空格问题-代表的无效字符的个数-使用Trie树的经典案例"><a href="#2-恢复空格问题-代表的无效字符的个数-使用Trie树的经典案例" class="headerlink" title="2. 恢复空格问题(代表的无效字符的个数)- 使用Trie树的经典案例 "></a><font color="red">2. 恢复空格问题(代表的无效字符的个数)- 使用Trie树的经典案例 </font></h3><ul>
<li>都可以转为Trie树+dp类型的题目 </li>
<li>这个不能暴力erase,因为可能出现一个单词是另外一个单词的前缀，可能导致erase顺序不同，结果不同；这个只能使用字典序；</li>
<li>另外一个减少暴力深搜索带来的超时问题，可以使用第二层循环每次枚举dict的每个元素，看是否与当前遍历序列的最后几个字符相同，而不是每个不同长度的单词一个一个的进行比较。</li>
<li>多次搜索：使用暴力的string find或者使用将small单词列表建立Trie树，然后big以每个字符为开头，查找字符串是否出现在Trie树中，在查找的路径中如果遇到isend=True说明找到了一个字符<br>然后继续找下去</li>
</ul>
<h3 id="3-环绕字符串中唯一的子字符串"><a href="#3-环绕字符串中唯一的子字符串" class="headerlink" title="3. 环绕字符串中唯一的子字符串"></a>3. 环绕字符串中唯一的子字符串</h3><ul>
<li>题意为：找到子串字符必须是连续的，这样的子串的个数，但是这样可以会出现重复比如abcbc，所以要使用dp (其实就是hash，记录以某个字符结尾的最长的子串)</li>
<li>计算出26个英文字母中每一个英文字母的结尾的最长的连续的环绕字符串，然后求和</li>
<li>PS：注意字符串去重，如果不考虑去重的话，可以直接使用滑动窗口记录子串个数；因为这个滑动窗口是直接出现不连续，窗口长度直接退化为1，所以可以只记录窗口长度，不记录窗口左右两端</li>
</ul>
<h3 id="4-lc97-交错字符串"><a href="#4-lc97-交错字符串" class="headerlink" title="4. lc97. 交错字符串"></a>4. lc97. 交错字符串</h3><ul>
<li>求第三个字符串是否能由第一个和第二个字符串组合得到，是否问题</li>
<li>易错点：不能使用双指针，因为针对一个两个字符串相同的情况可能造成错误</li>
<li>使用动态规划，dp[i][j]表示字符串1的前i个字符和字符串1的前j个字符能否组成第三个字符串的i+j个字符</li>
</ul>
<h3 id="5-最长公共前缀（lcp）"><a href="#5-最长公共前缀（lcp）" class="headerlink" title="5. 最长公共前缀（lcp）"></a>5. 最长公共前缀（lcp）</h3><p><code>dp[i][j]</code>表示从下标 i开始的子字符串 <code>s[i:]</code>和以下标 j 开始的子字符串 <code>s[j] </code>的最长公共前缀的长度。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=n<span class="hljs-number">-1</span>;j&gt;=<span class="hljs-number">0</span>;j++)&#123;<br>        <span class="hljs-keyword">if</span>(s[i]==s[j])&#123;<br>            dp[i][j]=dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            dp[i][j]=<span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="状态压缩"><a href="#状态压缩" class="headerlink" title="状态压缩"></a>状态压缩</h2><h3 id="1-划分为k个相同子集，也可以看做dfs-回溯-贪心"><a href="#1-划分为k个相同子集，也可以看做dfs-回溯-贪心" class="headerlink" title="1. 划分为k个相同子集，也可以看做dfs+回溯+贪心"></a>1. 划分为k个相同子集，也可以看做dfs+回溯+贪心</h3><ul>
<li>状态压缩的话就是dp[i]中i的每一个数由二进制位的状态组成，然后遍历二进制的每一个状态，当前的状态可以由当前状态中任意取消一个1的状态转移过来，或者用当前的状态更新下一个状态（将状态中为0的转为1），只有只有dp[i]=true, 而且当前状态的和%target+nums[i]&lt;=target下一个状态才为true,否则为false<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">canPartitionKSubsets</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> size=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">int</span> total_sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>            total_sum+=nums[i];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(total_sum%k!=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> target=total_sum/k;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">int</span> total_state=<span class="hljs-number">1</span>&lt;&lt;size;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(total_state, <span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sum</span><span class="hljs-params">(total_state, <span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>]=<span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;total_state;i++)&#123;<br>            <span class="hljs-keyword">if</span>(!dp[i])&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">// cout&lt;&lt;i&lt;&lt;endl;</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;size;j++)&#123;<br>                <span class="hljs-comment">// cout&lt;&lt;j&lt;&lt;endl;</span><br>                <span class="hljs-keyword">if</span>((i&amp;(<span class="hljs-number">1</span>&lt;&lt;j))==<span class="hljs-number">0</span>)&#123;   <span class="hljs-comment">//注意：位运算一定要记得打上括号之后再判断是否相等，否则会出错！！！！！</span><br>                    <span class="hljs-keyword">int</span> next=i|(<span class="hljs-number">1</span>&lt;&lt;j);<br>                    <span class="hljs-comment">// cout&lt;&lt;next&lt;&lt;endl;</span><br>                    <span class="hljs-keyword">if</span>(sum[i]%target+nums[j]&lt;=target)&#123;<br>                        sum[next]=sum[i]+nums[j];<br>                        dp[next]=<span class="hljs-literal">true</span>;<br>                        cout&lt;&lt;next&lt;&lt;endl;<br>                    &#125;<span class="hljs-keyword">else</span>&#123;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[total_state<span class="hljs-number">-1</span>];<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-优美的排列"><a href="#2-优美的排列" class="headerlink" title="2. 优美的排列"></a>2. 优美的排列</h3><ul>
<li>也是状态压缩 或者回溯，相比第2题需要枚举当前位置放的数是哪个，所以多一层循环。上面那道题因为数的位置是固定的，所以只需要判断这个数放没放。</li>
<li>其实还是顺序放，当前放了m个，那么下一个要放的数就是m+1， 所以也可以不同像下面的题解一样多一层循环（3月8日修改）<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-class"><span class="hljs-title">public</span>:</span><br>    <span class="hljs-built_in">int</span> count(<span class="hljs-built_in">int</span> number)&#123;<br>        <span class="hljs-built_in">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(number!=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>(number&amp;<span class="hljs-number">1</span>)&#123;<br>                res++;<br>            &#125;<br>            number=number&gt;&gt;<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-built_in">int</span> countArrangement(<span class="hljs-built_in">int</span> n) &#123;<br>        <span class="hljs-built_in">int</span> state=<span class="hljs-number">1</span>&lt;&lt;n;<br>        <br>        vector&lt;<span class="hljs-built_in">int</span>&gt; dp(state, <span class="hljs-number">0</span>);<br>        dp[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> num=<span class="hljs-number">1</span>;num&lt;=n;num++)&#123; //类似背包的，当前放第num数， 标准答案是将状态放在外层， 然后通过<span class="hljs-number">1</span>个个数判断当前的num<br>            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;state;i++)&#123;<br>                // <span class="hljs-keyword">if</span>(!dp[i])&#123;<br>                //     <span class="hljs-keyword">continue</span>;<br>                // &#125;<br>                <span class="hljs-keyword">if</span>(count(i)!=num-<span class="hljs-number">1</span>)&#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>                    <span class="hljs-keyword">if</span>((i&amp;(<span class="hljs-number">1</span>&lt;&lt;j))==<span class="hljs-number">0</span>)&#123;<br>                        <span class="hljs-keyword">if</span>(num%(j+<span class="hljs-number">1</span>)==<span class="hljs-number">0</span>||(j+<span class="hljs-number">1</span>)%num==<span class="hljs-number">0</span>)&#123;<br>                            <span class="hljs-built_in">int</span> <span class="hljs-built_in">next</span>=i^(<span class="hljs-number">1</span>&lt;&lt;j);<br>                            dp[<span class="hljs-built_in">next</span>]+=dp[i];<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[state-<span class="hljs-number">1</span>];<br>        <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-华为的一个机试题目"><a href="#3-华为的一个机试题目" class="headerlink" title="3. 华为的一个机试题目"></a>3. 华为的一个机试题目</h3><ul>
<li><p>需要在规定燃油内（规定长度内）得到的资源最大化（有点像0-1背包问题）， 但是这个不同之处在于：从不同点到相同的i，消耗的燃油是不一样的， 而且这个最后还需要回到原点，所以dist需要走过的位置mask 以及最后的位置i</p>
</li>
<li><p>其实就是先求每个mask的最小dist, 得到d[mask][i]:也就是以i结尾的最小燃油，然后遍历这个数组，如果d[mask][i]+fuel[i][0]&lt;=maxdist 那么更新ans<br>ans=max(ans, g[mask])</p>
</li>
<li><p>为什么不直接求d[fuel][i]的最大化，这样也会重复vis统一节点<br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/circle/discuss/a4pRYY/">https://leetcode-cn.com/circle/discuss/a4pRYY/</a></p>
</li>
</ul>
<h3 id="4-访问所有节点的最短路径-hard"><a href="#4-访问所有节点的最短路径-hard" class="headerlink" title="4. 访问所有节点的最短路径(hard)"></a>4. 访问所有节点的最短路径(hard)</h3><ul>
<li>题意：一笔走完所有的节点，注意可能重复访问同一个节点</li>
<li>主要思路：<br>先求出任意两个节点间的距离，使用floyd，同时记得出事dist[i][i]=0<br>然后使用d[mask][i]:表示最后状态为mask,并且以i结尾的最短路径<br>最后遍历d[mask][i] 求最小值</li>
<li>易错点，mask的循环一定要在节点i的循环的外面， 否则就会出错<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> mask=<span class="hljs-number">1</span>;mask&lt;(<span class="hljs-number">1</span>&lt;&lt;n);mask++)&#123;<br>          <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>              <span class="hljs-keyword">if</span> (mask &amp; (<span class="hljs-number">1</span> &lt;&lt; i)) &#123; <span class="hljs-comment">//如果i这个点已经被选过</span><br>                  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;n;k++)&#123;<br>                      <span class="hljs-keyword">if</span>((mask&amp;(<span class="hljs-number">1</span>&lt;&lt;k))==<span class="hljs-number">0</span>)&#123;<br>                          d[mask|(<span class="hljs-number">1</span>&lt;&lt;k)][k]=<span class="hljs-built_in">min</span>(d[mask|(<span class="hljs-number">1</span>&lt;&lt;k)][k],d[mask][i]+dist[i][k]); <span class="hljs-comment">//需要先使用floy求出任意两点之间的最短距离</span><br>                      &#125;<br>                  &#125;<br>              &#125;<br>          &#125;<br>      &#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-基于陈述统计最多好人数"><a href="#5-基于陈述统计最多好人数" class="headerlink" title="5. 基于陈述统计最多好人数"></a>5. 基于陈述统计最多好人数</h3><ul>
<li>这个是枚举状态（二进制），与dp无关，但是和状态压缩dp有点类似</li>
</ul>
<h3 id="6-两个数组最小的异或值之和-lc2172：-数组的最大与和"><a href="#6-两个数组最小的异或值之和-lc2172：-数组的最大与和" class="headerlink" title="6. 两个数组最小的异或值之和  / lc2172： 数组的最大与和 "></a>6. 两个数组最小的异或值之和  / <font color="red">lc2172： 数组的最大与和 </font></h3><ul>
<li>这两道题都是位运算相关的状态压缩<br>第一题枚举nums2每个数应该放的位置<br>第二题需要先装为状态压缩的样子，因为每个index有两个slot,所以需要先转为2*n个slot，那么slot和index对应关系为j/2+1<br>然后枚举每个数应该放在哪个slot,同时注意这道题不是每个状态都有值，对于one_num of state i&gt;=num数量, 直接continue</li>
<li>一个位可以放两个数的情况，需要展开分别讨论<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-number">1</span> &lt;&lt; (numSlots * <span class="hljs-number">2</span>))</span></span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; f.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>    <span class="hljs-keyword">int</span> c = __builtin_popcount(i); <span class="hljs-comment">//当前已经放了几个数，下一个放的数就是nums[c]</span><br>    <span class="hljs-keyword">if</span> (c &gt;= nums.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">//直接跳过</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; numSlots * <span class="hljs-number">2</span>; ++j) &#123;<br>        <span class="hljs-keyword">if</span> ((i &amp; (<span class="hljs-number">1</span> &lt;&lt; j)) == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 枚举空篮子 j</span><br>            <span class="hljs-keyword">int</span> s = i | (<span class="hljs-number">1</span> &lt;&lt; j);<br>            f[s] = <span class="hljs-built_in">max</span>(f[s], f[i] + ((j / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>) &amp; nums[c]));<br>            ans = <span class="hljs-built_in">max</span>(ans, f[s]); <span class="hljs-comment">//有效的状态求结果</span><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="7-状态压缩的二分查找方法"><a href="#7-状态压缩的二分查找方法" class="headerlink" title="7. 状态压缩的二分查找方法"></a>7. 状态压缩的二分查找方法</h3><p>lc805. 数组的均值分割</p>
<ul>
<li>30个元素进行状态压缩枚举可能会超时,因为转为两个集合，分别状态压缩，然后进行排序后，使用双指针查找和为0的组合是否存在<ol>
<li>通过公式推导可以得到需要找到k个元素，他们的平均值是整个数组的平均值，将每个元素-avg,那就是找k个数加起来和为0</li>
<li>本来是暴力枚举，但是因为30个元素可能超时间，所以使用二分枚举</li>
<li>二分枚举先各自判断是否有和为0的情况（一定要记得删除不包含任何元素的状态压缩这种情况），再删除掉一个元素不包括和包括所有元素的情况</li>
<li>最后使用双指针查找和为0的组合</li>
</ol>
</li>
</ul>
<h2 id="动态规划-拓扑排序"><a href="#动态规划-拓扑排序" class="headerlink" title="动态规划 + 拓扑排序"></a>动态规划 + 拓扑排序</h2><h3 id="1-并行课程III"><a href="#1-并行课程III" class="headerlink" title="1. 并行课程III"></a>1. 并行课程III</h3><p>题意：可能具有拓扑结构+每节课程都有上课时间， 任意两节不依赖课程可以同时上，求最短上完所有课程的时间<br>转化：拓扑排序的最长路径<br>两种解决方案：</p>
<ul>
<li>转为dfs，建立依赖关系的时候反向建立，然后将度为0的点放入队列之中（root）,dfs求深度，然后多棵树取最长深度</li>
<li>使用拓扑排序，将度为0的点放入队列，同时每次在取出队列中的点的时候，用当前点的结果f[v]更新v后面所有后修课程的结果<br>f[w]=max(f[w], f[v]+time[v])</li>
</ul>
<h2 id="反向dp"><a href="#反向dp" class="headerlink" title="反向dp"></a>反向dp</h2><h3 id="1-lc174-地下城游戏"><a href="#1-lc174-地下城游戏" class="headerlink" title="1. lc174. 地下城游戏"></a>1. <font color="red">lc174. 地下城游戏</font></h3><ul>
<li>正序的含义为“从起点出发，到达位置（i，j）所需要的最少血量”；正向dp有两个因素影响，可能每条路各有一个因素好，因此不知道选择哪条；（当前需要的血量，和整条路径中至少需要的血量）</li>
<li>倒序的含义是“从（i，j）出发，到达终点需要最少的血量”。初始血量本来就是要求的，所以只能倒序dp</li>
<li>转移方程：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span>(i==m<span class="hljs-number">-1</span>&amp;&amp;j==n<span class="hljs-number">-1</span>)&#123;<br>    dp[i][j]=<span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>-dungeon[i][j], <span class="hljs-number">1</span>);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i==m<span class="hljs-number">-1</span>)&#123;<br>    dp[i][j]=<span class="hljs-built_in">max</span>(dp[i][j+<span class="hljs-number">1</span>]-dungeon[i][j], <span class="hljs-number">1</span>); <span class="hljs-comment">//每个点的初始健康点都必须为正整数</span><br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j==n<span class="hljs-number">-1</span>)&#123;<br>        dp[i][j]=<span class="hljs-built_in">max</span>(dp[i+<span class="hljs-number">1</span>][j]-dungeon[i][j], <span class="hljs-number">1</span>);                <br>&#125;<span class="hljs-keyword">else</span>&#123;<br>        dp[i][j]=<span class="hljs-built_in">max</span>(<span class="hljs-built_in">min</span>(dp[i+<span class="hljs-number">1</span>][j], dp[i][j+<span class="hljs-number">1</span>])-dungeon[i][j], <span class="hljs-number">1</span>); <br>&#125;   <br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="数位dp"><a href="#数位dp" class="headerlink" title="数位dp"></a>数位dp</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-special-integers/solution/shu-wei-dp-mo-ban-by-endlesscheng-xtgx/">力扣（LeetCode）官网 - 全球极客挚爱的技术成长平台</a><br>主要是抓住现在的index, mask(前面i位选择的数组)， isLimit（前面是否选的最大）， isNum 前面是否填了数字（非0）<br>注意最开始的时候isLimit=True, isNum=false<br>同时记忆化搜索主要用于出现重复计算的情况，因此可以从4维降低到2维 dp[index][mask]<br>一些类似的题目：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/numbers-with-repeated-digits/">https://leetcode.cn/problems/numbers-with-repeated-digits/</a></p>
<p><a target="_blank" rel="noopener" href="https://zerotrac.github.io/leetcode_problem_rating/#/">灵神网页</a></p>
<h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><h3 id="1-每个物品选择或者不选择，使得总体的方案是n-同时花费最少类似题"><a href="#1-每个物品选择或者不选择，使得总体的方案是n-同时花费最少类似题" class="headerlink" title="1. 每个物品选择或者不选择，使得总体的方案是n, 同时花费最少类似题"></a>1. 每个物品选择或者不选择，使得总体的方案是n, 同时花费最少类似题</h3><p>例题1: lc1029. 两地调度</p>
<ul>
<li>第一想法是使用二进制的暴力枚举</li>
<li>因为整体的方案一定要是n, 所以一定要初始化dp[0][j] (j&gt;=2为一个比较大的值)； 同时dp[i][0] 为dp[i-1][0]+cost[i][1]<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++">    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=costs[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=costs[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">2</span>;j&lt;=n/<span class="hljs-number">2</span>;j++)&#123;<br>        dp[<span class="hljs-number">0</span>][j]=<span class="hljs-number">1000000</span>; <span class="hljs-comment">//注意这个是非常重要的！！！！</span><br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>        dp[i][<span class="hljs-number">0</span>]=dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]+costs[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n/<span class="hljs-number">2</span>;j++)&#123; <span class="hljs-comment">//j代表剩余的0类的数量</span><br>            dp[i][j]=<span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j]+costs[i][<span class="hljs-number">1</span>], dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+costs[i][<span class="hljs-number">0</span>]);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></li>
<li>第二种方法是贪心：<br>a[i] - b[i]代表将i员工派往a地比派往b地的费钱程度，数值越高表示派往a地越不划算；<br>  将所有花费按a[i] - b[i]从小到大排序，则前n个为派往a地更划算的员工，后n个为派往b地更划算的员工。</li>
</ul>
<p>例题2: lc474. 一和零 （类似于0-1背包问题）</p>
<ul>
<li>选不选择每个字符串，满足0， 1不超过m, n同时使得最后的字符串个数最多; 或者选了这个不能选择左右两边， 类似问题都使用dp</li>
<li>这种第一种想到的思路是回溯，更进一步的方法是动态规划</li>
<li>回溯思路如果不求具体序列，只求总数的话，可以考虑动态规划解决<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span>(j&gt;=zero_num&amp;&amp;k&gt;=one_num)&#123;<br>    dp[i][j][k]=<span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][j-zero_num][k-one_num]+<span class="hljs-number">1</span>, dp[i<span class="hljs-number">-1</span>][j][k]);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    dp[i][j][k]=dp[i<span class="hljs-number">-1</span>][j][k]; <span class="hljs-comment">//一定注意else别忘了</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="1-斐波拉切数列问题"><a href="#1-斐波拉切数列问题" class="headerlink" title="1. 斐波拉切数列问题"></a>1. 斐波拉切数列问题</h3><p><font color="red"> 扩展题：lc873. 最长的斐波那契子序列的长度</font></p>
<ul>
<li>使用动态规划的话，不能只数列的最后一个数，而要考虑数列的最后两个数 dp[i][j]=max(dp[i][j], d[k][i]+1);<br>因为有三个变量，为了减少三重循环为二重，使用hash_map 找到k的index为 hash[arr[j]-arr[i]]</li>
<li>使用二重循环暴力寻找，为了减少寻找的时间，使用hash_map（因为数据各不相同）</li>
</ul>
<h3 id="2-成熟的牛不断生小牛的问题"><a href="#2-成熟的牛不断生小牛的问题" class="headerlink" title="2. 成熟的牛不断生小牛的问题"></a>2. 成熟的牛不断生小牛的问题</h3><h3 id="3-汉罗塔问题"><a href="#3-汉罗塔问题" class="headerlink" title="3. 汉罗塔问题"></a>3. 汉罗塔问题</h3><h3 id="4-走地图问题（最短-最长价值-龙与地下城游戏）"><a href="#4-走地图问题（最短-最长价值-龙与地下城游戏）" class="headerlink" title="4. 走地图问题（最短/最长价值/龙与地下城游戏）"></a>4. 走地图问题（最短/最长价值/龙与地下城游戏）</h3><h3 id="5-扔鸡蛋问题"><a href="#5-扔鸡蛋问题" class="headerlink" title="5. 扔鸡蛋问题"></a>5. 扔鸡蛋问题</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">dp[i][j]=<span class="hljs-number">1</span>+dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+dp[i<span class="hljs-number">-1</span>][j] <span class="hljs-comment">//dp[i][j]表示用i次操作j个鸡蛋能够验证的最高高度</span><br></code></pre></td></tr></table></figure>
<h3 id="6-画匠问题"><a href="#6-画匠问题" class="headerlink" title="6. 画匠问题"></a>6. 画匠问题</h3><ul>
<li><p>动态规划或者二分算法</p>
</li>
<li><p>动态规划：类似于鸡蛋问题，可以使用滑动数组，将二维转为一维，但是在转的时候注意i j的顺序 dp[i-1][0<del>j]可以转 dp[0</del>i][j]不太好转</p>
</li>
<li><p>二分解法如下<br>二分法，限制所有画作完成的时长，然后检查在这个时长限制下画家的数量够不够。够的话说明时间还可以压缩，不够的话就要放宽时长限制，多给一些时间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span> limit)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> cnt=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> tmpsum=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;arr.<span class="hljs-built_in">size</span>();i++)&#123;<br>        tmpsum+=arr[i];<br>        <span class="hljs-keyword">if</span>(tmpsum&gt;limit)&#123;<br>            cnt++;<br>            tmpsum=arr[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt+<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">int</span> left=INT_MIN, right=<span class="hljs-number">0</span>; <span class="hljs-comment">//表示一个画家画的时长</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;arr.<span class="hljs-built_in">size</span>();i++)&#123;<br>    left=<span class="hljs-built_in">max</span>(arr[i], left);<br>    right+=arr[i];<br>&#125;<br><br><span class="hljs-keyword">if</span>(K&gt;=arr.<span class="hljs-built_in">size</span>())&#123;<span class="hljs-comment">//如果画家数量比画多</span><br>    <span class="hljs-keyword">return</span> left;<span class="hljs-comment">//返回时长最大的画</span><br>&#125;<br><br><span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>    <span class="hljs-keyword">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">int</span> tmp=<span class="hljs-built_in">getNumber</span>(mid);<br>    <span class="hljs-keyword">if</span>(tmp==K)&#123;<br>        right=mid;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tmp&lt;K)&#123;<br>        right=mid<span class="hljs-number">-1</span>;<span class="hljs-comment">//应该也可以和tmp==K合并为right=mid</span><br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        left=mid+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> right;<span class="hljs-comment">//最小的时长</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="7-邮局选址的问题"><a href="#7-邮局选址的问题" class="headerlink" title="7. 邮局选址的问题"></a><font color="red">7. 邮局选址的问题</font></h3><ul>
<li>转移状态的枚举类似于画匠问题</li>
<li>因为两个邮局的情况，不清楚那个邮局负责哪些居民区，那么就枚举，然后求最小。</li>
<li>这道题前提是要知道：建立一个邮局的时候，建在中间是最优的情况！<ol>
<li>提前求i ~ j这段距离建立一个邮局的最小距离</li>
<li>dp[i][j]表示0 ~ i这段居民区，有j+1个邮局的最小距离   也可以改成j对应j个邮局，这样初始化dp[i][1],循环j从 2 ~ num</li>
<li>初始化边界dp[i][0]=w[0][i];</li>
<li>建立转移方程： dp[i][j]=min(dp[k][j-1]+w[k+1][i], dp[i][j]) k从0到i，（官方题解：两端值都取!!!!!），表示建邮局的位置<br>注意j&lt;=i，当j&gt;i dp=0; 每次进入k循环的时候，在初始化dp[i][j]=INT_MAX</li>
<li>返回结果 dp[n-1][K-1];<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> w[size+<span class="hljs-number">1</span>][size+<span class="hljs-number">1</span>];<br><span class="hljs-comment">//求任意两个居民点之间建立一个邮局的最短距离</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i+<span class="hljs-number">1</span>;j&lt;size;j++)&#123;<br>        w[i][j]=w[i][j<span class="hljs-number">-1</span>]+a[j]-a[(i+j)/<span class="hljs-number">2</span>];<br>    &#125;<br>&#125;<br>dp[i][<span class="hljs-number">0</span>]=w[<span class="hljs-number">0</span>][i];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=size<span class="hljs-number">-1</span>;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=num<span class="hljs-number">-1</span>;j++)&#123;  <br>        <span class="hljs-keyword">if</span>(j&gt;=i)&#123;<span class="hljs-comment">//邮局数量&gt;=居民区数量  如果不进行判断就需要 k&lt;=i，否则就会因为进不去 k 的循环，导致dp[i][j]=INT_MAX</span><br>            dp[i][j]=<span class="hljs-number">0</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            dp[i][j]=INT_MAX;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;i;k++)&#123;<br>                dp[i][j]=<span class="hljs-built_in">min</span>(dp[k][j<span class="hljs-number">-1</span>]+ w[k+<span class="hljs-number">1</span>][i], dp[i][j]); <span class="hljs-comment">//注意k+1可能==size，因此需要w需要size+1空间</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
总结，从左到右开始建立，而不是使用二进制记录状态，随机建立<br>状态转移类似最长递增子序列的思路， 需要提前计算i， j之间建立一个邮局的最短距离</li>
</ol>
</li>
</ul>
<h3 id="8-数组的最大价值-区间dp"><a href="#8-数组的最大价值-区间dp" class="headerlink" title="8. 数组的最大价值 (区间dp)"></a><font color="red">8. 数组的最大价值 (区间dp)</font></h3><ul>
<li>题意，就是找任意不相交区间且每个区间首位值相等，使得这些区间加起来价值最大</li>
<li>转移方程：<br><code>  dp[i]=max(dp[i-1], dp[j-1]+presum[i]-presum[j-1]); （a[i]==a[j]）</code><br>因为需要<code>a[j]==a[i]</code>，如果使用二重循环会超时<br>解决方案：<br>（1）使用hash存储不同a[i]对应的下标<br>（2）记录另外一个hash 使得<code>hash[a[i]]=max(hash[a[i]], dp[i-1]-presum[i-1]) </code></li>
<li>之后再进行更新就不用循环找与i相同的下标j,可以直接更新<code>dp[i]=max(dp[i-1], presum[i]+hash[a[i]]); </code><br>（注意要对<code>hash[a[i]]</code>是否存在进行分类讨论）</li>
</ul>
<h3 id="9-盒子放置（谷歌）-现在无权限查看"><a href="#9-盒子放置（谷歌）-现在无权限查看" class="headerlink" title="9. 盒子放置（谷歌）/现在无权限查看"></a><font color="red">9. 盒子放置（谷歌）/现在无权限查看</font></h3><ul>
<li>使用动态规划的思想；</li>
<li>dp[i][j] 表示当前第i个box，第j个position能放置的最多的box数量。<br>如果 box[i - 1] &lt;= position[j - 1]，则dp[i][j] = dp[i - 1][ j - 1] + 1 贪心，放在最后一个位置最好<br>反之，dp[i][j] = max(dp[i-1][j], dp[i][j - 1]) 其中di[i-1][j]表示不放第i个box, dp[i][j - 1] 第i个box不放在j个位置</li>
</ul>
<p><strong>重要！！！！！</strong></p>
<ul>
<li>注意下标i从0 ~ n-1，但是这个因为有w，所以最好和w对应，不转为1 ~ n。<br>从i从0开始取的话，每次k循环，划分两个部分相加， 后半部分都不会包含第一个数，因此j要从2开始取，否则就会造成dp[0][0]//第一个0代表有地址，第二个0代表无邮局，就会返回INT_MAX,造成结果错误<br>背包问题，i下标是1~n 因为i可能从i-1推导，需要i&gt;=1</li>
</ul>
<h3 id="8-“马”在棋盘上的概率"><a href="#8-“马”在棋盘上的概率" class="headerlink" title="8. “马”在棋盘上的概率"></a>8. “马”在棋盘上的概率</h3><ul>
<li>类似的==地图问题==，虽然当前位置可以由它四面八方的位置推出来，但是因为步数，所以对应的三维数组还是由之前的状态推导出来，因此仍然可以使用动态规划<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> K=<span class="hljs-number">1</span>;K&lt;=k;K++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> q=<span class="hljs-number">0</span>;q&lt;<span class="hljs-number">8</span>;q++)&#123;<br>                <span class="hljs-keyword">int</span> nextx=i+dx[q];<br>                <span class="hljs-keyword">int</span> nexty=j+dy[q];<br>                <span class="hljs-keyword">if</span>(nextx&gt;=<span class="hljs-number">0</span>&amp;&amp;nextx&lt;n&amp;&amp;nexty&gt;=<span class="hljs-number">0</span>&amp;&amp;nexty&lt;n)&#123;<br>                    dp[i][j][K]+=dp[nextx][nexty][K<span class="hljs-number">-1</span>]/<span class="hljs-number">8.0</span>; <span class="hljs-comment">//下一个和当前反过来感觉也行</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">double</span> sum=<span class="hljs-number">0.0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>        sum+=dp[i][j][k]; <span class="hljs-comment">//k步走到每个棋盘的概率加起来</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li><p>图与动态规划，一定要注意vis的问题，bellman-ford以及floyd算法都是图的动态规划的例子<br>但是注意因为bellman-ford是求距离最小，所以不会出现重复vis同一个节点的情况<br>但是如果求max的情况，使用动态规划+图就可能造成一个节点vis多次，因此最好考虑记忆化dfs或者状态压缩</p>
</li>
<li><p>状态压缩问题，将状态放在外层比较保险；如果是list数组，那么可以将num放在外面，如果是图，那么只能将状态放在外面。 通常状态压缩使用的题目是将数据放在哪个位置，得到最大/最小、/满足什么样的条件的XXX类似题型<br><font color="red">图类型的状态压缩：求遍历这个图中所有节点的最小代价（代价指的是走过路径长度的总和， 应该是顺序走完）。状态压缩dp，注意不要理解成最小生成树</font></p>
</li>
</ol>
<ol start="3">
<li><p>动态规划的关键是处理 i 取值范围 j取值范围，转移方程以及边界情况求动态规划<br>也就是找到dp[i]-&gt; dp[j] (j&lt; i) 的递推公式,这个递推可能由i，j之间回文，括号，或者异或和组成；特别的，如果是回文可以提前得到任何i，j之间是否为回文字符串，模板代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=s_len<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>     <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i+<span class="hljs-number">1</span>;j&lt;s_len;j++)&#123;<br>         p[i][j]=(s[i]==s[j]&amp;&amp;p[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>]);<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure></li>
<li><p>区间dp问题，外围长度的字符状态，可以由内围的长度的字符推导出来 <code>dp[i][size]</code><br> 数组中左右相邻顺序不变的题，一般使用区间dp （lc1130. 叶值的最小代价生成树）<br> 这种问题有两种思路：<br> a. 直接当前问题划分为左右两个子问题<br> b. 将当前问题划分为左右两个子问题+当前的问题</p>
</li>
<li><p>如果进行了状态压缩：<br>0-1的最大背包问题，逆向枚举<br>多重背包问题也是，只能逆向枚举<br>完全背包（无限个）才是正向枚举！！！</p>
</li>
<li><p>有的时候动态规划不好解决，考虑使用带记忆的dfs，（比如要求所有的路径，或者所有路径中花费最小等等） 而且dp 的index可以为一个vector（类似与状态压缩）</p>
</li>
<li><p>最短时间类似题，除了考虑动态规划，也可以向二分算法中思考，比如画匠问题</p>
</li>
<li><p>动态规划可以解决true/false（是否能化为k个相同区间，单词拆分问题）, 最小最大最长问题，总数问题</p>
</li>
<li><p>当动态规划的状态比较多的情况下<br>注意 res+=dp[i][m]%MOD(wrong answer)<br>res=(res+dp[m][i])%MOD(right answer);</p>
</li>
<li><p>划分性dp有两种情况：以i为结尾，和0-i之间，区分这两种情况就是判断在进行dp递推的时候，如果dp[i] 依赖于多个之前的dp[j]那么应该使用以i为结尾，如果dp[i]只依赖之前的一个dp[j]那么使用0-i之内的元素<br>（最长子序列和最长子串问题）</p>
</li>
<li><p>使用状态枚举（状态压缩）的方法，要求k&lt;32 !!!!如果n&lt;100那么就不能这么枚举</p>
</li>
<li><p>背包问题可能也会加一个额外的条件，类似于最短路径问题（Dijstra/bellman-ford/floyd）中再加一个额外条件,具体例题见“货物转移”(lintcode)模板： dp数量最小+weight最大类似题目</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span>(d[j]+<span class="hljs-number">1</span>&lt;d[i])&#123; <span class="hljs-comment">//找到更优解</span><br>    d[i]=d[j]+<span class="hljs-number">1</span>;<br>    weight[i]=weight[j]; <span class="hljs-comment">// update weight and d</span><br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(d[i]==d[j]+<span class="hljs-number">1</span>)&#123;<br>    weight[i]=max/<span class="hljs-built_in">min</span>(weight[j], weight[i]); <span class="hljs-comment">//only update weight</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-keyword">continue</span>; <span class="hljs-comment">//do not update anything</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>动态规划一定要注意状态的初始化，在i 和 j都从1开始取的时候，一定要记得赋值dp[0][1到n] 以及dp[1到n][0]</p>
</li>
<li><p>如果出现反复将一个字符串的子串和字典中的每个字符比对的题目，可以使用Trie树，或者使用动态规划（True/False类型），提前判断某一个子字符串是否在字典中</p>
</li>
<li><p>刷一刷leetcode以面试题开始的题目</p>
</li>
</ol>
<ol start="16">
<li><p>非常重要的资源：<a target="_blank" rel="noopener" href="https://oi-wiki.org/dp/knapsack/">背包 DP - OI Wiki</a><br>OI-wiki  《背包九讲》</p>
</li>
<li><p>连续数组进行划分，使得划分个数满足条件，使用动态规划或者二分查找<br>例题：lc410. 分割数组的最大值(hard), 画匠问题</p>
</li>
<li><p>一定要注意数组越界可能不会报错，比如403. 青蛙过河，申请dp[size][size] size=18， 但是访问dp[18][29]范围为true<br>所以这道题关键在于一定要加上判断if(k&lt;=j+1) 才能进行dp的更新，否则就会发生访问到越界的数据</p>
</li>
</ol>
<ol start="19">
<li> 注意异或，因为值不一定为前面的值，所以dp[i][j]的i不能够减少，这种情况为了减少内存空间占用，使用dp[2][j]<br>转移方程为：<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs prolog">dp[i&amp;<span class="hljs-number">1</span>][j]= (dp[(i<span class="hljs-number">-1</span>)&amp;<span class="hljs-number">1</span>][j]+dp[(i<span class="hljs-number">-1</span>)&amp;<span class="hljs-number">1</span>][j^(arr[i<span class="hljs-number">-1</span>])])<span class="hljs-comment">%MOD;</span><br></code></pre></td></tr></table></figure>
返回结果为<code>dp[size&amp;1][max_j]</code></li>
</ol>
<ol start="20">
<li>动态规划主要在于定义状态有几种（删除/不删除元素  买股票/卖股票 等），以及定义状态间的递推-转移关系(当前状态可以由之前的状态决定)</li>
</ol>
<ol start="21">
<li><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-dice-rolls-with-target-sum/solution/dong-tai-gui-hua-bei-bao-wen-ti-yun-yong-axtf/">背包问题详解</a></li>
</ol>
<ol start="22">
<li>子数组是连续的；子序列是不连续的。数组题一定要先确定，选择的数是连续还是不连续，是可以打乱顺序还是不能打乱顺序<br>(lc1524. 和为奇数的子数组数目)</li>
</ol>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/leetcode/" class="category-chain-item">leetcode</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/dp/" class="print-no-link">#dp</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>动态规划</div>
      <div>http://shu0421.github.io/2021/11/13/leetcode/动态规划题型/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Shu</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2021年11月13日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/11/13/leetcode/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/" title="二分算法">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">二分算法</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/11/13/leetcode/%E5%8D%95%E8%B0%83%E6%A0%88%E7%9B%B8%E5%85%B3/" title="单调栈">
                        <span class="hidden-mobile">单调栈</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"H2RSYuSdiyJY9PtyUuEzMehk-gzGzoHsz","appKey":"VVHDe4hNQJHWFolrxe6l3FNA","path":"window.location.pathname","placeholder":"留下你的建议再离开~","avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
